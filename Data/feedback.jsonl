{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST: a list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-indexed vertices 1..9). Objective is to minimize max(ci).","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_EVAL_TYPE_ERR:Error 'Type List cannot be instantiated; use list() instead' indicates misuse of typing.List. Remove any List() instantiations and rely on built-in list(). Avoid from typing import List if your runner auto-constructs List().\nE_EVAL_PEN_SCALE:Conflict weight=1000 overwhelms objective but still mixes scales. Use lexicographic fitness: fitness = conflicts*1_000_000 + max_color. Guarantees conflicts are eliminated before optimizing colors.\nE_EVAL_PEN_HARD:Global PENALTY=1e9 collapses gradient and blocks learning. Return explicit infeasibility via very large conflicts term or raise invalids*1_000_000 instead of 1e9.\nR_INIT_DSATUR:No constructive initializer. Add DSATUR\/greedy-by-saturation to produce a 3-color solution rapidly. This reduces search time and avoids unnecessary high-k starts.\nNB_CODE_FAIL_OBJ:Neighbour introduces new color with p=0.15, directly harms min-k objective. Restrict candidate colors to 1..current_max only. Allow current_max+1 strictly disabled once a feasible 3-coloring is found.\nNB_SELECT_CONFLICTED:Random vertex selection wastes iterations. Select a vertex from the conflict set (endpoints of monochromatic edges), preferring max saturation degree to target constraint violations.\nNB_COLOR_CHOICE_HEUR:Random color choice yields high conflict churn. For the chosen vertex, evaluate all candidate colors in 1..current_max and pick argmin of delta_conflicts (break ties by minimizing resulting max_color). O(deg(v)) per move.\nNB_MOVE_SET_EXPAND:Operator too simple. Add color-swap\/Kempe-chain moves between two colors to escape local minima and enable k-reduction without increasing conflicts.\nNB_TABU_ATTR:Add tabu on (vertex,color) assignments with length L\u22487\u201315 to prevent cycling in conflict-minimization phase. Aspiration if a move reduces best conflicts.\nPERTURB_MISSING:'$Perturb' placeholder blocks metaheuristics. Implement perturb_solution: perform 1\u20133 Kempe-chain swaps or recolor a small random subset of conflicting vertices; adapt strength to stagnation.\nHEURISTIC_K_LOOP:Min-k goal is better driven by fixed-k feasibility loop. For k from 3 to 4: search to zero conflicts (tabu\/SA). If success at k, decrease k-1; else stop. Never allow k to increase during fixed-k phases.\nSTOP_CRITERIA:Missing stagnation\/time criteria. Add: terminate if best_conflicts==0 and no improvement in last X iterations, or after T milliseconds.\nAPI_SIG_COMPAT:Ensure generate_neighbour returns exactly (solution, 'SingleVertexRecolor', 'RandomChoice') as per contract; avoid typing annotations that your runner might execute. Heuristic signature must match TARGET_HEURISTIC_GENERAL_SIGNATURE.\nRANDOM_SEED_REPRO:Inject RNG seed via other_params for reproducibility; pass Random instance to operators to avoid global random.\nVALIDATION_REPAIR:If any color<1 or non-int, repair by mapping to valid colors before evaluation to avoid massive penalties that stall search.\nPERF_DELTA_EVAL:Current full evaluation O(|E|) per step is wasteful. Maintain adjacency list and compute delta_conflicts for the modified vertex only, reducing to O(deg(v)).\nK_CAP_ENFORCE:Known optimum k=3. Once a feasible 3-coloring is found, hard-cap colors to {1,2,3} and filter any moves that introduce color 4.\nRESULTS_PIPELINE_FIX:Runner errors on SAMPLE_SOL hint the evaluation harness is instantiating typing.List. Purge typing-based instantiations in all components and tests. Use only built-ins to satisfy MAIN_CRITICAL_INSTRUCTION and avoid environment differences.\"","Componentes":{"REPRESENTATION":"COLOR_LIST: a list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-indexed vertices 1..9). Objective is to minimize max(ci).","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    CONFLICT_PEN = 1000\n    INVALID_PEN = 1000\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY\n    if len(solution) != 9:\n        return PENALTY\n\n    invalids = 0\n    all_ints = True\n    for x in solution:\n        if not isinstance(x, int):\n            all_ints = False\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    if not all_ints:\n        return PENALTY\n\n    # Objective part\n    obj = max(solution) if len(solution) == 9 else PENALTY\n\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    conflicts = 0\n    if invalids == 0:\n        for u, v in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = obj + conflicts * CONFLICT_PEN + invalids * INVALID_PEN\n    return fitness\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by recoloring a single random vertex\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback: initialize a random valid solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Determine current color bound\n    current_max = max(sol) if len(sol) == 9 and all(isinstance(x, int) for x in sol) else 3\n\n    # Choose a vertex to modify\n    idx = random.randrange(9)\n\n    # Candidate color set: existing colors and with small probability a new color (current_max+1)\n    colors = list(range(1, current_max + 1))\n    if random.random() < 0.15:\n        colors.append(current_max + 1)\n\n    # Ensure a different color is chosen if possible\n    current_color = sol[idx]\n    if len(colors) > 1 and current_color in colors:\n        colors = [c for c in colors if c != current_color]\n\n    sol[idx] = random.choice(colors)\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor a random subset (~30-50%) of vertices\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    n = 9\n    k = random.randint(max(1, n \/\/ 3), max(1, n \/\/ 2))\n    idxs = random.sample(range(n), k)\n\n    current_max = max(sol)\n    for i in idxs:\n        # Allow recolor from existing palette with small chance to introduce a new color\n        palette = list(range(1, current_max + 1))\n        if random.random() < 0.2:\n            palette.append(current_max + 1)\n        # Avoid keeping the same color if alternatives exist\n        old = sol[i]\n        if len(palette) > 1 and old in palette:\n            palette = [c for c in palette if c != old]\n        sol[i] = random.choice(palette)\n        current_max = max(current_max, sol[i])\n\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"SIG_MISMATCH: Heuristic implementations violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Provide a single entry point def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and wrap SA\/ILS\/TS as strategy branches inside it.\n\nGEN_NEIGH_RET_ARITY: generate_neighbour returns three values (solution, 'SingleVertexRecolor','RandomChoice'). Framework expects either one or two. Standardize to return exactly (new_solution, move_meta) or only new_solution and adapt caller accordingly.\n\nNB_META_INCOMPAT: Type-annot in NB signature ('NB_Type','Movement_Type') is misleading and unused by callers. Remove or enforce a consistent MoveMeta dict with fixed keys to avoid unpack errors.\n\nPERTURB_MISSING: Perturbation Function undefined ($Perturb). ILS\/SA require a valid perturb_solution callable. Implement and pass through the Heuristic signature or remove ILS\/SA paths until available.\n\nALG_API_INCONSISTENT: SA\/ILS\/TS reported custom signatures not matching TARGET_HEURISTIC_GENERAL_SIGNATURE. Stop exposing def SA(...), def ILS(...), def TS(...). Provide internal functions and call via Heuristic with other_params={'alg':'SA', ...}. Ensure parameter unpack uses dict with defaults.\n\nBEST_SCORING_CONVENTION: Heuristics must treat lower fitness as better (HEURISTICS_VALUE_BEST_AS_LESSER_COST). Verify all acceptance and best updates use strictly < and not > or max-logic.\n\nEVAL_SCALE_COUPLING: fitness = conflicts*1e6 + max_color + invalids*1e6 makes conflicts and invalids indistinguishable in magnitude; a single conflict equals a single invalid structurally. If you intend lexicographic [invalids, conflicts, max_color], use fitness = invalids*1e12 + conflicts*1e6 + max_color to strictly prioritize validity over conflicts.\n\nEVAL_REDUNDANT_MAX: max_color=9 on invalids>0 hides useful gradient for repair. Keep true max_color to retain secondary pressure post-repair attempts or move max_color behind conflicts only after invalids reach 0.\n\nEVAL_CONST_COST_ON_TIES: Using constant 1e6 penalties can cause plateaus for equal conflict counts. Add tertiary term: sum_colors or small jitter weighted by vertex degree to diversify tie-breaking deterministically.\n\nNB_COLOR_CAP_RISK: cap_max=min(current_max,3) can overly constrain early search when current_max>3 but conflicts remain; while target is 3, hard cap may induce stagnation. Replace with soft cap: palette=range(1,min(current_max,4)) and penalize colors>3 via evaluation rather than banning.\n\nNB_NO_INCREASE_POLICY: \u201cno new colors introduced\u201d blocks escape from local minima where temporary increases reduce conflicts enabling later reductions. Allow temporary +1 color under SA\/TS with penalty, then drive back to 3.\n\nNB_LOCAL_OPT_WEAK: Single-vertex recolor is weak for graph coloring. Add Kempe-chain interchanges and pair-swap moves. Suggest: with p=0.5 do Kempe chain on random conflicting edge; else recolor highest-conflict vertex.\n\nNB_DET_TIEBREAK: Random tie-breaking without seeded RNG hurts reproducibility. Pass rng in other_params and use rng.choice. Store rng state in best meta.\n\nINCR_EVAL_MISSING: Full re-evaluation O(|E|) per move is wasteful. Implement \u0394-evaluation for recolor moves in O(deg(v)): maintain conflict edge count and max_color usage histogram.\n\nTABU_DESIGN_GAP: No tabu attributes defined; returning raw solution offers no move identity. Use move attribute (vertex, old_color->new_color). Tabu tenure keyed on (vertex,color) pairs with aspiration if fitness improves best.\n\nSA_COOLING_PARAMS: Error logs show mismatched params. Standardize other_params={'alg':'SA','T0':..., 'Tmin':..., 'alpha':...}. Use exponential cooling T<-T*alpha and probabilistic accept exp(-(new-old)\/T).\n\nILS_ACCEPTANCE: Acceptance unspecified. Use acceptance if new_fitness <= current or with probability exp(-(new-current)\/T_pert) during perturb phase; or neutral acceptance up to a capped worsening threshold.\n\nTERMINATION_CRITERIA: Absent or inconsistent. Add max_iters, stall_iters, and time budget in other_params; stop on zero-conflicts and max_color<=3 to short-circuit.\n\nREPR_CONSTRAINTS: Ensure all operators keep colors in [1..current_max+1], maintain list length 9, and int types to avoid invalid penalties interfering with guidance.\n\nINIT_STRATEGY_WEAK: Random init in [1..3] may start infeasible. Add greedy DSATUR initialization to supply strong starting solution with \u22643\u20134 colors.\n\nKNOWN_SOLUTION_EXPLOIT: Hard-code upper bound k<=3 from known solution to guide search: enforce evaluation penalty for max_color>3 and a repair that tries to recolor any color-4 vertices first.\n\nOBS_ERR_HANDLING: \u201cFailed to run target heuristic: too many values to unpack\u201d indicates caller expects 2 returns. Add robust unpack try\/except and normalize outputs to a standard tuple.\n\nLOGGING_MINIMAL: No per-iteration metrics. Log (iter, fitness, conflicts, max_color, acceptance_flag) to validate convergence and detect stalls; keep overhead O(1).\n\nACTIONABLE_FIX_ORDER:\n1) Normalize API: implement Heuristic with standardized other_params and wrappers; fix generate_neighbour to return (solution, meta).\n2) Implement perturb_solution: multi-vertex random recolor or Kempe-chain burst (length L in [2..5]).\n3) Add \u0394-evaluation and conflict tracking for O(deg) updates.\n4) Introduce Kempe-chain move + tabu or SA acceptance to escape local minima.\n5) Seed RNG via other_params['seed'] and remove unseeded random calls.\n\nEXPECTED_IMPACT: Resolving API\/arity errors enables execution; Kempe-chain + \u0394-eval improves convergence speed; soft color cap + SA\/Tabu escape yields reliable attainment of 3-coloring matching known optimum.\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9]","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic objective: minimize conflicts first, then max color\n    # fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    # Valid solution is a list of 9 integers >= 1\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 50_000_000\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    max_color = max(solution) if invalids == 0 else 9\n\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    return fitness\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Single-vertex recolor guided by conflict minimization; no new colors introduced\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)  # Enforce cap at 3 once reachable\n    palette = list(range(1, cap_max + 1))\n\n    # Identify conflicting vertices and their conflict counts\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    if conflicted_vertices:\n        # Choose a vertex with maximum conflicts (break ties randomly)\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        # No conflicts: choose a random vertex; prefer reducing max color if possible\n        idx = random.randrange(n)\n\n    old_color = sol[idx]\n\n    # Evaluate all candidate colors to minimize resulting conflicts on idx\n    best_color = old_color\n    best_conf = 10**9\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        # Tie-break: prefer smaller color to help reduce max color usage\n        key = (cnt, c)\n        if cnt < best_conf or (cnt == best_conf and c < best_color):\n            best_conf = cnt\n            best_color = c\n\n    sol[idx] = best_color\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","PERTURB_CODE":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation (1-2 swaps) to escape local minima while preserving color count\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)\n    r = random.randint(1, 2)\n\n    def kempe_swap(start):\n        a = sol[start]\n        # Choose b different from a within current palette\n        b_choices = [c for c in range(1, cap_max + 1) if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        comp = []\n        dq = deque([start])\n        visited[start] = True\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on the component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Target signature violated. Use def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove parentheses from function parameters to avoid eager calls.\nE_ALGO_SIGS_INVALID:SA\/ILS\/TS definitions include parentheses in parameters (e.g., generate_neighbour()). Correct to pass callables without parentheses and ensure positional ordering matches TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_TYPE_HINT_RET:Neighbour return annotation invalid -> (\\\"NB_Type\\\",\\\"Movement_Type\\\"). Replace with -> Tuple[List[int],Dict[str,Any]] or omit annotation. Avoid instantiating typing.Tuple; never call Tuple().\nNB_PALETTE_BUG:Palette construction allows c>4 (e.g., current_max=3 gives up to 5). Fix to allow only {1..max(current_max,3)} with optional +1 color: palette=sorted(set(range(1,min(4,max(3,current_max))+1))) and if allow expansion: if allow_extra and current_max<4: palette.append(current_max+1).\nNB_COLOR_EXPANSION_UNCONTROLLED:Unbounded temporary colors inflate search space. Gate expansion on stagnation counter or conflict presence; forbid expansion when conflicts=0 and aim to reduce max_color deterministically.\nNB_MOVESET_INADEQUATE:Single-vertex recolor is too weak; high risk of local minima. Add moves: (1) Kempe-chain swap between two colors; (2) Pairwise color swap on conflicted vertex; (3) Recolor-to-lowest-feasible for vertices in highest color class; (4) Ejection chain when stuck.\nNB_CODE_FAIL_LOCAL_OPT:Conflict-only scoring ignores lexicographic objective. Add secondary key to minimize resulting max_color and tertiary to minimize color index sum. Compute local delta instead of raw count.\nNB_TIE_BREAKING_WEAK:Random choice on ties increases variance. Prefer deterministic tie-break: lowest resulting max_color, then degree, then vertex id.\nNB_REPAIR_INCONSISTENT_INIT:On invalid input, init with random 1..3 disregards degrees. Use DSATUR\/RLF or greedy-by-degree to seed a feasible low-color solution and compress colors post-move.\nPERTURB_ABSENT:Perturbation function is missing ($Perturb). Implement: (a) Kempe-chain random swap; (b) Merge highest color into others with limited conflict allowance; (c) Partial restart on top-k conflicted vertices; (d) Random walk of L recolors on conflicted vertices.\nE_FITNESS_SCALING:Large constants risk overflow in other contexts and obscure intent. Replace with tuple-based lexicographic objective: return (invalids,conflicts,max_color,sum_colors) and compare tuples in the heuristic; or compute delta with early abort.\nE_DELTA_UNUSED:Full reevaluation each step is wasteful. Maintain conflicts per vertex and track delta when recoloring a single vertex: O(deg(v)) update for conflicts, max_color, and sum_colors.\nE_NORMALIZE_COLORS:Color labels drift upward. After conflict-free step, relabel colors to contiguous 1..k to reduce max_color and improve comparability; attempt deterministic lowering pass.\nE_STOPPING_CRITERION_MISSING:No convergence\/stagnation control specified. Add: stop after T iterations without improvement and trigger perturbation; attempt k-reduction once conflict-free.\nE_TABU_STRATEGY_UNSPEC:Taboo_Search lacks explicit short-term memory. Add tabu on (vertex,color) with aspiration if move improves best.\nE_SA_SCHEME_WEAK:Annealing missing temperature schedule and acceptance using objective deltas. Use geometric cooling, accept with exp(-delta\/T), reheating on stagnation.\nE_ILS_ACCEPTANCE_VAGUE:Define acceptance as accept if new_score<=current or with probability p on slight worsening; incorporate adaptive perturbation strength based on stagnation.\nE_EDGE_CASES:If all vertices conflict-free, neighbour should prioritize reducing max_color by trying to move any vertex from the highest color to lower feasible colors before random recolor.\nR_SIG_FIX:Refactor all heuristic signatures to match TARGET_HEURISTIC_GENERAL_SIGNATURE and pass functions as first-class objects. Validate with a minimal harness using evaluate_solution on known solution.\nR_NB_UPGRADE:Implement dual-phase neighborhood: (Phase A) conflict-minimization moves on conflicted vertices; (Phase B) color-reduction moves focusing on highest color class. Include Kempe swaps in both.\nR_PERTURB_SPEC:Use adaptive perturb: L=ceil(alpha*conflicted_vertices) with alpha in [0.2,0.5]; prefer vertices with highest conflict; apply color swaps rather than random recolors.\nR_INIT_DSASATUR:Build initial solution using DSATUR; cap initial k at 4 then attempt reduction to 3 with focused search.\nR_VALIDATION_TESTS:Add unit tests: (1) evaluate_solution(known_solution)== tuple or <= target scalar; (2) neighbour returns list len==9, ints>=1; (3) move never increases conflicts when conflicts>0 unless SA\/TS allow probabilistically.\nR_LOGGING_MIN:Track metrics per iteration: conflicts, max_color, best_score, accepted_worse. Use fixed seed for reproducibility in tests.\nR_COMPRESS_PALETTE_AFTER_IMPROVEMENT:After any improvement, relabel and try greedy descent on max_color before resuming stochastic moves.\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9]","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    # Conflicts and auxiliary metrics\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n    max_color = max(solution) if len(solution) == n and all(isinstance(x, int) for x in solution) else n\n    sum_colors = sum(solution) if invalids == 0 else n * n\n\n    # Lexicographic objective: invalids >> conflicts >> max_color >> sum_colors\n    fitness = invalids * (10**12) + conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","NB_CODE":"import random\nfrom typing import Tuple, Dict, Any\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Identify conflicts per vertex\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    # Choose target vertex: most conflicted if any, else random\n    if conflicted_vertices:\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        idx = random.randrange(n)\n\n    current_max = max(sol)\n    # Soft palette: allow temporary +1 color up to 4 to escape local minima\n    palette = list(range(1, min(current_max + 1, 4) + (1 if current_max < 4 else 0)))\n    # Ensure palette non-empty and includes existing colors\n    if not palette:\n        palette = [1, 2, 3]\n\n    old_color = sol[idx]\n\n    # Score candidate colors by local conflicts, then color value\n    best_color = old_color\n    best_key = (10**9, old_color)\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        key = (cnt, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n\n    sol[idx] = best_color\n\n    move_meta = {\"move\": \"SingleVertexRecolor\", \"vertex\": idx + 1, \"from\": old_color, \"to\": best_color}\n    return sol, move_meta\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = list({x for x in sol})\n        if len(palette) <= 1:\n            return\n        # choose a different color b\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on this component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Apply 1-2 Kempe swaps to escape local minima while preserving color count\n    r = random.randint(1, 2)\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Componente":null,"Version":3,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Heuristic signatures deviate from TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace positional function calls like generate_neighbour() with function references and unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\\nE_CALL_STYLE:Passing generate_neighbour() in signature evaluates it at definition time. Use generate_neighbour without parentheses.\\nE_UNPACK_ERR:Neighbour returns (solution, meta) but consuming code expects two scalars or wrong arity. Define a strict interface: generate_neighbour -> (new_solution, nb_type, move_type). Avoid dict to prevent unpack errors.\\nE_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Provide def perturb_solution(solution, intensity, rng) returning a valid COLOR_LIST[9].\\nE_TS_API:TS failed due to unpacking an int. Ensure evaluate_solution returns scalar fitness only and TS unpacks neighbour outputs matching agreed interface.\\nE_SA_API:SA\/ILS function signatures do not match required Heuristic signature and parameter order. Consolidate to the general signature and pack algorithm-specific params in other_params.\\nNB_CODE_FAIL_LOCAL_OPT:Conflict reduction only recolors one vertex; lacks pair\/swap operators. Add 2-opt-like pair recolor and ejection chains to escape plateaus.\\nNB_KEMPE_SCOPE:Kempe swap chosen at random may be weak. Prioritize Kempe on top-color vertices with max adjacency to target lower color and accept only if max_color decreases or fitness improves.\\nNB_PALETTE_FLOOR:base_max=max(3,current_max) forces \u22653 colors even when 2-coloring is feasible locally. Set base_max=current_max and allow temporary expansion only via controlled diversification.\\nNB_TEMP_EXPANSION:Temporary +1 color allowed only if current_max<4 restricts escape. Generalize to allow +1 when stuck for T iterations, then retract via focused reduction.\\nEVAL_SCALARIZATION:fitness=conflicts*1e6+max_color*1000+sum may still allow accidental tradeoffs under large sums. Enforce lexicographic tuple compare or increase separation (e.g., 1e9\/1e6) and cap sum with tie-break only when conflicts==0 and max_color equal.\\nEVAL_VALIDATION:Invalid color penalty uses invalids*(1e12) but permits values > n unchecked. Add upper bound guard if a palette limit is enforced elsewhere; otherwise document unbounded colors allowed only via operator.\\nR_SEEDING:greedy_seed(order by degree) deterministic tie-breaking may bias color usage. Add randomized tie-break or DSATUR-based seeding to reduce initial max_color.\\nR_DIVERSIFICATION:RandomBestLocal does not track stagnation. Add time-based adaptive move selection: increase perturbation intensity after S stagnant iterations, reset on improvement.\\nR_TABU:No tabu memory used in neighbour; for TS integrate short-term tabu list on (vertex,color) assignments with aspiration by best fitness to prevent cycling.\\nR_ACCEPTANCE:ILS\/SA acceptance criteria unspecified. For ILS, accept if fitness improves or with small probability relative to delta; for SA, compute p=exp(-delta\/T) only when delta>0 and decrease T multiplicatively.\\nAPI_META:move_meta dict non-standard. Return plain tuple (nb_type, move_type) to avoid downstream key access; or provide a small dataclass-like tuple for allocation-free unpacking.\\nPERF_RAND:Random module used without seeding. Add rng parameter passed from Heuristic and avoid global state to ensure reproducibility.\\nSTOP_COND:No termination\/stagnation criteria defined. Add max_iters, max_no_improve, and time budget checks within Heuristic.\\nTEST_HARNESS:Provide adapter wrappers mapping SA\/ILS\/TS to the general Heuristic signature and a minimal driver that validates interface contracts before run.\\nKNOWN_SOLUTION_USE:Hardcode feasibility check: once conflicts==0 and max_color==3, trigger reduction-only neighbourhood; stop early when no 3->2 reduction exists to save iterations.\\nLOGGING_MIN:Record (iter, fitness, conflicts, max_color, move) for diagnostics; disable by default to avoid overhead and enable via flag in other_params.\\nACTION_PLAN:1) Fix interface\/signatures and neighbour return shape. 2) Implement perturb_solution. 3) Strengthen neighbourhood (Kempe priority, pair recolor). 4) Add acceptance\/termination. 5) Seed control and evaluation lexicographic separation. 6) Add tabu\/adaptive diversification for stagnation recovery.\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9]","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return invalids * (10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    max_color = max(solution) if solution else n\n    sum_colors = sum(solution)\n\n    # Lexicographic scalarization: invalids >> conflicts >> max_color >> sum_colors\n    fitness = conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Repair\/initialize input solution\n    def greedy_seed():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for u in order:\n            used = {colors[v] for v in adj[u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: compute conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    # Normalize palette bounds\n    base_max = max(3, current_max)\n    palette = list(range(1, base_max + 1))\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u):\n        # Try assign the smallest feasible color that reduces max color\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, current_max):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        # BFS on subgraph induced by colors {a,b}\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    move_meta = {\"NB_Type\": \"\", \"Movement_Type\": \"\"}\n\n    # Phase A: if conflicts>0, reduce conflicts preferentially\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # Choose most conflicted, tie-break by higher degree then lowest index\n        if conflicted_vertices:\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        # Allow temporary +1 color only when conflicts>0 and current_max < 4\n        local_palette = list(palette)\n        if current_max < 4:\n            local_palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in local_palette:\n            if c == old and len(local_palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        move_meta[\"NB_Type\"] = \"LocalSearch\"\n        move_meta[\"Movement_Type\"] = \"SingleVertexRecolor\"\n        return sol, move_meta\n\n    # Phase B: conflict-free -> attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    # Try greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u)\n        if new_c is not None:\n            old = sol[u]\n            sol[u] = new_c\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"LowerColorGreedy\"\n            return sol, move_meta\n\n    # If no direct lowering feasible, try a Kempe swap with a lower color\n    if top_vertices:\n        u = random.choice(top_vertices)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            kempe_swap(u, a, b)\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"KempeSwap\"\n            return sol, move_meta\n\n    # Fallback: mild diversification via recolor of random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    move_meta[\"NB_Type\"] = \"Diversification\"\n    move_meta[\"Movement_Type\"] = \"RandomBestLocal\"\n    return sol, move_meta\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # Simple greedy seed if invalid\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        sol = [0]*n\n        for u in order:\n            used = {sol[v] for v in adj[u] if sol[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u] = c\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            # Prefer colors not used by neighbors\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Measure conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(2, min(6, conflicts))\n\n    # Apply 1-2 Kempe swaps + a short random walk recolor\n    for _ in range(1 + (1 if random.random() < 0.5 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","SAMPLE_SOL":"[3,2,1,2,3,1,2,2,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Componente":null,"Version":4,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_API_SIG_MISMATCH:Heuristic signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE. Enforce def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).;E_GENNB_RET_OVERPACK:generate_neighbour returns 3 values (sol,NbType,Move) causing 'too many values to unpack'. Standardize to return only new_solution; move metadata via other_params['last_move'] if needed.;E_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Implement perturb_solution(solution, other_params) with reproducible stochasticity.;E_EVAL_OBJ_MISALIGNED:Evaluation optimizes lexicographic (conflicts,max_color,sum) while reporting 'EXPECTED SCORE' as 3. Provide wrapper objective: if conflicts>0 return large penalty; else return max_color only; remove sum_colors from primary objective.;E_EVAL_NUM_PRECISION:Returns float with 1e12\/1e18 weights; risks precision bleed. Return int; use Python int arithmetic to avoid float rounding.;E_EVAL_OVERWEIGHT_SUM:sum_colors biases search after feasibility, harming plateau moves. Drop sum_colors from fitness or relegate to tie-break only within code (no weight cascade).;E_DATA_REDUNDANCY:Edges\/adjacency rebuilt in every neighbour call. Precompute adjacency in other_params once to reduce overhead.;E_RANDOM_NONDETERMINISM:Random choices not seeded. Inject rng in other_params and use rng.random()\/rng.randrange to ensure reproducible runs and fair comparisons.;NB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor lacks stronger escape when all colors clash. Add 2-opt recolor (swap color labels), multi-vertex recolor, and conflict-driven tabu tenure.;NB_KEMPE_SCOPE:Kempe swap picks random lower color; may not target top color removal effectively. Prioritize b from colors in N(u) minimizing new_max and re-evaluate effect on top_color count.;NB_REDUCTION_GREEDY_WEAK:LowerColorGreedy uses first-fit which often stalls. Replace with best-fit using minimal added conflicts then minimal new_max; iterate until no improvement.;NB_CONFLICT_FOCUS:Selection of most-conflicted vertex ignores color class sizes. Weight tie-break by potential to reduce top_color count (vertices in top color first).;NB_MOVE_ACCEPT:Neighbour generator unconditionally returns modified solution. Provide delta-aware accept in Heuristic (e.g., SA\/TS) and allow generator to also return candidate without forced modification.;E_TS_UNPACK:Tabu search expects tuple from evaluate or neighbour; failed with 'cannot unpack non-iterable int'. Normalize interfaces: evaluate_solution returns scalar; generate_neighbour returns new_solution only.;ALG_SA_SIG:SA\/ILS\/TS functions using positional params with parentheses in signature text are wrong. Implement one general Heuristic wrapper that internally routes to SA\/ILS\/TS via other_params['mode'] and unified callable interfaces.;R_STR_INADEQUATE:COLOR_LIST with unbounded labels inflates palette drift. Enforce dynamic palette cap in other_params['max_color_cap'] and forbid temporary +1 unless conflicts persist T steps.;ACCEPT_CRITERION_DRIFT:Allowing palette expansion while conflicts>0 without rollback can increase k permanently. Add rollback on non-improving expansions and maintain best feasible with smallest k.;INIT_INCONSISTENT:Neighbour repairs invalid solutions via internal greedy seed. Move seeding to a dedicated initializer (DSATUR) and pass a validated currentSolution to avoid hidden reinitializations.;E_METRICS_REPORT:Current logs show function-level exceptions only. Add per-iteration metrics: conflicts, k, delta, move_type; dump summarized counts at end for diagnosability.;E_STOPPING_RULES:No convergence\/stagnation control. Add stopping on (conflicts==0 and no k reduction for X iters) and restart diversification with controlled perturbation.;PERT_SPECIFIC:Add perturb_solution implementing: (a) color-class merge attempts; (b) random Kempe chain on top color; (c) shuffle colors via relabel to expose symmetry.;E_CODE_PERF:Complexity per neighbour O(deg) but adjacency rebuild makes it O(m) each time. Cache adj, conflict counts; update incrementally in O(deg(u)).;VALIDATION_GUARD:evaluate_solution silently accepts any ints \u22651. Clamp colors to [1, cap] or penalize excessive labels more strongly to prevent color explosion.;GOAL_EXTRACTION:For reporting best_score as minimal k, set best_score=fitness if conflicts>0 else max_color, and ensure comparison uses lesser-better across modes.;EDGE_CASES:Empty\/None solution path handled ad hoc. Explicitly check and seed; remove dead code (empty solution guard).;\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9]","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**18\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return 10**18 + invalids\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # If solution empty (should not), guard\n    if not solution:\n        return 10**18\n\n    max_color = max(solution)\n    sum_colors = sum(solution)\n\n    # Strong lexicographic scalarization: conflicts >> max_color >> sum_colors\n    # weights ensure no trade-offs\n    fitness = conflicts * (10**12) + max_color * (10**6) + sum_colors\n    return float(fitness)\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Greedy seed (DSATUR-like simplified) if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # Select vertex with max saturation (distinct neighbor colors), tie by degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u, top_color):\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, top_color):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, prioritize reducing them\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        if conflicted_vertices:\n            # choose most conflicted, tie by higher degree then lower index\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 1))\n        # Allow temporary +1 expansion to escape deadlocks when necessary\n        if all(local_conflicts_if(u, c) >= conflict_counts[u] for c in palette):\n            palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old and len(palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        return sol, \"LocalSearch\", \"SingleVertexRecolor\"\n\n    # Conflict-free: attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u, top_color)\n        if new_c is not None:\n            sol[u] = new_c\n            return sol, \"ColorReduction\", \"LowerColorGreedy\"\n\n    # Kempe swap with a lower color targeting reduction\n    if top_vertices:\n        # pick vertex with highest adjacency to lower colors\n        def score(u):\n            return -sum(1 for v in adj[u] if sol[v] < sol[u])\n        u = min(top_vertices, key=score)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            before_max = max(sol)\n            kempe_swap(u, a, b)\n            after_max = max(sol)\n            move = \"KempeSwapReduce\" if after_max < before_max else \"KempeSwapNeutral\"\n            return sol, \"ColorReduction\", move\n\n    # Diversification: recolor random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    palette = list(range(1, max(1, current_max) + 1))\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"Diversification\", \"RandomBestLocal\"\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair\/seed if invalid\n    def greedy_seed():\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    for _ in range(1 + (1 if random.random() < 0.6 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Componente":null,"Version":5,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Refactor to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and PASS callables, do not call them in the signature.\nE_CALLABLE_USAGE:Errors show generate_neighbour() was invoked at definition time. Accept and forward the function objects; call inside the heuristic loop.\nSA_SIG_ERR:Simulated Annealing signature incorrect. Remove positional calls in signature; include temperature params via other_params dict and use callable parameters.\nILS_SIG_ERR:Iterated Local Search signature incorrect. Accept perturb_solution and others as callables; add iterations and acceptance_rate in other_params.\nTS_SIG_ERR:Tabu Search signature incorrect and name misspelled. Use def Heuristic(...); parameters in other_params: iterations, tabu_tenure, aspiration; ensure neighbor returns two values only.\nPERTURB_MISSING:Perturbation Function not provided ($Perturb). Implement a concrete perturbation (e.g., multi-vertex Kempe-chain shuffle or random k-vertex recolor) and wire it via perturb_solution callable.\nEV_OBJ_MISALIGNED:Evaluation uses max(solution) without color compaction. Normalize colors to 1..k before scoring to avoid artificial inflation from gaps.\nEV_TIE_BREAK_WEAK:Feasible tie-breaking ignores secondary criteria. Add secondary objective: minimize count of vertices at max color, then sum of colors, to guide reductions smoothly.\nEV_PENALTY_SCALING:Penalty 1e9+conflicts gives no gradient among infeasible moves except +1 per conflict. Use M large but add max_color as lower-order term: score = M*conflicts + max_color to guide conflict resolution.\nR_COLOR_GAPS:Representation allows non-compact color labels. After any move, relabel colors to consecutive IDs to keep k tight and help neighbor operators.\nINIT_SEED_COLOR_BLOAT:greedy_seed can introduce excessive colors. Constrain using DSATUR with reuse priority and backtracking on overflow; or run DSATUR with cap k and repair conflicts rather than opening new colors freely.\nNB_CODE_FAIL_LOCAL_OPT:Conflict repair recolors a single most-conflicted vertex with limited palette (range(1,current_max)). Add Kempe-chain moves and color-swap (swap two colors\u2019 classes) to escape stalemates and reduce k.\nNB_TOP_COLOR_REDUCTION_WEAK:Only lowers one top-color vertex then break. Iterate over all top-color vertices; attempt multi-pass and try recoloring with coordinated neighbor repairs.\nNB_PALETTE_BUG:When current_max==1, range(1,current_max+0) is empty; recolor degenerates to no-op. Ensure candidate palette includes at least {1,2} during conflict repair with temporary color introduction plus immediate compaction.\nNB_DIVERSIFICATION_RISK:Diversification allows any color up to current_max and can stagnate. Add probability to attempt color-swap or Kempe-chain; prohibit increasing new_max unless accepting via metaheuristic logic.\nNB_RAND_NONDET:Randomness unseeded. Accept rng\/state via other_params and use rng methods for reproducibility.\nNB_COST_MODEL:local_conflicts_if ignores downstream effects. Use incremental delta evaluation with neighbor conflict counts and color-class occupancy to rank moves faster and better.\nCOLOR_SWAP_MISSING:Lack of 2-color swaps limits k-reduction. Add explicit swap of two color classes and test feasibility; powerful for graph coloring.\nKEMPE_CHAIN_MISSING:No Kempe-chain exploration. Implement Kempe-chain interchanges to navigate plateaus and reduce colors.\nSEARCH_ESCAPES_INADEQUATE:Only random single-vertex recolor for diversification. Add SA\/TS acceptance to allow uphill moves with control; or use ILS perturbation with multi-vertex shuffle.\nTABU_COMPONENT_WEAK:No tabu memory. Add tabu list on (vertex,color) with tenure and aspiration to prevent cycling.\nPERF_INC_EVAL:Recompute conflicts from scratch. Maintain adjacency and per-vertex conflict counts; update in O(deg(u)) per move.\nPARAMS_STRUCT:Use other_params dict with validated keys: {'iterations','time_limit','rng_seed','max_k','anneal':{'T0','Tmin','alpha'},'tabu':{'tenure','iter'},'ils':{'perturb_size','accept_rate'}}.\nAPI_RETURN_STD:Standardize generate_neighbour to return (new_solution, move_tag). Ensure all heuristics expect and handle exactly this signature to avoid unpack errors.\nVALIDATION_HANDLING:Evaluation returns huge penalty for invalid solutions but neighbor attempts repair ad hoc. Centralize repair: validate and repair before evaluation; avoid returning sentinel penalties in normal flow.\nTERMINATION_CRITERIA:Undefined stopping rules. Add iteration\/time caps and early stop on score==3 (known optimum).\nKNOWN_SOLUTION_USE:Leverage known k=3 as target; implement decreasing-k strategy: iteratively attempt k-coloring with k from max_color down to 3 using feasibility search.\nLOGGING_MIN:Set minimal structured logs: iter, score, conflicts, k, move_tag for debuggability without I\/O or OS calls.\nTEST_BENCH:Add unit tests for evaluate_solution and neighbor invariants (no index errors, no color<1); verify known solution scores 3.\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9]","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # Large integer penalty; lesser is better\n        return int(10**9 + conflicts)\n\n    # Feasible: objective is to minimize max color (k)\n    return int(max(solution))\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # DSATUR-like greedy seeding if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Helper: count conflicts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # If conflicts exist, try to recolor a conflicted vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # pick the most conflicted, tie-break by higher degree then lower index\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 0)) or [1]\n        if not palette:\n            palette = [1]\n        # Ensure at least one candidate; try existing palette only to avoid color inflation\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in range(1, current_max + 0):\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        # If no better color in current palette, allow same color (no-op) to keep signature\n        sol[u] = best_color\n        move = \"SingleVertexRecolor\"\n        return sol, move\n\n    # Conflict-free: attempt to reduce maximum color by lowering vertices of top color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Try to lower each top-color vertex using best-fit (min conflicts)\n    improved = False\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # Choose the candidate minimizing future conflicts around neighbors (tie by smaller color)\n        best_c = None\n        best_c_key = (10**9, 10**9)\n        for c in candidate_colors:\n            loc = local_conflicts_if(u, c)\n            key = (loc, c)\n            if key < best_c_key:\n                best_c_key = key\n                best_c = c\n        if best_c is not None:\n            sol[u] = best_c\n            improved = True\n            move = \"LowerColorGreedyBestFit\"\n            break\n\n    if improved:\n        return sol, move\n\n    # As a diversification step, recolor a random vertex within current palette to its best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in range(1, current_max + 1):\n        if c == old:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"DiversificationBestLocal\"\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Simple repair\/seed if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Kempe chain swap focused on a random vertex\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Short random recolor walk constrained to current palette\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Determine conflict level to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.6:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","SAMPLE_SOL":"[2,3,1,3,2,1,3,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9] \/\/ list of 9 positive integers; color labels compacted to 1..k","Componente":null,"Version":6,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_OBJ_INVARIANCE:Evaluation depends on label order via max_color_count and sum_colors after compaction. Replace tertiary\/quaternary terms with label-invariant metrics (e.g., max class size, class-size variance) or drop them.\nE_OBJ_MISALIGN:KNOWN_SOLUTION_EXPECTED_SCORE=3 conflicts with evaluate_solution returning 1000*k+... Align evaluation with k-first lexicographic cost or expose a k-only scorer for success checks\/termination.\nE_PENALTY_SCALE:Fixed M=1e6 may be over\/under-scaled across instances. Use lexicographic tuple comparison or dynamically set M > max secondary range; or return a tuple to avoid brittle weighting.\nE_VALIDATION_RIGID:Hard-fails non-int colors but later compaction could handle zeros. Allow 0 as uncolored only if intended, otherwise keep strict but document.\nNB_API_SIG:generate_neighbour type hint '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is invalid and may break runners parsing annotations. Remove or replace with '-> Tuple[List[int], str]'.\nNB_RUNTIME_OVERHEAD:Adjacency rebuilt every call O(n+m). Cache static graph and adjacency externally; pass via other_params or module-level constant to cut per-call cost.\nNB_SEED_REPAIR:Function silently seeds on invalid input, mixing responsibilities. Split into seed_solution() and generate_neighbour(); enforce input validity at driver level.\nNB_MOVE_SCOPE:Kempe chains and class swaps are large moves under a \u201cneighbour\u201d API, harming fine-grained search acceptance. Gate with probabilities or move schedule; default to 1-vertex recolor.\nNB_CONFLICT_HEURISTIC:Local recolor minimizes neighbor conflicts only; may increase global conflicts via chain effects. Add delta-evaluation of full conflict delta using edge list for the moved vertex.\nNB_K_REDUCTION:ReduceK step only tries smallest feasible color; also try recolor+Kempe to enable class removal, and attempt color-class merge checks before diversification.\nNB_DIVERSIFICATION:Random class swap is symmetric and may be neutral. Bias swaps using class sizes or cut-set size; or use path-relinking toward elite solutions.\nNB_REPRODUCIBILITY:random used without seed control. Accept rng in other_params and use Random instance to ensure determinism for benchmarking.\nNB_OUTPUT_CONTRACT:Returns (neighbor, move_type) but heuristic driver may expect only neighbor. Standardize return or adapt driver; document contract.\nNB_CONFLICT_SELECTION:Selects single most conflicted vertex only. Use breakout moves on a pool (e.g., choose among top-k conflicted by tie-breaking on saturation\/degree).\nNB_KEMPE_SAFETY:Kempe interchange chosen with random other color may increase conflicts. Evaluate delta before accepting; otherwise revert.\nNB_COMPACTION_COST:Frequent compact_colors adds O(n) per move. Maintain a color remapping structure; defer compaction to evaluation or only on accepted moves.\nPERTURB_MISSING:Perturbation function undefined. Provide perturb_solution implementing e.g., multi-vertex ejection chain, random Kempe cascade, or targeted class removal attempts.\nREP_CONSISTENCY:Representation says labels compacted 1..k but code compacts in multiple places. Centralize compaction in a single utility to prevent inconsistencies and double work.\nE_TYPING_FAILURE:Runner error 'Type List cannot be instantiated' indicates environment evaluates typing annotations. Remove typing imports\/annotations to avoid runtime instantiation errors.\nE_DELTA_EVAL:Full reevaluation per move is O(m). Implement delta evaluation for conflicts and k tracking per moved vertex to achieve amortized O(deg(u)).\nE_STOP_CRITERION:Objective\u2019s tertiary\/quaternary tie-breakers may trap search in label artifacts. Use robust tie-breakers like total conflicts then k then sum of class boundary conflicts.\nE_EDGE_DUP:Edge list duplicated across components. Define once and share to avoid divergence and reduce overhead.\nE_CONSTRAINT_ENFORCEMENT:Neighbour may create conflicts during diversification. If heuristic requires feasible neighborhood, add feasibility filter or penalty-aware acceptance.\nHEURISTIC_SIGNATURE:Target signature provided but no Heuristic implementation. Implement driver with SA\/ILS\/TS variants conforming to signature and return best, best_score consistently.\nACCEPTANCE_POLICY:Moves are always returned without acceptance logic. Integrate evaluate_solution and an acceptance criterion (e.g., SA temperature, tabu filter) into Heuristic, not into neighbour.\nTABU_MEMORY:Tabu Search failures suggest missing tabu structure. Add short-term tabu on (vertex,color) assignments with aspiration based on best_score.\nSCALABILITY:Hard-coded n=9 and embedded edges limit reuse. Generalize via other_params graph input; validate lengths accordingly.\nCONFLICT_PRIORITIZATION:Use DSATUR-like ordering for conflicted vertices (higher saturation, then degree) to improve repair effectiveness.\nCOLOR_CLASS_OPERATORS:Add color class split\/merge and recolor of boundary vertices to systematically attempt k reduction.\nTERMINATION_METRICS:Track stalls by conflict and k improvements separately to adaptively switch between intensification and diversification.\nACTIONABLE_FIXES:1) Remove typing annotations\/imports; 2) Externalize graph and cache adjacency; 3) Implement perturb_solution; 4) Implement delta-eval; 5) Rework objective to lexicographic (conflicts,k) with invariant ties; 6) Add RNG to other_params; 7) Enforce consistent neighbor return contract.\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9] \/\/ list of 9 positive integers; color labels compacted to 1..k","EVAL_CODE":"import math\nfrom typing import List, Dict\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return int(10**12)\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping: Dict[int,int] = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts and stats\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    k = max(compact)\n    max_color_count = sum(1 for x in compact if x == k)\n    sum_colors = sum(compact)\n\n    # Penalty with gradient among infeasible moves; lesser is better\n    # Primary: conflicts; Secondary: k; Tertiary: number of vertices at max color; Quaternary: sum of colors\n    M = 10**6\n    if conflicts > 0:\n        return int(M*conflicts + 1000*k + 10*max_color_count + sum_colors)\n\n    # Feasible\n    return int(1000*k + 10*max_color_count + sum_colors)","NB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u: int, color: int) -> int:\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Kempe chain interchange between two colors a and b starting from u\n    def kempe_chain_interchange(u: int, a: int, b: int):\n        visited = [False]*n\n        dq = deque([u])\n        visited[u] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, repair by recolor or Kempe move\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        # Try recolor within palette to minimize local conflicts\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return compact_colors(sol), \"ConflictRecolor\"\n        # Try Kempe chain with a random other color to break ties\n        if len(palette) >= 2:\n            other = random.choice([c for c in palette if c != old])\n            kempe_chain_interchange(u, old, other)\n            return compact_colors(sol), \"ConflictKempe\"\n        return compact_colors(sol), \"ConflictNoOp\"\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # choose smallest color to bias compaction\n        c = min(candidate_colors)\n        sol[u] = c\n        return compact_colors(sol), \"ReduceK_LowerTopVertex\"\n\n    # If k-reduction failed, diversify via color-class swap of two colors\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return compact_colors(sol), \"Diversify_SwapClasses\"\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return compact_colors(sol), \"Diversify_RandomRecolor\"","PERTURB_CODE":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Seed if invalid\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Kempe chain swap focused on random vertices\n    def kempe_swap(start_idx: int):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk constrained to current palette\n    def random_walk_recolors(L: int):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Determine conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Componente":null,"Version":7,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\"\n\"FEEDBACK\":\"H_SIG_MISMATCH:Heuristic drivers (SA\/ILS\/TS) do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) across all or provide adapter wrappers per algorithm.\"\nH_FUNC_PASSING_ERROR:Function references are passed\/called incorrectly. Remove parentheses when passing: use generate_neighbour not generate_neighbour(). Same for evaluate_solution and perturb_solution.\"\nRET_SHAPE_INCONSISTENCY:generate_neighbour returns (solution,move) but at least one driver expects only solution or expects 3+. Define a single contract: return solution only OR wrap with adapter: def gen_adapt(sol): s,_=generate_neighbour(sol); return s.\"\nTS_EVAL_UNPACK:Tabu Search attempts to unpack evaluate_solution's int (cannot unpack non-iterable). Unify: either make evaluate_solution return only int everywhere, or add adapter: def eval_adapt(s): return evaluate_solution(s), None.\"\nOBJ_SCALE_MISMATCH:Expected score 3 conflicts with evaluate_solution\u2019s large lexicographic int. For functional correctness, adapt objective: def objective(s): k=...; conf=...; return k if conf==0 else 10**9+conf. Update drivers to use objective for acceptance\/comparison.\"\nPERTURB_MISSING:$Perturb placeholder breaks ILS signature. Implement perturb_solution(solution,other_params) that performs controlled multi-vertex recolor\/Kempe perturbations and preserves feasibility when possible.\"\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor restricted to existing palette may stall. Add targeted Kempe chain on (old,best_color) minimizing conflicts; include pair-exchange (swap colors on vertex and one neighbor) to escape plateaus.\"\nNB_K_REDUCTION_WEAK:ReduceK step only lowers top-color vertices greedily. Add focused top-color elimination: iterate vertices of top_color and try Kempe chains with each lower color; if none, move a minimal hitting set of conflicting neighbors.\"\nR_STR_INADEQUATE:Color relabeling each step breaks memory for Tabu. Canonicalize only for evaluation; keep stable labels in the search state to allow (vertex,color) tabu tenure. Alternatively, implement a deterministic relabeling policy applied once per iteration and mirrored in tabu keys.\"\nE_CODE_PERF:O(m) recomputation per neighbor with repeated compaction. Cache class_sizes, k, and conflict_counts; maintain incremental deltas for single-vertex recolor and color-class swap to achieve O(deg(u)) per move.\"\nDIVERSIFICATION_NOISE:Class-swap diversification is blind and may destroy progress. Gate by no-improvement counter and accept only if conflicts do not increase beyond a threshold; prefer randomized Kempe cycles of bounded size.\"\nSEED_REPRODUCIBILITY:Randomness used without controllable seed. Add seed parameter in other_params and seed RNGs for reproducible runs and fair evaluation.\"\nACCEPTANCE_POLICY_DRIFT:SA\/ILS mixing feasibility and cost inconsistently will misguide acceptance. Enforce lexicographic acceptance: primarily minimize conflicts, secondarily minimize k; only then apply tie-breakers.\"\nSTOPPING_CRITERIA:Drivers lack explicit stopping rules. Add max_iters, max_no_improve, and time budget in other_params; expose early-stop on reaching conflicts=0 and k<=3.\"\nINIT_STRATEGY:Greedy seed DSATUR is fine but unscored. Add multi-start with different DSATUR tie-breakers and pick the best by objective before metaheuristic phase.\"\nTABU_TUNING:Define tabu on (vertex,color) with tenure in [7, 10] and aspiration if move yields better best_score; maintain short-term memory of moved vertices to prevent immediate reversals.\"\nK_SEARCH_FRAME:Adopt decreasing-k framework: solve feasibility for fixed k with Tabu\/SA; when feasible, decrement k and restart from compacted solution. Guarantees alignment with minimization target.\"\nCONSTRAINT_CHECK:Ensure evaluation rejects invalid solutions fast without remapping overhead; return penalty immediately on invalidity to save cycles.\"\nLOGGING_MINIMAL:Record only scalar metrics (score, conflicts, k, move_type) per iteration to avoid overhead; avoid storing full solutions except current and best.\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9]","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # k and label-invariant tie-breakers based on class sizes\n    k = max(compact)\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    # ignore index 0\n    class_sizes = class_sizes[1:]\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq) with dynamic safe weights\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n           # max_class <= n\n    max_quat = n*n        # sum of squares <= n^2 when one class has all\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR-like: pick vertex with most distinct neighbor colors, then degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Fine-grained move: single-vertex recolor prioritized on conflicts\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (compact_colors(sol), \"ConflictRecolor\")\n        # If no improvement with palette recolor, try a small Kempe chain with one random other color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == old:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = old\n            return (compact_colors(sol), \"ConflictKempe\")\n        return (compact_colors(sol), \"ConflictNoOp\")\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (compact_colors(sol), \"ReduceK_LowerTopVertex\")\n\n    # Diversify: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (compact_colors(sol), \"Diversify_SwapClasses\")\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (compact_colors(sol), \"Diversify_RandomRecolor\")\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]  \/\/ list of 9 positive integers; color labels are 1..k","Componente":null,"Version":8,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_OBJ_MISMATCH:Evaluation returns large lexicographic weight; external EXPECTED SCORE uses k=3. Provide EVAL_WRAPPER: if conflicts>0 return 10**12 else return k to align with runners.\nE_EVAL_OVERWEIGHT:SumSq and MaxClass tie-breakers can constrain exploration without improving k. Remove SumSq or demote to post-processing; keep lex order (conflicts,k,MaxClass) only.\nE_EVAL_REDUNDANCY:Recompute compact and class sizes each call O(V+E). Implement delta evaluation keyed by moved vertex and affected neighbors to cut to O(deg(u)).\nNB_CODE_FAIL_LOCAL_OPT:Kempe choice is random. Enumerate candidate colors b and select that minimizing resulting local conflicts; accept only if conflicts do not increase.\nNB_K_REDUCTION_WEAK:Only lowers single top-color vertex. Add TopClass recoloring (try greedy recolor of full top class, then targeted Kempe chains) to actually remove color k.\nNB_LACKS_COMPACTION:Neighbour does not compact labels post-move; although evaluation compacts, search may carry dead colors. Add in-neighbour compaction after any change that empties a class.\nNB_PALETTE_CONSTRAINT:Conflict recolor restricts to current palette, blocking constructive new color moves in SA\/ILS phases. Allow temporary new color when stuck to escape local minima, coupled with strong k-penalty.\nNB_MOVE_DIVERSIFICATION_WEAK:Diversify_SwapClasses is symmetry-only; no structural change. Replace with color-pair Kempe chain on high-cut pairs and random vertex recolor with tabu tenure.\nNB_DELTA_MISSING:Neighbour does not provide delta score. Return (sol, move, delta) or expose DeltaEvaluate(u,old,new) to enable efficient acceptance in SA\/TS.\nPERTURB_MISSING:'$Perturb' placeholder breaks TARGET_HEURISTIC_FUNCTIONALITY. Implement perturb_solution: multi-vertex kick (e.g., pick top color class, random 2-color Kempe on induced subgraph, or random recolor k% of vertices).\nAPI_INTEGRATION_FAIL:SAMPLE_SOL loader expects str.strip but receives list. Normalize input types or serialize sample solutions as space-separated strings.\nHEURISTIC_ABSENT:No Heuristic(...) implementation. Provide SA\/ILS\/TS driver adhering to signature, using evaluate_solution and generate_neighbour; ensure best is updated when score strictly decreases.\nACCEPT_RULE_UNSPECIFIED:No acceptance criterion. For SA: Metropolis with geometric cooling; for ILS\/TS: best-improving with aspiration and tabu on (vertex,color) pairs.\nR_INIT_WEAK:Greedy seed inside neighbour only on invalid input. Expose a robust initializer (DSATUR or greedy with tie-breaking by saturation, degree, index) for starting states.\nE_CONSTRAINT_VALIDATION_LAX:Evaluation only checks ints>=1. Add explicit hard penalty if k>n or any color==0; early exit when conflicts detected to save compute.\nNB_ORDERING_STATIC:Chooses highest-conflict single vertex deterministically, risking cycling. Break ties with age\/last-moved and maintain short-term memory (tabu) on vertices.\nK_TARGETING_UNFOCUSED:No explicit k-target loop. Implement descending-k framework: attempt to find feasible coloring with k-1 by iterative repair; if fail, diversify and retry.\nSTOPPING_CRITERIA_UNSPECIFIED:Add max_iters, no_improve_limit, and time cap; track move acceptance ratio to auto-tune temperature\/perturbation strength.\nRANDOMNESS_UNCONTROLLED:Set and pass RNG seed in other_params for reproducibility; avoid hidden globals in components.\nCOMPAT_CONSTRAINT:Ensure all component code is pure and side-effect free per MAIN_CRITICAL_INSTRUCTION; remove any I\/O assumptions in loaders and avoid filesystem calls.\nTESTS_MISSING:Add unit tests: conflict resolution reduces conflicts; Kempe never increases k; top-class recolor eliminates color when feasible; evaluate_solution matches wrapper score when conflict-free.\"","Componentes":{"REPRESENTATION":"COLOR_LIST[9]  \/\/ list of 9 positive integers; color labels are 1..k","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure fast\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations (label-invariant evaluation)\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # Number of colors\n    k = max(compact) if compact else 0\n\n    # Tie-breakers\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    class_sizes = class_sizes[1:] if k > 0 else []\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq)\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n\n    max_quat = n*n\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # 1) If conflicts exist: prioritize resolving a high-conflict vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n\n        # Try recoloring within existing palette minimizing local conflicts and k\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (sol, \"ConflictRecolor\")\n\n        # If no gain, attempt a Kempe chain swap on a random alternate color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                sol[x] = b if sol[x] == old else (old if sol[x] == b else sol[x])\n            return (sol, \"ConflictKempe\")\n\n        return (sol, \"ConflictNoOp\")\n\n    # 2) If conflict-free: attempt to reduce number of colors by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (sol, \"ReduceK_LowerTopVertex\")\n\n    # 3) Diversification: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (sol, \"Diversify_SwapClasses\")\n\n    # 4) Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (sol, \"Diversify_RandomRecolor\")\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","SAMPLE_SOL":[2,3,1,3,2,1,3,3,1]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONSECUTIVE_1_TO_K","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"HEUR_SIGNATURE_VIOLATION:All metaheuristics violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass functions without parentheses.\nNB_RET_SIG_MISMATCH:generate_neighbour returns 3 values; SA\/ILS\/TS attempt to unpack 2 or 1. Standardize to return (new_solution, meta_dict) or just new_solution and update all call sites consistently.\nPERTURB_MISSING:Placeholder '$Perturb' is undefined. Implement a perturb_solution(currentSolution,other_params) operator (e.g., Kempe-chain shake or remove-highest-color-and-greedy-reinsert).\nE_SCALARIZATION_WEAK:Penalties allow non-consecutive palette with low cost. Use lexicographic scalarization: fitness=conflicts*1e6 + gaps*1e4 + k to strictly prioritize feasibility, then consecutiveness, then k.\nE_RANGE_PENALTY_UNDERWEIGHT:PEN_RANGE=10 is negligible versus objective and conflicts. Increase to >=1e4 or remove by enforcing consecutiveness via normalization.\nE_CONSISTENCY:Do not mutate semantics in evaluate_solution. Keep it pure and deterministic; move any normalization out of evaluation.\nNB_COLOR_NORMALIZE_DESTABILIZES:_normalize_consecutive_colors uses order-of-appearance, relabeling many vertices per move and breaking memory in Tabu\/SA states. Replace with stable mapping using sorted palette to keep color classes invariant: map sorted(set(cols)) -> 1..k.\nNB_MOVE_SET_LIMITED:Single-vertex recolor and swaps have poor ability to escape plateaus. Add Kempe-chain interchange, color-class merge\/split, and targeted recolor of conflicted vertices.\nNB_COLOR_REDUCTION_MISSING:Lack of explicit k-reduction. Add operator: attempt to drop max color c_max by recoloring its vertices greedily (DSATUR order); accept if conflicts do not increase beyond threshold.\nNB_CONFLICT_DRIVEN_SELECTION:Uniform vertex choice wastes iterations. Bias selection to conflicted vertices; if no conflicts, focus on vertices of the highest color to reduce k.\nSA_PARAM_API_ERROR:SA signature shows generate_neighbour() and evaluate_solution() called in parameters; pass function objects, not results. Fix parameter passing and internal calls accordingly.\nTS_UNPACK_ERROR:Error 'cannot unpack non-iterable int object' indicates caller expected tuple but got scalar. Standardize generate_neighbour return and adjust unpacking in TS loop.\nILS_API_ERROR:ILS signature and acceptance args inconsistent with TARGET_HEURISTIC_GENERAL_SIGNATURE. Move acceptance policy into other_params or internal logic and adhere to the unified signature.\nINIT_STRATEGY_INADEQUATE:Random\/naive starts slow convergence. Add DSATUR\/greedy constructive initializer to produce feasible 3-coloring quickly on this graph.\nE_TEST_COVERAGE_GAP:Missing validations. Add unit checks: evaluate_solution([3,1,2,1,3,2,1,1,2])==3; conflicts counted correctly; consecutive palette detection robust.\nR_SEED_CONTROL_MISSING:No deterministic control. Route RNG seed via other_params to reproduce runs and enable tuning.\nE_RUNTIME_METRIC:Evaluation is O(|E|) per call; acceptable. Cache conflict counts and adjacency to support incremental evaluation for single-vertex recolors to reduce amortized cost.\nTABU_LIST_DEFINITION_WEAK:Without stable color labels, tabu on moves is meaningless. After stable normalization, define tabu on (vertex,color) assignments or on Kempe-chain signatures.\nACCEPTANCE_CRITERIA_WEAK:ILS\/SA lack clear acceptance logic consistent with minimization. Ensure best is updated on strictly lower fitness; tie-breaking favors lower k, then fewer conflicts.\nSTOPPING_CRITERIA:No robust stop. Add iteration\/time budgets and early stop when k==3 and conflicts==0 with gaps==0 on this instance.\nINSTRUMENTATION_MISSING:Record conflicts,k,gaps per iteration to diagnose penalty interactions and premature convergence.\nFINAL_CORRECTION_SUMMARY:Fix API\/signatures, standardize neighbor return, implement perturbation, enforce stable normalization or strong penalties, expand move set with Kempe-chain and color-reduction, add DSATUR init and tests for the known 3-color solution.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_CONSECUTIVE_1_TO_K","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Objective: minimize number of colors while satisfying constraints.\n    # Embedded problem data (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Entry checks\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n\n    cols = solution\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Consecutive color indexing check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if k > 0:\n        if unique_colors != list(range(1, k+1)):\n            # Penalize non-consecutive usage; approximate via missing indices in expected 1..k\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            # If the minimum color is not 1, add a violation\n            if unique_colors[0] != 1:\n                range_violations += 1\n\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","NB_CODE":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    # Relabel colors to 1..k preserving order of appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor; sometimes try color reduction or swap\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple default feasible-shaped neighbor\n        base = [1]*9\n        return (_normalize_consecutive_colors(base), \"Random-Recolor\", \"Single-Vertex\")\n\n    cols = list(solution)\n    n = len(cols)\n    # Choose move type\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor to existing or new color (allow exploration)\n        i = random.randrange(n)\n        current_max = max(cols) if cols else 1\n        # Bias towards existing colors\n        if random.random() < 0.85:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Random-Recolor\", \"Single-Vertex\")\n    elif r < 0.85:\n        # Swap colors of two vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        cols[i], cols[j] = cols[j], cols[i]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Swap-Vertices\", \"Swap-Two\")\n    else:\n        # Relabel two colors (color permutation on palette) to encourage consolidation\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            cols = [ (b if c==a else a if c==b else c) for c in cols ]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Relabel-Colors\", \"Palette-Permutation\")\n","PERTURB_CODE":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    mapping = {}\n    nxt = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple randomized recolors plus optional palette squeeze\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    cols = list(solution)\n    n = len(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new color\n        if random.random() < 0.9 and current_max > 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max if current_max > 1 else 1\n    # Palette squeeze: try to map highest color to a lower one probabilistically\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.7:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [ (target if c==highest else c) for c in cols ]\n    cols = _normalize_consecutive_colors(cols)\n    return cols\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_PALETTE_1..k; indices 1..9 map to nodes 1..9; values are positive ints; colors normalized to sorted unique palette 1..k","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_API_SIG_MISMATCH:SA\/ILS\/TS signatures use generate_neighbour() and evaluate_solution() as parameters with parentheses. Pass callables without parentheses per TARGET_HEURISTIC_GENERAL_SIGNATURE and return (best_solution,best_score).\nNB_RET_INCOMPATIBLE:generate_neighbour returns (solution,move_name) but heuristics expect a solution only; standardize to return solution (list[int]) exclusively or update all heuristics to handle a 2-tuple safely.\nPERTURB_MISSING:Perturbation function is placeholder. Implement def perturb_solution(solution, intensity=1, rng=None): returning a normalized list; include Kempe-chain swap or multi-vertex recolor to escape local minima.\nTS_UNPACK_BUG:Tabu Search attempts to unpack a non-iterable from evaluate_solution (float). Ensure you do not unpack evaluate_solution; only compare floats from evaluate_solution(neigh).\nR_IFACE_CONTRACT:All components must adhere to Representation. Always normalize palette after any modification. Expose a shared normalize_palette(cols) and call it in init\/neighbour\/perturb.\nE_SCALARIZATION_REDUNDANCY:gaps term is redundant if neighbours\/perturb normalize palettes. Remove gaps from fitness or stop normalizing in neighbour; prefer keeping normalization and drop gaps to reduce noise.\nINIT_STRATEGY_WEAK:No explicit initializer; default fallback is ad hoc. Add DSATUR\/greedy constructive init producing a 3-color feasible start, improving convergence.\nNB_CODE_FAIL_LOCAL_OPT:Only single-vertex recolor is used; this stalls near plateaus. Add moves: (a) color-swap between two colors, (b) Kempe-chain recoloring, (c) targeted k-reduction by removing max color and repairing violated vertices.\nE_CODE_PERF:Full recomputation per move is O(|E|)=18 edges (fine), but enable optional delta evaluation in heuristics to scale; keep pure evaluate_solution unchanged for determinism.\nHEURISTIC_RETURN_TYPES:All heuristics must return (best_solution: list[int], best_score: float). Ensure acceptance\/comparison always uses floats from evaluate_solution.\nILS_ACCEPTANCE_PARAM:Parameter spelled 'aceptance_rate' in message; correct to acceptance_rate and implement acceptance: new accepted if score <= curr or random()<acceptance_rate.\nSA_PARAM_HANDLING:other_params should carry TEMP, MIN_TEMP, cooling_factor; ensure they are read from dict and SA acceptance uses exp(-(new-old)\/T) with T updated by cooling_factor.\nTS_TABU_DEFINITION:Define tabu on moves or solutions: use tuple(solution) in a set\/queue with fixed size; add aspiration if candidate_score < best_score to override tabu.\nRNG_CONTROL:Inject rng via other_params and pass into neighbour\/perturb for reproducibility. Avoid global random where possible.\nKNOWN_SOLUTION_CHECK:Add a unit check in harness: assert evaluate_solution([3,1,2,1,3,2,1,1,2])==3 to verify pipeline integrity.\nERROR_HANDLING:Guard heuristics against neighbours returning invalid shapes; if tuple, extract first element; if invalid, reinitialize with normalized default and continue.\nINTERFACE_STANDARDIZATION:Final unified signatures: \n- Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) -> (best_solution, best_score)\n- generate_neighbour(solution, rng=None) -> solution\n- perturb_solution(solution, intensity=1, rng=None) -> solution\n- evaluate_solution(solution) -> float\nStop using auxiliary move_name in return paths; log moves separately if needed.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_CONSECUTIVE_PALETTE_1..k; indices 1..9 map to nodes 1..9; values are positive ints; colors normalized to sorted unique palette 1..k","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic, pure evaluation. Lower is better.\n    # Embedded graph (1-indexed):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette consecutiveness gaps\n    palette = sorted(set(cols))\n    k = len(palette)\n    gaps = 0\n    if k > 0:\n        expected = set(range(1, k+1))\n        gaps = len(expected.difference(palette))\n        if palette[0] != 1:\n            gaps += 1\n\n    # Lexicographic scalarization: feasibility -> consecutiveness -> k\n    fitness = conflicts * 1_000_000.0 + gaps * 10_000.0 + float(k)\n    return float(fitness)\n","NB_CODE":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    # Map sorted palette to 1..k to satisfy representation constraints deterministically\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # If invalid input, return a default normalized solution\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return (_stable_normalize_palette([1,2,3,1,2,3,2,1,3]), \"Init-Default\")\n\n    cols = list(solution)\n\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = len(cols)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors, small chance to explore new color\n        if random.random() < 0.9:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Conflict-Driven\")\n    else:\n        # No conflicts: try to reduce k by changing a vertex with highest color\n        current_max = max(cols)\n        candidates = [i for i,c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        # Try a different existing lower color with bias\n        if current_max > 1 and random.random() < 0.85:\n            new_color = random.randint(1, current_max-1)\n        else:\n            new_color = random.randint(1, current_max)\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Reduce-k\")\n","PERTURB_CODE":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef perturb_solution(solution):\n    # Strong shake: multiple recolors + optional palette squeeze; keeps representation normalized\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return _stable_normalize_palette([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    n = len(cols)\n\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer recolors within current palette; occasional exploration to new color\n        if random.random() < 0.92 or current_max == 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max + 1\n\n    # Palette squeeze: map highest color to a random lower one with some probability\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.75:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    cols = _stable_normalize_palette(cols)\n    return cols\n","SAMPLE_SOL":"[3,1,2,1,3,2,1,1,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_PALETTE_CONSECUTIVE. Nodes 1..9 map to indices 1..9. Each entry is a positive int color. Palette normalized to 1..k with k=|unique colors|.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"E_OBJ_CONSTRAINT_GAP:Evaluation does not enforce consecutive palette explicitly; k=len(set(cols)) allows gaps. Add normalization or penalty term for non-consecutive colors in evaluation or auto-normalize in Heuristic loop.;E_PENALTY_SCALE_RISK:conflicts weight 1e6 may cause float issues and hinder fine-grained acceptance in SA; use integer fitness tuple (conflicts, k) or lexicographic compare to avoid scaling artifacts.;E_REDUNDANT_IMPORTS:Unnecessary math\/random imports within evaluation increase overhead; remove inside hot path.;E_STATELESS_CACHE_MISS:No memoization of evaluate_solution; add lightweight hashing (tuple(solution)) cache to reduce repeated evals in SA\/ILS.;NB_CODE_FAIL_LOCAL_OPT:Neighbour lacks targeted 2-opt analogs for color classes; add color-class elimination attempts with greedy recoloring of class maxColor to lower colors.;NB_MOVE_IMBALANCE:Conflict-driven recolor uses random existing color; prefer min-conflict color with adjacency scan to accelerate feasibility repair.;NB_KEMPE_RISK:Kempe-chain swaps chosen uniformly; bias seeds on vertices adjacent to maxColor to focus k-reduction; add post-swap min-conflict repair for any new conflicts.;NB_COLOR_SWAP_LIMIT:Swap-Colors is symmetry move; often neutral. Replace with guided color merge (try map maxColor->lower if feasible, else repair small set).;NB_NORMALIZE_ONLY_LOCALLY:_normalize called per move; normalize once per outer iteration in Heuristic to reduce repeated remapping cost.;REP_VALIDATION_WEAK:Representation relies on neighbours to normalize; enforce normalization in Heuristic before evaluation and after perturbation to guarantee consecutive palette.;PERTURB_MISSING:Perturbation function undefined ($Perturb). Provide concrete shaking: random recolor of p vertices using min-conflicts, or destroy-repair by removing maxColor class and recoloring with greedy DSATUR.;SA_SCHEDULE_GENERIC:No evidence of temperature schedule tuning; adopt geometric T_k=T0*alpha^k with reheats on stagnation; calibrate T0 via initial delta distribution; stop by max_evals not iterations.;ILS_WEAK_DIVERSIFICATION:Perturbation in ILS unspecified; add adaptive perturb strength proportional to stagnation and preserve elite structure (don\u2019t touch vertices critical for k).;TS_SIGNATURE_MISMATCH:Tabu Search signature incompatible with TARGET_HEURISTIC_GENERAL_SIGNATURE and unpack error shown. Standardize TS to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and package taboo params in other_params.;TS_TABU_DEFECT:No aspiration or move attributes defined; use attribute-based tabu on (vertex,color) with tenure in [l,u], aspiration if move improves best_score.;TS_MOVE_SELECTION_WEAK:Selecting neighbour via external generator hides tabu filtering; integrate neighbourhood evaluation with incremental conflict delta and choose best admissible.;API_UNIFORMITY_FAIL:Heuristics return heterogeneous tuples; standardize return to (best_solution,best_score,last_solution,last_score,meta) for all to avoid parsing failures.;E_INIT_INCONSISTENT:DSATUR-like init embedded in neighbour on invalid input only; extract dedicated initializer and call at Heuristic start to ensure high-quality feasible seeds.;E_INCREMENTAL_DELTA:Evaluation recomputes conflicts O(|E|) per move; implement incremental delta updates by tracking conflicts per vertex and adjacency to achieve O(deg(v)) updates.;E_GRAPH_STATIC:Edges rebuilt in multiple places; precompute adjacency list once and pass via closure\/other_params to cut overhead.;E_ACCEPTANCE_POLICY_OPAQUE:Heuristic acceptance criteria unspecified; for SA use Metropolis on fitness tuple; for ILS use accept-if-better with occasional kick; for TS use best-admissible deterministic.;STOPPING_CRITERIA_VAGUE:Use budget-based stopping (max_evals, max_time) and early-stop if k reaches proven lower bound (use clique lower bound).;LB_TIGHTENING_OMITTED:No lower bound exploited; compute omega via greedy clique heuristic to know when k is optimal and stop.;FEASIBILITY_REPAIR_ABSENT:After k-reduction attempts, lack of immediate repair; invoke min-conflict recolor loop until conflicts=0 or revert.;MOVE_PORTFOLIO_THIN:Add ejection-chain recoloring and pairwise recolor with BFS-limited neighborhood to escape plateaus.;RANDOM_SEED_CONTROL:No seed management; add optional seed in other_params for reproducibility and fair comparisons.;CODE_SAFETY:Ensure no filesystem\/network\/os calls inside heuristic components per MAIN_CRITICAL_INSTRUCTION; audit imports and remove side-effect code.;INTERFACE_CONTRACT:Ensure Heuristic returns best_score consistent with evaluate_solution and uses lower-is-better convention; avoid negative scores since problem is minimization.;TESTS_COVERAGE_GAP:Add unit tests: (a) normalization, (b) evaluation of known solution=3, (c) neighbour preserves domain and length, (d) perturb keeps indices consecutive after normalization.;LOGGING_MINIMAL:Add lightweight telemetry: counts of conflicts, k, move types distribution, acceptance rate to detect stagnation and retune parameters.;PERF_PARAM_TUNING:Auto-tune alpha, tenure, perturb_strength using brief racing on small evaluation budget before main run.;RESTART_STRATEGY:Implement multi-start with elite archive and Path-Relinking between elite solutions to intensify around k=3 frontier.;OUTPUT_VALIDATION:Add final palette re-normalization and assert feasibility; if infeasible, trigger focused repair or report last feasible best only.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_PALETTE_CONSECUTIVE. Nodes 1..9 map to indices 1..9. Each entry is a positive int color. Palette normalized to 1..k with k=|unique colors|.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size (objective proxy for k)\n    k = len(set(cols)) if cols else 0\n\n    # Fitness: prioritize feasibility, then minimize k\n    fitness = conflicts * 1_000_000.0 + float(k)\n    return float(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Simple greedy DSATUR-like initializer to produce feasible small-k coloring\n        order = [1,3,6,5,4,7,2,9,8]  # heuristic order\n        cols = [0]*n\n        used = set()\n        for u in order:\n            uidx = u-1\n            forbidden = set()\n            for (a,b) in edges:\n                if a == u and cols[b-1] != 0:\n                    forbidden.add(cols[b-1])\n                elif b == u and cols[a-1] != 0:\n                    forbidden.add(cols[a-1])\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[uidx] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new\n        new_color = random.randint(1, current_max) if (random.random() < 0.92 or current_max == 0) else current_max + 1\n        cols[i] = new_color\n        return (_normalize(cols), \"Recolor-Conflict\")\n    else:\n        # Mixture of advanced moves on feasible solution to reduce k\n        move_choice = r\n        current_max = max(cols)\n        if move_choice < 0.4 and current_max > 1:\n            # Targeted k-reduction: pick a vertex with highest color and try a lower one\n            candidates = [i for i,c in enumerate(cols) if c == current_max]\n            i = random.choice(candidates)\n            target = random.randint(1, current_max-1)\n            cols[i] = target\n            return (_normalize(cols), \"Targeted-Reduce-k\")\n        elif move_choice < 0.75 and current_max >= 2:\n            # Color-swap between two colors\n            c1, c2 = random.sample(sorted(set(cols)), 2)\n            mapping = {c1: c2, c2: c1}\n            new_cols = [mapping.get(c, c) for c in cols]\n            return (_normalize(new_cols), \"Swap-Colors\")\n        else:\n            # Kempe-chain recoloring between two colors\n            palette = sorted(set(cols))\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                # Build adjacency list\n                adj = {i: set() for i in range(1, n+1)}\n                for (u,v) in edges:\n                    adj[u].add(v)\n                    adj[v].add(u)\n                # Pick a seed vertex of color c1 or c2\n                candidates = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n                seed = random.choice(candidates)\n                # BFS on subgraph induced by colors c1,c2\n                stack = [seed]\n                visited = set([seed])\n                while stack:\n                    u = stack.pop()\n                    for w in adj[u]:\n                        if w not in visited and cols[w-1] in (c1,c2):\n                            visited.add(w)\n                            stack.append(w)\n                # Swap colors on the Kempe chain\n                for u in visited:\n                    cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n                return (_normalize(cols), \"Kempe-Chain\")\n            else:\n                # Fallback recolor\n                i = random.randrange(n)\n                cols[i] = 1\n                return (_normalize(cols), \"Fallback-Recolor\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake to escape local minima; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Constructive fallback: simple 3-color pattern normalized\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n\n    # Multi-vertex random recolors (shake)\n    steps = max(5, n \/\/ 2 + 1)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Mostly within current palette; occasional new color\n        cols[i] = random.randint(1, max(1, current_max)) if random.random() < 0.9 else current_max + 1\n\n    # Palette squeeze: try to remove highest color by remapping to lower\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.8:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    # Optional secondary Kempe swap to restructure\n    if random.random() < 0.6 and len(set(cols)) >= 2:\n        c1, c2 = random.sample(sorted(set(cols)), 2)\n        # adjacency for chain\n        adj = {i: set() for i in range(1, n+1)}\n        for (u,v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        seeds = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n        if seeds:\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1,c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n\n    return _normalize(cols)\n","SAMPLE_SOL":"[3,1,2,1,3,2,1,1,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Componente":null,"Version":3,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"EVAL_OBJ_SCALING:Using 1e6 as a tie-breaker for conflicts is arbitrary and brittle. Replace scalarization with strict lexicographic evaluation (conflicts, k, nonconsecutive_flag) to avoid sensitivity to constants.\"\n\"FEEDBACK\",\"EVAL_CONSEC_HARDNESS:Nonconsecutiveness penalized by 0.5 is too weak; infeasible with respect to spec. Enforce consecutiveness as a hard constraint in evaluation (treat nonconsecutive as invalid or add penalty >> n) or normalize after every move.\"\n\"FEEDBACK\",\"EVAL_VALIDATION_SCOPE:Domain only checks ints>=1; does not verify consecutiveness directly as feasibility. Either normalize solution pre-eval or reject nonconsecutive palettes with PEN_INVALID.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Conflict repair uses min-conflicts limited to palette_max; may stall if all colors conflict. Add tie-breaking by least-saturation neighbor and allow temporary color palette_max+1 with immediate post-normalization pressure (e.g., tabu\/anneal) to escape plateaus.\"\n\"FEEDBACK\",\"NB_K_REDUCTION_WEAK:ReduceK-RecolorMaxClass tries single-vertex recolor; too myopic. Add: (a) move highest-color vertex via color interchange (Kempe guided) to lowest feasible color; (b) targeted recolor of its neighborhood to free a color (1-swap\/2-swap).\"\n\"FEEDBACK\",\"NB_KEMPE_SCOPE:Kempe chain swaps entire bi-colored connected component; may cause regressions. Implement bounded Kempe on the component containing the seed only (already done) but add heuristic seed selection: choose vertices from max color class or conflicted frontier.\"\n\"FEEDBACK\",\"NB_NORMALIZE_POLICY:Normalization mapping occurs inside neighbor; this can mask palette pressure from the metaheuristic and complicate acceptance criteria. Move normalization to a single, consistent stage: after accepting a move in the top-level Heuristic.\"\n\"FEEDBACK\",\"NB_MOVE_DIVERSITY:Missing additional neighborhoods: (a) color class merge attempt (try drop color k and repair), (b) vertex sequence recolor using DSATUR order, (c) reactive perturbative swap of two colors on an induced subgraph of high edge-cut.\"\n\"FEEDBACK\",\"PERTURB_MISSING:Perturbation Function undefined ($Perturb). Provide concrete perturbation: e.g., random c1\/c2 Kempe on large component, or drop-color-with-repair, with strength parameter tied to stagnation.\"\n\"FEEDBACK\",\"HEUR_SIG_COMPLIANCE:Target signature specified but not validated. Ensure Heuristic returns (new_solution, new_best, new_best_score, meta_state) and strictly consumes generate_neighbour\/evaluate_solution\/perturb_solution via passed callables.\"\n\"FEEDBACK\",\"TS_SIG_MISMATCH:Taboo_Search signature and caller unpacking inconsistent: \u2018too many values to unpack (expected 2)\u2019. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE or wrap adapter returning exactly (solution, score).\"\n\"FEEDBACK\",\"TS_RETURN_ARITY:Reported failure indicates return arity mismatch. Standardize: return (best_solution, best_score) from low-level search or upgrade to full Heuristic tuple; update caller accordingly.\"\n\"FEEDBACK\",\"INIT_STRATEGY:Fallback to greedy only on invalid input wastes opportunity. Always initialize with DSATUR or Welsh-Powell and optionally run a quick repair pass to start from low k.\"\n\"FEEDBACK\",\"OBJ_DIRECTION:Stated convention is lower-is-better; ensure all metaheuristics use minimization consistently. Verify SA acceptance uses delta=curr-new (<0 improves), and ILS uses min instead of max.\"\n\"FEEDBACK\",\"RANDOM_SEED:No controllable randomness. Add seed parameter in other_params to ensure reproducibility and fair comparisons across runs.\"\n\"FEEDBACK\",\"MOVE_ACCEPTANCE:Feasible vs infeasible transitions not explicitly managed. Introduce staged search: Phase 1 reduce conflicts to 0; Phase 2 fixed-feasible search with k-reduction and strong penalties for introducing conflicts.\"\n\"FEEDBACK\",\"DROP_COLOR_OPERATOR_MISSING:No explicit attempt to reduce k by banning color k and repairing. Add operator: set all vertices with color k to 0\/unassigned, then greedy recolor with min-conflicts; accept if feasible.\"\n\"FEEDBACK\",\"E_CODE_PERF:Recomputing adjacency\/conflicts per move is acceptable at n=9 but scales poorly. Maintain incremental conflict counts and color class membership to get O(degree) updates per move.\"\n\"FEEDBACK\",\"VALIDATION_GAP:Evaluation only protects against type\/length. Add strict check that max(color) == number_of_distinct_colors to satisfy consecutive indexing, or normalize before scoring.\"\n\"FEEDBACK\",\"SEARCH_STAGNATION:No adaptive mechanism on plateaus. Add reactive mechanisms: (a) increase perturbation strength after N non-improving iterations, (b) diversify move selection probabilities.\"\n\"FEEDBACK\",\"REPORTING_INADEQUATE:Move names returned but not logged\/aggregated. Track move success rates and conflicts\/k trajectory to auto-tune move probabilities.\"\n\"FEEDBACK\",\"CONSTRAINT_ENFORCEMENT:Consecutiveness handled softly; representation allows any positive ints. Prefer canonical representation invariant: always store normalized palettes to ensure feasibility space is respected.\"\n\"FEEDBACK\",\"TESTS_MISSING:No unit tests for evaluate_solution edge cases (nonconsecutive palettes, conflicts, invalid types). Add tests to prevent regressions during operator changes.\"\n\"FEEDBACK\",\"KNOWN_SOLUTION_USE:Known 3-coloring provided; no mechanism to verify optimality or use as target. Add lower bound check (e.g., clique size) and stop early once k=3 feasible is reached on this instance.\"\n\"FEEDBACK\",\"NEI_BIAS:Kempe and recolor choices are uniform random; this can waste iterations. Bias selection towards vertices with high degree or high conflict participation.\"\n\"FEEDBACK\",\"ILS_PERTURB_SCOPE:ILS result feasible but perturb strength unspecified. Parameterize and calibrate perturbation amplitude relative to k and conflict count to avoid thrashing.\"\n\"FEEDBACK\",\"API_COUPLING:Routines embed the graph; makes reuse brittle. Pass graph via other_params or closures to keep Heuristic general and testable.\"\n\"FEEDBACK\",\"RETURN_CONSISTENCY:All metaheuristics must consistently return (best_solution, best_score, start_solution, start_score). Tabu and others must align to avoid unpacking errors.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length\/domain checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted) if cols else 0\n    # Consecutive indexing check: palette must be [1..k]\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    gap_penalty = 0.5 if not is_consecutive else 0.0\n\n    # Fitness: prioritize feasibility (conflicts), then minimize k, then enforce consecutiveness\n    fitness = conflicts * 1_000_000.0 + float(k) + gap_penalty\n    return float(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols, edges):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        # Try colors 1..palette_max (and optionally palette_max+1 as exploratory)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i+1]:\n                if cols[nb-1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # Greedy DSATUR-like initializer\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        order = sorted(range(1, n+1), key=lambda u: (-degrees[u], u))\n        cols = [0]*n\n        used = set()\n        for u in order:\n            forbidden = {cols[v-1] for v in adj[u] if cols[v-1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u-1] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-Greedy\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols, edges)\n\n    if conflicted:\n        # Conflict-driven min-conflicts recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n    else:\n        # Feasible: attempt k-reduction focused moves\n        current_max = max(cols)\n        r = random.random()\n        if r < 0.5 and current_max > 1:\n            # Try to recolor a vertex from the highest color class to a lower feasible color\n            candidates = [i for i, c in enumerate(cols) if c == current_max]\n            if candidates:\n                i = random.choice(candidates)\n                target_colors = list(range(1, current_max))\n                random.shuffle(target_colors)\n                moved = False\n                for ctry in target_colors:\n                    conflict = False\n                    for nb in adj[i+1]:\n                        if cols[nb-1] == ctry:\n                            conflict = True\n                            break\n                    if not conflict:\n                        cols[i] = ctry\n                        moved = True\n                        break\n                if moved:\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n        # Kempe-chain swap between two colors to restructure\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # BFS on subgraph induced by colors c1,c2\n            seeds = [i+1 for i, c in enumerate(cols) if c in (c1, c2)]\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1, c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n            return (_normalize(cols), \"Kempe-Chain\")\n        # Fallback: slight recolor\n        i = random.randrange(n)\n        cols[i] = 1\n        return (_normalize(cols), \"Fallback-Recolor\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake + destroy\/repair; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Destroy: remove highest color class (if any) and mark its vertices for repair\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        # Repair: greedy min-conflicts recoloring for removed vertices in random order\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            # Try existing colors first, allow new color if needed\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i+1]:\n                    if cols[nb-1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0:\n                # Occasionally allow introducing a new color if unavoidable\n                if random.random() < 0.2:\n                    best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Additional shake: random recolor a few vertices within current palette\n    steps = max(4, n \/\/ 2)\n    if cols:\n        palette_max = max(cols)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","SAMPLE_SOL":"[3,2,1,3,2,1,2,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Componente":null,"Version":4,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_OBJ_MISALIGNED_SCALE: evaluate_solution returns 3,000,000 for a 3-color feasible while EXPECTED SCORE FROM KNOWN SOLUTION lists 3. Standardize objective consumption to use the same scale everywhere or switch to tuple lexicographic comparison to avoid temperature\/threshold miscalibration.\"\n\"FEEDBACK\",\"E_EVAL_BASES_LEAK: Gigantic bases (1e9,1e6) create extreme deltas that destabilize SA\/ILS acceptance. Replace scalarization with a tuple (conflicts,k,nonconsec) and implement lexicographic compare; for SA, use staged acceptance: accept if \u0394conflicts<0; else if \u0394conflicts=0, accept by exp(-\u0394k\/Tk); else use exp(-\u0394conflicts\/Tc).\"\n\"FEEDBACK\",\"E_RESULT_INCONSISTENCY: ILS score 4002000000 contradicts reported solution palette {1,2,3,4}. With current scoring it implies k=2. Fix scoring usage or result logger; add a decode function to print (conflicts,k,nonconsec) alongside raw score to verify integrity.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Neighbour returns (new_solution, move_name), but Tabu expects only a solution. Provide an adapter or update TS to unpack tuples. Example: wrap generate_neighbour with lambda s: generate_neighbour(s)[0] and capture move_name separately for tabu attributes.\"\n\"FEEDBACK\",\"E_API_SIGNATURE_DRIFT: Taboo_Search signature mismatches TARGET_HEURISTIC_GENERAL_SIGNATURE. Harmonize API: all metaheuristics must accept (currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) and treat generate_neighbour as returning (sol, move_name).\"\n\"FEEDBACK\",\"NB_REDUNDANT_ADJ_COMPUTE: Adjacency built on every neighbour call. Precompute adj and degree once and pass via other_params to cut overhead; same for edges and n.\"\n\"FEEDBACK\",\"NB_INIT_PATH_DEP: DSATUR-like init is hidden inside neighbour only when solution invalid. Make initialization explicit and always start from a strong feasible seed (DSATUR\/greedy with tie-breaking by saturation, degree) to accelerate convergence.\"\n\"FEEDBACK\",\"NB_COLOR_DROP_RISK: DropColorRepair sets zeros temporarily; safe internally, but add assert to ensure no zero escapes. Also incorporate conflict-aware reinsertion ordering (highest degree first) to reduce repair conflicts.\"\n\"FEEDBACK\",\"NB_LIMITED_DIVERSIFICATION: Only one Kempe chain operator with random c2. Add: (i) multi-step Kempe sequences, (ii) ejection chain moving a vertex from max class downwards, (iii) color class merge attempts with localized repairs, (iv) heavy-tail random recolor of a small subset.\"\n\"FEEDBACK\",\"NB_REDUCEK_INCOMPLETE: ReduceK-RecolorMaxClass tests single-vertex moves. Add pairwise recolor or bipartite matching on induced subgraph between max color class and union of lower classes for batch recoloring to empty the max class.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Using plain integer labels without structure limits guided moves. Maintain color class buckets and per-vertex forbidden-color counts to pick admissible colors in O(deg) and enable smarter candidate selection.\"\n\"FEEDBACK\",\"E_CONSEC_ENFORCEMENT: Normalization after each move is good; additionally enforce consecutiveness in evaluation as a hard tie-break only when conflicts==0 to avoid misleading pressure during infeasible phases.\"\n\"FEEDBACK\",\"E_ACCEPT_SCALE: With current score magnitudes, SA temperature must be unrealistically large to allow any uphill move. Normalize acceptance to component deltas (\u0394conflicts, \u0394k) instead of raw score, or rescale bases to <=1e3.\"\n\"FEEDBACK\",\"E_STOP_CRITERION: No clear convergence or stall detection. Add adaptive restarts when no improvement in X iterations and intensify around vertices in max color class.\"\n\"FEEDBACK\",\"P_PERTURB_MISSING: Perturbation Function is undefined. Implement problem-specific perturb: (a) drop highest color class then greedy repair, (b) random Kempe-chain of length L, (c) shuffle a small subset of conflicted vertices, (d) double-bridge on color-class partition.\"\n\"FEEDBACK\",\"E_LOWER_BOUNDING: Compute clique number \u03c9(G) to set a firm lower bound on k and stop once k==\u03c9. Use maximal clique heuristics to guide which color classes to merge or protect.\"\n\"FEEDBACK\",\"E_METRICS_OBSERVABILITY: Log (conflicts,k,nonconsec), palette histogram, and move_name per iteration. Use these to tune operator selection probabilities adaptively (multi-armed bandit on move success).\"\n\"FEEDBACK\",\"E_HEURISTIC_POLICY: Bias move selection by state: if conflicts>0, prioritize min-conflicts on highest-degree conflicted vertices; if conflicts==0, focus 80% on ReduceK operators, 20% on diversification (Kempe\/ejection).\"\n\"FEEDBACK\",\"E_TABU_FEATURES: For Tabu, define tabu attributes as (vertex,color) or (move_name,vertex) with aspiration if it yields lower (conflicts,k). Ensure tabu tenure scales with n and current conflicts; maintain frequency-based penalties to escape cycles.\"\n\"FEEDBACK\",\"E_TIME_EFFICIENCY: Cache per-vertex conflict counts and update incrementally on recolor to reduce neighbour evaluation from O(m) to O(deg). Avoid full evaluate_solution calls when possible by maintaining (conflicts,k,nonconsec) incrementally.\"\n\"FEEDBACK\",\"E_VALIDATION_STRICT: Add fast guards: reject any neighbour that raises conflicts when already at conflicts==0 unless it can reduce k within a bounded repair budget; this avoids useless drift.\"\n\"FEEDBACK\",\"E_TEST_COVERAGE: Build unit tests for evaluate_solution against known cases, and for generate_neighbour invariants (domain, consecutiveness). Verify that known solution scores to 3,000,000 with current scalarization or refactor to tuple scoring output.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e15\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Lexicographic scalarization: (conflicts, k, nonconsecutive_flag)\n    # Large bases ensure strict priority without brittleness to small-scale changes\n    nonconsec_flag = 0 if is_consecutive else 1\n    score = conflicts * 1_000_000_000 + k * 1_000_000 + nonconsec_flag * 1_000\n    return float(score)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    # If color class current_max becomes empty, normalization will drop it (reducing k)\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        for i in to_repair:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2 = random.choice([c for c in palette if c != c1])\n        seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n        if seeds:\n            seed = random.choice(seeds)\n            new_cols = list(cols)\n            _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n            return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1, 2, 3, 1, 2, 3, 2, 3, 1])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0 and random.random() < 0.2:\n                best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    if cols:\n        palette_max = max(cols)\n        steps = max(3, n \/\/ 3)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","SAMPLE_SOL":"[3,2,1,3,2,1,2,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Componente":null,"Version":5,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\n- \"E_OBJ_SCALARIZATION:Conflicts weight 1e6 vs k weight 1e3 may still allow temporary conflict increases to dominate search excessively; consider lexicographic handling or adaptive penalty to prioritize conflict=0 strictly then minimize k.\"\n- \"E_NONCONSEC_PENALTY_WEAK:Penalty=1 is negligible; once conflict=0 and k fixed, tie-breaking may be unstable; increase to >=10 to reduce noise or remove by always normalizing colors and dropping check from objective.\"\n- \"E_DUP_GRAPH_DEF:Graph hardcoded in both evaluation and neighbour; risk of drift. Centralize in a single source and pass via other_params.\"\n- \"E_TIME_COMPLEXITY:Each neighbour O(E) with repeated scans (min-conflicts, repair, Kempe). Cache adjacency and conflict counts in other_params and update incrementally to O(deg) per move.\"\n- \"E_INIT_STRATEGY:DSATUR-like is degree-first, not true DSATUR; saturation ordering missing. Implement real DSATUR to reduce initial k and speed convergence.\"\n- \"E_CONSEC_ENFORCE_REDUNDANT:Objective also checks consecutiveness while neighbour always normalizes; remove consecutive check from evaluate_solution to save time.\"\n- \"NB_CODE_FAIL_LOCAL_OPT:Kempe-chain applied with random c2\/seed; lacks targeted selection; focus on most-constrained vertices and color pairs involved in blocking recolors.\"\n- \"NB_REDUCEK_WEAK:DropColorRepair may reintroduce conflicts silently and doesn\u2019t verify k reduction; add acceptance filter to keep only non-worsening conflicts and prefer k drops.\"\n- \"NB_LACK_SWAP:No 2-swap\/vertex-exchange between color classes; add pairwise recolor\/swap to escape plateaus when Kempe fails.\"\n- \"NB_COLOR_CLASS_MERGE:No merge attempts of sparse classes; implement merge-by-repair of two smallest classes with guided reassignment.\"\n- \"NB_SAT_GUIDED_RECOLOR:Recolor choices ignore saturation; prefer colors minimizing future conflicts via saturation degree and blocking count.\"\n- \"NB_RANDOM_NOISE_HIGH:Fallback random recolor can increase k post-normalization indirectly; restrict choices to existing palette and non-conflicting candidates when feasible.\"\n- \"R_REPRESENTATION_RISK:LIST_INT permits gaps if normalization fails; ensure normalize is called after every move (currently implicit but not enforced by API). Add assert or wrapper.\"\n- \"ILS_PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Provide concrete perturb operator (e.g., multi-vertex Kempe kicks, color-class split).\"\n- \"TS_SIGNATURE_MISMATCH:Taboo_Search signature incompatible with TARGET_HEURISTIC_GENERAL_SIGNATURE; refactor to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass tabu params via other_params.\"\n- \"HEURISTIC_ACCEPTANCE:SA\/ILS acceptance strategy unspecified; ensure conflict-first acceptance (reject moves increasing conflicts when any conflict-free exists) and temperature schedule tuned to drop k post-feasible.\"\n- \"OBJ_VALIDATION:Known optimum k=3 yields score 3000; lock termination when score==3000 and no conflicts; add early-stop to save compute.\"\n- \"MOVE_ATTR_TABU:For TS, tabu on (vertex,color) or (Kempe chain pair, component) rather than solutions; add aspiration by improving k or conflicts.\"\n- \"REPAIR_ORDERING:DropColorRepair orders by degree only; include tie-break by saturation and number of available colors to reduce dead-ends.\"\n- \"PARALLEL_TRY_COLORS:Min-conflicts loops colors sequentially; evaluate candidate colors with early cut and pick argmin with random tie-break; keep a small candidate set by neighbor-color frequency.\"\n- \"EDGE_CASES:Min-conflicts allows new color palette_max+1 during repair phase, which can increase k after feasibility; disallow new color when conflicts==0 or gate by simulated annealing acceptance.\"\n- \"RANDOMNESS_SEEDING:Non-deterministic behavior without seed control; expose rng in other_params for reproducibility during testing.\"\n- \"CODE_REUSE:Utility builders (_adjacency_list, _normalize) recreated per call; hoist to outer scope and pass via other_params to cut overhead.\"\n- \"METRICS_LOG:No move-level diagnostics; log conflicts,k,move_name to facilitate operator efficacy analysis and adaptive operator selection.\"\n- \"ADAPTIVE_OPS:Static operator probabilities (0.4\/0.7) may be suboptimal; implement bandit-based adaptivity on move success in reducing conflicts\/k.\"\n- \"SCALABILITY:Hard-coded n=9; generalize to arbitrary graphs via other_params while preserving constraint 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.\"\n- \"TEST_COVERAGE:Tabu error indicates pipeline lacks interface tests; add unit tests for signature compliance and return types for all heuristics.\"\n- \"ACTION_PLAN_MINIMAL:Implement true DSATUR init, fix TS signature, define perturb, enforce conflict-first acceptance, add targeted Kempe and 2-swap, disallow new colors in feasible phase, cache conflicts for O(deg) updates.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 1\n\n    # Scalarization with moderate bases to preserve priority: conflicts >> k >> consecutive\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        # Order repairs by vertex degree for robustness\n        order = sorted(to_repair, key=lambda i: -len(adj[i + 1]))\n        for i in order:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2_candidates = [c for c in palette if c != c1]\n        if c2_candidates:\n            c2 = random.choice(c2_candidates)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = list(cols)\n                _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n                return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    for i in targets:\n        cols[i] = 0\n    random.shuffle(targets)\n    # Repair order by degree desc\n    targets = sorted(targets, key=lambda i: -len(adj[i + 1]))\n    for i in targets:\n        best_c = 1\n        best_conf = math.inf\n        palette_max = max([c for c in cols if c > 0], default=0)\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        if best_conf > 0 and random.random() < 0.25:\n            best_c = max(1, palette_max) + 1\n        cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    palette_max = max(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","SAMPLE_SOL":"[2,1,3,1,2,3,1,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSECUTIVE_COLORS_1_TO_k","Componente":null,"Version":6,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"E_EVAL_METRIC_MISALIGN:Expected 3 for known optimum but score=3000 due to scalarization. Return lexicographic tuple (conflicts,k,nonconsec) or scale k to 1 and nonconsec to 0\/1 to match framework comparisons.\nE_EVAL_CONSEC_PENALTY_WEAK:nonconsec_flag=10 is negligible next to k*1000 only breaks ties; explicitly normalize or hard-enforce consecutiveness before scoring.\nE_EVAL_DUP_GRAPH:Edges duplicated across components; centralize adjacency to avoid drift and maintenance bugs.\nE_EVAL_VALIDATION_OVERHEAD:Full validation each call adds O(n+|E|). Cache n, edges, and precomputed adjacency; expose delta-evaluation to the heuristic core.\nNB_CODE_FAIL_LOCAL_OPT:Two-swap feasibility check evaluates against pre-swap colors and exempts direct neighbor j incorrectly. Recompute both endpoints\u2019 constraints after swap or simulate swap then check all incident edges; otherwise hidden conflicts slip through.\nNB_KEMPE_UNSAFE:Kempe-chain may increase conflicts in feasible phase. Restrict to pairs that do not introduce conflicts or accept only if score improves.\nNB_NORMALIZE_EVERY_MOVE:Per-move renumbering breaks trajectory continuity and tabu memory; apply canonical normalization only on acceptance\/recording best, or use a stable mapping (e.g., color classes ordered by min vertex).\nNB_INIT_ONLY_ON_INVALID:No constructive start from arbitrary valid but poor solutions. Provide DSATUR+greedy recolor kick even when valid to escape plateaus.\nNB_OPERATOR_IMBALANCE:Random operator selection lacks adaptation. Introduce online operator selection (e.g., probability weights updated by improvement credit) and temperature\/perturbation coupling.\nNB_LOCALITY_WEAK:Repair-MinConflicts recolors a single conflicted vertex. Add 2-opt-like moves: recolor small vertex sets, ejection chains, or swap color classes to cross plateaus.\nNB_REDUCEK_GREEDY_FRAGILE:DropColorRepair fails early on first infeasible vertex. Use backtracking limited discrepancy or reorder by saturation with lookahead to salvage more cases.\nNB_GRAPH_TIGHT_CORES:Target recolor ignores K-core structure. Prioritize vertices in high core or high DSAT to meaningfully reduce k.\nR_STR_INADEQUATE:Frequent normalization of palette degrades search memory. Represent colors with stable labels; enforce consecutiveness only at evaluation or via canonical remap on copy.\nAPI_SIG_MISSING:Core Heuristic(...) orchestrator absent; cannot run SA\/ILS\/TS consistently. Implement main loop with acceptance, tenure, restart, and shared RNG seed control.\nPERTURB_MISSING:$Perturb placeholder; provide concrete large-move perturbation (e.g., remove highest color class, multi-Kempe cascades, or random recolor of a color-class subset) with intensity scheduled by stagnation.\nRUNTIME_ERROR_TYPING:Framework errors 'Type List cannot be instantiated' indicate typing module names leaking into runtime. Remove 'from typing import List, Tuple' in executed code or guard with if TYPE_CHECKING; use builtin list\/tuple in annotations.\nCOMPAT_CONSTRAINT:Ensure no filesystem\/network\/os access per CRITICAL_INSTRUCTIONS; audit imports (random, math only). Avoid f-strings embedding unicode arrows if logs parsed strictly; use ASCII labels.\nSCALING_EFFICIENCY:Add incremental conflict counters and per-vertex forbidden color bitsets; maintain palette size and consecutiveness cheaply. This reduces neighbor eval to O(\u0394) instead of O(|E|).\nSTOPPING_CRITERIA:Define clear convergence\/stagnation with adaptive restarts and time\/iteration caps; current design unspecified, causing inconsistent comparisons across metaheuristics.\nDIVERSIFICATION:Add path-relinking between elite solutions or strategic oscillation on k to escape local minima once conflicts=0 at current k.\nVERIFICATION:Include assert-based unit checks: degree-0 vertices, consecutive mapping correctness, Kempe invariants on induced subgraph, and two-swap post-check to prevent silent infeasibility.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN_9_CONSECUTIVE_COLORS_1_TO_k","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 10  # enforce consecutiveness with noticeable penalty\n\n    # Scalarization: prioritize conflicts, then k, then consecutiveness\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","NB_CODE":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols: List[int]):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _is_color_feasible(i: int, color: int, cols: List[int], adj) -> bool:\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _best_existing_color(i: int, cols: List[int], adj) -> int:\n        # Choose among existing colors only\n        palette_max = max(cols) if cols else 1\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    def _two_swap(cols: List[int], adj) -> Tuple[List[int], bool]:\n        # Try to swap colors of two vertices from different colors without creating conflicts\n        nloc = len(cols)\n        order = list(range(nloc))\n        random.shuffle(order)\n        for i in order:\n            for j in order:\n                if i >= j:\n                    continue\n                ci, cj = cols[i], cols[j]\n                if ci == cj:\n                    continue\n                # Check feasibility if swapped\n                ok_i = all((cols[nb - 1] != cj) or (nb - 1 == j) for nb in adj[i + 1])\n                ok_j = all((cols[nb - 1] != ci) or (nb - 1 == i) for nb in adj[j + 1])\n                if ok_i and ok_j:\n                    new_cols = list(cols)\n                    new_cols[i], new_cols[j] = cj, ci\n                    return _normalize(new_cols), True\n        return cols, False\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n\n    adj = _adjacency_list(n, edges)\n\n    if not valid:\n        # True DSATUR initialization\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        colors_used = 0\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree then id\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            colors_used = max(colors_used, c)\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return _normalize(cols), \"Init-DSATUR\"\n\n    cols = _normalize(list(solution))\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: recolor a high-degree conflicted vertex using existing colors only\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        best_c = _best_existing_color(i, cols, adj)\n        cols[i] = best_c\n        return _normalize(cols), \"Repair-MinConflicts\"\n\n    # Feasible phase: aim to reduce k without increasing conflicts\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(candidates)\n        for i in candidates:\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                if _is_color_feasible(i, ctry, cols, adj):\n                    cols[i] = ctry\n                    return _normalize(cols), \"ReduceK-RecolorMaxClass\"\n\n    # Operator 2: Drop highest color class and greedy repair using existing colors only\n    if r < 0.75 and current_max > 1:\n        tmp = list(cols)\n        to_repair = [i for i, c in enumerate(tmp) if c == current_max]\n        for i in to_repair:\n            tmp[i] = 0\n        # Order by degree then by number of available colors (descending difficulty)\n        order = sorted(to_repair, key=lambda i: ( -len(adj[i + 1]), -sum(1 for c in range(1, current_max) if all(tmp[nb - 1] != c for nb in adj[i + 1])) ))\n        feasible = True\n        for i in order:\n            assigned = False\n            for c in range(1, current_max):\n                if all(tmp[nb - 1] != c for nb in adj[i + 1]):\n                    tmp[i] = c\n                    assigned = True\n                    break\n            if not assigned:\n                feasible = False\n                break\n        if feasible:\n            return _normalize(tmp), \"ReduceK-DropColorRepair\"\n\n    # Operator 3: Targeted Kempe-chain between max color and a blocking lower color\n    if current_max > 1:\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == current_max]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = _kempe_chain_swap(list(cols), adj, current_max, c2, seed)\n                return _normalize(new_cols), f\"Kempe-Chain-{current_max}\u2194{c2}\"\n\n    # Operator 4: 2-swap between vertices of different colors to diversify without conflicts\n    new_cols, ok = _two_swap(cols, adj)\n    if ok:\n        return _normalize(new_cols), \"Two-Swap\"\n\n    # Fallback: recolor a random vertex to a random existing color (keeps feasibility with check)\n    i = random.randrange(n)\n    pal = sorted(set(cols))\n    random.shuffle(pal)\n    for c in pal:\n        if _is_color_feasible(i, c, cols, adj):\n            cols[i] = c\n            break\n    return _normalize(cols), \"Fallback-Recolor\"\n","PERTURB_CODE":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Strong shake: drop highest color class (if any) + greedy repair (existing colors) + multiple Kempe swaps + random within-palette recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = _normalize(list(solution))\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and attempt repair using existing colors only\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        # Repair order by degree desc then by fewest feasible colors first\n        order = sorted(targets, key=lambda i: ( -len(adj[i + 1]), sum(1 for c in range(1, maxc) if any(cols[nb - 1] == c for nb in adj[i + 1])) ))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # If cannot place using existing colors, temporarily assign a random existing color; conflicts allowed during perturb\n                pal = list(range(1, maxc)) if maxc > 1 else [1]\n                cols[i] = random.choice(pal)\n\n    # Step 2: Multiple Kempe swaps to restructure\n    palette = sorted(set([c for c in cols if c > 0]))\n    if len(palette) >= 2:\n        num_swaps = 3\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random within-palette recolors for additional shake (conflicts allowed in perturb)\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    return _normalize(cols)\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Componente":null,"Version":7,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_OBJ_SCALING:Discontinuous mega-penalties create flat plateaus and misguide search. Use lexicographic objective (conflicts, nonconsecutive_flag, k) or adaptive penalty lambda to preserve gradient signal.\nE_NONCONSEC_POLICY:Penalizing non-consecutive palettes in evaluation harms exploration. Always normalize before scoring or treat consecutiveness as a tie-breaker only.\nE_INFEASIBLE_SCORE:All-ones solution cannot have score 3.0 under current evaluate_solution; inconsistency indicates the metaheuristic bypasses evaluation or overwrites scores. Enforce single source of truth: always call evaluate_solution to set best_score.\nE_PERF_DUP_GRAPH:Adjacency and edges rebuilt inside generate_neighbour each call. Precompute and close over static graph structures to reduce overhead.\nNB_REPAIR_MINCONFLICTS:Current move only tries existing colors; cannot break deadlocks. Allow temporary introduction of a new color to remove conflicts, then invoke reduction moves.\nNB_REPAIR_CONFCOUNT:Min-conflicts computation ignores feasibility w.r.t. neighbors\u2019 constraints for future steps; add tie-break using number of feasible colors after move to avoid cycling.\nNB_REDUCE_ORDERING:_drop_max_color_repair ordering key is ill-posed (counts colors already present among neighbors rather than feasible options). Replace with ordering by fewest-feasible-colors first (forward-checking) and higher degree.\nNB_KEMPE_TARGETING:Kempe swaps chosen randomly; low success rate. Target pairs (c_max, c_t) that maximize potential unload of c_max by seeding from vertices in c_max with highest degree into c_t.\nNB_TWO_SWAP_LIMIT:Two-swap explores O(n^2) pairs randomly and rarely reduces k. Replace with color-assignment 1-opt (recolor single vertex to lowest feasible color) plus strategic color-class merge attempts.\nNB_DSATUR_INIT:Initialization recomputed on invalid input only. Provide DSATUR restart\/constructive perturb to escape local minima periodically.\nNB_CONSEC_CANON:Normalization called conditionally; some moves leave gaps. Enforce normalization after every accepted neighbor to satisfy representation and reduce symmetry.\nPERTURB_UNDEFINED:Missing perturbation function ($Perturb). Provide a concrete, bounded-strength perturbation (e.g., shuffle subset of vertices in max color, or perform p Kempe swaps) with parameterizable intensity.\nAPI_SIG_MISMATCH:Tabu Search fails due to signature mismatch and neighbor return arity (expects 1 return; provided 2). Standardize to generate_neighbour -> (neighbor_solution, move_tag) and adapt TS to ignore tags or provide a wrapper.\nTS_PARAM_SCHEMA:Tabu Search signature in error message differs from TARGET_HEURISTIC_GENERAL_SIGNATURE; harmonize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass taboo params via other_params dict.\nILS_INVALID_ACCEPT:ILS reports invalid best solution with optimal score. Add feasibility guard: accept\/update best only if conflicts==0; otherwise never overwrite feasible best with infeasible candidates.\nOBJ_TIEBREAK:When conflicts equal, prefer smaller k, then fewer vertices in max color, then lower sum of degrees in max color to bias toward reducible palettes.\nR_REP_CANONICAL:Representation requires consecutive colors. Enforce canonicalization function applied at all interfaces (init, neighbor gen, perturb, acceptance) to prevent drift.\nSEED_CONTROL:Randomness uncontrolled harms reproducibility and tuning. Thread an rng state through all components; avoid global random to enable deterministic runs.\nMETRICS_LOGGING:Current outputs omit conflicts, k, and move tags over time. Log (iter, conflicts, k, max_color_size, move_tag) for diagnosis and operator efficacy tuning.\nPERF_EVAL_CACHE:Repeated evaluation of same solutions likely in SA\/TS. Cache evaluate_solution with a bounded LRU keyed by tuple(solution) to cut redundant cost.\nCOLOR_REDUCTION_LOOP:Add explicit k-reduction phase: while feasible try {drop-repair, targeted recolor of max color, Kempe guided by cut size}. Only revert to exploration when reduction fails for T attempts.\nMOVE_PORTFOLIO_GAP:No 2-opt on color classes and no path recolor. Add recolor-path move (augmenting path between two colors) and max-color vertex ejection to lowest feasible color with conflict repair via BFS.\nACCEPTANCE_POLICY:SA\/ILS acceptance should compare lexicographically; current scalar penalties distort temperature schedules. Redefine acceptance around tuple with temperature applied to conflicts first.\nCODE_CONSTRAINT:Ensure 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS is satisfied across all components; audit TS\/ILS implementations for any violations.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Scoring policy (lower is better):\n    # 1) Any conflicts dominate with huge penalty\n    # 2) If conflict-free but non-consecutive, penalize heavily\n    # 3) Otherwise return k so global optimum for this instance returns 3\n    if conflicts > 0:\n        return float(1_000_000_000 + conflicts * 1_000_000 + k)\n    if not is_consecutive:\n        return float(1_000_000 + k)\n    return float(k)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _is_color_feasible(i, color, cols, adj):\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        return [colored[i] for i in range(1, n + 1)]\n\n    def _two_swap_simulated(cols, adj):\n        # Try swap colors of two vertices and verify by simulation\n        idx = list(range(n))\n        random.shuffle(idx)\n        for a in idx:\n            for b in idx:\n                if a >= b:\n                    continue\n                if cols[a] == cols[b]:\n                    continue\n                new_cols = list(cols)\n                new_cols[a], new_cols[b] = new_cols[b], new_cols[a]\n                ok = True\n                # Check all incident edges of a and b\n                for nb in adj[a + 1]:\n                    if new_cols[nb - 1] == new_cols[a]:\n                        ok = False\n                        break\n                if ok:\n                    for nb in adj[b + 1]:\n                        if new_cols[nb - 1] == new_cols[b]:\n                            ok = False\n                            break\n                if ok:\n                    return new_cols, True\n        return cols, False\n\n    def _attempt_reduce_max_color(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        # Try move vertices from max color to lower feasible colors\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            targets = list(range(1, current_max))\n            random.shuffle(targets)\n            for c in targets:\n                if _is_color_feasible(i, c, cols, adj):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    # If no more vertices use current_max, normalize down\n                    if all(x != current_max for x in new_cols):\n                        new_cols = _normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def _drop_max_color_repair(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        new_cols = list(cols)\n        targets = [i for i, c in enumerate(new_cols) if c == current_max]\n        if not targets:\n            return cols, False\n        for i in targets:\n            new_cols[i] = 0\n        # order by degree desc then by fewest feasible options first\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), sum(1 for c in range(1, current_max) if any(new_cols[nb - 1] == c for nb in adj[i + 1]))))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(new_cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        # successful repair, normalize down\n        new_cols = _normalize_consecutive(new_cols)\n        return new_cols, True\n\n    def _kempe_chain_safe(cols, adj):\n        # Try a Kempe swap between highest color and a lower color; accept only if conflicts not worse\n        base_conf = _conflicts_count(cols)\n        if base_conf < 0:\n            return cols, False  # never happens, guard\n        current_max = max(cols)\n        lower = [c for c in sorted(set(cols)) if c < current_max]\n        if current_max <= 1 or not lower:\n            return cols, False\n        c2 = random.choice(lower)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (current_max, c2)]\n        if not seeds:\n            return cols, False\n        seed = random.choice(seeds)\n        # Build component\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, c2):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = c2\n            elif new_cols[u - 1] == c2:\n                new_cols[u - 1] = current_max\n        if _conflicts_count(new_cols) <= base_conf:\n            # normalize only if color class current_max becomes empty\n            if all(x != current_max for x in new_cols):\n                new_cols = _normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = _adjacency_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = _dsatur_construct(adj)\n        init_cols = _normalize_consecutive(init_cols)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = list(solution)\n\n    # Phase 1: if conflicts exist, repair them greedily (min-conflicts for a high-degree vertex)\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # choose a conflicted vertex preferring higher degree\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        # try existing colors first\n        palette = sorted(set(cols))\n        random.shuffle(palette)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in palette:\n            if c == cols[i]:\n                # evaluate current color too\n                pass\n            # count conflicts if assign c\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c and nb - 1 != i:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_cols = list(cols)\n        new_cols[i] = best_c\n        return new_cols, \"Repair-MinConflicts\"\n\n    # Phase 2: feasible; attempt to reduce palette size\n    op_order = [\n        \"reduce_move\", \"drop_repair\", \"kempe\", \"two_swap\"\n    ]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            new_cols, ok = _attempt_reduce_max_color(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-RecolorMaxClass\"\n        elif op == \"drop_repair\":\n            new_cols, ok = _drop_max_color_repair(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-DropColorRepair\"\n        elif op == \"kempe\":\n            new_cols, ok = _kempe_chain_safe(cols, adj)\n            if ok:\n                return new_cols, \"Kempe-Chain\"\n        elif op == \"two_swap\":\n            new_cols, ok = _two_swap_simulated(cols, adj)\n            if ok:\n                return new_cols, \"Two-Swap\"\n\n    # Fallback: recolor a random vertex with a random existing color if feasible\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    random.shuffle(palette)\n    for c in palette:\n        if _is_color_feasible(i, c, cols, adj):\n            new_cols = list(cols)\n            new_cols[i] = c\n            return new_cols, \"Fallback-Recolor\"\n\n    return list(cols), \"No-Op\"\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # deterministic valid seed 3-coloring\n        return [2,1,3,1,2,3,1,1,3]\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and try greedy repair within existing colors\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), i))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # allow conflicts during perturbation: assign random existing color\n                pal = list(range(1, max(1, maxc)))\n                cols[i] = random.choice(pal) if pal else 1\n\n    # Step 2: Multiple Kempe-chain swaps across random color pairs (diversification)\n    def _kempe_swap_component(cols, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    palette = sorted(set(cols))\n    for _ in range(3):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = _kempe_swap_component(cols, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette to shake\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    # Step 4: Light repair pass to avoid too many conflicts\n    for i in range(n):\n        # try to reduce conflicts at i by picking a different color if possible\n        best_c = cols[i]\n        best_inc = 0\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == cols[i]:\n                best_inc += 1\n        if best_inc == 0:\n            continue\n        for c in range(1, max(2, pal_max + 1)):\n            if c == cols[i]:\n                continue\n            inc = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    inc += 1\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    # Normalize at the end to keep consecutive color indices\n    cols = _normalize_consecutive(cols)\n    return cols\n","SAMPLE_SOL":"[2,1,3,1,2,3,1,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Componente":null,"Version":8,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_SCORE_SCALE_MISMATCH:Known optimum expects score=3, but evaluate_solution returns ~3043 for feasible 3-colorings. Replace scalarization with piecewise: if conflicts>0 return 1e9+conflicts; else return k + 1e-6*(max_color_size) + 1e-9*(sum_deg_max). Ensures exact k-minimization and ties only slightly perturbed.\nE_TIEBREAKERS_OVERWEIGHTED:Current weights (1e6,1e3,10,1) can distort hill-climbing on feasible space. Use epsilon-scale inside feasible region to avoid misleading gradients.\nE_NORMALIZE_SIDE_EFFECTS:normalize_consecutive in evaluation and neighbourhood changes objective non-locally, breaking SA energy continuity. Restrict normalization to evaluation only, and preserve raw labels in moves; or enforce canonical relabeling after each accepted move only.\nE_VALIDATION_LENIENT:Only checks ints>=1. Add cap on max color label to avoid silent palette bloat during repair. Suggest bound max label to current_max+1.\nNB_CODE_FAIL_LOCAL_OPT:Repair picks a single conflicted vertex greedily; may cycle. Add randomized min-conflicts with breakout: select among argmin by degree tie with probability p, else random conflicted vertex.\nNB_SCOPE_LIMITED:Only 1-vertex recolors plus targeted Kempe. Add 2-move class-merge attempt: try recoloring all vertices of color k into {1..k-1} using greedy order; if success, drop k.\nNB_COLOR_DROP_GREEDY_ORDER:drop_color_repair orders by |feasible| then degree; add lookahead via limited BFS conflict count or DSATUR order on induced subgraph of max color to reduce early dead-ends.\nNB_KEMPE_TARGET_HEURISTIC:Target color chosen by cut size only; add acceptance if it reduces k-feasibility proxy: decrease of |forbidden colors| for max-color vertices. Keep even if conflicts unchanged but proxy improves.\nNB_RANDOM_FALLBACK_WEAK:Random 1-opt on feasible palette often no-op. Prefer swap-move: pick vertex i and swap colors a<->b on its 2-color component to unlock moves.\nR_STR_INADEQUATE:Consecutive relabeling embedded in operators obscures true palette structure. Maintain representation as raw labels; apply normalize_consecutive only in evaluation and before returning final answer.\nP_MISSING:Perturbation Function placeholder $Perturb causes ILS stagnation. Implement degree-biased multi-vertex Kempe cascade: pick top-d conflicted or max-color vertices, perform t random (a,b)-component swaps; ensure feasibility preserved or soft-conflict cap.\nP_TOO_WEAK_FOR_ILS:For feasible plateaus, add kick: select random subset S of max-color vertices and recolor to nearest feasible lower colors using DSATUR on subproblem; if fail, revert.\nSA_TEMP_SCHEME_UNSPECIFIED:Without cooling\/acceptance tuning, SA likely sticks on feasible k=4. Set T0 to median delta of worsening moves; geometric cooling alpha in [0.90,0.98]; reheating on long stagnation.\nILS_RESTART_POLICY:No elite recentering or adaptive perturb strength. Use adaptive kick size proportional to plateau length; reset around best with variable perturb t in [2,10].\nTABU_SIG_MISMATCH:Taboo_Search failure shows signature misuse. Wrap to TARGET_HEURISTIC_GENERAL_SIGNATURE, and fix return to (solution, move_tag). Maintain tabu on (vertex,color) assignments with aspiration for k decrease.\nTABU_TENURE_STATIC:taboo_duration static harms intensification. Use reactive tenure based on conflict frequency; increase on cycles, decrease on improvements.\nOBJ_CONSISTENCY:Heuristics_value_best_as_lesser_cost violated if intermediates rely on different scales. Standardize all modules on the same piecewise evaluation to ensure consistent comparisons.\nINIT_POLICY_SINGLE:Only DSATUR. Add multi-start with different DSATUR tie-breakers (order by id, by degree desc, random permutation) and retain the best to seed SA\/ILS\/TS.\nCONSTRAINT_TRACKING:feasible_colors computed on current palette only; during repair you introduce new color but not bounded. Allow temporary new color only if targeted drop is attempted within next L steps; else penalize.\nDIAGNOSTICS_INSUFFICIENT:Move tags present but no counters. Log acceptance rates per move type; adapt operator probabilities via softmax bandit on short-term gains in k.\nTERMINATION_PLATEAU:No plateau escape rule. Add time\/iter budget split: repair->reduceK->intensify cycles; if no k decrease in W windows, force perturb or restart.\nUNIT_TEST_GAP:Add tests: (a) known 3-color solution must score 3; (b) any conflict>0 must score >1e9; (c) neighbor never increases conflicts when already zero unless perturb explicitly allowed; (d) color drop attempts reduce k or leave unchanged.\nACTIONABLE_FIX_ORDER:1) Replace evaluation with piecewise f. 2) Remove in-move normalization; normalize only in eval\/return. 3) Implement strong Perturb as above. 4) Add class-merge neighborhood and swap-move. 5) Standardize SA\/ILS\/TS acceptance on f and fix Tabu signature. 6) Add diagnostics and adaptive operator selection.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(1e12)\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    cols = normalize_consecutive(list(solution))\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette metrics\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n\n    # Tiebreakers to encourage reducible palettes\n    # - max color class size\n    # - sum of degrees inside max color class\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    max_color = max(cols)\n    max_class_indices = [i+1 for i, c in enumerate(cols) if c == max_color]\n    max_color_size = len(max_class_indices)\n    sum_deg_max = sum(degrees[i] for i in max_class_indices)\n\n    # Lexicographic scalarization: conflicts >> k >> structure\n    score = conflicts * 1_000_000 + k * 1_000 + max_color_size * 10 + sum_deg_max\n    return float(score)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def conflicted_vertices(cols):\n        conf = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conf.add(u-1)\n                conf.add(v-1)\n        return conf\n\n    def feasible_colors(i, cols, palette, adj):\n        used = {cols[nb - 1] for nb in adj[i + 1]}\n        return [c for c in palette if c not in used]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def attempt_reduce_move(cols, adj):\n        # try moving a vertex from max color to lowest feasible lower color\n        current_max = max(cols)\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            for c in range(1, current_max):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    new_cols = normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def drop_color_repair(cols, adj):\n        current_max = max(cols)\n        idxs = [i for i, c in enumerate(cols) if c == current_max]\n        if not idxs:\n            return cols, False\n        temp = list(cols)\n        for i in idxs:\n            temp[i] = 0\n        # order by fewest feasible colors then higher degree\n        order = sorted(idxs, key=lambda i: (len(feasible_colors(i, temp, list(range(1, current_max)), adj)), -len(adj[i + 1])))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(temp[nb - 1] != c for nb in adj[i + 1]):\n                    temp[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        temp = normalize_consecutive(temp)\n        return temp, True\n\n    def kempe_targeted(cols, adj):\n        base = conflicts_count(cols)\n        current_max = max(cols)\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if not lower_colors:\n            return cols, False\n        # pick target color that maximizes adjacency between max color and target color\n        def cut_size(target):\n            cut = 0\n            for (u, v) in edges:\n                cu, cv = cols[u-1], cols[v-1]\n                if {cu, cv} == {current_max, target}:\n                    cut += 1\n            return cut\n        lower_colors.sort(key=lambda c: -cut_size(c))\n        target = lower_colors[0]\n        # seed from a vertex in max color with highest degree into target\n        candidates = [i+1 for i, c in enumerate(cols) if c == current_max]\n        candidates.sort(key=lambda u: (-sum(1 for w in adj[u] if cols[w-1] == target), -len(adj[u]), u))\n        if not candidates:\n            return cols, False\n        seed = candidates[0]\n        # build (current_max, target) component of seed\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, target):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = target\n            elif new_cols[u - 1] == target:\n                new_cols[u - 1] = current_max\n        if conflicts_count(new_cols) <= base:\n            new_cols = normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = dsatur_construct(adj)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = normalize_consecutive(list(solution))\n\n    # If conflicts exist: repair with min-conflicts; allow temporary new color to break deadlocks\n    conf = conflicts_count(cols)\n    if conf > 0:\n        conf_set = list(conflicted_vertices(cols))\n        # select vertex with fewest feasible colors, then higher degree\n        palette = sorted(set(cols))\n        conf_set.sort(key=lambda i: (len(feasible_colors(i, cols, palette, adj)), -len(adj[i + 1]), i))\n        i = conf_set[0]\n        feas = feasible_colors(i, cols, palette, adj)\n        new_cols = list(cols)\n        if feas:\n            # choose lowest feasible color to aid normalization\n            new_cols[i] = min(feas)\n            return normalize_consecutive(new_cols), \"Repair-MinConflicts\"\n        else:\n            # introduce a new color temporarily\n            new_cols[i] = max(palette) + 1\n            return normalize_consecutive(new_cols), \"Repair-IntroduceColor\"\n\n    # Feasible: attempt palette reduction moves\n    op_order = [\"reduce_move\", \"drop_repair\", \"kempe\"]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            nxt, ok = attempt_reduce_move(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-RecolorFromMax\"\n        elif op == \"drop_repair\":\n            nxt, ok = drop_color_repair(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-DropRepair\"\n        elif op == \"kempe\":\n            nxt, ok = kempe_targeted(cols, adj)\n            if ok:\n                return nxt, \"Kempe-Targeted\"\n\n    # Fallback: recolor random vertex to lowest feasible existing color (keeps feasibility)\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    feas = feasible_colors(i, cols, palette, adj)\n    if feas:\n        new_cols = list(cols)\n        new_cols[i] = min(feas)\n        return normalize_consecutive(new_cols), \"Fallback-1Opt\"\n\n    # If no feasible change, return as is\n    return normalize_consecutive(cols), \"No-Op\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def kempe_swap_component(cols, adj, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        cols = dsatur_construct(adj)\n    else:\n        cols = normalize_consecutive(list(solution))\n\n    # 1) Eject a portion of max color class and try to reinsert within current palette\n    maxc = max(cols)\n    max_idxs = [i for i, c in enumerate(cols) if c == maxc]\n    if max_idxs:\n        # remove about half of max class (at least 1)\n        random.shuffle(max_idxs)\n        m = max(1, len(max_idxs) \/\/ 2)\n        removed = max_idxs[:m]\n        for i in removed:\n            cols[i] = 0\n        for i in removed:\n            # greedy insert to smallest feasible color < maxc if possible, else random in [1, maxc]\n            feas = [c for c in range(1, maxc) if all(cols[nb - 1] != c for nb in adj[i + 1])]\n            if feas:\n                cols[i] = random.choice(feas)\n            else:\n                cols[i] = random.randint(1, maxc)\n\n    # 2) Perform a few Kempe-chain swaps across random color pairs\n    for _ in range(2):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = kempe_swap_component(cols, adj, c1, c2, seed)\n\n    # 3) Randomly recolor a few vertices within current palette to diversify\n    palette = sorted(set(cols))\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.choice(palette)\n\n    # 4) Light local repair: for vertices in conflict, choose a color minimizing local conflicts\n    for i in range(n):\n        # count current conflicts at i\n        cur_inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == cols[i])\n        if cur_inc == 0:\n            continue\n        best_c = cols[i]\n        best_inc = cur_inc\n        for c in sorted(set(cols)):\n            if c == cols[i]:\n                continue\n            inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    cols = normalize_consecutive(cols)\n    return cols\n","SAMPLE_SOL":"[2,1,3,1,2,3,1,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0-crit\"\n\"FEEDBACK\":\"E_SAMPLE_SOL_PARSE:Type mismatch causes 'list' has no attribute 'strip'. Standardize loader to accept Python lists or require JSON string and parse accordingly.; E_MISSING_PERTURB:$Perturb placeholder not implemented. Provide a concrete perturbation that escapes deep basins (e.g., multi-vertex Kempe-chain shuffle, random recolor of a conflicting subset).; E_SIG_MISMATCH:generate_neighbour returns (sol, NB_Type, Movement_Type) but many metaheuristic drivers expect only a solution. Align interface or wrap adapter.; NB_CODE_FAIL_TARGETING:Uniform vertex selection ignores conflicts. Bias selection to conflicting vertices and highest-degree\/DSATUR critical vertices.; NB_MOVE_SET_WEAK:Only single-vertex recolor and node swap. Add Kempe-chain interchange, color-merge attempts, and pairwise color swap on induced subgraphs.; NB_SWAP_LOW_IMPACT:Swapping node positions preserves color multiset and rarely reduces conflicts. Replace with color-class swap or targeted recolor of endpoints of a conflict.; NB_NORM_SIDE_EFFECTS:_normalize_colors after every move alters move identity and tabu features. For Tabu\/annealing logs, either normalize only when evaluating or define stable move attributes (vertex,color).; E_RANGE_PENALTY_REDUNDANT:Evaluation punishes non-consecutive colors but neighbor normalization already enforces consecutiveness. Remove PEN_RANGE or disable normalization to avoid double pressure.; E_RANGE_LOGIC:range_violations double counts when first color != 1 and missing set non-empty. Define violations as |{1..k} \\ unique_colors| with k=max(unique_colors) and no extra ad-hoc increment.; E_PENALTY_SCALE:PEN_CONFLICT=1000 dwarfs objective=O(1\u20139). Annealing temperature\/tabu scores become dominated. Calibrate (e.g., 50\u2013200) and\/or use lexicographic objective: minimize conflicts first, then k.; E_EVAL_COMPLEX:O(|E|) per call may bottleneck under heavy SA\/ILS. Implement incremental delta evaluation for recolor moves and maintain adjacency conflict counts.; E_INIT_WEAK:No constructive seeding. Add DSATUR\/greedy initialization to start near 3-color region.; E_K_REDUCTION_ABSENT:No explicit k-minimization loop. Implement outer loop that tries to recolor with k-1 (freeze palette, forbid using color k, or merge two smallest classes with repair).; E_PERTURB_SCOPE:ILS perturb should be stronger than local moves. Use multi-vertex targeted recolors on a random conflict cycle, or swap palettes between two colors across a connected component.; E_METAPARAMS_UNSPECIFIED:Cooling schedule\/tabu tenure\/ILS iteration counts absent. Provide parameter schema in other_params and guards for stagnation\/early stop.; E_CONSTRAINT_HANDLING:Hard conflicts treated via penalty only. For feasibility-first phases, enforce no-conflict moves (graph recoloring heuristic) before k reduction.; E_HEURISTIC_OBJECTIVE:Ensure best\/best_score use lower-is-better consistently and never negate evaluate_solution.; R_REPRESENTATION:LIST_INT_9_CONSEC_COLORS is fine but enforce via representation, not penalty. If normalization kept, drop range penalty and ensure generate_neighbour never emits zeros\/out-of-range.; R_MOVE_ADAPTIVITY:Adapt probability of Recolor vs advanced moves based on conflict count; increase exploration when stagnating.; R_TABU_FEATURE:Define tabu on (vertex,old_color\u2192new_color) with aspiration by objective; avoid tabu on normalized color IDs.; R_STOPPING:Add convergence criteria: no improvement in X iters, time budget, or zero-conflict with minimal k confirmed by failed recolor to k-1.; R_VALIDATION:Add quick verifier for conflicts and consecutiveness to assert invariants during development.; FIX_SAMPLE_AND_KNOWN:Replace raw list literals with JSON arrays or parser-compatible format to prevent load failures in SA\/ILS\/Tabu runners.; TESTS:Unit tests for evaluate_solution on edge cases: invalid types, non-consecutive labels, known 3-coloring, single-conflict case.; SUGGESTED_MOVE_IMPL:Kempe-chain BFS between two colors; greedy recolor of conflict vertices choosing least-conflicting color; periodic attempt to remove a color by recoloring its vertices greedily with backtracking depth 2.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Fitness combines objective (colors used) with penalties for constraint violations\n    # Lower is better.\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Base penalties\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n    # Validate type and length\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Validate entries\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n    # Compute conflicts\n    conflicts = 0\n    cols = solution\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # Range\/consecutiveness check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if unique_colors:\n        if unique_colors != list(range(1, k+1)):\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            if not unique_colors or unique_colors[0] != 1:\n                range_violations += 1\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","NB_CODE":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    # Relabel colors to be consecutive 1..k while preserving equality pattern\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type: one of {\"Recolor\",\"Swap\"}\n    if not isinstance(solution, list):\n        return solution, \"Invalid\", \"NoOp\"\n    n = len(solution)\n    if n != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move type probabilistically\n    move = \"Recolor\" if random.random() < 0.7 else \"Swap\"\n    if move == \"Recolor\":\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        # Allow choosing among 1..current_k+1 to escape local minima\n        new_color = sol[idx]\n        if current_k <= 1:\n            candidate_colors = [1, 2]\n        else:\n            candidate_colors = list(range(1, current_k + 2))\n        candidate_colors = [c for c in candidate_colors if c != new_color]\n        if not candidate_colors:\n            return sol, \"Local\", \"Recolor\"\n        sol[idx] = random.choice(candidate_colors)\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Recolor\"\n    else:  # Swap\n        if n < 2:\n            return sol, \"Local\", \"Swap\"\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Swap\"\n","PERTURB_CODE":"import random\nimport copy\nfrom typing import List\n\ndef _normalize_colors_pert(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: perform multiple recolors and a shuffle block\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        candidate_colors = list(range(1, max(3, current_k + 1)))\n        if sol[idx] in candidate_colors and len(candidate_colors) > 1:\n            candidate_colors.remove(sol[idx])\n        sol[idx] = random.choice(candidate_colors)\n    # Random block shuffle\n    i, j = sorted(random.sample(range(n), 2))\n    block = sol[i:j+1]\n    random.shuffle(block)\n    sol[i:j+1] = block\n    sol = _normalize_colors_pert(sol)\n    return sol\n","SAMPLE_SOL":[1,2,3,1,2,3,2,1,3]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS; solution is a JSON array of 9 positive integers where colors are consecutively labeled from 1..k.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_EVAL_TYPEHINT_FAIL:Error 'Type List cannot be instantiated; use list() instead' indicates typing.List is being instantiated by the framework. Replace all typing annotations 'List' with builtin 'list' and remove 'from typing import List'. Alternatively add 'from __future__ import annotations' and avoid importing List.\"\n\"E_EVAL_PEN_REDUNDANT:PEN_RANGE is redundant because neighbours normalize colors to consecutive labels; set PEN_RANGE=0 or remove missing-label logic to prevent double-incentivizing normalization.\"\n\"E_EVAL_OBJ_PRECISION:Objective mixes k with large penalties; ensure conflicts dominate but still allow tie-breaking by k. Keep PEN_CONFLICT >> 1 and optionally drop PEN_RANGE. Verify numeric stability using integers where possible.\"\n\"E_EVAL_VALIDATION:Current checks allow excessively large colors; add hard cap (<=9) or post-normalize in evaluate_solution to ensure consistent scoring.\"\n\"E_PERF_CONST_DATA:Edges\/adjacency recomputed repeatedly; hoist edges, n, adj to module-level constants to remove repeated construction in evaluate and neighbourhood.\"\n\"NB_SIG_MISMATCH:Docstring says returns (NB_Type, Movement_Type) but function returns (new_solution, NB_Type, Movement_Type). Fix signature documentation to avoid integration errors, or adjust to required API.\"\n\"NB_MOVE_SELECTION:Random thresholds static; adopt conflict-aware adaptive scheme: p(Recolor)=min(0.9, 0.2+0.7*conflict_vertices\/9), else Kempe, rare PaletteSwap when conflict=0 to diversify.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Recolor cost only counts immediate conflicts; include projected k-reduction incentive: score = conflicts + \u03bb*(c==current_k+1) with small \u03bb, and forbid introducing new color when conflict=0 unless it enables future merge.\"\n\"NB_KEMPE_SCOPE:Kempe component BFS restricted to {c1,c2}; add targeted choice of c2 from conflicting neighbour colors to increase likelihood of conflict removal. If conflict-free, choose c2 to reduce usage of highest-index color.\"\n\"NB_NORMALIZE_OVERUSE:Normalization after each move may cause oscillation and masks palette usage estimates; normalize only when evaluating or when k-changes, not after every move. If kept, remove PEN_RANGE to avoid redundancy.\"\n\"NB_NO_TABU_INFO:No memory of recent colors\/moves; for Tabu, add tabu list on (vertex,color) assignments with short tenure to prevent cycling.\"\n\"PERTURB_MISSING:'$Perturb' placeholder breaks ILS\/SA; implement strong perturbation: multiple random Kempe-chain swaps across distinct color pairs, followed by targeted recolor attempts on highest-index color class.\"\n\"INIT_MISSING:No constructive initializer; add DSATUR\/greedy largest-degree-first to start near k=3. Also include simple 3-color seed from maximal independent sets when feasible.\"\n\"HEURISTIC_FUNC_ABSENT:Target signature Heuristic(...) not provided; implement SA\/ILS\/Tabu wrappers that call generate_neighbour and evaluate_solution, enforce 'lower is better', and accept improving\/non-improving moves per method.\"\n\"E_RESULTS_FAILURE_CAUSE:The algorithm failures stem from evaluation type-hint issue; fix annotations, re-run, and add unit test evaluating KNOWN_SOLUTION -> 3.\"\n\"R_REP_ENFORCEMENT:Representation requires consecutive labels; ensure every pipeline stage either preserves or repairs consecutiveness before scoring and before output.\"\n\"E_RANDOM_SEED:Stochastic operators lack seed control; expose 'seed' in other_params and seed Python RNG for reproducibility in benchmarking.\"\n\"E_CONSTRAINT_REDUCE_K:Add explicit color-elimination move: pick highest color k, try to recolor its vertices into {1..k-1} via greedy conflict-avoiding assignment; if successful, decrement k.\"\n\"E_API_TYPES:Type hints in generate_neighbour use typing.List inside runtime; switch to builtin list[int] hints throughout and remove Tuple import to avoid any runtime evaluation glitches.\"\n\"E_TESTS_ADD:Automate checks: (1) evaluate_solution(KNOWN_SOLUTION)==3, (2) invalid inputs return PEN_INVALID, (3) neighbour returns list of len 9 ints in 1.., consecutive after repair, (4) conflict count strictly decreases on average when conflicts>0.\"\n\"E_STOPPING_CRITERIA:Add budgeted iterations and time caps, with stagnation detection to trigger perturbation; log best_score and conflict count over time for diagnostics.\"\n\"E_METRICS_LOG:Track k, conflicts, accepted_moves, and improvement rate; abort once k=3 and conflicts=0 to avoid over-searching.\"\n\"E_DOC_FIX:Return annotation '-> (\\\"NB_Type\\\",\\\"Movement_Type\\\")' is invalid typing; either remove or change to '-> tuple[list[int], str, str]' to match actual return.\"\n\"PERF_INPLACE:Avoid deep copy where unnecessary; operate on array copies with slice assignment and reuse buffers to reduce allocations.\"\n\"ROBUSTNESS_CONFLICT_VERT:_conflict_vertices scans all edges each call; cache conflict set and update incrementally after moves for O(deg) updates.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS; solution is a JSON array of 9 positive integers where colors are consecutively labeled from 1..k.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 100.0\n    PEN_RANGE = 5.0\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = solution\n    # conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # consecutiveness penalty: count missing labels in 1..max_color\n    unique_colors = set(cols)\n    max_color = max(unique_colors) if unique_colors else 0\n    missing = 0\n    if max_color > 0:\n        present = unique_colors\n        missing = sum(1 for c in range(1, max_color+1) if c not in present)\n    k = len(unique_colors)\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * float(conflicts) + PEN_RANGE * float(missing)\n    return float(fitness)\n","NB_CODE":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\"}\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _recolor_move(sol: List[int]) -> List[int]:\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose high-degree vertex to explore color reduction\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            candidates = [i for i,d in enumerate(degs) if d == max_deg]\n        v = random.choice(candidates)\n        # evaluate best color in 1..current_k+1\n        best_color = sol[v]\n        best_cost = 1e9\n        palette = list(range(1, current_k+2))\n        for c in palette:\n            if c == sol[v]:\n                continue\n            cost = 0\n            for u in adj[v]:\n                cost += 1 if sol[u] == c else 0\n            # slight bias to lower color ids to promote compact palette\n            cost_tie = (c*1e-3)\n            score = cost + cost_tie\n            if score < best_cost:\n                best_cost = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        current_k = len(set(sol))\n        if current_k < 2:\n            return sol\n        # Pick a seed vertex biased to conflicts\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n        else:\n            seed = random.randrange(n)\n        # pick a second color different from seed color\n        c1 = sol[seed]\n        other_colors = [c for c in range(1, current_k+1) if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        # BFS over subgraph induced by colors {c1,c2}\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol: List[int]) -> List[int]:\n        # swap labels of two random colors (can help escape encoding biases)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move adaptively\n    conflict_count = len(_conflict_vertices(sol))\n    r = random.random()\n    if conflict_count > 0:\n        # prioritize fixing conflicts\n        move_type = \"Recolor\" if r < 0.7 else \"KempeSwap\"\n    else:\n        # diversify\n        move_type = \"KempeSwap\" if r < 0.6 else \"Recolor\"\n        if r > 0.9:\n            move_type = \"PaletteSwap\"\n    if move_type == \"Recolor\":\n        new_sol = _recolor_move(sol)\n    elif move_type == \"KempeSwap\":\n        new_sol = _kempe_swap(sol)\n    else:\n        new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move_type\n","PERTURB_CODE":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation combining multiple targeted recolors and a Kempe swap\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # pick random color pair and random seed among vertices with one of these colors\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # number of recolors scaled with size\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # choose high degree vertices when no conflicts\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            vs = [i for i,d in enumerate(degs) if d == max_deg]\n            v = random.choice(vs)\n        palette = list(range(1, max(3, k + 1)))\n        if sol[v] in palette and len(palette) > 1:\n            palette.remove(sol[v])\n        sol[v] = random.choice(palette)\n    # apply multiple Kempe swaps to strongly shake structure\n    for _ in range(2):\n        sol = _kempe_swap(sol)\n    # random palette relabel to change encoding\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","SAMPLE_SOL":"[2,3,1,3,2,1,3,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Target heuristic signature not honored. Heuristic drivers expect different arities; provide a single unified Heuristic matching TARGET_HEURISTIC_GENERAL_SIGNATURE and create adapters for SA\/ILS\/TS or remove incompatible drivers.\nE_NEIGH_RETURN:generate_neighbour returns (sol,'Local',move) causing 'too many values to unpack'. Standardize to return only new_solution or exactly (new_solution, move_type) and update all callers accordingly.\nE_PERTURB_MISSING:Perturbation Function is placeholder '$Perturb'. Provide a concrete perturb_solution consistent with signature; ILS cannot run without it.\nE_DRIVER_INTEGRATION:SA\/ILS\/TS call patterns do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement a single orchestration Heuristic that internally runs the chosen metaheuristic, and expose exactly the general signature.\nE_EVAL_PENALTY_SCALE:PEN_CONFLICT=1e6 dwarfs k; SA\/TS parameterization will be ineffective. Use lexicographic compare in driver (minimize conflicts first, then k) or set PEN_CONFLICT ~ 100\u20131000 with temperature\/tabu tuned accordingly.\nE_TEMP_SCALE:Annealing temperature not scaled to evaluation range. Calibrate T0 to median delta from random moves or to ~percentile of conflict deltas; set cooling to maintain non-zero acceptance early.\nE_NORMALIZE_SIDE_EFFECTS:Frequent _normalize_colors changes palette IDs, breaking move semantics (e.g., \u201chighest color\u201d drift). Normalize only at evaluation and at acceptance checkpoints; keep internal colors stable during move generation or track true max color pre-normalization.\nE_DUP_COMP:Repeated recomputation of conflicts\/adjacency inside moves. Cache adj list and optionally current conflicts in outer scope; pass to move functions to avoid O(|E|) overhead per probe.\nE_MOVE_POLICY:_recolor_move may worsen conflicts deterministically. Add no-worsening guard (accept only if conflicts do not increase) unless acceptance rule (SA) overrides; otherwise search thrashes.\nE_RECOLOR_PALETTE:Palette includes current_k+1 only if conflicts exist via extra _conflict_vertices() call. Precompute conflict_exists once; test lower colors first to bias elimination.\nE_KEMPE_SCOPE:Kempe component uses c1,c2 BFS but seed choice when conflict-free is random; bias c2 to neighbor colors of highest-color vertices to target color elimination.\nE_ELIMINATE_LIMIT:EliminateColor is purely greedy; may stall. Add small lookahead: try recoloring neighbors with least saturation (DSATUR-like) before giving up a vertex.\nE_TABU_DEFINITION:No tabu fields present. For TS, define tabu attributes on vertex-color assignments and Kempe pairs with tenure and aspiration by best-so-far improvement.\nE_INIT_STRATEGY:Sample solution is valid but not derived systematically. Seed with DSATUR\/Greedy with largest-first ordering to start near k=3 and reduce burn-in.\nE_PROGRESS_ADAPT:Move probabilities static. Adapt based on stagnation: increase Kempe\/Eliminate when conflict-free; prioritize Recolor when conflicts>0 and high.\nE_CONSTRAINT_ENFORCE:Consecutive color indexing is enforced by normalize, but drivers must also ensure the reported k equals max(color). Validate at acceptance.\nR_FIX_NEIGH_SIGNATURE:Change def generate_neighbour(solution) -> (new_solution, move_type) and update all heuristic callers to unpack two values only.\nR_ADD_PERTURB:Implement perturb_solution as multi-step shake: e.g., 2\u20134 random Kempe swaps seeded on highest color class plus 1\u20132 recolors on conflicted vertices.\nR_UNIFIED_HEURISTIC:Implement Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) that can switch mode={'SA','ILS','TS'} from other_params, handling acceptance, tenure, and iterations internally.\nR_EVAL_LEX:In the driver, compare (conflicts,k) tuples rather than scalar fitness; keep evaluate_solution numeric for tooling but use a secondary function returning (conflicts,k).\nR_CACHE_STRUCTS:Precompute edges\/adjacency once; pass into generate_neighbour and reuse conflict vertex list within a move to reduce duplicate scans.\nR_SA_PARAMS:Set T0 to median absolute delta from 100 random neighbors; cooling alpha ~0.95\u20130.99; stop at T_min where acceptance rate<1%.\nR_TABU_IMPL:Maintain tabu list on (vertex,color) for tenure ~7\u201310, aspiration if candidate improves best (conflicts,k). Diversify via palette swaps when tabu blocks all.\nR_ELIMINATE_COLOR_PLUS:When conflict-free, run a focused elimination cycle on max color: order vertices by DSAT; attempt recolor; if fail, trigger a targeted Kempe between target and best alternative color.\nR_ADAPT_PROBS:Increase EliminateColor probability when max color class size shrinks; decrease when conflicts spike; log move efficacy and reweight.\nR_INIT_DSATUR:Construct initial solution via DSATUR to likely reach k=3 quickly, reducing reliance on penalties.\nR_ACCEPT_NO_WORSE:Under local search, accept only neighbors with non-increasing conflicts; tie-break by k then by move simplicity; allow worsening only under SA with calibrated T.\nR_TESTS:Unit-test generate_neighbour return shape, perturb presence, and that evaluate_solution([1]*9) >> evaluate_solution(valid_3_coloring) to confirm scaling.\nR_LOG_MINIMAL:Return move_type and delta(conflicts,k) from neighbor for lightweight diagnostics without file or OS access.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1e6\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    # conflicts\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = float(PEN_CONFLICT * conflicts + k)\n    return float(fitness)\n","NB_CODE":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, \"Local\", Movement_Type) where Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\",\"EliminateColor\"}\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        # Try colors from 1..current_k (+ optionally current_k+1 only if conflict exists)\n        palette = list(range(1, current_k + (1 if _conflict_vertices(sol) else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            # prefer lower color ids slightly and avoid introducing new color\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            # choose c2 from neighbor colors to address conflict\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            # try to reduce usage of highest color\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            # pick any vertex of color c1 as seed\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to greedily recolor vertices of the highest color into lower colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move\n","PERTURB_CODE":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        # choose random seed among vertices with color a or b\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # Targeted random recolors\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # bias to highest color and high-degree vertices\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    # Multiple Kempe swaps\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    # Random palette relabel\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":3,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"PERTURB_MISSING:Missing perturbation function. Provide conflict-driven Kempe-chain shake + ruin-and-recreate with randomized DSATUR repair for diversification.; TS_SIG_ERROR:Tabu Search signature uses generate_neighbour() and evaluate_solution() values instead of callables and expects wrong return arity. Fix to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and ensure neighbour returns (sol, move) or unpack accordingly.; TS_UNPACK_FAIL:Neighbour returns (sol, move) but TS expects 2 values with a callable misuse. Update TS to handle (new_sol, move)=generate_neighbour(sol) and pass functions without calling.; E_EVAL_PENALTY_STATIC:Static PEN_CONFLICT=1000 may stall color-minimization after conflicts resolved. Use adaptive penalty: PEN_CONFLICT = base * (1 + alpha * iters_without_improve).; E_EVAL_REDUNDANT_NORMALIZE:Repeated _normalize_colors in both evaluation and neighbourhood inflates runtime and may distort intended palette operations. Normalize once at entry to Heuristic loop and maintain invariant.; NB_REDUNDANT_GRAPH_BUILD:_edges\/_adj_list rebuilt on every call. Cache once (edges, adj, degrees) in closure\/other_params to reduce overhead.; NB_CONFLICT_DETECTION_INCONSISTENT:_conflict_vertices operates on raw sol, not normalized, risking mismatch if non-consecutive labels appear. Normalize at function start or enforce invariant in caller.; NB_RECOLOR_RISK_COLOR_BLOAT:_recolor_move allows introducing new color when conflicts exist, increasing k unnecessarily. Restrict to existing palette unless conflicts persist for T stagnation steps; if adding color, add exactly 1 then immediately attempt elimination.; NB_ELIMINATE_GREEDY_CONFLICT:_eliminate_highest_color greedily recolors without lookahead, often creating many conflicts. Replace with greedy-first-fit guided by saturation (DSATUR order) and fallback Kempe-chain repair.; NB_KEMPE_SELECTION_WEAK:Kempe seed selection not explicitly targeting edges causing conflicts with highest color class. Bias seed to conflicting vertices in max color to accelerate color elimination.; NB_PALETTE_SWAP_NOOP:Palette swap followed by normalization negates diversification. Either omit normalization after palette swap or remove palette swap to avoid wasted moves.; NB_MOVE_POLICY_STATIC:Fixed probabilities not adaptive to landscape. Use adaptive move selection via multi-armed bandit (e.g., Exp3\/UCB) scoring moves by recent improvement.; INIT_STRATEGY_UNSPECIFIED:Starting from arbitrary solution degrades performance variance. Initialize with DSATUR greedy 3-color attempt; if fails, start with 4 and immediately eliminate.; ACCEPT_CRITERIA_SUBOPT:For SA\/ILS, acceptance not detailed; risk premature convergence. Use Late Acceptance or Threshold Accepting tied to conflicts then k.; TERMINATION_CRITERIA_WEAK:No explicit stop based on no-improve and feasible-k target. Add dual-criterion: stop when conflicts=0 and k unchanged for X iters or time budget.; REPRESENTATION_WEAK_INVARIANT:LIST_INT_9 with arbitrary labels causes constant normalization. Maintain consecutive colors invariant after every move to simplify and speed evaluation.; E_CODE_PERF:Overall O(|E|) per eval with high constant due to rebuilds; with caching, reduce to tight O(|E|) and ~3x speedup.; PARAM_TUNING_MISSING:No annealing schedule\/tabu tenure guidance. Set SA T0 from std of 50 random deltas, T_end = 1e-3 T0, alpha=0.95; Tabu tenure = 7\u201315, aspiration = best_score-1.; DIVERSIFICATION_INADEQUATE:Add ejection-chain recoloring and large-neighborhood ruin (remove a color class, reinsert with greedy\/Kempe repair) when stagnating.; RESULT_VALIDATION:Lack of feasibility-first enforcement. Enforce lexicographic objective (conflicts, k) in acceptance and store best-feasible separately from best-overall.; API_CONTRACT_ENFORCEMENT:Ensure Heuristic strictly adheres to signature and returns (best_solution, best_score, best_feasible, best_feasible_score) or documented tuple; mismatch caused TS failure.; TEST_COVERAGE_GAP:Add unit tests: neighbour preserves domain and length; normalization idempotence; evaluate_solution known cases (0-conflict k=3 returns 3.0).;\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","NB_CODE":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, move_type)\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        candidates = conflicted[:]\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        conflict_exists = len(conflicted) > 0\n        palette = list(range(1, current_k + (1 if conflict_exists else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e18\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, move\n","PERTURB_CODE":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]  \n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":4,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.crit\"\n\"FEEDBACK\",\"E_SIG_MISMATCH:Target requires Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Align all algorithm entry points to this signature or provide an adapter layer to map SA\/ILS\/TS to the required interface.\"\n\"FEEDBACK\",\"NB_RET_SHAPE:generate_neighbour returns (solution, move_type). Algorithms likely expect a single solution. Provide an adapter nb_adapter=lambda s: generate_neighbour(s)[0] for SA\/ILS\/TS, or refactor heuristics to accept the 2-tuple.\"\n\"FEEDBACK\",\"PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Implement def perturb_solution(sol): return kempe_multi_shake(sol, iters=3) to enable ILS and general restarts.\"\n\"FEEDBACK\",\"TS_UNPACK_ERR:Tabu implementation is unpacking evaluate_solution output or a wrong callable. Ensure TS only unpacks generate_neighbour return and treats evaluate_solution as scalar cost.\"\n\"FEEDBACK\",\"SA_UNPACK_ERR:SA indicates 'too many values to unpack'; ensure neighbor_call returns a single solution in SA loop or use the adapter. Also stop calling generate_neighbour() with no args; pass current solution.\"\n\"FEEDBACK\",\"ILS_SIG_ERR:ILS signature indicates acceptance_rate; failure stems from same neighbor return shape and missing perturb_solution. Fix both.\"\n\"FEEDBACK\",\"E_PEN_SCALE:Penalty 1e6 per conflict can dwarf temperature\/acceptance. Tune annealing schedule to conflict scale or use lexicographic acceptance: prioritize delta_conflicts, tie-break by delta_k.\"\n\"FEEDBACK\",\"NORM_POLICY:Normalization inside generate_neighbour changes color labels each step, breaking move memory (Tabu) and acceptance comparability. Restrict normalization to evaluation or only after color elimination; keep neighbor colors stable otherwise.\"\n\"FEEDBACK\",\"ADJ_PRECOMP:Edges\/adjacency rebuilt on every call. Precompute once (edges, adj_list, degrees) in module scope to reduce overhead in tight loops.\"\n\"FEEDBACK\",\"MOVE_SET_BALANCE:Recolor heuristic allows introducing new colors under conflict, inflating k. Constrain to existing palette unless no zero-conflict option exists; add min-conflict tie-breaking by lowest color not increasing k.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Local opt traps likely; add 2-color path\/cycle targeted Kempe with best-improving swap selection instead of random seed to escape.\"\n\"FEEDBACK\",\"TABU_ATTR:For TS, define tabu attributes as (vertex,color) and aspiration on conflict decrease; without this, recolor moves will cycle due to normalization.\"\n\"FEEDBACK\",\"TEMP_SCHEDULE:Provide temperature initialized to median |delta| and geometric cooling tuned to keep acceptance of uphill-conflict moves ~0.15 initially; otherwise SA freezes due to 1e6-scale deltas.\"\n\"FEEDBACK\",\"INIT_SOL:No initializer provided. Add DSATUR-based constructive initializer to start with low k and zero conflicts, improving convergence and reducing penalty dominance.\"\n\"FEEDBACK\",\"REPR_CONSTRAINT:Representation demands consecutive colors. Enforce consecutiveness at evaluation and output only; internally allow gaps to preserve neighborhood structure and tabu attributes; finalize with normalize_colors before scoring\/output.\"\n\"FEEDBACK\",\"K_ELIM_STRATEGY:_eliminate_highest_color relies on greedy reassignment plus single Kempe; add iterative vertex ordering with backtracking and limited BFS swaps to reliably remove the max color.\"\n\"FEEDBACK\",\"DIVERSIFICATION:Add large-scale perturbation: multiple randomized Kempe swaps across diverse color pairs, and random recolor of a small subset of vertices from the highest color class.\"\n\"FEEDBACK\",\"REPRODUCIBILITY:Inject optional random_seed in other_params and thread through all random calls to enable deterministic runs for testing.\"\n\"FEEDBACK\",\"TERMINATION:Define stopping criteria (max_evals, no_improve_iters) and return best solution consistently normalized to satisfy indexing constraint.\"\n\"FEEDBACK\",\"TESTS_MISSING:Add unit tests: (1) evaluate_solution known solution -> 3, (2) neighbor preserves length and domain, (3) normalization idempotence, (4) zero-conflict states never increase conflicts under Recolor unless necessary.\"\n\"FEEDBACK\",\"KNOWN_SOL_VALIDATE:Validate [3,1,2,1,3,2,1,1,2] against edges via evaluate_solution==3 to ensure baseline; if conflicts>0, correct known solution or graph edges.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # give up for this vertex (keep target); will be normalized\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","PERTURB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":5,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH: Heuristic implementations violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Fix to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass functions as callables (no parentheses in signature\/arguments).\"\n\"FEEDBACK\":\"E_CALLABLE_INVOCATION: SA\/ILS\/TS signatures show generate_neighbour() and evaluate_solution() invoked in parameter list. Remove parentheses; use function references and call inside algorithm.\"\n\"FEEDBACK\":\"E_RET_UNPACK_SA_ILS: 'too many values to unpack (expected 2)' indicates your generate_neighbour return is being unpacked into two when your code expects a different arity, or vice versa. Standardize generate_neighbour to return only new_solution. If move_type is needed, return a tuple and unpack accordingly within the heuristic; otherwise drop move_type.\"\n\"FEEDBACK\":\"E_RET_UNPACK_TS: 'cannot unpack non-iterable int object' suggests you attempted to unpack evaluate_solution return as a tuple. evaluate_solution returns a float cost. Do not unpack.\"\n\"FEEDBACK\":\"NB_API_CONTRACT: For robustness, define generate_neighbour(solution)->new_solution only. If logging move types, provide a separate hook. Current tuple (new_solution, move_type) breaks callers not designed for it.\"\n\"FEEDBACK\":\"PERTURB_MISSING: 'Perturb' is undefined. Implement perturb_solution(solution, intensity, rng) consistent with the Heuristic signature. Use Kempe-chain bursts + color class shuffle to escape deep basins.\"\n\"FEEDBACK\":\"R_CONST_RECOMPUTE: _edges and _adj_list rebuilt on each call. Cache as module-level constants to cut overhead: EDGES=list(...); ADJ precomputed once. This improves neighbor\/evaluation throughput.\"\n\"FEEDBACK\":\"NB_CODE_FAIL_LOCAL_OPT: Recolor move ignores 'forbidden' and may assign neighbor color that increases conflicts even in conflict-free phase. Enforce no-conflict recolors during elimination to maintain feasibility: only choose colors not in forbidden when conflicts==0.\"\n\"FEEDBACK\":\"NB_OFF_BY_ONE: palette = range(1, current_k + (1 if allow_new and conflicted else 0) + 1) creates an extra color (k+2 upper bound) when conflicted. Correct to range(1, current_k + (1 if allow_new else 0) + 1).\"\n\"FEEDBACK\":\"NB_ELIMINATION_WEAK: _eliminate_highest_color relies on greedy then single Kempe swap; may stall. Add multi-vertex Kempe chain exploration and Try recolor sequence with small BFS over feasible colors to fully evacuate max color class.\"\n\"FEEDBACK\":\"EVAL_SCALE_RISK: PEN_CONFLICT=1e6 dwarfs k by 6 orders; good for feasibility-first but SA acceptance may underflow if TEMP scale small. Calibrate TEMP to match delta magnitudes or rescale penalties (e.g., 1e4) to stabilize acceptance.\"\n\"FEEDBACK\":\"EVAL_NORMALIZE_SIDE_EFFECT: Normalization remaps colors each evaluation, disrupting move memory (tabu) and temperature schedules. Keep neighbor ops normalized already and avoid re-normalization in evaluation except for validation; or base tabu on color partitions, not raw labels.\"\n\"FEEDBACK\":\"INIT_SAMPLE_INVALID: 'Sample Solution' is not a valid Python list and violates expected input contract. Provide as [3,1,2,1,3,2,1,1,2].\"\n\"FEEDBACK\":\"OBJ_CONSISTENCY: Ensure algorithms treat lower score as better. SA\/ILS\/TS must compare new_cost < best_score and accept per minimization. Do not negate scores.\"\n\"FEEDBACK\":\"TABU_STATE_TYPE: If using tabu, store immutable representations (tuple(solution)) and move attributes, not raw lists, to avoid hashing issues.\"\n\"FEEDBACK\":\"DSATUR_IMPL_ISSUE: _dsatur_order computes used_colors from raw sol; since sol is normalized later, ensure _dsatur_order is called after normalization only. Otherwise, saturation misestimation can occur when labels skip.\"\n\"FEEDBACK\":\"SEARCH_DIVERSITY: Add occasional color class merge\/split perturbation and random vertex recolor with bounded conflict repair to diversify beyond Kempe-only moves.\"\n\"FEEDBACK\":\"SA_CORE_FIX: Use standard loop: for it in range(max_it): neigh=generate_neighbour(curr); nc=evaluate(neigh); if accept(nc,curr_cost,T): curr=neigh; update best; T*=cooling. Acceptance: exp(-(nc-curr_cost)\/T) for nc>curr_cost.\"\n\"FEEDBACK\":\"ILS_CORE_FIX: LocalSearch() using neighbour until no improvement; then perturb_solution; acceptance: if new_cost<=incumbent or with threshold; iterate fixed times.\"\n\"FEEDBACK\":\"TS_CORE_FIX: Maintain tabu list of recent moves or solutions with tenure; aspiration if new_cost<best_score; neighborhood scan over fixed samples; use cost minimization.\"\n\"FEEDBACK\":\"KNOWNSOL_CHECK: Known solution achieves cost=3 with 0 conflicts; set stopping criterion when k==3 and conflicts==0.\"\n\"FEEDBACK\":\"COMPATIBILITY_RULE: 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS satisfied; ensure any added code adheres strictly.\"\n\"FEEDBACK\":\"PERF_HINT: Precompute degrees, color availability masks as bitsets for O(1) forbidden checks; reduces neighbor evaluation cost.\"\n\"FEEDBACK\":\"DIAGNOSTICS: Log (conflicts,k,cost) per iteration; if conflicts>0 for long, switch to conflict-directed Kempe with increased frequency; if conflicts==0 and k stable, trigger elimination-focused perturbation.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","PERTURB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","SAMPLE_SOL":"3,1,2,1,3,2,1,1,2"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":6,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Heuristic runners (SA\/ILS\/TS) fail due to interface inconsistency. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE and ensure generate_neighbour returns only new_solution; move_type must be removed or handled via other_params\/logging. Provide perturb_solution; replace '$Perturb' with a concrete function.\nE_RUNNER_COMPAT:generate_neighbour currently returns (solution, move_type) causing 'too many values to unpack'. Standardize contracts: generate_neighbour -> solution; evaluate_solution -> float; perturb_solution -> solution. Add thin adapter if move diagnostics are needed.\nE_PERTURB_MISSING:Missing Perturbation Function. Implement strong-diversification perturbation (e.g., multi-vertex Kempe-chain swaps + random recolor of a subset) to enable ILS\/SA escapes.\nE_CACHE_OVERHEAD:_edges\/_adj_list recomputed on every call across helpers, causing redundant O(E) allocations. Precompute once and close over them or pass via other_params to cut overhead.\nE_RANDOM_GLOBAL:Uncontrolled randomness (random.*). Inject rng via other_params with fixed seed for reproducibility, or thread-safe RNG object; avoid global state.\nE_NORM_SIDE_EFFECT:Normalization inside evaluation collapses distinct genotypes to identical phenotypes, flattening the landscape and hiding improvements. Prefer enforcing consecutive-color invariant at generator level only; in evaluate_solution, validate and penalize non-consecutive indexing instead of renumbering.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour returns mixed operations with stochastic branching without evaluation-aware guidance. Introduce best-of-m samples (first-improvement or steepest) to reduce regressions and conflicts.\nNB_COLOR_INFLATION:_recolor_move allows k+1 even when many legal colors exist, bloating palette. Restrict increases to when conflicts persist after trying all legal colors; add aspiration criterion based on net conflict delta.\nNB_KEMPE_ARBITRARY:_kempe_swap picks pairs randomly; low impact. Targeted Kempe: choose color pair (c1,c2) maximizing conflicting edges cut; seed from highest conflict degree vertices.\nNB_ELIMINATE_BUG:In _eliminate_highest_color, after Kempe swap, out may be updated to out2 even if assigned remains None, unintentionally modifying state without progress. Guard: only commit out=out2 if assignment succeeds; else revert.\nNB_ELIMINATE_LIMITED:Greedy recolor tries only first-fit up to target-1; misses opportunities. Replace with tabu-guided recolor or small ILP for the color class; try recoloring order by DSATUR and consider recolor to any color != target that avoids conflicts; use bipartite check for quicker merges.\nNB_DSATUR_OVERHEAD:_dsatur_order recomputes used_colors fully each call. Maintain incremental saturation degrees or compute once per move to reduce O(n+E) per step.\nNB_NOOP_PATH:On invalid input, generate_neighbour returns (solution, 'NoOp'), violating the single-return expectation and masking errors. Raise\/propagate an explicit failure via other_params or return the original solution only; let the runner validate inputs.\nE_SCALING_TUNING:PEN_CONFLICT=1e4 vs k penalty=1 makes conflicts dominant but may trap when conflicts=1 and k decreases. Add lexicographic evaluation: (conflicts, k) tuple converted to scalar with higher base or multi-stage acceptance in SA\/TS.\nE_MOVE_EVAL:Lack of move scoring inside generate_neighbour leads to blind changes. Implement neighborhood sampling with delta-evaluation of conflicts for candidate colors to pick the minimal incremental score move.\nR_REPR_CONSTRAINT:Representation claims LIST_INT_9_CONSEC_COLORS, but evaluation tolerates arbitrary ints due to normalization. Enforce consecutive colors at generator and perturbation; in evaluation, reject non-consecutive (penalty) to align components.\nR_INIT_STRATEGY:No constructive initializer defined. Add DSATUR\/Greedy coloring initializer to start near-feasible k, reducing search time.\nILS_ACCEPTANCE_WEAK:Acceptance rules unspecified. Define acceptance that prefers lower conflicts, then lower k; allow worsening moves under SA temperature or ILS acceptance_rate only when conflicts decrease or equal and diversity improves (Hamming distance threshold).\nTS_MEMORY_DEFICIT:Tabu structures unspecified. Define tabu list on vertex-color assignments and Kempe pairs with tenure; add aspiration when solution improves (conflicts or k). Ensure evaluate_solution returns scalar and TS never unpacks it.\nPERF_DELTA:Conflict recomputation scans all edges each time. Maintain adjacency and incremental conflict counts to update in O(deg(v)) per move.\nROBUSTNESS_TESTS:No unit tests against KNOWN SOLUTION. Add asserts: evaluate_solution([3,1,2,1,3,2,1,1,2])==3 and conflicts==0; include randomized regression tests for normalization and neighbor invariants.\nAPI_WRAPPER:Provide Heuristic wrapper matching TARGET_HEURISTIC_GENERAL_SIGNATURE that orchestrates generate_neighbour\/evaluate_solution\/perturb_solution with proper best-is-lower semantics. Ensure no file\/network\/OS access per MAIN_CRITICAL_INSTRUCTION.\nPARAM_TUNING:Expose parameters (PEN_CONFLICT, Kempe probability, elimination iterations, SA temp\/cooling, TS tenure) via other_params for systematic tuning and automated sweeps.\nLOGGING_MINIMAL:Remove move_type from return; instead, collect counters in other_params['stats'] to avoid breaking interfaces while retaining diagnostics.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate, then minimize k. Lower is better.\n    # Input: list of 9 positive integers (colors). Colors may be any positive ints; we normalize to consecutive 1..k.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains 1..k consecutive colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _recolor_move(sol):\n        # DSATUR-guided recolor. If conflicts exist, allow k+1; otherwise keep feasibility (no new conflicts).\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            order = _dsatur_order(sol)\n            cset = set(conflicted)\n            cand = [v for v in order if v in cset]\n            v = cand[0] if cand else random.choice(conflicted)\n            allow_new = True\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        # Palette up to k (+1 only if allowed)\n        palette = list(range(1, current_k + (1 if allow_new else 0) + 1))\n        best_c = sol[v]\n        best_score = 10**9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts_here = 1 if c in forbidden else 0\n            if not conflicted and conflicts_here > 0:\n                # preserve feasibility when already conflict-free\n                continue\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts_here + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate highest color class without introducing conflicts.\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        # Multiple passes with greedy recolor and occasional Kempe swaps\n        for _ in range(3):\n            random.shuffle(verts)\n            changed = False\n            for v in list(verts):\n                if out[v] != target:\n                    continue\n                forbidden = {out[u] for u in adj[v]}\n                assigned = None\n                for c in range(1, target):\n                    if c not in forbidden:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # try Kempe swap with a random forbidden color to free a slot\n                    if forbidden:\n                        f = random.choice(list(forbidden))\n                        out2 = _kempe_swap(out, seed=v, pair=(target, f))\n                        forb2 = {out2[u] for u in adj[v]}\n                        for c in range(1, max(out2)):\n                            if c not in forb2:\n                                out = out2\n                                assigned = c\n                                break\n                if assigned is not None:\n                    out[v] = assigned\n                    changed = True\n            out = _normalize_colors(out)\n            if not changed:\n                break\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"NoOp\")\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"NoOp\")\n    sol = _normalize_colors(solution)\n\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return (_recolor_move(sol), \"Recolor\")\n        else:\n            return (_conflict_directed_kempe(sol), \"KempeSwap\")\n    else:\n        r = random.random()\n        if r < 0.55:\n            return (_eliminate_highest_color(sol), \"EliminateColor\")\n        elif r < 0.85:\n            return (_kempe_swap(sol), \"KempeSwap\")\n        else:\n            return (_recolor_move(sol), \"Recolor\")\n","PERTURB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Prefer removing highest color class\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify\n    iters = 4\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":7,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"BUG_EVAL_TYPING:Runtime error 'Type List cannot be instantiated' indicates external code is calling List(). Remove 'from typing import List' and all typing usage; use built-in 'list' annotations or no annotations to avoid exposing 'List' symbol to runtime.\nE_API_MISMATCH:generate_neighbour returns a solution list, but signature comment implies ('NB_Type','Movement_Type'). Align to framework: return (neighbor_solution, 'recolor'|'kempe'|'other').\nP_MISSING:Perturbation function is absent ('$Perturb'). Provide a diversification operator (e.g., multi-vertex Kempe chain or random recolor of a small subset) with intensity parameter.\nH_MISSING:Heuristic(currentSolution,...) not implemented. Provide the driver with acceptance criteria (e.g., SA\/ILS) and proper best-score handling (lower is better) per TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_COST_SCALING:Conflict penalty 1e4 may be too low if k can increase during search; ensure PEN_CONFLICT >> max plausible k-deltas. Consider 1e6 to strongly prioritize feasibility.\nE_REDUNDANT_WORK:_edges\/_adj_list redefined per call. Precompute once (module-level constants) to reduce overhead.\nE_INVALID_HANDLING:Consecutive-colors constraint returns PEN_INVALID, but neighbour always normalizes; construction\/perturbation must also guarantee consecutiveness to avoid collapsing search with huge penalties.\nNB_CONFLICT_INTRO:When allow_new_color=True, recoloring ignores forbidden set and can add conflicts, degrading local search. Enforce zero-conflict recolors when conflicts=0; when conflicts>0, only accept moves that strictly reduce conflicts or keep them equal with k decrease.\nNB_LIMITED_TRIES:_recolor_best_of caps at 20 trials, risking premature stagnation. Use deterministic best-improving over full palette for selected vertex, or adaptive cap based on degree.\nNB_VERTEX_SELECTION:Selecting any from max color class can be ineffective. Prioritize highest-degree, highest-conflict vertices or DSATUR-based ordering for recolor attempts.\nNB_KEMPE_TARGETING:Kempe seed random; bias to conflicted edges and to colors involving max color to target k reduction. Abort swaps that increase conflicts.\nNB_NORMALIZE_SIDE_EFFECT:Normalization can reshuffle color IDs, disrupting strategies targeting 'max color'. Track color classes by relative rank post-normalization; evaluate k-change explicitly before and after.\nNB_DELTA_EVAL:Current _score recomputes conflicts O(|E|) per try. Use incremental delta evaluation via adjacency to get O(deg(v)) per recolor candidate.\nNB_RANDOMNESS:Unseeded randomness hurts reproducibility. Allow seed in other_params and use a local Random instance.\nR_STR_INADEQUATE:Pure color IDs weaken neighborhood structure for k-minimization. Add explicit color-elimination moves: try to recolor entire max color class using greedy recolor, then delete color if successful.\nINIT_CONSTRUCTION:No construction heuristic provided. Seed with DSATUR or greedy coloring to start near k=3; avoid random starts that inflate k.\nACCEPTANCE_CRITERIA:Not defined. For SA\/ILS, accept non-worsening on conflicts first, then k; forbid accepting moves that increase conflicts when a zero-conflict state exists.\nTABU_SUPPORT:If doing Tabu, maintain tabu on (vertex,color) assignments with aspiration on conflict decrease or k decrease; current neighbor has no memory, causing cycling.\nSTOPPING_RULES:Not specified. Add max_iters, no_improve_iters, and time budget; track best feasible with minimal k.\nPERF_CONSTANTS:Move helper functions inside generate_neighbour recreated per call. Hoist to module scope or cache adj\/edges to reduce allocations.\nTEST_VALIDATION:Add unit checks: evaluate_solution(known_solution)==3 and conflicts==0; fuzz test normalization to ensure 1..k invariant.\nPARAM_SCHEDULE:Probability 0.2 for allow_new_color is arbitrary. Tie it to stagnation counter; reduce to near-zero when conflict-free to focus on k reduction.\nSCALING_GENERALITY:Hardcoded n=9 and fixed edges. For generality, accept other_params['graph'] with precomputed adj\/edges; default to given graph if absent.\nOUTPUT_CONSISTENCY:Ensure Heuristic returns (best_solution, best_score) with best_score as lower-is-better consistent with evaluation, and expose currentSolution even if infeasible for recovery.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Feasibility-first: lower is better. Penalize any invalid\/non-consecutive encoding.\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    # Enforce consecutive color indexing 1..k\n    colors = set(solution)\n    k = len(colors)\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","NB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a single neighbor solution (list of ints) maintaining 1..k consecutive colors.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _is_consecutive(sol):\n        s = set(sol)\n        k = len(s)\n        return s == set(range(1, k+1))\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _score(sol, edges):\n        # Mirror evaluation without invalid penalties; assumes consecutive\n        return 10000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _recolor_best_of(sol, adj, edges, allow_new_color):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            # try to eliminate highest color\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        random.shuffle(cand_vertices)\n        best = None\n        best_score = float('inf')\n        tried = 0\n        for v in cand_vertices:\n            forbidden = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            random.shuffle(palette)\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                if not allow_new_color and c in forbidden:\n                    continue\n                # do not introduce immediate conflict when already conflict-free\n                if not conflicted and c in forbidden:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                tried += 1\n                if tried >= 20:\n                    return best if best is not None else sol\n        return best if best is not None else sol\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # Seed from conflicted vertex if any\n        edges = _edges()\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            # pick any different color\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        from collections import deque as _dq\n        vis = [False]*n\n        q = _dq([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Input validation and normalization to maintain representation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Decide move based on conflicts\n    if _conflicts_count(sol, edges) > 0:\n        # Try recolor without increasing colors first; if no improvement, allow k+1 rarely\n        out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n        if _score(out, edges) <= _score(sol, edges):\n            return out\n        if random.random() < 0.2:\n            return _recolor_best_of(sol, adj, edges, allow_new_color=True)\n        return _kempe_swap(sol, adj)\n    else:\n        # Conflict-free: try eliminate highest color or gentle Kempe\n        if random.random() < 0.7:\n            out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n            # Prefer solutions with fewer colors or equal colors and not worse\n            if (len(set(out)) < len(set(sol))) or (_score(out, edges) <= _score(sol, edges)):\n                return out\n        return _kempe_swap(sol, adj)\n","PERTURB_CODE":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: drop one color class and reinsert by DSATUR, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored has 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove a color class (prefer highest)\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if not verts:\n        return sol\n    colored = sol[:]\n    for v in verts:\n        colored[v] = 0\n    unassigned = set(verts)\n    sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply several Kempe shakes\n    shakes = 4\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","SAMPLE_SOL":"[3,1,2,1,3,2,1,1,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Componente":null,"Version":8,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\",\n\"FEEDBACK\":\"SIG_MISMATCH:Heuristic runners expect signature def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Align all algorithms to this exact signature and argument order.|\nSIG_GEN_NEIGH_RET:generate_neighbour returns (neighbor, move_type) but SA\/ILS\/TS expect a single neighbor; remove move_type from return or gate metadata via other_params\/logging.|\nSIG_PERT_MISSING:Perturbation Function undefined ('$Perturb'). Provide def perturb_solution(solution, other_params) with deterministic signature to satisfy ILS.|\nSA_UNPACK_ERR:SA currently unpacks generate_neighbour into two values; adjust SA to single neighbor or change generate_neighbour to return only the solution.|\nILS_UNPACK_ERR:ILS signature mismatches and missing perturb_solution cause failure. Fix to accept (generate_neighbour, perturb_solution, evaluate_solution) and iterate acceptance per acceptance_rate.|\nTS_UNPACK_ERR:TS attempts to unpack evaluate_solution (float) as tuple; ensure TS only reads scalar cost. Also use consistent neighbor return signature.|\nREP_CONSEC_ENFORCE_INIT:Initial solutions not normalized may be rejected by evaluate_solution. Normalize any provided currentSolution before first evaluation to maintain 1..k indexing.|\nE_VAL_PENALTY_SCALE:PEN_CONFLICT=1e9 may freeze SA acceptance and mislead TS aspiration; use adaptive penalty or two-phase: prioritize zero conflicts, then minimize k, but use smaller scale (e.g., 1e6) and\/or conflict-first lexicographic comparison in code.|\nE_VAL_REDUNDANCY:_edges() rebuilt every call; precompute edges\/adjacency once and close over them to reduce overhead.|\nNB_API_DOC:Type annotation -> ('NB_Type','Movement_Type') is invalid and misleading; remove and document return type as List[int].|\nNB_CONFLICT_RECOLOR:_best_recolor_vertex forbids recolors that keep temporary conflicts even when conflicted, which can stall; allow non-worsening moves (delta-conflicts <= 0) to increase escape options.|\nNB_SEARCH_WIDTH:Single-vertex recolor only explores O(n*k); add 2-opt style pair recolors or steepest-improving scan to escape plateaus.|\nNB_KEMPE_SCOPE:Kempe swap picks random c2; bias selection toward neighbor colors that reduce conflicts or eliminate max color. Evaluate delta before applying.|\nNB_COLOR_ELIM_GREEDY:color_elim aborts on first failure; try reorder of vertices by decreasing degree (DSATUR ordering) and attempt backtracking depth-1 before failing.|\nNB_NORMALIZE_FREQ:_normalize on every candidate is expensive; defer normalization until a move is selected by tracking remap lazily, or only normalize when k may change.|\nPERT_WEAKEST:No perturbation provided; add controlled shake: random Kempe chain on a high-degree seed, or recolor p vertices from max color class; parameterize p.|\nPERT_PROHIB_OS:Ensure perturb_solution avoids filesystem\/network\/OS per MAIN_CRITICAL_INSTRUCTION.|\nSEARCH_STRATEGY_FEASIBLE_FIRST:When conflicts>0, prioritize repair using DSATUR-based single-vertex best color, then Kempe; when conflicts==0, aggressively try color elimination then mild diversification.|\nTEMP_SCHEDULE:For SA, use geometric cooling with reheats when stagnation detected; ensure temperature only interacts with delta of evaluate_solution (scalar).|\nTABU_ATTR:For TS, define move attributes compatible with neighbor: tabu on (vertex,color) assignments or Kempe (c1,c2) pairs; aspiration if new best_score is achieved.|\nSTOP_CRITERIA:Add consistent max_iters\/no-improvement budget and early stop on k==3 known optimum to save compute.|\nK_TARGET_AWARE:Once conflict-free with k>3, add focused k-reduction phase: try to eliminate color k by solving bipartite recolor on subgraph induced by candidates (augmenting-path recoloring).|\nINITIAL_CONSTRUCT:Add robust initializer: greedy DSATUR to produce low-k conflict-free start, improving convergence and reducing penalties.|\nRANDOM_SEED_CTRL:Expose RNG seed via other_params for reproducibility and benchmarking.|\nSCORING_CACHE:Cache conflicts per vertex and update incrementally on local moves to reduce O(|E|) recomputation.|\nEDGES_STATIC:Hoist edges\/adj list to module-level constants to avoid repeated allocations in evaluation and neighborhood.|\nLOGGING_MINIMAL:Since runners parse outputs, keep any metadata internal; avoid returning non-solution types from core APIs to prevent unpack errors again.|\nTEST_HARNESS:Create unit tests to assert: evaluate_solution(known_solution)==3, generate_neighbour returns List[int], perturb_solution returns List[int], and normalization invariants hold.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONSEC_COLORS","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Strongly penalize any infeasibility or invalid encoding.\n    PEN_INVALID = 1e15\n    PEN_CONFLICT = 1e9\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    colors = set(solution)\n    k = len(colors)\n    # Enforce consecutive color indexing 1..k\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strong feasibility-first: any conflict dominates k\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","NB_CODE":"import random\nfrom collections import deque\n\n# Neighbor generator for graph coloring on fixed 9-vertex graph.\n# Returns (neighbor_solution_list, move_type_str)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _score(sol, edges):\n        return 1_000_000_000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _best_recolor_vertex(sol, adj, edges, allow_new_color=False):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        # Candidate vertices: conflicted first; otherwise try max color class\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        # Order by (degree, random tie-break), prefer higher degree\n        cand_vertices.sort(key=lambda v:(-len(adj[v]), random.random()))\n        best = None\n        best_move = None\n        best_score = float('inf')\n        for v in cand_vertices:\n            forb = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            # Try colors ordered to prefer lower indices to help k reduction\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                # If currently conflict-free, do not introduce conflicts\n                if not conflicted and c in forb:\n                    continue\n                # If conflicted, prefer colors not in forb; skip those that worsen conflicts\n                if c in forb:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                    best_move = \"recolor\"\n        return (best if best is not None else sol, (best_move if best_move is not None else \"recolor\"))\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol, \"kempe\"\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol, \"kempe\"\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out), \"kempe\"\n    def _color_elim(sol, adj, edges):\n        # Attempt to eliminate the highest color by greedy recoloring its vertices\n        k = max(sol)\n        target = k\n        verts = [i for i,c in enumerate(sol) if c == target]\n        if not verts:\n            return sol, \"color_elim\"\n        out = sol[:]\n        for v in verts:\n            forb = {out[u] for u in adj[v]}\n            placed = False\n            for c in range(1, target):\n                if c not in forb:\n                    out[v] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, \"color_elim\"  # fail, return original\n        out = [c if c < target else c-1 for c in out]  # remove empty top color if any\n        return _normalize(out), \"color_elim\"\n    # Validate input and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"invalid\")\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Strategy: if conflicts>0, recolor best-improving; else try color elimination, else Kempe\n    if _conflicts_count(sol, edges) > 0:\n        neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n        if neigh != sol:\n            return (neigh, mv)\n        # fallback Kempe\n        neigh, mv = _kempe_swap(sol, adj)\n        return (neigh, mv)\n    else:\n        # Conflict-free: prioritize reducing k\n        if random.random() < 0.7:\n            elim, mv = _color_elim(sol, adj, edges)\n            if elim != sol and max(elim) < max(sol):\n                return (elim, mv)\n        # gentle recolor to explore\n        if random.random() < 0.5:\n            neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n            if neigh != sol:\n                return (neigh, mv)\n        return _kempe_swap(sol, adj)\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n# Strong perturbation to escape local minima while preserving consecutive color encoding.\n\ndef perturb_solution(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored: list with 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove one color class (prefer the highest) and repair with DSATUR\n    target = max(colors) if random.random() < 0.8 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if verts:\n        colored = sol[:]\n        for v in verts:\n            colored[v] = 0\n        unassigned = set(verts)\n        sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply multiple Kempe shakes to diversify\n    shakes = 5\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","SAMPLE_SOL":"[2,3,1,3,2,1,3,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels must be contiguous 1..k","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_EVAL_TYPECHECK:Int coercion allows floats to pass (int(x)==x). Use isinstance(x,int) and x>=1 to avoid silent acceptance of floats.\nE_EVAL_SCALE:Penalty magnitudes (1e9\/1e5\/1e4) flatten gradients; small changes invisible to SA\/ILS temperature. Use lexicographic tuple or scaled weights ensuring EDGE_PEN >> 1, GAP_PEN << EDGE_PEN but not orders of magnitude apart (e.g., EDGE_PEN=1e3, GAP_PEN=50) or implement explicit lex compare.\nE_EVAL_CONTIG_BIAS:Contiguity penalized instead of normalized; search wastes effort on label permutations. Add canonical_relabel(solution)->compressed 1..k before scoring to eliminate GAP_PEN entirely.\nE_EVAL_REDUNDANCY:Seen-check does both len(seen)!=k and loop over 1..k; the loop is redundant after compression. Remove to reduce overhead.\nE_EVAL_INCR:Full O(|E|) re-eval each move is costly. Maintain current conflicts and per-vertex conflict counts; compute delta for single-vertex recolor in O(deg(v)).\nE_NEIGH_BIAS_NEW_COLOR:allow_new=True inflates k and harms objective. Gate new color introduction to when current vertex conflicts with all existing colors or under diversification phase only; otherwise restrict to 1..k.\nE_NEIGH_UNINFORMED:Random vertex recolor ignores conflicts. Use conflict-guided selection: pick vertex from conflict set, prefer colors minimizing added conflicts (first-fit\/least-conflict).\nE_NEIGH_WEAK_SWAP:Global label swap is neutral w.r.t. conflicts and k; only useful due to contiguity penalty (which should be removed via relabel). Replace with Kempe-chain interchange between two colors on a conflicted vertex.\nE_NEIGH_MISSING_MOVES:No color-removal or repair moves. Add: (a) RemoveColor(k): greedily recolor vertices of max color using available colors; (b) Saturation-move (DSATUR-style) on high-degree conflicted vertices; (c) Multi-vertex ejection chains to free a color.\nE_PERTURB_MISSING:$Perturb undefined. Implement perturb_solution as k-step conflict-guided random Kempe chains or a kick that targets top-c conflict vertices; ensure returns a valid list in-place and respects signature.\nE_INIT_WEAK:No constructive heuristic specified. Use DSATUR\/Greedy with smallest available color to get low-k starting point (often k=3 for this instance).\nE_RESULT_IO:Error 'list' object has no attribute strip indicates loader expects str. Fix input parser to accept list directly or serialize via ' '.join(map(str,sol)) before load; add type guard.\nE_API_CONTRACT:generate_neighbour mutates in-place and returns only metadata. Ensure meta is actually used by Tabu (attribute-based tabu on (vertex,color) or (color-pair) for Kempe); otherwise return (new_solution, meta) or copy externally to avoid unintended aliasing.\nE_ACCEPTANCE:SA acceptance must use delta=f_new-f_old with lower-better convention; verify sign to avoid accepting worse (higher) solutions more often than intended. Align with 'best as lesser cost'.\nE_CONTIG_CONSTRAINT:Contiguity as feasibility constraint complicates search. Enforce contiguity by canonical relabel after every move; drop GAP_PEN from objective to simplify landscape to (conflicts, k).\nE_TABU_SCOPE:Tabu on global swaps is meaningless with relabel. Define move attributes for recolor: tabu[(vertex,old_color)] for tenure T, aspiration if f<best.\nE_STOPPING:Undefined. Add max_iters, max_no_improve, and time cap; for ILS set perturb strength adaptively on stagnation.\nE_RANDOMNESS:No seeding controls. Add seed parameter in other_params to ensure reproducibility for evaluation.\nE_GRAPH_LOCALITY:Edges hardcoded only in evaluate; neighbor lacks access for informed moves. Pass adjacency list in other_params or precompute deg list for conflict-guided heuristics.\nE_CONSTRAINT_REPAIR:After each move, apply canonical_relabel and optionally local repair (least-conflict recolor) to quickly restore feasibility before accepting.\nE_KNOWN_SOL_VERIFY:Add unit tests: assert evaluate_solution([3,1,2,1,3,2,1,1,2])==3 after canonical relabel; reject if >3 or conflicts>0 for regression safety.\nR_REP_CANONICAL:Add function canonical_relabel(solution): map encountered colors to 1..k in first-occurrence order to guarantee contiguous labels without penalties.\nR_MOVE_KEMPE:Implement kempe_chain(solution, v, c2): BFS on subgraph induced by colors {c_old,c2}, swap to reduce conflicts; prioritize conflicted v.\nR_MOVE_REMOVE_COLOR:Implement remove_color(solution, c_max): iterate vertices with color c_max in descending degree order, assign feasible colors minimizing added conflicts; abort if infeasible, else decrement k.\nR_EVAL_LEX:Return tuple (conflicts, k) with custom comparator in metaheuristic; if float required, use fitness=conflicts*W+k with W large but within numeric stability (e.g., W=1e6).\nR_DELTA_CACHE:Maintain color_of[v], conflicts_of[v], and for each v, count conflicts per color to enable O(1) delta for recolor; update neighbors incrementally after a move.\nR_INIT_DSATUR:Build initial solution using DSATUR ordering to get low k baseline; often reaches k=3 on this graph quickly.\nR_PARAMETER_TUNING:For SA, schedule T0 based on initial delta stats; for ILS, perturb strength ~ 2\u20134 Kempe chains; for Tabu, tenure ~ [5,10] with aspiration based on best improvement.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels must be contiguous 1..k","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: minimize k with penalties for violations and non-contiguous labels.\n    # Lower is better.\n    HARD_PEN = 10**9\n    GAP_PEN = 10**5\n    EDGE_PEN = 10**4\n    # Validate type\/length\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Validate values\n    try:\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n    # Graph edges embedded locally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Base objective: k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: colors must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += GAP_PEN\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += GAP_PEN\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += EDGE_PEN * conflicts\n    return float(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator.\n    Returns a tuple (NB_Type, Movement_Type) as required.\n    Side-effect: mutates the provided solution list to a neighbouring solution.\n    Movement types implemented:\n      - (\"Recolor\", \"SingleVertex\"): change color of one vertex to an existing or new color\n      - (\"SwapColors\", \"Global\"): swap two color labels globally to encourage contiguity exploration\n    \"\"\"\n    # Validate basic structure defensively; if invalid, do nothing and declare a no-op recolor\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        try:\n            if int(x) != x or x < 1:\n                return (\"Recolor\", \"SingleVertex\")\n        except Exception:\n            return (\"Recolor\", \"SingleVertex\")\n    # Choose movement\n    move_roll = random.random()\n    if move_roll < 0.7:\n        # Single-vertex recolor\n        idx = random.randrange(9)\n        current_k = 0\n        for x in solution:\n            if x > current_k:\n                current_k = x\n        # candidate colors: 1..current_k (+ maybe current_k+1 to allow new color introduction)\n        allow_new = True\n        candidates = list(range(1, current_k + 1 + (1 if allow_new else 0)))\n        if solution[idx] in candidates:\n            candidates.remove(solution[idx])\n        if not candidates:\n            return (\"Recolor\", \"SingleVertex\")\n        new_color = random.choice(candidates)\n        solution[idx] = new_color\n        return (\"Recolor\", \"SingleVertex\")\n    else:\n        # Global swap of two colors\n        colors = sorted(set(int(x) for x in solution))\n        if len(colors) < 2:\n            return (\"SwapColors\", \"Global\")\n        a, b = random.sample(colors, 2)\n        if a == b:\n            return (\"SwapColors\", \"Global\")\n        for i in range(len(solution)):\n            if solution[i] == a:\n                solution[i] = b\n            elif solution[i] == b:\n                solution[i] = a\n        return (\"SwapColors\", \"Global\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed copy of the given solution by applying multiple random recolors\n    and occasional global color swaps. Does not modify the input list.\n    \"\"\"\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-length vector if malformed\n        sol = [1 + (i % 3) for i in range(9)]\n    else:\n        sol = [int(x) if int(x) == x and x >= 1 else 1 for x in solution]\n    res = sol[:]\n    # Determine number of perturbation steps\n    steps = 5 + random.randrange(6)  # 5..10\n    for _ in range(steps):\n        roll = random.random()\n        if roll < 0.75:\n            # recolor one vertex\n            idx = random.randrange(9)\n            k = 0\n            for x in res:\n                if x > k:\n                    k = x\n            candidates = list(range(1, k + 2))  # allow introducing k+1\n            if res[idx] in candidates:\n                candidates.remove(res[idx])\n            if candidates:\n                res[idx] = random.choice(candidates)\n        else:\n            # swap two colors globally\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for i in range(9):\n                    if res[i] == a:\n                        res[i] = b\n                    elif res[i] == b:\n                        res[i] = a\n    return res\n","SAMPLE_SOL":[1,2,3,1,2,3,2,1,3]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels are maintained contiguous 1..k via canonical relabeling after each move.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-critique\"\n\"FEEDBACK\":\"E_IFACE_MISMATCH:TARGET_HEURISTIC_GENERAL_SIGNATURE not respected by SA\/ILS\/TS implementations. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure all heuristics return (best_solution,best_score,meta) consistently.;E_TS_SIGNATURE:Tabu Search signature deviates and uses parentheses on callables in signature string. Fix to accept function objects, add params via other_params dict, and remove extra positional args to avoid unpacking errors.;E_ILS_RET_SHAPE:Iterated_Local_Search returning ('Kempe', 1e12, solution, 3.0) indicates tuple ordering\/type bug. Enforce return of (best_solution,best_score,meta).;E_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Implement def perturb_solution(solution, intensity, rng) with no I\/O and ensure compatibility with Heuristic signature.;E_CANONICAL_RELABEL_SIDE_EFFECTS:Canonical relabeling is applied in-place after every neighbor move, breaking move memory and acceptance consistency. Restrict canonicalization to evaluation or create a canonicalized copy for evaluation only; keep search state stable to preserve move semantics.;NB_REMOVE_COLOR_ROLLBACK_BUG:RemoveColor greedy repair mutates several vertices and on failure only relabels rather than reverting to the pre-move state. This corrupts state and can increase conflicts silently. Fix by copying solution before attempt or storing changed vertices and reverting on failure.;NB_REMOVE_COLOR_GREEDY_WEAK:Greedy reassignment with simple least-conflict and degree ordering often fails to eliminate a color. Add backtracking with limited depth, try DSATUR order on target-color vertices, and allow temporary two-color Kempe repairs to complete elimination.;NB_KEMPE_UNGUIDED:Kempe chain swap applied without checking conflict delta may worsen fitness. Compute delta conflicts and accept only if non-worsening under annealing criteria; otherwise reject.;NB_TIE_BREAKING_BIAS:least_conflict_color lacks randomized tie-breaking among equal minima, causing search stagnation. Add random tie-break to diversify.;NB_INTRODUCE_NEW_COLOR:Allowing k+1 introduction when conflicts>0 increases k and harms objective with huge W not helping. Disable new color introduction or gate it only under perturbation; keep recolor within 1..k unless performing explicit diversification.;NB_CONFLICT_SELECTION:Selecting a random conflicted vertex ignores conflict severity. Use max-conflict or stochastic-greedy selection (e.g., sample top-p by conflict count) to intensify.;E_DELTA_EVAL_ABSENT:total conflict recomputation implicit across moves is O(m) per probe. Implement incremental delta evaluation for recolor and Kempe by counting neighbor color frequencies to reduce to O(deg(v)) or O(size(component)).;E_WEIGHT_SCALE:W=1e6 and HARD_PEN=1e12 produce large floats. Use integers to avoid float precision and make comparisons exact. fitness = conflicts*W + k using ints.;E_CANONICAL_ORDER_NONSTABLE:First-occurrence canonical relabeling depends on current array order and can oscillate across equivalent states, confusing Tabu hashing. Use stable canonicalization with sorted unique colors mapping by value or maintain a persistent mapping across steps.;REP_BOUNDING:Representation allows arbitrary ints then canonically mapped. Add hard constraint to cap colors at some Kmax during neighbor generation to avoid unbounded growth.;INIT_CONSTRUCTION_WEAK:No constructive heuristic provided. Seed with DSATUR or greedy coloring to reach k<=3 quickly, reducing search burn-in.;SEARCH_POLICY:No temperature\/acceptance or restart policy described for ILS\/SA. For SA, schedule cooling geometric with reheats on plateau; for ILS, define perturbation intensity adaptive to last improvement gap.;TABU_MEMORY_DEF:No tabu attributes defined. Use short-term tabu on (vertex,color) with aspiration on better score; store tenure dynamically based on conflicts or iteration.;STOP_CRITERIA:Missing deterministic stopping metrics. Add max_evals, max_no_improve, and time budget to ensure reproducibility and fairness.;NB_API_CONTRACT:generate_neighbour mutates in-place but does not return post-move delta or success flag. Return (move_type, success, delta_conflicts, delta_k) to enable efficient acceptance and rollback.;RANDOM_SEED:No RNG seeding control. Pass rng instance via other_params to ensure reproducibility and avoid global random calls.;KNOWN_SOLUTION_USE:Known optimal k=3 available but unused. Add bounding: if conflict-free and k>3 then trigger focused color-elimination; if k<=3 and conflict-free, stop.;E_EVAL_CANONICAL_DUP:evaluate_solution canonicalizes; neighbor also canonicalizes. Double work. Remove canonicalization from neighbor or from evaluate; keep exactly one.;NB_LOCAL_OPT_ESCAPE:Current perturbation absent and Kempe often insufficient. Add multi-vertex kick: random multi-color merge attempt followed by greedy repair; or random vertex recolor with temporary tabu.;E_RESULT_VALIDATION:Reported SA\/ILS results list inconsistent structures and scores. Add validation layer that asserts evaluate(best_solution)==best_score and zero conflicts if best_score<=k_max.;E_LOGGING_MINIMAL:No move acceptance or reason tracking. Log counts of move types, acceptance rates, and color-elimination attempts to diagnose stagnation.;IMPL_SAFETY:Ensure all components avoid filesystem\/network\/os access per constraints and maintain pure in-memory operations only.;SUGGESTED_FIX_ORDER:1) Fix interface\/signature\/returns; 2) Implement robust rollback in RemoveColor and delta-eval; 3) Add DSATUR init and perturb_solution; 4) Gate canonicalization; 5) Add tabu memory and acceptance control; 6) Add validation and deterministic stopping.;EXPECTED_GAIN:With DSATUR init, guided recolor, Kempe with acceptance checks, and correct RemoveColor, convergence to k=3 conflict-free expected rapidly; tabu\/ILS then become reliable across runs.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels are maintained contiguous 1..k via canonical relabeling after each move.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return float(HARD_PEN)\n        if x < 1:\n            return float(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in first-occurrence order\n    def canonical_relabel(sol):\n        mapping = {}\n        next_c = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            res.append(mapping[c])\n        return res\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return float(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color\n    Always applies canonical relabeling after a successful move to keep labels contiguous.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # BFS on subgraph induced by colors {c1,c2}\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        # swap colors on visited set\n        changed = False\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n                changed = True\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n                changed = True\n        return changed\n    # Build conflict set\n    conflicted = []\n    for v in range(1,10):\n        if conflicts_of_vertex(solution, v) > 0:\n            conflicted.append(v)\n    k = max(solution)\n    move_roll = random.random()\n    # Try RemoveColor occasionally when no conflicts (intensification)\n    if not conflicted and move_roll < 0.3 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # attempt greedy reassignment\n        feasible = True\n        for v in sorted(verts, key=lambda x: -len(adj[x])):\n            colors = list(range(1, target))\n            new_c, add = least_conflict_color(solution, v, colors)\n            if new_c is None or any(solution[nb-1] == new_c for nb in adj[v]):\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            canonical_relabel_inplace(solution)\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # if failed, revert by relabeling to maintain contiguity (no destructive tracking needed)\n        canonical_relabel_inplace(solution)\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        v = random.choice(conflicted)\n        colors = list(range(1, k+1))\n        new_c, add = least_conflict_color(solution, v, colors)\n        # with small probability, allow introducing k+1 if it strictly reduces conflicts at v\n        introduce_new = False\n        if (new_c is None or add > 0) and random.random() < 0.1:\n            introduce_new = True\n        if introduce_new:\n            solution[v-1] = k+1\n        elif new_c is not None:\n            solution[v-1] = new_c\n        # else leave as is\n        canonical_relabel_inplace(solution)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain move for diversification or when conflict-free but stuck on higher k\n    # Choose a vertex and a different color\n    v = random.randrange(1,10)\n    # pick a candidate color among existing colors different from current\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            kempe_chain_swap(solution, v, c2)\n            canonical_relabel_inplace(solution)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to a random existing color\n    idx = random.randrange(9)\n    choices = [c for c in range(1, k+1) if c != solution[idx]]\n    if choices:\n        solution[idx] = random.choice(choices)\n    canonical_relabel_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple conflict-guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        # build conflict list\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            # recolor a conflicted vertex with least-conflict color; occasionally allow new color\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, add = least_conflict_color(res, v, colors)\n            if (new_c is None or add > 0) and random.random() < 0.15:\n                res[v-1] = k+1\n            elif new_c is not None:\n                res[v-1] = new_c\n        else:\n            # Kempe chain diversification\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n        # keep labels contiguous\n        canonical_relabel_inplace(res)\n    return res\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS: solution[i-1] in {1..k} for vertex i; contiguous labels enforced by evaluation canonical relabeling.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_REP_CANON_GAPS:Evaluation canonicalizes but neighbour ops use raw labels; gaps can arise. Enforce canonical relabel after each accepted move to keep k accurate for operators.\"\n\"E_REMOVE_TARGET_EMPTY:RemoveColor selects target=max(solution); with gapped labels target may not exist, returning success with no k reduction. Add guard: if count(color==target)==0 then skip; only return success if max(solution) actually decreases.\"\n\"NB_KMAX_DEAD:Kmax=max(4,k) but recolor uses colors=1..min(Kmax,k)=1..k; never introduces new colors, making Kmax irrelevant. Remove Kmax or allow temporary k+1 during conflict-reduction phases.\"\n\"NB_KEMPE_OBJECTIVE_MISMATCH:Kempe swap judged only by edge-conflicts; ignores k. Prefer criterion: accept swaps that do not increase fitness (conflicts*W+k), and prioritize swaps that reduce color class size of max color to enable k-1.\"\n\"NB_RECOLOR_GREEDY_STAGNATION:Least-conflict recolor forbids staying in place and may accept worsening moves without temperature\/acceptance logic. Add no-worsen filter or integrate acceptance from SA; break ties with saturation-degree to improve guidance.\"\n\"NB_GREEDY_REPAIR_INCOMPLETE:RemoveColor fails on first infeasible vertex then full rollback; misses feasible reorderings. Use randomized multi-order attempts, backtracking limited-depth, or min-conflicts with tabu on recent assignments.\"\n\"NB_CONFLICT_SELECTION_COARSE:Top-band selection v with conflicts in [max,max-1] can oscillate. Use argmax conflicts with aspiration and aging, or break ties by higher degree\/saturation.\"\n\"E_EVAL_COST_OM:evaluate_solution recomputes all conflicts O(m) each call. Maintain per-vertex conflict counts and update in O(deg(v)) per move; use cached k and color class sizes to compute fitness delta.\"\n\"E_EVAL_STATIC_W:Static W=1e6 may be mis-scaled across neighborhoods. Use adaptive penalty (e.g., increase W when conflicts persist, decrease when zero) or two-phase search: fix k and minimize conflicts, then decrement k.\"\n\"STATE_HASHING_INCONSISTENT:Tabu\/visited sets on raw labeling will treat isomorphic colorings as different. Store canonicalized solution as key for memory and equality checks.\"\n\"RNG_SEED_MISSING:Lack of seed control impedes reproducibility. Add seed parameter in other_params and seed local RNG.\"\n\"INIT_CONSTRUCTIVE_MISSING:No high-quality initializer. Add DSATUR\/Greedy with repair to start near k=3, then local search to refine.\"\n\"PERTURB_MISSING:$Perturb placeholder; no implementation. Provide perturb_solution implementing e.g., k-color shake (random Kempe swaps, ejection chains) with strength adaptive to stagnation.\"\n\"ALG_TABU_SIGNATURE_ERROR:Tabu Search signature incompatible; runtime failure. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE and pass functions as callables, not evaluated results.\"\n\"ALG_FUNC_ARG_PASSING_ERROR:Code shows generate_neighbour() and evaluate_solution() called in signature, causing unpack errors and loss of function references. Pass generate_neighbour and evaluate_solution without parentheses.\"\n\"ACCEPTANCE_AND_PHASE_CONTROL_WEAK:ILS returned penalty 1e12, indicating failure to enforce feasibility before intensification. Enforce feasibility-first phase per k; only update best when conflicts==0.\"\n\"OBJ_DRIVE_K_REDUCTION_WEAK:No explicit k-reduction schedule. Implement systematic descent: for k from current down to 3, run intensive conflict-minimization with restarts; only attempt k-1 upon zero conflicts.\"\n\"MOVE_DIVERSIFICATION_THIN:Limited diversification beyond Kempe. Add color-class swap, path-relinking between elite solutions, and breakout moves that allow bounded conflict increases with subsequent repair.\"\n\"TERMINATION_CRITERIA_UNCLEAR:No explicit iteration\/plateau budgets. Define max_iters, max_no_improve, and restart thresholds; log fitness to trigger perturbation.\"\n\"VERIF_LOGGING_MISSING:No instrumentation to detect operator efficacy. Track move type -> delta fitness and adapt move probabilities (roulette wheel) to favor productive neighborhoods.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_CONTIGUOUS: solution[i-1] in {1..k} for vertex i; contiguous labels enforced by evaluation canonical relabeling.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors if non-worsening on edge conflicts\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with rollback on failure\n    Canonical relabeling is NOT applied here to preserve move semantics; evaluation will canonicalize.\n    Colors are capped to Kmax to prevent unbounded growth.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonworsen(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # component in subgraph induced by colors {c1,c2}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = total_conflicts(sol)\n        # apply swap on a copy to test\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = total_conflicts(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    Kmax = max(4, k)  # hard cap; we avoid introducing new colors in neighbour\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # order by degree descending (DSATUR-like on subproblem)\n        order = sorted(verts, key=lambda x: -len(adj[x]))\n        original = solution[:]\n        feasible = True\n        for v in order:\n            # try colors 1..target-1 by least-conflict with randomized ties, but ensure feasibility\n            new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n            # ensure no conflict after assignment\n            ok = True\n            for nb in adj[v]:\n                if solution[nb-1] == new_c:\n                    ok = False\n                    break\n            if not ok:\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # rollback on failure\n        for i in range(9):\n            solution[i] = original[i]\n        # fall through to other moves\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.7:\n        # pick a vertex among the top-conflict ones (stochastic greedy)\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c >= max_cf - 1]  # top band\n        v = random.choice(top)\n        colors = list(range(1, min(Kmax, k) + 1))  # restrict within existing colors\n        new_c, _ = least_conflict_color(solution, v, colors)\n        solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonworsen(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_CANON_BY_EVAL: solution is a list of 9 positive integers; vertex i uses solution[i-1]. Evaluation canonically relabels colors to 1..k to enforce contiguity.","Componente":null,"Version":3,"Feedback":"COMPONENT_VERSION: 1.0\nFEEDBACK: \nE_EVAL_COST:O(|E|)=17 per call. Implement incremental delta-evaluation (track per-vertex conflict counts and k) to reduce neighbor assessment to O(deg(v)) and O(1) k-updates.\nE_EVAL_CANON:Canonical relabeling on every evaluation breaks locality and adds overhead. Cache color-contiguity and only relabel when k decreases or non-contiguity is detected.\nE_EVAL_HARDPEN:Single HARD_PEN for all structural errors hides diagnostics. Add distinct penalties per failure mode (non-list, wrong length, non-int, <1) to enable faster debugging.\nNB_FITNESS_DUP:Neighbour uses an internal proxy fitness with hardcoded W=1e6. Risk of drift if evaluator constants change. Remove duplication; pass evaluate_solution and compute deltas, or centralize W in other_params.\nNB_K_EQ_1_STALL:With k=1 and conflicts, least_conflict_color returns cur and all paths are no-ops. Allow temporary color introduction (k+1) under conflict pressure to escape deadlocks; later reduce k via RemoveColor\/Kempe.\nNB_REMOVE_COLOR_WEAK:RemoveColor gated by p=0.25 only when conflict-free; often misses k-reduction opportunities. Trigger deterministically whenever conflict-free, and retry multiple greedy\/Kempe attempts before fallback.\nNB_REMOVE_COLOR_LOCAL:Repair checks only immediate neighbor feasibility per recolor; ordering can cause dead-end. Use DSATUR order (highest saturation, then degree) and backtracking with small beam width to improve success rate.\nNB_KEMPE_NONWORSENING:Kempe swaps restricted to non-worsening kills diversification. Allow neutral\/worsening swaps; delegate acceptance to the metaheuristic (SA\/ILS). Provide move metadata to inform Tabu.\nNB_MOVE_SCOPE:Recolor only considers existing colors; misses beneficial within-k recolors that enable subsequent color elimination. Add targeted recolors of vertices colored with max color to minimize its footprint.\nNB_CONFLICT_SELECTION:Ties on max-conflict vertex are random; can thrash. Break ties by higher degree or higher saturation to increase descent efficacy.\nNB_RETURN_META:generate_neighbour mutates in place and returns (\"NB_Type\",\"Movement_Type\") only. If Tabu\/SA expect the moved attributes, also return minimal move delta (e.g., (v, old_c, new_c) or (KempeSet, c1, c2)) to support tabu features and delta evaluation.\nAPI_SIG_MISMATCH_TS:Tabu Search signature incompatible. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove extra positional params and pass taboo sizes via other_params.\nTS_UNPACK_ERROR:Error \"too many values to unpack (expected 2)\" indicates mismatch with generate_neighbour\u2019s return and\/or mutation semantics. Do not expect a new solution returned; operate on a copy, call generate_neighbour(copy), then evaluate_solution(copy).\nTS_TABU_FEATURE:Current Tabu lacks a well-defined move attribute. Use attribute-based tabu: forbid (vertex, new_color) for tenure t, add aspiration if fitness improves best_score. Track tenure and aspiration in other_params.\nPERTURB_MISSING:$Perturb undefined. Implement a robust perturbation: multi-vertex Kempe chain with random color pair; random walk of length L capped by conflict budget; color split\/merge focused on max color to promote k reduction.\nINIT_CONSTRUCT:No constructive initializer specified. Add DSATUR or greedy coloring initializer that targets k=3 quickly to reduce search time and improve convergence.\nOBJ_SCALING:W=1e6 is overkill; large but unnecessary. Use W=|E|+1 (=18) to ensure any conflict dominates k yet keeps numbers small; guarantees lexicographic preference without overflow risk and speeds arithmetic.\nRANDOM_CONTROL:No seeding control; experiments irreproducible. Add seed input via other_params and propagate to random for deterministic runs when needed.\nSTOP_CRITERIA:Unspecified termination. Add budget-based stopping (evals\/time) plus stagnation criteria (no improvement for T iterations) to prevent wasted computation.\nK_REDUCTION_PHASE:No explicit k-phase strategy. Alternate phases: (1) minimize conflicts at fixed k, (2) invoke RemoveColor\/Kempe focused on eliminating color k, repeat until failure, then perturb.\nLOCAL_OPT_ESCAPE:Only Kempe as diversification is weak. Add path-relinking between elite solutions or ejection chains targeting vertices of max color to escape plateaus.\nVALIDATION_GUARDS:generate_neighbour silently no-ops on invalid states. Add counters to detect and penalize consecutive no-ops; trigger perturbation when threshold exceeded.\nRESULTS_DIAG:TS failed to run; SA\/ILS outputs not normalized. Log iterations, best_score trajectory, k timeline, and conflict counts to diagnose convergence and operator efficacy.\nKNOWN_SOLUTION_USE:Known 3-coloring provided; bake a feasibility check to early-stop when fitness==3 and return immediately, avoiding unnecessary search.","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_CONTIGUOUS_CANON_BY_EVAL: solution is a list of 9 positive integers; vertex i uses solution[i-1]. Evaluation canonically relabels colors to 1..k to enforce contiguity.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange accepted if non-worsening on (conflicts*W + k)\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with guarded repair; rollback on failure\n    Canonical relabeling is NOT applied here; evaluation will canonicalize. Operators avoid introducing new colors.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def fitness_pair(sol):\n        # proxy for evaluate: conflicts*W + k, W large\n        W = 10**6\n        return total_conflicts(sol) * W + max(sol)\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonnw(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = fitness_pair(sol)\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = fitness_pair(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = max(solution)\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if len(verts) > 0:\n            order = sorted(verts, key=lambda x: (-len(adj[x]), x))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                # try colors 1..target-1 by least-conflict with randomized ties, ensure feasibility locally\n                new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n                ok = True\n                for nb in adj[v]:\n                    if solution[nb-1] == new_c:\n                        ok = False\n                        break\n                if not ok:\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback on failure or no k decrease\n            for i in range(9):\n                solution[i] = original[i]\n        # fall through\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c == max_cf]\n        v = random.choice(top)\n        colors = list(range(1, k+1))\n        new_c, new_cost = least_conflict_color(solution, v, colors)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonnw(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 5 + random.randrange(4)  # 5..8\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","SAMPLE_SOL":"[3,2,1,3,2,1,2,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Componente":null,"Version":4,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_PALETTE_CHECK_LOGIC:Condition to introduce k+1 is incorrect. 'all(solution[nb-1] != c for c in palette for nb in adj[v])' is almost always False. Use 'if set(palette).issubset({solution[nb-1] for nb in adj[v]}): palette.append(k+1)'.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_INTRO_NEW_COLOR:Recolor path rarely expands palette, blocking escape from local minima. Fix via subset test or compute conflict-free colors and only append k+1 when none available.\"\n\"FEEDBACK\",\"NB_API_CONTRACT_VIOLATION:generate_neighbour mutates in-place but returns only metadata. If the heuristic driver expects an immutable neighbor, side-effects corrupt 'currentSolution'. Return the modified solution or ensure the caller copies before call.\"\n\"FEEDBACK\",\"ILS_OUTPUT_PACKING_ERROR:Iterated_Local_Search returns ('Kempe', 1000000000001, ...), causing evaluate_solution to receive a non-list (HARD_NONLIST). Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE and return (best_solution, best_score) only.\"\n\"FEEDBACK\",\"TS_SIGNATURE_MISMATCH:Taboo_Search signature deviates from TARGET_HEURISTIC_GENERAL_SIGNATURE, leading to 'too many values to unpack'. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"FEEDBACK\",\"PERTURB_MISSING:'Perturbation Function' is undefined ($Perturb). Provide a valid perturbation preserving representation (e.g., Kempe chain on random color pair, or random recolor of a small subset) to enable ILS\/TS escapes.\"\n\"FEEDBACK\",\"NB_REMOVE_COLOR_FRAGILE:RemoveColor fails if any vertex reassignment conflicts mid-process; no backtracking. Use sequence planning (order by DSATUR or try small Kempe swaps) or attempt multi-start greedy repair with rollback per vertex.\"\n\"FEEDBACK\",\"NB_UNUSED_CODE:total_conflicts() is defined but unused. Remove to reduce overhead and ambiguity.\"\n\"FEEDBACK\",\"NB_DETERMINISM:Randomness is uncontrolled. Add RNG seed in other_params or expose rng to ensure reproducibility for evaluation.\"\n\"FEEDBACK\",\"E_EDGE_REBUILD:Edges\/adjacency recomputed in both evaluate_solution and generate_neighbour. Extract constants outside hot loops or cache adjacency to reduce repeated O(|E|) setup.\"\n\"FEEDBACK\",\"E_CANONICAL_RELABEL_EARLY:Canonical relabeling occurs every evaluation. Pre-canonicalize in neighbor operations or only when k may change to cut overhead in tight loops.\"\n\"FEEDBACK\",\"REP_INIT_WEAK:No constructive initializer. Start from DSATUR\/greedy coloring to reach k\u22483 quickly, reducing search time and conflicts.\"\n\"FEEDBACK\",\"MOVE_SET_LIMITED:Only single-vertex recolor, Kempe swap, and RemoveColor. Add color-merge attempts and 1-walk\/2-walk moves to target specific conflicts and reduce k more reliably.\"\n\"FEEDBACK\",\"ACCEPTANCE_POLICY_UNSPECIFIED:Simulated Annealing\/ILS acceptance not shown; ensure fitness strictly prioritized (conflicts first, then k). For SA, temperature schedule should avoid accepting moves that increase conflicts once conflict-free.\"\n\"FEEDBACK\",\"STOPPING_CRITERIA:No convergence checks on stable k=3 states. Add stagnation and no-improvement counters to trigger perturbation or terminate early.\"\n\"FEEDBACK\",\"E_DIAGNOSTICS:Operator return values ('Operator','MovementType') are unused by drivers and leaked into ILS result. Standardize driver to ignore metadata or wrap it in logs only; never propagate to solution pipeline.\"\n\"FEEDBACK\",\"NB_VERTEX_SELECTION:Conflicted vertex tie-break uses degree only. Prefer DSATUR or conflict-weighted degree to prioritize high-impact recolors.\"\n\"FEEDBACK\",\"NB_LEAST_CONFLICT_TIE:Random tie-breaking increases variance. Add secondary criterion (preferring lowest used color) to bias toward k reduction.\"\n\"FEEDBACK\",\"REPAIR_AFTER_KEMPE:Kempe may increase conflicts transiently. Follow each Kempe with a bounded greedy repair on affected subgraph to prevent fitness spikes.\"\n\"FEEDBACK\",\"CONSTRAINT_ENFORCEMENT:Evaluation handles canonicalization and hard penalties, but neighbor ops assume valid ints. Add defensive clamp to keep colors >=1 and <=k+1 post-ops.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): least-conflict recolor; may introduce k+1 if stuck.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free.\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return True\n    # Build state\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # Attempt deterministic RemoveColor if conflict-free\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            order = sorted(verts, key=lambda v: (-len(set(solution[nb-1] for nb in adj[v])), -len(adj[v]), v))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                new_c, _ = least_conflict_color(solution, v, palette)\n                if any(solution[nb-1] == new_c for nb in adj[v]):\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through if failed\n    # Conflict-guided recolor primary\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # choose vertex by highest conflict then degree\n        cf = [(v, vertex_conflicts(solution, v), len(adj[v])) for v in conflicted]\n        best_cf = max(cf, key=lambda t: (t[1], t[2]))[1]\n        cand = [v for v,c,deg in cf if c == best_cf]\n        v = random.choice(cand)\n        palette = list(range(1, k+1))\n        # allow introducing new color if k==1 or no improvement possible\n        if k == 1 or all(solution[nb-1] != c for c in palette for nb in adj[v]):\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            applied = kempe_chain_swap(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor within current palette\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if not choices:\n        choices = [1]\n    solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Input is not modified.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        conflicted = [v for v in range(1,10) if vertex_conflicts(res, v) > 0]\n        roll = random.random()\n        if roll < 0.55:\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                # focus on max color to promote k reduction\n                maxc = max(res)\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            palette = list(range(1, k+1))\n            if k == 1 and conflicted:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = new_c\n        else:\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","SAMPLE_SOL":"[1,3,2,3,1,2,3,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Componente":null,"Version":5,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_API_SIG_MISMATCH:Heuristic and TS expect inconsistent signatures\/returns. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and ensure generate_neighbour returns only a modified solution or (solution,meta); update TS to not unpack two values from generate_neighbour unless designed. \nE_TS_INTERFACE:Tabu Search error 'too many values to unpack' indicates it expects single return. Standardize generate_neighbour to return solution only; log metadata separately. \nE_INPLACE_MUTATION:generate_neighbour mutates in place, breaking SA\/ILS that may cache or compare previous states. Return a new copy; avoid side-effects to preserve acceptance criteria. \nE_META_LEAK:Results show ('Kempe', 1000000000001, ...) meaning algorithm mixed metadata and solution\/score order. Enforce strict tuple protocol: always (solution, score) and log operator separately. \nE_PERTURB_MISSING:Perturbation function undefined ($Perturb). Implement def perturb_solution(sol, intensity, rng): perform k-preserving Kempe cycles, vertex recolor shuffles, or double-bridge on color classes; must return a valid list and avoid filesystem\/network\/OS. \nE_KEMPE_COLOR_INFLATION:local_repair may introduce k+1 during Kempe, inflating palette and harming objective. Restrict repair to colors \u2264 current k; only allow k+1 in conflict-resolution phase when needed and guided by evaluation. \nE_REMOVE_COLOR_GREEDY_FAIL:RemoveColor uses single-pass greedy reassignment; rollback on first failure limits success. Add small backtracking\/beam (width=2\u20133) or retry with randomized DSATUR order; couple with targeted Kempe moves on vertices in max color class before retry. \nE_ADJ_RECOMPUTE_OVERHEAD:Adjacency rebuilt each call. Precompute adj and reuse; reduce per-neighbor cost from O(m) setup to O(1) setup + O(deg) ops. \nE_CANONICAL_GAP:Neighbour logic assumes contiguous 1..k via max(solution). If gaps exist (post-perturb), k is overstated. Compress colors at start of generate_neighbour to canonical labels before moves. \nE_CONFLICT_WEIGHT_TUNING:W=len(E)+1=18 is acceptable but rigid. Consider adaptive W >> k_max (e.g., 100) to further isolate feasibility vs k trade-offs during stochastic phases. \nE_DSAR_TIEBREAK:DSATUR proxy ties broken by randomness only; can oscillate. Add deterministic tiebreak on degree then vertex id to stabilize, or incorporate conflict delta lookahead. \nE_MOVE_DIVERSIFICATION:Kempe selection picks random vertex\/color; low impact. Bias selection to vertices in highest conflict or in max color class; try multiple candidate c2 and accept the best delta. \nE_ACCEPTANCE_POLICY:Ensure SA\/ILS evaluate neighbour deltas not absolute re-evaluations where possible; cache conflicts and k to compute O(deg) deltas for performance. \nE_REPRODUCIBILITY:random used without rng injection. Pass rng object from other_params and avoid global random for deterministic runs. \nE_CONSTRAINT_ENFORCEMENT:Evaluation enforces list\/int\/\u22651 via hard penalties, but heuristics should pre-validate and repair before calling evaluate to avoid wasting iterations on HARD_* states. \nR_PERTURB_SPEC:Implement k-preserving perturbation: (1) multi-Kempe chains on random color pairs; (2) shuffle of a random subset S (size 2\u20134) using greedy recolor within \u2264k; (3) double-bridge on color classes followed by local repair. \nR_INTERFACE_STD:Define generate_neighbour to return (new_solution, meta) where meta={'op':..., 'move':...}; ensure all algorithms handle this dict or ignore it; never conflate with solution\/score. \nR_COLOR_ELIM_PHASE:Add explicit elimination phase when conflict-free: repeatedly attempt RemoveColor with iterative deepening (max retries r, random orderings), interleaving Kempe moves targeted at max color class. \nR_LOCAL_REPAIR_POLICY:During repair prefer smallest non-neighbor color; if none, attempt single Kempe on conflicting neighbor pair before introducing new color. \nR_CACHE_STRUCTS:Precompute edges, adj, degree, and reuse across calls via closures or other_params to minimize overhead. \nR_VALIDATION_HOOK:Add assert-like fast checks: length==9, ints>=1, and canonical relabel inside neighbour\/perturb to keep solutions evaluable and reduce HARD_* penalties. \nR_TABU_FIX:Tabu Search signature must accept function objects not calls; store tabu on moves keyed by (vertex, old_color, new_color) or color-pair for Kempe; update to work with meta returned by generate_neighbour. \nR_STOP_CRITERIA:Add stagnation counters and adaptive perturb intensity; escalate perturbation when no improvement for t iterations to escape local minima. \nR_EVAL_DELTA:Provide delta_evaluate(sol, move, cached_state) to avoid full evaluate_solution calls, improving throughput significantly on small graphs but scaling better for larger instances.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; introduces k+1 iff no conflict-free color exists.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with local repair.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free via safe reassignment with rollback.\n    Assumes 'solution' is a mutable list of length 9 with ints >=1; clamps outputs to >=1.\n    \"\"\"\n    # Validate minimal shape; if invalid, nothing done but metadata returned\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # Bias toward smaller colors to promote k reduction\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair(sol, touched):\n        # Greedy fix for any new conflicts on touched vertices\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            palette = list(range(1, kcur+1))\n            allowed = [c for c in palette if c not in neighbour_colors(sol, v)]\n            if not allowed:\n                palette.append(kcur+1)\n                cnew, _ = least_conflict_color(sol, v, palette)\n                sol[v-1] = max(1, cnew)\n            else:\n                sol[v-1] = min(allowed)\n    # State\n    k = max(solution)\n    # If conflict-free, attempt to remove max color deterministically\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # Order by DSATUR proxy: unique neighbor colors count, then degree desc\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                allowed = [c for c in palette if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through\n    # Main path: DSATUR-guided recolor with correct k+1 introduction\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # DSATUR-like selection: prioritize higher saturation, then more conflicts, then degree\n        sat = []\n        for v in conflicted:\n            sat.append((v, len({solution[nb-1] for nb in adj[v]}), vertex_conflicts(solution, v), len(adj[v])))\n        best_sat = max(sat, key=lambda t: (t[1], t[2], t[3]))[1:]\n        cand = [v for (v,s,cfg,deg) in sat if (s,cfg,deg) == best_sat]\n        v = random.choice(cand)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain for diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            if touched:\n                local_repair(solution, touched)\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: simple recolor within current palette, prefer smallest non-conflicting color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # allow new color if absolutely necessary\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        # With probability, try to recolor conflicted or max-color vertices\n        if random.random() < 0.6:\n            # target a conflicted vertex if any; else one with max color\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                maxc = k\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification between two existing colors\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","SAMPLE_SOL":"[3,1,2,1,3,2,1,1,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. Each index i in [0..8] corresponds to vertex i+1. Colors are positive integers; evaluation canonically relabels to contiguous {1..k}.","Componente":null,"Version":6,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\",\n\"FEEDBACK\":\"E_PERTURB_MISSING:Missing Perturbation Function. Provide explicit perturb_solution to escape local minima; implement Kempe-chain burst, random color merge (attempt remove max color), and ruin-recreate on 2-3 vertices with rollback guards.\nE_HEURISTIC_SIG_MISUSE:Ensure Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) passes function objects, not calls. Do not unpack generate_neighbour return as a new solution; it mutates in-place and returns metadata only.\nE_TS_API_FAIL:'Taboo_Search' crashed: too many values to unpack. Root cause: neighbor returns (Operator,MovementType) while TS likely expects (candidate,meta). Fix TS to copy candidate=list(current), call generate_neighbour(candidate), then evaluate_solution(candidate). Also fix signature usage to pass functions, not invoked parentheses.\nE_EVAL_PENALTY_INTEGRATION:best-as-lesser violated in ILS run; best_score=1000000000001 (HARD_NONLIST). Add hard guards: if score>=1e12 treat as invalid and discard. Never update best with HARD_* penalties.\nE_STATE_TYPE_SAFEGUARD:ILS produced ('Kempe',1000000000001,...); indicates evaluate_solution received a tuple\/non-list somewhere. Enforce solution invariants after every move: assert type(list), len=9, ints>=1, canonicalize before evaluation.\nNB_CODE_FAIL_LOCAL_OPT:Recolor operator can return current color (no change) when least_conflict_color returns cur with 1e9. Enforce non-null move: if no improving color, either allow k+1 or force Kempe\/diversification to avoid stagnation.\nNB_K_INFLATION_DRIFT:Branch allows palette.append(k+1) too readily. Constrain k+1 usage only if vertex_conflicts cannot decrease in {1..k}; add acceptance rule rejecting k increase unless conflicts strictly drop.\nNB_REMOVE_COLOR_TERMINATION:RemoveColor tries greedy then Kempe without success criterion. Add bounded attempt count and rollback if max(solution) not reduced; otherwise you risk oscillation with no net progress.\nNB_KEMPE_REPAIR_WEAK:local_repair_no_inflate resolves only touched vertices; residual conflicts may persist. Extend bounded repair radius: include first-layer neighbors of touched or run a short DSATUR repair pass limited to k colors.\nNB_DSATURE_ORDERING_BIAS:Sat-degree tiebreak uses -v. Replace with random tie-breaking to avoid search bias; seed-controlled randomness for reproducibility.\nR_CANONICAL_COST:Canonical relabel inside neighbor each step is O(n) and ok, but avoid repeated sorting by caching color\u2192rank map when no k change. Minor but reduces overhead.\nH_ANNEALING_CONTROL:SA likely accepted early 3-color solution without exploration. Define temperature schedule T0 auto-scaled by initial delta, geometric cooling alpha in [0.90,0.99], reheats on stagnation, and minimum T_min where only improving moves accepted.\nH_ACCEPTANCE_POLICY:For conflict>0, accept only if conflicts decrease or probabilistically via SA; for conflict==0, accept only if k decreases or neutral moves that maintain k with structural diversification (Kempe) bounded by tabu on color pairs.\nH_RESTARTS:Add multi-start DSATUR initialization with different vertex orders to diversify starting palettes; keep best across restarts.\nE_TABU_LIST_DEFICIENT:Tabu search params unclear. Use tabu on (vertex,color) or moved color-class pair for L=7-10 iterations with aspiration if a move yields strictly lower fitness; prevent storing null moves.\nE_EVAL_TIEBREAK:Fitness conflicts*(|E|+1)+k is sound. Ensure any comparator uses strict <; avoid <= which can let worse structural states overwrite equal-scored incumbents.\nR_MEMO_EVAL:Graph is static; precompute adjacency once and reuse across components to reduce per-move overhead; avoid reconstructing edges\/adj in every call.\nR_MOVE_INTENSIFICATION:Add targeted ejection chain: pick vertex of max conflicts, attempt sequence of recolors within 1..k to resolve a cycle; bound depth=3 to maintain speed.\nR_PERTURB_SPEC:Implement perturb_solution(mode,intensity): modes={'kempe_burst','color_merge','shuffle_subset'}; intensity controls number of vertices\/colors affected. Ensure returns None and mutates in-place; always re-canonicalize.\nTEST_GUARDRAILS:Add unit checks: after every operator, assert evaluate_solution(solution)<HARD_NONLIST and max(sol)==len(set(sol)) after canonicalization. Abort move otherwise and rollback to backup.\nREPRO_CTRL:Set random.seed(other_params.get('seed',42)) at Heuristic entry and allow per-iteration jitter seeds for diversification while preserving reproducibility.\nDATA_FLOW_COPY:Always work on candidate=curr[:] before neighbor to preserve incumbent for rollback; only commit on acceptance. Prevent aliasing bugs across SA\/ILS\/TS.\nSTOP_COND:Add dual criteria: max_iters and max_no_improve; log best_score trajectory for diagnosis. Use known optimum 3 to early-stop when k==3 and conflicts==0.\nRETURN_META:Heuristic should return (best_solution,best_score,last_solution,last_score) consistently across algorithms to avoid downstream unpack errors.\nKNOWN_SOLUTION_USE:Incorporate known solution as validation test; fail fast if algorithm returns score>3 after large budget, output diagnostics on move distribution.\nCOMPAT_RULES:Ensure no component accesses filesystem\/network\/os; keep all randomness internal; all functions pure w.r.t. external state except in-place mutation on solutions.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_INTS. Each index i in [0..8] corresponds to vertex i+1. Colors are positive integers; evaluation canonically relabels to contiguous {1..k}.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; allows k+1 only if no color fits.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with bounded local repair (no k increase).\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color with rollback.\n    Mutates 'solution' list in place as per required signature returning metadata only.\n    Safeguards: validates and canonicalizes solution to contiguous labels 1..k at entry.\n    \"\"\"\n    # Minimal validation and canonicalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonical relabel to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair_no_inflate(sol, touched):\n        # Attempt to resolve conflicts on touched set without increasing k\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            # Try smallest non-neighbor color within 1..kcur\n            allowed = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, v)]\n            if allowed:\n                sol[v-1] = min(allowed)\n            else:\n                # As last resort try recoloring one conflicting neighbor to any non-neighbor color <= kcur\n                for nb in adj[v]:\n                    if sol[nb-1] == sol[v-1]:\n                        alt = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, nb)]\n                        if alt:\n                            sol[nb-1] = min(alt)\n                            break\n        # leave unresolved if impossible without k inflation; evaluation will penalize\n    # State\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If conflict-free, try to remove highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # DSATUR-like order\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            backup = solution[:]\n            feasible = True\n            for v in order:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            if verts:\n                seed = random.choice(verts)\n                # Try swapping max color with a smaller color\n                smaller = [c for c in range(1, target)]\n                if smaller:\n                    c2 = random.choice(smaller)\n                    touched = kempe_chain_swap(solution, seed, c2)\n                    local_repair_no_inflate(solution, touched)\n                    return (\"Kempe\", \"ChainSwap\")\n    # Conflict-driven recolor majority branch\n    if conflicted and random.random() < 0.75:\n        # Pick vertex by (saturation, conflicts, degree, -id)\n        sat_data = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            sat_data.append((sat, cfg, deg, -v, v))\n        _,_,_,_,v = max(sat_data)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Diversification: Kempe chain between two existing colors\n    colors_now = sorted(set(solution))\n    if len(colors_now) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors_now if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            local_repair_no_inflate(solution, touched)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 8 + random.randrange(5)  # 8..12\n    for _ in range(steps):\n        k = max(res)\n        if random.random() < 0.6:\n            # target conflicted else vertex in max color class\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                cand = [i for i,c in enumerate(res, start=1) if c == k]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification within existing colors if possible\n            colors_now = sorted(set(res))\n            if len(colors_now) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors_now if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","SAMPLE_SOL":"[3,1,2,3,1,2,1,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Componente":null,"Version":7,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0-crit\"\n\"FEEDBACK\",\"E_IO_SAMPLE_SOL:Loader expects str with .strip(); provided list. Fix interface or wrap with json.dumps\/list->str before load.\nE_MISSING_COMPONENT:Perturbation function undefined ($Perturb). Provide concrete perturbation to enable ILS\/SA diversification.\nE_HEURISTIC_ABSENT:Main Heuristic(...) not provided. Implement orchestration (init, neighborhood search, acceptance, restart) per required signature.\nNB_CODE_FAIL_KPLUS1:Neighbor may introduce k+1 with only local v-conflict reduction; fitness penalizes k but may drift upward without global gain. Gate k+1 by global delta fitness or forbid when any conflict-free color exists.\nNB_CODE_CANON_COST:Frequent canonicalize() is O(n log n) via sorted(set). Replace with first-seen remap O(n): iterate solution, assign new labels as encountered.\nNB_CODE_DUP_GRAPH:Edges rebuilt in multiple functions. Centralize as immutable constant to avoid divergence and reduce overhead.\nNB_KEMPE_UNSAFE:Kempe swap returned without fitness check can increase conflicts. Enforce accept-if-improves or allow only under diversification flag.\nNB_VERTEX_SELECT_NO_TIES:Random tie-break adds noise; add deterministic secondary key (ID) to improve repeatability for debugging.\nNB_ROLLBACK_SCOPE:Rollback only for k+1 trial; other branches (Kempe, diversification) lack protective rollback. Snapshot and revert if fitness worsens unless in perturbation.\nNB_LOCAL_OPT_ESCAPE_WEAK:Only Kempe\/diversification single recolor. Add color class swap (swap all vertices of two colors) and multi-vertex greedy repair to escape plateaus.\nNB_CODE_FAIL_LOCAL_OPT:Operator too simple for elimination phase; add targeted recoloring of highest color via BFS ordering and backtracking if blocked.\nE_EVAL_NO_DELTA:Full recomputation O(|E|) per move. Provide delta-eval utilities: track affected edges of moved vertex to update conflicts in O(deg(v)).\nE_EVAL_WEIGHT_TUNING:W=|E|+1 ok, but neighbor uses vertex-level conflict checks; align acceptance on fitness (conflicts*W+k) to avoid objective mismatch.\nR_STR_INADEQUATE:Contiguous relabeling each step causes churn. Maintain internal canonical form invariant and avoid re-sorting at every move.\nINIT_POLICY_WEAK:No initializer specified. Use DSATUR\/greedy coloring to produce low-conflict, low-k start state.\nACCEPTANCE_RULE_MISSING:For SA\/ILS\/TS, define acceptance (Metropolis for SA, best-improving\/first-improving for ILS, tabu tenure for TS) aligned to fitness.\nTS_MEMORY_ABSENT:Add short-term tabu list on (vertex,color) assignments; aspiration for better global best.\nILS_PERTURB_DEFICIENT:Design k-preserving perturbations (Kempe with constrained colors) and k-reducing attempts; control strength by temperature\/iteration.\nNB_MOVE_DIVERSITY_LOW:Add: (1) move vertex to least-conflict color; (2) swap colors of two vertices; (3) recolor small induced subgraph of conflicted vertices; (4) merge-split of color classes for k reduction.\nSTOPPING_CRITERIA_UNDEFINED:Add max_iters, no_improve_limit, time cap, and early stop on fitness==k with zero conflicts.\nREPRODUCIBILITY_MISSING:Expose rng seed in other_params; thread through all random calls for determinism in tests.\nMETRICS_LOGGING_ABSENT:Track best_score, current_score, k, conflicts, move types; enable adaptive operator selection (e.g., probability weights by recent success).\nCONSTRAINT_ENFORCEMENT:Neighbor modifies in-place; ensure caller clones when needed. Document and enforce via tests to prevent unintended side-effects.\nERROR_HANDLING:When validation fails in neighbor, it returns default metadata but may leave solution invalid. Normalize to valid 1..k and verify postcondition.\nSCALABILITY:Adjacency recomputed per call. Precompute adj list once; pass via other_params to cut overhead.\nVALIDATION_TESTS_MISSING:Add unit tests: (1) evaluate_solution on edge cases (types\/length\/values), (2) neighbor preserves list,int,>=1 and canonical 1..k, (3) fitness monotonicity under conflicts change.\nCOLOR_ELIM_STRATEGY:Greedy elimination only tries min allowed; add small backtracking with limited depth or ILP check on subgraph induced by highest color to improve k reduction success.\nMOVE_SELECTION_POLICY:Use best-improving among sampled candidates (e.g., sample 10 conflicted vertices and test 1..k colors with delta-eval) instead of single try to reduce stagnation.\nSA_SCHEDULE_UNSPECIFIED:Define cooling (geometric or Lundy\u2013Mees) and temperature init via fitness variance over sampled neighbors to ensure effective exploration.\nPARAM_TUNING:Expose and tune probabilities for Kempe vs recolor vs elimination attempts; adapt based on stagnation and conflict rate.\nI\/O_CONTRACT:Document and fix API for SAMPLE_SOL ingestion (expect string JSON\/CSV). Provide serializer and parser shims to avoid 'strip' errors.\nKNOWN_SOL_VERIF:Add assert evaluate_solution(known)==3 in tests to guard regressions and to calibrate acceptance gates.\nCODE_STYLE_SAFETY:Ensure no filesystem\/network\/os access per constraints; keep pure functions. Extract constants and helpers to minimize side effects.\nACTIONABLE_FIX_ORDER:1) Implement Perturb + Heuristic + acceptance + stopping. 2) Add delta-eval + centralized graph. 3) Harden neighbor (rollback, k+1 gating, safer Kempe). 4) Fix SAMPLE_SOL loader. 5) Add tests and logging.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_INTS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator. Returns metadata (Operator, MovementType).\n    Safeguards:\n      - Validates and canonicalizes to contiguous 1..k at entry.\n      - Avoids null moves; rolls back if a tentative move increases k without reducing conflicts.\n      - Prefers conflict reduction; when conflict-free attempts color elimination (k reduction) with rollback.\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonicalize to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # tie-break randomly among minimal colors, with preference for smaller index\n        m = min(best_list)\n        candidates = [c for c in best_list if c == m]\n        return random.choice(candidates if candidates else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_order(vertices):\n        data = []\n        for v in vertices:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            deg = len(adj[v])\n            data.append((sat, deg, random.random(), v))\n        data.sort(reverse=True)\n        return [v for *_rest, v in data]\n    def canonicalize(sol):\n        cols = sorted(set(sol))\n        mp = {c:i+1 for i,c in enumerate(cols)}\n        for i in range(9):\n            sol[i] = mp[sol[i]]\n    # Current state\n    k = max(solution)\n    base_conf = conflicts_count(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If no conflicts, try to eliminate the highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            backup = solution[:]\n            success = True\n            for v in dsatur_order(verts):\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    success = False\n                    break\n            canonicalize(solution)\n            if success and max(solution) < target and conflicts_count(solution) == 0:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            seed = random.choice(verts)\n            smaller = [c for c in range(1, target)]\n            if smaller:\n                c2 = random.choice(smaller)\n                kempe_chain_swap(solution, seed, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # If conflicts present, attempt focused recolor with limited allowance for k+1 only if conflicts drop\n    if conflicted:\n        # Choose vertex by (saturation, conflicts, degree, random)\n        candidates = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            candidates.append((sat, cfg, deg, random.random(), v))\n        candidates.sort(reverse=True)\n        v = candidates[0][-1]\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        backup = solution[:]\n        # Try within 1..k first\n        if allowed:\n            new_c, _ = least_conflict_color(solution, v, allowed)\n            if new_c != solution[v-1]:\n                solution[v-1] = new_c\n                return (\"Recolor\", \"SingleVertex\")\n        # Consider k+1 only if it reduces conflicts at v\n        if True:\n            tentative = k + 1\n            if tentative not in neigh_cols:\n                pre_v = vertex_conflicts(backup, v)\n                solution[v-1] = tentative\n                post_v = vertex_conflicts(solution, v)\n                if post_v < pre_v:\n                    return (\"Recolor\", \"SingleVertex\")\n                # rollback if no gain\n                for i in range(9):\n                    solution[i] = backup[i]\n        # If recolor failed, use Kempe swap between two existing colors\n        colors_now = sorted(set(solution))\n        if len(colors_now) >= 2:\n            v = random.randrange(1,10)\n            cur = solution[v-1]\n            others = [c for c in colors_now if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_chain_swap(solution, v, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # Diversification: simple recolor towards smallest available color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, max(solution)+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # as last resort stay or introduce k+1 only if it doesn't create same-color neighbors at v\n        t = max(solution) + 1\n        if t not in neigh_cols:\n            solution[idx] = t\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    # Modes: kempe_burst, color_merge, shuffle_subset\n    steps = 6 + random.randrange(5)  # 6..10\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick random vertex and swap with another color\n            v = random.randrange(1,10)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.7 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            changed = False\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n                    changed = True\n            if changed:\n                # canonicalize after merge attempt\n                cols = sorted(set(res))\n                mp = {c:i+1 for i,c in enumerate(cols)}\n                res = [mp[c] for c in res]\n        else:\n            # shuffle_subset: recolor a random subset preferring minimal conflicts\n            subset = random.sample(range(1,10), k=min(3, 1 + random.randrange(3)))\n            for v in subset:\n                neigh_cols = neighbour_colors(res, v)\n                palette = list(range(1, k+1))\n                allowed = [c for c in palette if c not in neigh_cols]\n                if not allowed and k >= 1:\n                    palette.append(k+1)\n                new_c, _ = least_conflict_color(res, v, palette)\n                res[v-1] = max(1, new_c)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","SAMPLE_SOL":[3,1,2,3,1,2,1,3,2]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Componente":null,"Version":8,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"H_API_CONTRACT:generate_neighbour returns only metadata ('Operator','MovementType'); frameworks expect the modified solution object. Return (new_solution, {'op':..., 'move':...}).\\nH_ACCEPTANCE_SPLIT:Neighbour enforces non-worsening moves, starving SA\/TS which need uphill\/aspiration. Make neighbour neutral (produce candidates only); delegate acceptance to the heuristic core.\\nH_SIG_MISMATCH_TABU:Tabu Search signature incompatible with TARGET_HEURISTIC_GENERAL_SIGNATURE and generate_neighbour usage. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt TS internals to this contract.\\nH_ILS_HARD_PENALTY:ILS result ('Kempe', 1000000000001, ...) shows evaluate_solution got a non-list (operator tuple) instead of a solution. Fix neighbour return type and ILS unpacking.\\nP_MISSING:Perturbation function is undefined ($Perturb). Implement a kick operator: e.g., multi-vertex Kempe swaps + targeted recolor burst on top-conflicted vertices.\\nNB_INVALID_SEED_BUG:When solution is not a list, code does solution[:] = tmp which raises on non-list. Replace with return tmp or rebind via solution.clear(); solution.extend(tmp) only if list; otherwise return a fresh list.\\nNB_CANON_INSIDE:Canonicalization inside neighbour changes labels across iterations, breaking Tabu memory and noisy for SA temperature. Canonicalize only in evaluate_solution or after successful k-reduction; keep neighbour operating on current labels.\\nNB_DELTA_POLICY:Allowing k+1 recolors during conflict phase can inflate palette and stall convergence. Gate k+1 strictly on conflicts decrease (\u0394conflicts < 0) rather than fitness tie; or forbid unless base_conf > W.\\nNB_DETERMINISM_LOOP:Choice v = 1 + (sum(base) % 9) causes cycling. Use a PRNG seeded via other_params, or a round-robin iterator over conflicted vertices to ensure coverage.\\nNB_ROLLBACK_SAFETY:Multiple in-place edits without guaranteed revert if rejected risks state corruption. Produce trial copies; only commit on accept.\\nNB_OP_SET_GAPS:No explicit \u201cmove-conflicted-to-least-used-color\u201d or \u201cmerge color classes with repair\u201d. Add: (a) GreedyMove(v): assign min-feasible color preferring underused; (b) MergeColors(a,b) + DSATUR repair on affected vertices.\\nNB_KEMPE_SCOPE:Kempe chain seed selection heuristic weak. Prioritize seeds from highest-conflict vertices and choose partner color maximizing cut across the chain.\\nE_CODE_PERF:Full recomputation O(|E|) per trial and repeated canonicalization O(n) per move. Implement delta evaluation: maintain per-vertex conflict counts; update in O(deg(v)) on recolor\/Kempe; canonicalize only on k-change.\\nE_LABEL_STABILITY:First-seen relabeling is non-stable across equal-fitness trials, hindering tabu hashing. Use stable relabeling (sort color classes by smallest vertex id) in evaluation only, or maintain an external mapping cache.\\nE_PENALTY_TIERS:Hard penalties are indistinguishable except by constant; log\/track failure type explicitly for diagnostics in the heuristic loop; avoid canonicalization attempt on hard-penalized inputs.\\nR_REPR_AFFINITY:Representation ok but mix of in-place mutate + canonicalization complicates reproducibility. Enforce pure functional neighbour (returns new list) for clarity and easier hashing.\\nA_TABU_MEMORY:Define tabu on (vertex,color) moves in canonical space or on edge-conflict deltas; avoid tabu on raw color labels subject to relabeling.\\nA_DSatur_USAGE:DSATUR key uses current colors including conflicts; add \u201cavailable colors count\u201d and prioritize vertices with zero feasible colors within 1..k to unlock deadlocks sooner.\\nA_NEIGH_FILTER:When conflicted, forbid trials that keep v\u2019s conflicts unchanged unless they reduce k in the same move; this prunes plateaus.\\nA_HEURISTICS_PARAMS:Expose other_params for PRNG seed, max_k, and operator weights; support adaptive operator selection (e.g., ALNS with score-based weights).\\nA_STOP_CRITERIA:Add early stop when k=3 and conflicts=0; verify against KNOWN SOLUTION. Add stagnation counters per k-level to trigger perturbation.\\nTEST_KNOWN_SOLUTION:Unit test evaluate_solution([3,1,2,1,3,2,1,1,2]) == 3; regression test neighbour does not increase k from a feasible k=3 solution.\\nFIX_RUN_ERRORS:Taboo_Search failure 'too many values to unpack'\u2014update to unpack (cand, meta) from generate_neighbour and pass function objects, not function calls, in the signature.\\nCODE_SAFETY:Remove unused imports; ensure no filesystem\/network\/OS access per constraints; keep functions pure and deterministic under provided seed.\\nINSTRUMENTATION:Add counters for operator success rates and average \u0394fitness to reweight operator selection over time (credit assignment).\\nSCALING_PATH:Generalize edges\/adj from parameters; avoid hardcoding to 9 to enable reuse; but keep complexity O(|E|) per iteration with delta updates.\\n\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_INTS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k using first-seen mapping\n    mapping = {}\n    nxt = 1\n    sol = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol.append(mapping[c])\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator with rollback safety.\n    - Maintains canonical colors 1..k (first-seen remap) at entry and after move.\n    - Prefers fitness-improving moves; accepts non-worsening if no improvement found.\n    - Operators: Recolor (single vertex), Kempe (chain swap), RemoveColor (greedy repair), SwapClasses (color-class swap).\n    Returns metadata tuple (Operator, MovementType).\n    Postcondition: solution is a list of 9 positive ints with contiguous labels starting at 1.\n    \"\"\"\n    # Basic validation and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        # reset to a valid seed\n        for i in range(9):\n            if i < len(solution) if isinstance(solution, list) else False:\n                pass\n        tmp = [1,2,3,1,2,3,2,1,3]\n        solution[:] = tmp\n    else:\n        for i,x in enumerate(solution):\n            if not isinstance(x, int) or x < 1:\n                solution[i] = 1\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize_inplace(sol):\n        mp = {}\n        nxt = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            sol[i] = mp[c]\n    canonicalize_inplace(solution)\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    W = len(edges) + 1\n    # Helpers\n    def fitness(sol):\n        # compute fitness with canonical form enforced\n        # conflicts*W + k\n        conflicts = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * W + max(sol)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_key(sol, v):\n        sat = len({sol[nb-1] for nb in adj[v]})\n        deg = len(adj[v])\n        return (sat, vertex_conflicts(sol, v), deg, -v)  # deterministic tie-break by -id\n    # Current state\n    base = solution[:]\n    base_fit = fitness(base)\n    base_conf = conflicts_count(base)\n    k = max(base)\n    # 1) If conflict-free, try to eliminate highest color greedily\n    if base_conf == 0 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(base, start=1) if c == target]\n        trial = base[:]\n        # order by DSATUR (on trial which == base initially)\n        verts_sorted = sorted(verts, key=lambda v: dsatur_key(trial, v), reverse=True)\n        feasible = True\n        for v in verts_sorted:\n            neigh = neighbour_colors(trial, v)\n            allowed = [c for c in range(1, target) if c not in neigh]\n            if allowed:\n                trial[v-1] = min(allowed)\n            else:\n                feasible = False\n                break\n        canonicalize_inplace(trial)\n        if feasible:\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"RemoveColor\", \"GreedyRepair\")\n        # Try Kempe-assisted elimination from one of target vertices\n        if verts:\n            trial = base[:]\n            seed = verts[0]\n            c2 = 1 if target != 1 else 2\n            kempe_chain_swap(trial, seed, c2)\n            canonicalize_inplace(trial)\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"Kempe\", \"ChainSwap\")\n    # 2) Conflicted phase: focused recolor for best delta\n    if base_conf > 0:\n        conflicted = [v for v in range(1,10) if vertex_conflicts(base, v) > 0]\n        if conflicted:\n            v = sorted(conflicted, key=lambda x: dsatur_key(base, x), reverse=True)[0]\n            neigh_cols = neighbour_colors(base, v)\n            palette = list(range(1, k+1))\n            best_trial = None\n            best_fit = None\n            # Try within 1..k avoiding neighbor colors\n            for c in palette:\n                if c == base[v-1] or c in neigh_cols:\n                    continue\n                tr = base[:]\n                tr[v-1] = c\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            # Consider k+1 only if it improves global fitness\n            t = k + 1\n            if t not in neigh_cols:\n                tr = base[:]\n                tr[v-1] = t\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            if best_trial is not None and best_fit <= base_fit:\n                solution[:] = best_trial\n                return (\"Recolor\", \"SingleVertex\")\n    # 3) Kempe swap between two colors to escape plateaus\n    colors_now = sorted(set(base))\n    if len(colors_now) >= 2:\n        v = 1 + (sum(base) % 9)  # deterministic-ish pick without external state\n        c1 = base[v-1]\n        c2 = colors_now[0] if colors_now[0] != c1 else colors_now[1]\n        trial = base[:]\n        kempe_chain_swap(trial, v, c2)\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"Kempe\", \"ChainSwap\")\n    # 4) Swap color classes (global relabel) if it helps\n    if len(colors_now) >= 2:\n        a, b = colors_now[0], colors_now[-1]\n        trial = [ (b if c==a else (a if c==b else c)) for c in base ]\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"SwapClasses\", \"Global\")\n    # 5) Fallback: minimal safe recolor to smallest available color (may be equal fitness)\n    idx = (sum(base) % 9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(base, v)\n    choice = None\n    for c in range(1, k+1):\n        if c != base[v-1] and c not in neigh_cols:\n            choice = c\n            break\n    trial = base[:]\n    if choice is not None:\n        trial[v-1] = choice\n    else:\n        t = k + 1\n        if t not in neigh_cols:\n            trial[v-1] = t\n    canonicalize_inplace(trial)\n    if fitness(trial) <= base_fit:\n        solution[:] = trial\n        return (\"Recolor\", \"SingleVertex\")\n    # No acceptable move found; leave solution as-is\n    canonicalize_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors, Kempe swaps,\n    and color-merge attempts. Representation preserved (list of 9 positive ints).\n    Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize(sol):\n        mp = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            out.append(mp[c])\n        return out\n    res = canonicalize(base)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 6 + (sum(res) % 5)  # 6..10 deterministic-ish\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick vertex by a simple hash and swap with another color\n            v = 1 + ((res[0] * 3 + res[1] * 5 + res[2] * 7) % 9)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.75 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n            res = canonicalize(res)\n        else:\n            # shuffle_subset: recolor a random subset avoiding neighbor colors; may introduce k+1 sparsely\n            subset_size = 1 + (random.randrange(3))\n            subset = random.sample(range(1,10), k=min(3, subset_size))\n            for v in subset:\n                neigh = neighbour_colors(res, v)\n                palette = [c for c in range(1, k+1) if c not in neigh and c != res[v-1]]\n                if palette:\n                    res[v-1] = random.choice(palette)\n                else:\n                    if k < 5 and (k+1) not in neigh:\n                        res[v-1] = k+1\n            res = canonicalize(res)\n    res = canonicalize(res)\n    return res\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1. Each solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-indexed vertices). Objective: minimize number of distinct colors while penalizing any edge with equal endpoint colors.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_RUNTIME_ERROR:Error 'Type List cannot be instantiated; use list() instead' indicates runtime misuse of typing types. Replace all annotations 'List[int]'\/'Tuple[...]' with built-in 'list[int]'\/'tuple[...]' or remove annotations in executed code paths.\nE_TYPE_ANNOT_BUG:Avoid returning annotation -> ('NB_Type','Movement_Type'). Use 'tuple[list[int], str, str]' or no annotation to prevent runtime evaluation mishaps.\nNB_RETURN_ANNOT_BUG:Signature says returns (new_solution, NB_Type, Movement_Type) but annotation omits solution type. Fix to '-> tuple[list[int], str, str]'.\nNB_CODE_FAIL_LOCAL_OPT:Single 1-vertex recolor is too weak; add 2-opt style color swaps (Kempe chain or pairwise color exchange on a vertex subset) to escape plateaus.\nNB_COLOR_BLOAT:Unbounded new-color creation (p=0.15) inflates k. Make probability adaptive: reduce to 0 when conflicts=0; otherwise p=min(0.15, conflicts\/|E|).\nNB_TARGET_FOCUS:Neighbor does not bias toward conflict resolution. Choose v from conflict vertices with high probability; pick colors from feasible set first; break ties by minimizing new groups_used.\nE_CODE_PERF:Evaluation is O(m) each call. Add delta-evaluation for 1-vertex recolor: update conflicts by checking only incident edges and update groups_used via per-color counts.\nOBJ_SCALING:Conflict penalty 1000 is arbitrary; verify it dominates max feasible k. Tighter bound: use penalty = n (or m+1). Here set to m+1=18 to ensure feasibility-first without numeric blow-up.\nPERTURB_MISSING:Missing 'perturb_solution'. Add segment re-color perturbation: randomly pick a conflict component and perform a Kempe chain swap or merge two colors then repair.\nHEURISTIC_SIG_MISMATCH:Missing Heuristic function with required signature. Implement SA\/ILS\/TS wrapper: Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nDIVERSIFICATION_LACK:Add tabu memory on (vertex,color) assignments or short-term ban on recently used colors to avoid cycling; maintain aspiration for improved score.\nINTIALIZATION_WEAK:No constructor provided. Use greedy DSATUR or largest-first coloring to start near k=3; then apply local search to remove colors.\nMOVE_SELECTION_POLICY:Random vertex pick is inefficient. Use conflict-driven selection and first-improvement or best-improvement over feasible colors to accelerate descent.\nCOLOR_MERGE_OPERATOR:Add explicit color-merge attempt: pick two colors, recolor vertices of one into the other with minimal conflict, then repair; strong for k-reduction.\nTERMINATION_CRITERIA:Define clear stopping rules: max iters without improvement, time budget, or reaching known optimum (k=3). Combine with adaptive temperature\/perturb strength.\nROBUSTNESS_VALIDATION:Add strict input checks to neighbor: ensure n=9, clamp colors to >=1, and avoid duplicate neighbor indices when computing 'neighbors'.\nKNOWN_SOLUTION_EXPLOIT:Use known feasible k=3 as target; once conflicts=0 with k<=3, stop; guide search by penalizing introduction of 4th color heavily.\nREPRODUCIBILITY:Add RNG seed via other_params to ensure deterministic runs during benchmarking.\nCODE_SAFETY:Ensure no filesystem\/network\/OS access; keep pure functions per MAIN_CRITICAL_INSTRUCTION.\nAPI_COMPAT:Return values must be plain Python types; avoid typing objects in runtime returns or annotations that frameworks may eval.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_INT_GE1. Each solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-indexed vertices). Objective: minimize number of distinct colors while penalizing any edge with equal endpoint colors.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better\n    # Validate\n    BIG = 10_000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Heavy penalty per conflict ensures feasibility is prioritized\n    return groups_used + conflicts * 1000","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # One-vertex recolor to a potentially existing or new color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback safe neighbor\n        return ( [1]*n, \"1-vertex-recolor\", \"stochastic\" )\n    new_sol = solution.copy()\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    v = random.randrange(n)\n    # Determine conflicting colors at v\n    neighbors = [u if u!=v else w for (u,w) in edges if v in (u,w)]\n    bad_colors = set(new_sol[u] for u in neighbors)\n    max_col = max(new_sol) if new_sol else 1\n    # Candidate colors: prefer existing colors not in bad_colors; allow exploration via new color with small prob\n    candidates = [c for c in range(1, max_col+1) if c not in bad_colors]\n    if not candidates or random.random() < 0.15:\n        candidates.append(max_col+1)\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    return ( new_sol, \"1-vertex-recolor\", \"stochastic\" )","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Medium kick: recolor a random subset of vertices to random existing or new colors\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = solution.copy()\n    max_col = max(new_sol)\n    k = random.randint(2, max(3, n\/\/3))\n    idxs = random.sample(range(n), k)\n    for v in idxs:\n        # 50% choose existing color, 50% allow possibly new color\n        if random.random() < 0.5:\n            new_sol[v] = random.randint(1, max_col)\n        else:\n            new_sol[v] = random.randint(1, max_col+1)\n    return new_sol","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"IF_SIG_MISMATCH:generate_neighbour returns 3 values but SA\/ILS\/TS expect 2; standardize to (new_solution, move_tag) or update unpacking to handle 3-tuple.\nIF_CALLABLE_PASSING:Heuristic signatures pass generate_neighbour() and evaluate_solution() as invoked functions; pass callables without parentheses to avoid None\/arity errors.\nIF_UNIFIED_API:Heuristic implementations (SA\/ILS\/TS) do not match TARGET_HEURISTIC_GENERAL_SIGNATURE; refactor to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nPERTURB_MISSING:$Perturb is undefined; implement perturb_solution with k-vertex random recolor or multi-step Kempe shake; expose strength parameter in other_params.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to 1-vertex recolor and Kempe swap; add 2-opt style pair color swap and greedy recolor using DSATUR priority to escape shallow basins.\nNB_API_CONTRACT:Return meta as a compact tag string only; remove Movement_Type or wrap meta in a dict to avoid unpacking ambiguity across heuristics.\nE_INIT_CONSTRUCT:No constructive initializer; add DSATUR\/greedy constructor to produce low-color, low-conflict starts, reducing SA\/ILS warm-up.\nE_EVAL_DELTA:Full O(m) eval each step; implement delta evaluation for single-vertex recolor and Kempe swaps to achieve O(deg(v)) updates.\nE_PENALTY_TUNING:Conflict penalty=18(=m+1) ensures feasibility-first but can stall color-minimization; after conflicts=0, enable forced k-reduction (merge colors with recolor\/kempe attempts).\nK_CAP_CONTROL:Colors unbounded; impose k_max (e.g., 4) in early phases and schedule k_max decay; reject moves introducing >k_max colors unless stuck.\nSA_PARAM_CONTROL:Cooling\/acceptance unspecified; use geometric cooling T*=alpha*T with alpha in [0.90,0.99], reheating on stagnation, and accept worse by exp(-delta\/T).\nILS_ACCEPTANCE:Acceptance rule unclear; accept if better or if perturb improves feasibility; otherwise accept by threshold on conflict reduction then color reduction.\nTS_MEMORY:Tabu Search lacks tenure\/aspiration detail; track tabu on (vertex,color) for tenure ~ n and allow aspiration when solution improves best_score.\nMOVE_BIAS:Kempe start biased to conflicts only; also target highest saturation degree\/conflict impact vertex to maximize delta reduction.\nRANDOMNESS_CONTROL:Set RNG seed via parameter for reproducibility in benchmarking; avoid global random state coupling across components.\nTERMINATION_CRITERIA:Define clear stopping conditions (max_evals, no_improve_iters) and return best feasible with minimal colors.\nPOSTPROCESSING:Add greedy color compaction pass: repeatedly try to recolor highest color class into lower classes using DSATUR ordering.\nMETRICS_LOG:Log (groups_used, conflicts, evals, temp\/iter) per iteration for diagnosis; detect stalls and trigger perturbation.\nINTERFACE_TESTS:Add unit tests to verify neighbor API arity, evaluate_solution invariants, and that feasible solutions return groups_used with zero conflicts.\nKNOWN_SOLUTION_CHECK:Include smoke test to verify known solution scores 3 and is conflict-free to validate evaluate_solution consistency.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_INT_GE1","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility without numeric blow-up\n    return groups_used + conflicts * 18\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\", \"fallback\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicts and conflict vertices\n    conflicts = 0\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    m = len(edges)\n    # Adaptive probability of introducing a new color\n    p_new_color = 0.0 if conflicts == 0 else min(0.15, conflicts \/ float(m))\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type\n    if random.random() < 0.55:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color if conflicts exist\n        if random.random() < p_new_color:\n            candidates = candidates + [max_col+1]\n        new_color = random.choice(candidates) if candidates else (max_col if max_col != new_sol[v] else max_col+1)\n        new_sol[v] = new_color\n        return (new_sol, \"1-vertex-recolor\", \"stochastic-greedy\")\n    else:\n        # Kempe chain swap between two colors starting at a (possibly conflicting) vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        color_a = new_sol[start]\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Degenerate, fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if random.random() < p_new_color:\n                candidates = candidates + [max_col+1]\n            new_sol[v] = random.choice(candidates) if candidates else max_col+1\n            return (new_sol, \"1-vertex-recolor\", \"fallback\")\n        # Pick a different color b\n        color_b = random.choice([c for c in colors_present if c != color_a])\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\", \"stochastic\")\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        # Swap colors a<->b in the Kempe component containing start\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(max(2, n\/\/3), max(3, n\/\/2))\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.7 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                # Fallback recolor\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"H_SIG_MISMATCH:Target signature violated. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass function objects, not invoked callables.;H_TABU_API_ERROR:Taboo_Search failed due to wrong signature and invoked generators (generate_neighbour(), evaluate_solution()). Fix to accept function refs and unpack (new_sol, move_tag).;H_PERTURB_MISSING:Perturbation function undefined ($Perturb). Provide def perturb_solution(solution, strength, rng_state) returning a valid neighbor.;H_NEIGHBOR_CONTRACT:generate_neighbour returns (solution, tag). Heuristics must consume the first element and optionally log the tag; current code likely assumes a solution only.;H_COLOR_BLOAT:Recolor step can introduce new colors (max_col+1) too easily, inflating k. Restrict to existing colors unless in explicit diversification phase or when conflicts persist beyond threshold.;H_COLOR_ELIM_OP_MISSING:Lacks directed color-elimination moves. Add operator: pick least-used color L, try move-all of vertices in L to feasible existing colors via greedy\/Kempe; if success, drop L.;H_INIT_WEAK:No constructive initializer. Use DSATUR\/greedy-by-degeneracy to produce a 3\u20134 color feasible start, improving convergence.;H_EVAL_LEXICOGRAPHY:Penalty 18 enforces feasibility but still allows algorithms to trade conflicts vs colors inappropriately. Make conflicts lexicographically dominant: score = conflicts*10**6 + groups_used to strictly prioritize feasibility.;H_EVAL_DELTA:Full re-evaluation is O(m). Implement delta evaluation using adjacency to compute conflict change in O(deg(v)) per move; cache groups_used and color counts for O(1) updates.;H_ACCEPTANCE_POLICY:ILS accepted infeasible (score 39). Enforce feasibility-only acceptance during intensification; allow infeasible only in diversification with capped conflict budget.;H_SA_TUNING_UNSPECIFIED:Set T0 from objective std-dev over 200 random neighbors; cooling geometric alpha in [0.90,0.98]; reheating on stagnation; minimum temperature where accept rate <1%.;H_PERTURB_STRENGTH:Calibrate ILS perturbation to flip 1\u20132 vertices per 9 (small instance). Use adaptive strength increase on repeated returns.;H_TABU_DESIGN:Use vertex-color move tabu with tenure in [5,9]; aspiration if move improves best; diversify via frequency-based penalties on overused colors\/vertices.;H_KEMPE_SCOPE_LIMIT:Kempe swap applied blindly; restrict to conflicts-started chains and accept only if conflicts non-increasing; add biased selection of color_b that appears among neighbors of start.;H_BOUND_COLORS:Maintain dynamic k_max; prohibit introduction of color > k_max during intensification; periodically attempt k reduction by launching feasibility search under k-1.;H_REPAIR_OPERATOR:Add fast repair: iterate conflicted vertices in descending conflict degree; recolor to smallest feasible existing color; repeat until no conflicts or no progress.;H_MOVE_SELECTION:Use saturation-degree or conflict-weighted vertex selection instead of uniform\/random for recolor to target high-impact vertices.;H_HEURISTIC_CONSISTENCY:Best-as-lesser-cost rule must be enforced across all modules; verify no negation in scoring\/acceptance.;H_REPRO_SEED:Expose rng seed in other_params for reproducibility and comparative evaluation.;H_STOP_CRITERIA:Add stall-based termination (no best improvement over X iterations) and multi-start restarts to escape poor basins.;H_TESTS:Add unit tests: evaluate_solution(KNOWN)=3; neighbor preserves domain and length; Kempe swap color-set integrity; perturb returns valid solution.;H_OUTPUT_VALIDATION:Before main loop, sanitize currentSolution to ints>=1 and compress colors to 1..k to prevent label drift.;H_LOGGING:Record move_tag frequencies and acceptance to diagnose operator efficacy; down-weight ineffective operators over time (ALNS-style).\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_INT_GE1","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility\n    return groups_used + conflicts * 18\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type: recolor or Kempe swap\n    if random.random() < 0.6:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color only if conflicts exist\n        if conflict_vertices and random.random() < 0.1:\n            candidates = candidates + [max_col+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        else:\n            new_sol[v] = max_col if max_col != new_sol[v] else max_col+1\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors starting at a selected vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if conflict_vertices and random.random() < 0.1:\n                candidates = candidates + [max_col+1]\n            if candidates:\n                new_sol[v] = random.choice(candidates)\n            else:\n                new_sol[v] = max_col+1\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        others = [c for c in colors_present if c != color_a]\n        if not others:\n            return (new_sol, \"noop\")\n        color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or occasionally new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.8 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Componente":null,"Version":3,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-critique-graphcoloring-9v\"\n\"FEEDBACK\":\"SIG_HEURISTIC_MISMATCH:Heuristic must match def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure all drivers call this exact signature and pass function objects, not evaluated results.\nTS_SIG_ERROR:Tabu Search signature and neighbor use are inconsistent. Do not call generate_neighbour() in the signature. Accept function objects; inside TS, call neigh=generate_neighbour(sol) and unpack (new_sol, move_tag). Current error 'too many values to unpack' indicates incorrect unpacking or passing a function call.\nPERTURB_MISSING:$Perturb placeholder is unresolved. Iterated_Local_Search degenerates without a defined perturbation. Implement a concrete perturb_solution with controlled strength (e.g., multi-vertex recolor + targeted Kempe swaps).\nOBJ_LEX_TOO_RIGID:The conflicts*1e6 + groups lexicographic scheme prevents guided reduction of color count once feasibility is reached via fixed-k search. Add mode switch: phase 1 minimize conflicts at fixed K_max=3; phase 2, if infeasible at K_max=3, temporarily increase to 4 with high penalty but force periodic K back-off.\nK_BOUNDS_UNSPECIFIED:Representation allows unbounded colors; neighbor introduces kmax+1, inflating k unnecessarily. Add parameter K_max and enforce 1<=color<=K_max in all moves for feasibility-first at k=3.\nEVAL_NO_DELTA:Full O(|E|) evaluation each step. Maintain incremental state: conflict count per edge and color counts per vertex neighborhood to compute O(deg(v)) deltas on moves; track groups_used via color class sizes.\nINIT_WEAK:No constructive initializer provided. Use DSATUR or greedy-by-degree to produce a high-quality 3-color start; also attempt sequential graph reduction and color class merging.\nNB_CONFLICT_WEIGHTING:Vertex selection mixes degree bias and random; lacks conflict weighting. Prioritize vertices by conflict degree and then by saturation degree to intensify search pressure where needed.\nNB_NEW_COLOR_POLICY:Neighbor occasionally introduces a new color even when k should be minimized. Disable new color creation when running at fixed K_max, or gate it behind strong aspiration and immediate color compression.\nNB_KEMPE_UNTARGETED:Kempe swap picks color_b randomly among neighbors; low impact on conflicts\/k. Choose color_b maximizing potential conflict reduction or enabling color class elimination; evaluate local delta before committing.\nNB_COLOR_COMPRESSION_MISSING:After recolor\/Kempe, gaps in color labels persist, inflating groups_used. Add normalization to relabel colors to [1..k'] and drop empty classes every few iterations.\nNB_MOVE_DIVERSITY_LIMITED:Only single-vertex recolor and 2-color Kempe provided. Add color-class merge, ejection chains, and pairwise vertex swap within fixed k to escape plateaus; include multi-vertex Kempe chains.\nILS_PERTURB_STRENGTH:ILS result shows remaining conflicts (score 2000003). Implement adaptive perturbation strength (increase after repeated local minima), and use acceptance criterion that prefers feasibility then k reduction.\nSA_SCHEDULE_UNSPECIFIED:No explicit cooling or reheating strategy reported. Use geometric cooling with calibrated T0 based on initial delta distribution; reheating on stagnation; two-phase temperature scaling (higher for conflict removal, lower for k compression).\nTABU_MEMORY_DEFINITION:Define tabu attributes on (vertex,color) assignments with tenure tied to degree and recent improvement; add aspiration for moves that reduce conflicts or k.\nSTOP_CRITERIA:Terminate immediately when conflicts=0 and groups_used<=3; otherwise use plateau-based stopping and time\/iteration caps per phase.\nREPRODUCIBILITY:Seed RNGs via a passed seed parameter to enable deterministic runs for benchmarking.\nGRAPH_CONSTANTS_DUPLICATION:Edges\/adjacency duplicated across functions. Centralize graph definition and precomputed adjacency to prevent inconsistencies and reduce overhead.\nEVAL_FEASIBILITY_FIRST:Given known 3-colorability, run fixed-k feasibility search at k=3 using DSATUR start, conflict-weighted recolor, targeted Kempe, and tabu; only if infeasible after budget, escalate to k=4 then immediately attempt color elimination.\nCODE_SAFETY_CONSTRAINT:Ensure all components avoid filesystem\/network\/OS access per MAIN_CRITICAL_INSTRUCTION; keep pure functions for portability and verifiability.\nACTIONABLE_FIX_ORDER:1) Implement perturb_solution (conflict-driven multi-vertex recolor + Kempe; adaptive strength). 2) Enforce K_max=3 and color compression. 3) Correct TS signature\/unpacking and add tabu attributes with aspiration. 4) Add DSATUR initializer. 5) Add delta-evaluation cache. 6) Calibrate SA schedule and acceptance with two-phase objective.\nBENCH_VALIDATION:Benchmark across 100 seeded runs; report feasibility rate at k=3, average iterations to feasibility, and mean evals, to validate improvements objectively.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_INT_GE1","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","SAMPLE_SOL":"[1, 2, 3, 1, 2, 3, 2, 1, 3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}.","Componente":null,"Version":4,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_OBJ_INTEGRATION_BUG:Heuristics report best_score=3 for infeasible SA\/ILS outputs containing edge conflicts. Enforce evaluate_solution return as the sole objective signal; reject any 'groups_used' shortcuts or custom scoring paths.\nE_FEAS_LEXICO:Lexicographic objective (conflicts >> colors) is correct, but acceptance criteria in SA\/ILS likely ignore the conflict term. Enforce acceptance on full cost=conflicts*1e6+groups_used; never compare only groups_used.\nNB_API_MISMATCH:generate_neighbour returns (new_solution, move_tag) but TS\/others expect a single solution. Provide a thin adapter or update all heuristics to consume the tuple. Example fix: wrap as lambda s: generate_neighbour(s)[0] where tuple is unsupported, or refactor all algorithms to accept (solution, move_tag).\nTS_SIGNATURE_MISMATCH:Taboo_Search signature def TS(...) differs from TARGET_HEURISTIC_GENERAL_SIGNATURE and unpacks arguments incorrectly, causing 'too many values to unpack'. Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE and pass neighbor\/evaluator as callables; remove extraneous parameters or encapsulate them in other_params.\nR_INIT_WEAK:No robust initializer; reliance on arbitrary samples hampers convergence. Add DSATUR or greedy-by-degree seeding to start from low-conflict, low-k configurations.\nNB_CODE_FAIL_LOCAL_OPT:Recolor operator lacks directed conflicting-edge reduction; it picks least-conflicting color but does not ensure delta-eval guidance across entire objective. Add delta-evaluation to pick color with minimal increase in conflicts and tie-break by reducing groups_used.\nNB_KEMPE_LIMITED:Kempe swap component selection is single-start and random; lacks bias to reduce conflicts or colors. Prioritize starts on conflict vertices; select color_b minimizing frontier conflicts; abort swaps that increase conflicts.\nNB_COLOR_BLOAT:New color introduction (kmax+1) occurs under conflicts without immediate compaction; labels can drift upward. After any accepted move, compress labels to 1..m and reindex to prevent artificial k inflation and to stabilize neighborhoods.\nE_CODE_PERF:Full recompute of conflicts is O(|E|) per evaluation; expensive under heavy sampling. Implement incremental delta evaluation using adjacency lists and maintain per-vertex conflict counts; target O(deg(v)) updates per move.\nE_STATE_REUSE:Lack of cached structures (adjacency, degrees, conflicts) inside heuristic loop causes repeated rebuild cost. Precompute adjacency once and pass via other_params; avoid recomputing edges and degrees in every neighbor call.\nACC_POLICY_WEAK:Acceptance logic unspecified\/loose; SA temperature schedule not aligned to lexicographic objective causing premature acceptance of color-increasing moves. Use strict lexicographic acceptance: first require non-increasing conflicts; only when equal, allow probabilistic acceptance on groups_used.\nILS_PERTURB_MISSING:Perturbation function undefined ($Perturb). This cripples escape from local minima. Add conflict-directed multi-vertex perturbation: select a random conflict edge, perform a length-2 or length-3 Kempe chain followed by greedy recolor of both endpoints.\nTABU_LIST_DEFINITION:Tabu tenure not tied to move attributes; storing raw solutions is memory-heavy and ineffective. Tabu should track move attributes (vertex,color) or swapped color pairs for Kempe moves; aspiration if move reduces conflicts.\nR_STR_INADEQUATE:Representation not normalized after moves; the same partition can appear in many labelings, fragmenting search. Enforce label compaction and canonical relabeling (e.g., order colors by first occurrence).\nSTOPPING_CRITERIA_WEAK:No explicit feasibility-first termination. Add early stop when conflicts==0 and groups_used==3; otherwise continue only if searching for proof of 2-colorability (impossible here) with cap.\nNEIGHBOR_BALANCE:Recolor probability fixed at 0.7 may stall; adaptive mixing based on stagnation required. Increase Kempe probability when conflicts plateau; decrease when groups_used stalls.\nHEURISTIC_SIGNATURE_CONSISTENCY:TARGET_HEURISTIC_GENERAL_SIGNATURE must be used by SA\/ILS\/TS. Remove algorithm-specific positional params; pass them through other_params, and unwrap inside Heuristic.\nSPECIFIC_FIX_ADAPTER:Provide neighbor adapters to unify API. Example: def nb_sol(s): return generate_neighbour(s)[0]; def nb_move(s): return generate_neighbour(s).\nSPECIFIC_FIX_PERTURB:Define perturb_solution as: select k in {2..4} conflict vertices; for each, choose least-conflicting feasible color; if none, perform targeted Kempe between current and best alternative color; then compress labels.\nSPECIFIC_FIX_INIT:Add deterministic DSATUR initializer to quickly find 3-coloring; fallback to greedy by degree with random tie-breaks to diversify restarts.\nSPECIFIC_FIX_EVAL_DELTA:Augment evaluate_solution with a companion delta_evaluate(solution, v, new_color, adj) that updates conflicts and groups in O(deg(v)) to enable efficient local search.\nVALIDATION_ENFORCEMENT:Reject or repair any solution violating list length or positivity at Heuristic entry; avoid silent coercion in neighbor which can mask upstream bugs; log move_tag only for analytics, not control flow.\nREPRO_STABILITY:Excessive random.random calls without seeds reduce reproducibility. Accept a rng object in other_params and use it consistently across components.\nCOLOR_MERGE_OPERATOR_MISSING:Lack of explicit color merge hinders k reduction when feasible. Add operator: pick two colors a,b; try recolor all vertices of b into any color != a by greedy least-conflict; if success, remove b and compress.\nKNOWLEDGE_CHECK:Known feasible 3-coloring exists; algorithms must never accept\/confuse infeasible solutions with score=3. Add assertion: if best_score<1_000_000 then ensure conflicts==0; otherwise flag and discard.\"","Componentes":{"REPRESENTATION":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best if best else [kmax+1]\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","SAMPLE_SOL":"[3,2,1,3,2,1,2,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}. Canonicalize after moves by relabeling colors to 1..m in order of first occurrence.","Componente":null,"Version":5,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_PERTURB_MISSING:Perturbation function is undefined ('$Perturb'). Define a concrete perturb_solution to escape local minima (e.g., random Kempe multi-chain, color-class merge+repair, or k-1 recolor attempts).\nE_TS_SIGNATURE:Tabu function signature uses function calls in parameters 'generate_neighbour()' and 'evaluate_solution()' instead of function refs; fix to pass callables. Ensure it matches TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_TS_UNPACK:Tabu expects 1 value from neighbor but receives 2 (solution, tag). Update TS to unpack both and ignore or use tag; adjust acceptance and tabu recording accordingly.\nE_OBJ_PRIORITY:Evaluation is lexicographic but neighbor moves optimize only conflict count; add explicit k-reduction operators when conflicts==0 (try recolor to existing colors, targeted color elimination).\nE_ADJ_REBUILD:Adjacency and edges rebuilt every generate_neighbour call. Precompute once and pass via other_params to cut overhead (O(m) per call to O(1)).\nE_CANON_TABU:Canonicalization after each move breaks color-ID-based tabu memory. Store tabu on structural attributes (vertex, old_color, new_color) or sorted color-pair swap, not raw color labels.\nE_ILS_BROKEN:ILS best_score 2000003 indicates acceptance\/elite tracking is incorrect. Enforce strict minimization (use < for improvements), deep-copy best, and never overwrite best with worse solutions.\nE_SA_WEAK_EXPLORE:Recolor probability fixed (0.65) without adaptive schedule. Tie exploration to temperature or stagnation; increase Kempe probability when progress stalls.\nE_KEMPE_ESTIMATE:Boundary conflict estimate ignores internal conflict resolutions\/creations asymmetrically. Evaluate exact delta on affected edges after simulated swap before commit.\nE_MOVE_SCOPE_LIMITED:Only single-vertex recolor and 2-color Kempe. Add: (a) color-class elimination with repair; (b) multi-vertex steepest descent (choose best among top-K vertices); (c) swap colors of two vertices in conflict if decreases conflicts; (d) path-relinking towards best.\nE_INIT_QUALITY:No constructive seeding. Add DSATUR\/greedy with smallest-available-color to start near 3-coloring; improves convergence and reduces conflicts.\nE_CONSTRAINT_REPAIR:When conflicts>0, restrict recolor candidates to colors not in neighbor set first, but also allow temporary new color only under annealing control; currently may introduce color bloat early.\nE_RANDOM_SEED:No seed control. Add seed in other_params for reproducibility; expose in Heuristic interface.\nE_EVAL_DUP:Validation and set operations executed every evaluation. Cache n, edges, adj, and pre-validated flag in other_params; short-circuit validations in inner loop.\nE_MOVE_SELECTION:Conflict vertex selection uniform; prioritize by conflict degree or DSAT to maximize conflict drop per move.\nE_LOCAL_OPT:No 2-opt-like refinement for color groups. Add pairwise color merge tests with quick feasibility checks using bipartite test on induced subgraph for colors a,b (Kempe feasibility).\nE_STOPPING:No stagnation-based stopping or adaptive restarts. Add max_no_improve with perturbation escalation.\nE_K_CONTROL:Track current k=max(color) and enforce attempts to reduce k when feasible; periodically forbid creation of new colors when conflicts small.\nR_REP_CANON_FREQ:Canonicalize only after acceptance to reduce unnecessary noise in neighborhood evaluation; otherwise cache-miss\/tabu inflation.\nR_PERTURB_SPECIFIC:Implement perturb_solution as: (i) pick worst color class; (ii) attempt greedy recolor of its vertices into others by DSAT priority; (iii) if fail, perform 2\u20133 random Kempe swaps involving that class.\nR_TS_TABU_DEF:Define tabu attribute as (vertex, new_color) with tenure; aspiration if evaluation improves best. Maintain tenure decay and short\/long-term memory to avoid cycles.\nR_HEURISTIC_API:Ensure Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) returns (best_solution,best_score,meta) and never calls filesystem\/network per MAIN_CRITICAL_INSTRUCTION.\nR_TEST_CASES:Add unit tests: (a) neighbor returns valid canonical solution; (b) no-op moves avoided; (c) evaluation monotonicity under conflict changes; (d) TS handling of move_tag; (e) perturb does not increase k uncontrollably.\nE_PERF_BIG:Penalty scale 1e6 is arbitrary but fine; verify no overflow and keep integers. Consider returning tuple (conflicts, groups) and compare lexicographically in code to avoid magic constants.\"","Componentes":{"REPRESENTATION":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}. Canonicalize after moves by relabeling colors to 1..m in order of first occurrence.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            # Choose the neighbor color with minimum frontier conflicts after swap estimate\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                # estimate: count edges crossing component boundary that would become conflicts\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                # Use Kempe chain between current color and best alternative\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list occasionally\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","SAMPLE_SOL":"[3,2,1,3,2,1,2,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Componente":null,"Version":6,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_OBJ_LEX_ORDER:Evaluation mixes feasibility and color count but returns conflicts*1e6+groups; threshold 1e6 is arbitrary. Enforce 'strict feasibility first' by using BIG >> |E| (e.g., 10**9) and document metric. \nE_EVAL_PERF:Full recomputation O(|E|) per call. Implement delta-evaluation for recolor and Kempe-swap to avoid repeated full evaluate_solution calls in the heuristic loop. \nE_EVAL_VALIDATION:Sanity checks return BIG but allow silently bad states. Add assert-style fast-fail in optimizer to prevent propagating invalid states; keep evaluate_solution pure. \nNB_CODE_FAIL_LOCAL_OPT:Neighborhood lacks direct vertex-move with tabu attributes (color assignment with tabu on (v,color)). Add steepest-descent recolor with conflict delta table for stronger local improvement. \nNB_SCOPE_LIMITED:Kempe swap restricted to a single connected (a,b)-component from a chosen start; exploration biased. Enumerate multiple starts or randomly sample 2\u20133 components per iteration to escape plateaus. \nNB_COLOR_BLOAT_CONTROL:Canonicalize after every move, but no cap on spawning new colors during recolor. Disallow kmax+1 unless v is in conflict and best_conf>0; also add color-merge attempts when conflict-free. \nNB_SELECTION_HEURISTIC:Vertex choice prioritizes degree, not saturation. Replace with DSATUR-based pick among conflict vertices (maximize distinct neighbor colors) to reduce conflicts faster. \nNB_TIEBREAK_WEAK:Recolor ties broken uniformly. Break ties by minimizing secondary objectives: resulting saturation increase and potential for future merges. \nNB_KEMPE_SCORING:Boundary conflicts estimation ignores change in total color count. Add bonus for component swaps that enable color class elimination in next step (e.g., if a class becomes empty or singleton). \nNB_MISSING_MOVE_TYPES:Lacks swap of two vertices\u2019 colors and color class split\/merge. Add: (i) vertex-vertex color swap for equal-degree candidates, (ii) color class merge with repair, (iii) 1-move recolor with temporary violation allowed followed by greedy repair. \nP_PERTURB_ABSENT:Perturbation function missing ($Perturb). Implement multi-kempe perturb or random k-vertex recolor with tabu mask to escape deep local minima; intensity adaptive to stagnation. \nP_INTENSITY_CTRL:No adaptive perturbation strength. Use reactive mechanism: increase perturb depth after T stagnated iters; reset on improvement. \nH_INTERFACE_MISMATCH:Taboo_Search signature incorrect; expects generate_neighbour() vs functions. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE and pass callables, not invoked results. \nH_STATE_PACKING:Heuristic returns tuples inconsistent across methods. Standardize to (best_solution, best_score, meta) and ensure meta includes move counts and last_move_type for diagnostics. \nH_SA_PARAM_UNSPEC:Simulated Annealing parameters not shown; risk of accidental success. Calibrate schedule with geometric cooling, reheating on stagnation, and acceptance based on delta conflicts then delta colors. \nH_ILS_REPAIR_MISSING:ILS ended with conflicts (score 2000003). Insert deterministic greedy repair (DSATUR\/Kempe chains) after each local optimum and after perturb to enforce feasibility before k-reduction. \nH_PHASED_STRATEGY:No k-fixed feasibility phase. Implement two-phase: (1) decremental k-coloring: fix k and search for zero conflicts; (2) when feasible, reduce k by 1 and restart from recolored solution. \nH_TABU_CORE:No explicit tabu attributes. Use tabu on (vertex,color) with aspiration if yields better score; fixed tenure with reactive adjustment; short-term memory of recent Kempe (color_a,color_b) pairs to diversify. \nR_INIT_WEAK:Single provided initial solution may bias search. Generate multiple seeds: greedy DSATUR, largest-first, random valid k=4, and use best. \nR_CANON_ORDER:Canonical relabeling by first occurrence can cause oscillation in heuristic that compares by label. Ensure all comparisons are evaluation-based, not label-based; optionally freeze class IDs within a run. \nM_SCORING_STABILITY:Use tuple objective (conflicts, colors) in the heuristic core to avoid precision\/overflow and to compare lexicographically without magic constants; convert to scalar only for API compliance. \nM_LOGGING_DEFICIT:Lack of move acceptance diagnostics. Log per-iteration: conflicts, colors, last_move, accepted\/rejected, stagnation counter to tune operators. \nT_TEST_COVERAGE:No unit tests for edge cases (all same color, max color, isolated failures). Add tests validating zero-conflict detection, Kempe correctness, canonicalization stability, and evaluation invariants. \nK_TARGET_PRIORITY:Emphasize feasibility before k-minimization in acceptance criteria; reject moves that increase conflicts unless temperature\/perturbation allows, and reset to last feasible state after bounded infeasible walk. \nS_KNOWN_SOLUTION_USE:Known 3-color solution not exploited. Use it as benchmark and seed; implement intensification around this basin via path-relinking from current to known best. \nC_TIME_BUDGET:No termination control. Add time\/iteration budget and early stop when conflicts=0 and colors stable for W iterations; expose parameters in other_params. \nAPI_COMPAT:Ensure Heuristic signature exactly matches TARGET_HEURISTIC_GENERAL_SIGNATURE and that no component accesses filesystem\/network\/OS per MAIN_CRITICAL_INSTRUCTION. \nREC_SPEC_IMPL:Implement perturb as multi-start Kempe storms + DSATUR repair; enforce k-fixed feasibility with tabu core; integrate reactive tenure; switch to decremental k strategy once a feasible 3-coloring is reached.\"","Componentes":{"REPRESENTATION":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Componente":null,"Version":7,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_MISSING_PERTURB:Missing Perturbation Function. Implement perturb_solution; without it, ILS cannot escape local minima. Suggest k-step conflict-driven Kempe swaps + vertex kicks on highest-conflict vertices.\"\nE_TS_SIGNATURE:Taboo_Search failed due to function passing\/unpacking. Pass function objects, not invocations. Fix TS to call neighbor as new,tag=generate_neighbour(cur) and ignore tag if unused. Ensure consistent 2-tuple throughout the TS pipeline.\nE_ILS_FEASIBILITY:ILS produced conflicts (score 2000000003). Add deterministic repair after each perturbation: greedily recolor conflict vertices until conflicts=0 or stop; restart if stuck.\nNB_RECOLOR_POLICY:Guided recolor only evaluates local delta conflicts and can increase color count. Enforce no new color unless unavoidable and use tie-break by smallest color-class size to promote class elimination.\nNB_CLASS_MERGE_RISK:Class-merge greedily recolors into conflicting colors causing temporary conflict explosions. Replace with feasibility-preserving merge: for each v in minority color a, assign the lowest-index color c\u2260a not present in N(v); abort merge if any v has no feasible c.\nNB_KEMPE_REDUNDANCY:Kempe component computed twice; remove duplicate traversal. Precompute comp once, score boundary, then apply swap on same comp to reduce overhead and inconsistencies.\nNB_DSATURE_PICK:DSATUR pick uses static conflict_vertices calculated pre-move; after internal changes it is not refreshed. Recompute conflicts for the chosen scenario or derive v from current conflicts each call.\nNB_CANON_TABU_INTERFERENCE:Per-move canonicalization alters color labels, breaking tabu memory keyed on labels. Canonicalize only when accepting a move or encode tabu on structural features (vertex-color pairs) post-canonicalization.\nPERF_DELTA_EVAL:Recomputes conflicts via O(deg) scans repeatedly. Maintain per-color neighbor counts for the selected vertex to evaluate recolor deltas in O(1) amortized; update counts incrementally after moves.\nE_EVAL_SCALE:conflicts*1e9+groups is fine, but use a named INF_CONFLICT_WEIGHT tied to n,|E| (e.g., 1e6>|E|) to avoid brittle constants across problems.\nR_REP_CANON_ORDER_BIAS:First-occurrence canonicalization induces order bias. Normalize by sorting color classes by (size, smallest-index) to stabilize labels and improve cross-heuristic comparability.\nSEARCH_K_REDUCTION:Add explicit k-reduction phase: after feasible solution, attempt to eliminate one color via iterative recoloring (DSATUR order restricted to vertices of the removed color) before accepting equality-cost moves.\nACCEPTANCE_CRITERIA:For SA\/ILS, enforce lexicographic acceptance aligned with evaluate_solution: reject equal-conflict but higher-color moves; allow equal-eval only with structural diversity measure to avoid cycling.\nRNG_SEED_REPRO:Stochastic behavior lacks seeding. Expose seed in other_params and seed random for reproducibility and fair benchmarking.\nNEIGHBOR_DIVERSITY:Current move set overuses recolor (60%). Increase probability of Kempe and feasibility-preserving class-merge when conflicts=0 to intensify color elimination.\nLOCAL_OPT_STAGNATION:No adaptive move-size when stagnant. Add adaptive perturbation strength (increase number of Kempe\/vertex kicks after t no-improvement iterations).\nFRAMEWORK_COMPAT:Heuristic signature valid, but ensure adapters: Heuristic(..., generate_neighbour, evaluate_solution, perturb_solution, other_params). Validate outputs strictly and re-canonicalize only on accepted moves.\nTEST_VALIDATION:Add assert checks in evaluate_solution for vertex range and immediate conflict counting to catch malformed neighbors during development; keep disabled in production for speed.\"","Componentes":{"REPRESENTATION":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Strict lexicographic objective: feasibility first, then color count\n    return conflicts * 1_000_000_000 + groups_used\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    def dsatur_pick(arr, prefer_conflict=True):\n        # DSATUR-based vertex selection; prefer conflict vertices first\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.6:\n        # Guided recolor with delta conflicts evaluation and no color bloat unless necessary\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Disallow spawning new color unless vertex is in conflict and no zero-conflict option\n        candidates = best_colors[:]\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.9:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        cand_bs = list(set(neigh_cols)) if neigh_cols else [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score candidate b by boundary conflicts after swap\n            def kempe_component(start_v, a, b, arr):\n                seen = [False]*n\n                stack = [start_v]\n                seen[start_v] = True\n                comp = []\n                while stack:\n                    x = stack.pop()\n                    if arr[x] == a or arr[x] == b:\n                        comp.append(x)\n                        for y in adj[x]:\n                            if not seen[y] and (arr[y] == a or arr[y] == b):\n                                seen[y] = True\n                                stack.append(y)\n                return comp\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                comp = kempe_component(start, color_a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # Bonus if swap may reduce color count (creates empty class)\n                after_counts = {}\n                for x in range(n):\n                    col = new_sol[x]\n                    if x in comp:\n                        col = b if new_sol[x] == color_a else (color_a if new_sol[x] == b else new_sol[x])\n                    after_counts[col] = after_counts.get(col, 0) + 1\n                bonus = 0\n                if after_counts.get(color_a, 0) == 0 or after_counts.get(b, 0) == 0:\n                    bonus = -0.5  # favor potential color elimination\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b\n            comp = []\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    else:\n        # Color-class merge attempt: pick two colors and try to recolor vertices of minority into majority greedily\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            a,b = random.sample(colors, 2)\n            # Make b the majority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            # Try recolor a-vertices into existing colors excluding a\n            order = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(order)\n            for v in order:\n                best_c = None\n                best_conf = None\n                for c in colors:\n                    if c == a:\n                        continue\n                    conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                    if best_conf is None or conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                if best_c is not None:\n                    new_sol[v] = best_c\n            move_tag = \"class-merge\"\n        else:\n            # Fallback: random recolor within current palette\n            v = random.randrange(n)\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, kmax)\n            move_tag = \"random-recolor\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    def collect_conflicts(arr):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    conflicts = collect_conflicts(sol)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve via recolor or Kempe\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor within current palette\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                # Kempe storm around the conflict vertex\n                colors_present = list(set(sol))\n                if len(colors_present) >= 2:\n                    b_choices = [c for c in colors_present if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: multiple random Kempe swaps or palette shake\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                # Occasionally allow introducing a new color to escape deep traps\n                if random.random() < 0.2:\n                    sol[v] = random.randint(1, kmax+1)\n                else:\n                    sol[v] = random.randint(1, kmax)\n        conflicts = collect_conflicts(sol)\n    sol = canonicalize(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"List[int] of length 9 where index i in 0..8 corresponds to vertex i+1. Values are positive integers (color labels). Canonicalization: after any move, relabel colors to 1..m by sorting color classes by (class size ascending, then smallest vertex index ascending), and mapping to labels 1..m in that order.","Componente":null,"Version":8,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\n\"E_PERTURB_MISSING:Perturbation Function not provided. Add explicit perturbation to escape deep local minima (e.g., color-drop+guided repair, multi-vertex Kempe storms, or random 2\u20134 vertex recolor with DSATUR repair).\"\n\"E_RUNTIME_TYPEERROR:Error 'Type List cannot be instantiated; use list() instead' indicates environment or code path attempts List(). Remove typing imports from runtime code or alias to avoid misuse; ensure no constructor calls to typing.List. Prefer built-in list and type hints via from __future__ import annotations or drop typing entirely in executed cells.\"\n\"E_NEIGHBOR_RECOMPUTE_ADJ:Adjacency rebuilt on every call. Cache adjacency\/degree in outer scope or pass via other_params to avoid O(|E|) rebuild per move.\"\n\"E_CANON_COST:Canonicalization executed every move with dict\/sort overhead O(n log k). Optimize by incremental relabel when move does not change class sizes, or delay canonicalization to acceptance only.\"\n\"E_CLASS_MERGE_ROLLBACK:Class-merge branch mutates solution then on failure does not revert before 'diversify', risking unintended degradation. Add transactional rollback or copy-on-write; only commit if ok==True.\"\n\"E_KEMPE_SCORING_WEAK:Boundary_conf heuristic can mis-estimate true conflict delta. Compute exact delta by counting conflicts on cut edges pre\/post or simulate swap on touched nodes only. Add tie-break to prefer eliminating a color and reducing degree conflicts adjacent to high-degree vertices.\"\n\"E_DSatur_PICK_SCOPE:DSATUR pick uses current neighbor color count but ignores feasibility of zero-conflict colors. Enhance tie-break to prefer vertices with available zero-conflict recolors and highest conflict degree; when no conflicts, target vertices in smallest color class to promote color elimination.\"\n\"E_RECOLOR_NEW_COLOR:Guided recolor permits introducing new color under conflict. This can bloat palette. Enforce hard rule: disallow k+1 unless no existing color yields \u2264 current conflicts; add late acceptance or penalize new-color introduction.\"\n\"E_CONFLICT_VERTICES_STALE:conflict_vertices computed once per call and reused after modifications; safe in single-move context but inaccurate for multi-step submoves (class-merge\/diversify). Recompute when needed or avoid using stale set for subsequent decisions within same call.\"\n\"E_FEASIBILITY_CHECK_DUP:Feasibility check re-scans all edges O(|E|). Maintain conflict count incrementally per move; return early once conflict>0.\"\n\"E_EDGE_DR:Edges duplicated across components. Centralize graph constants to avoid divergence; pass via other_params or module-level constant.\"\n\"E_EVAL_WEIGHT_TUNING:CONFLICT_WEIGHT=1e6 >> |E| is OK but large. Reduce to minimal safe value > |E| (e.g., 100) to keep integer magnitudes tight and reduce risk of arithmetic overflow in metaheuristic temperature\/acceptance calculations.\"\n\"E_HEURISTIC_OBJECTIVE_MISS:No explicit color-elimination objective inside neighborhood. Add focused elimination phase: pick smallest color class a, try reassignment of its vertices via greedy legal colors or constrained BFS Kempe swaps; accept only if |colors| decreases.\"\n\"E_MOVE_DIVERSITY_LIMITED:Neighborhood dominated by single-vertex recolor and single Kempe swap. Add moves: (1) pairwise color merge attempt with backtracking; (2) ejection chain on conflicting vertices; (3) multi-vertex recolor of a conflict cycle; (4) swap labels of two color classes to diversify without changing conflicts.\"\n\"E_TABU_INTEGRATION_ABSENT:If using Tabu Search, record tabu on (vertex,color) assignments and last-swapped color pairs for Kempe chains; aspiration if conflicts decrease or colors drop.\"\n\"E_ANNEAL_SCHED:If using SA, schedule unspecified. Use geometric cooling T_{k+1}=alpha*T_k with alpha in [0.90,0.99], reheats on stagnation, and move-dependent temperature scaling (higher T for color-drop attempts).\"\n\"E_ILS_PERTURB_WEAK:ILS requires strong-but-not-destructive perturb. Use k-random Kempe swaps seeded at high-conflict vertices, or drop smallest class and repair with DSATUR; iterate until feasible then intensify with class-elimination.\"\n\"E_ACCEPTANCE_POLICY:No acceptance criteria described. Implement best-improving first or filtered acceptance (Late Acceptance or Threshold Accepting) to avoid cycling and accept slight worsening moves that enable color drops.\"\n\"E_REP_CANON_SIDE_EFFECTS:Canonicalization reorders labels, breaking simple tabu on color labels. Maintain tabu in canonical label space only, or define tabu over structural features (adjacent color pairs, vertex adjacency patterns).\"\n\"E_INIT_STRATEGY:No initial solution strategy specified. Use DSATUR greedy coloring to start close to 3 colors, or construct from known 3-coloring to benchmark local search behavior.\"\n\"E_TEST_VALIDATION:Sample solution is 3-coloring; verify evaluate_solution returns 3. Add unit tests: (1) edge conflict injection, (2) color-drop improvements, (3) Kempe swap does not increase conflicts when prohibitively scored.\"\n\"R_PERTURB_SPEC:Implement explicit perturb_solution(solution): choose smallest color class a; attempt reassignment of its vertices one-by-one to legal colors using least-conflict choice with tie-break on class size; if any vertex has no legal color, perform targeted Kempe swap on (a,b) with b chosen to minimize new boundary conflicts; repeat for up to p vertices; canonicalize at end.\"\n\"R_NEIGHBOR_ENHANCE:Augment generate_neighbour with: (a) zero-conflict recolor first policy; (b) two-vertex swap within a\/b classes; (c) conflict-cycle flip; (d) adaptive probability of Kempe when conflicts>0, class-merge only when feasible and |colors|>3.\"\n\"R_EVAL_FAST:Maintain degree array and per-vertex conflict counts; update delta in O(deg(v)) on recolor and O(sum deg) on Kempe component, avoiding full-edge scans.\"\n\"R_PARAM_TUNING:Set move probabilities: recolor 0.4, Kempe 0.4, class-elim 0.2 when feasible; otherwise recolor 0.6, Kempe 0.4. Increase class-elim probability as stagnation length grows.\"\n\"R_STOPPING:Adopt multi-criteria stopping: time cap, no improvement over I iterations, or successful 3-coloring with zero conflicts; restart with different seeds if stuck > R restarts.\"\n\"R_SEED_CONTROL:Add RNG seeding via other_params to ensure reproducibility and facilitate debugging of stochastic behaviors.\"\n\"R_KNOWN_SOLUTION_CHECK:Integrate early stop if |colors|<=3 and conflicts==0; return immediately to minimize runtime.\"\n\"R_FRAMEWORK_COMPAT:Ensure Heuristic signature matches exactly and avoid any filesystem\/network\/os calls per constraints; keep pure functions; no global state except cached static graph structures.\"","Componentes":{"REPRESENTATION":"List[int] of length 9 where index i in 0..8 corresponds to vertex i+1. Values are positive integers (color labels). Canonicalization: after any move, relabel colors to 1..m by sorting color classes by (class size ascending, then smallest vertex index ascending), and mapping to labels 1..m in that order.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    BIG = 10**12\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    CONFLICT_WEIGHT = 1_000_000  # > |E| (=17), ensures feasibility prioritized\n    return conflicts * CONFLICT_WEIGHT + groups_used\n","NB_CODE":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        # Stable canonicalization by (class size, smallest index)\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    cur = sanitize(solution)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v: int, arr: List[int]):\n        return set(arr[w] for w in adj[v])\n    def dsatur_pick(arr: List[int], prefer_conflict: bool=True) -> int:\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    def kempe_component(start_v: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start_v]\n        seen[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            if arr[x] == a or arr[x] == b:\n                comp.append(x)\n                for y in adj[x]:\n                    if not seen[y] and (arr[y] == a or arr[y] == b):\n                        seen[y] = True\n                        stack.append(y)\n        return comp\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.55:\n        # Guided recolor; avoid introducing new colors when possible\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        neigh = neighbor_colors(v, new_sol)\n        # Evaluate conflicts for each existing color\n        best_cols = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_cols = [c]\n            elif conf == best_conf:\n                best_cols.append(c)\n        candidates = best_cols[:]\n        # Only allow new color if v is in conflict and no zero-conflict option exists\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not present in neighborhood\n        pref = [c for c in candidates if c not in neigh]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.85:\n        # Kempe chain swap\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        a = new_sol[start]\n        colors_present = list(set(new_sol))\n        b_choices = [c for c in colors_present if c != a]\n        if not b_choices:\n            v = start\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, max(1, kmax))\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score b by boundary conflicts after swap, with slight bonus for eliminating a color\n            best_b = None\n            best_score = None\n            for b in b_choices:\n                comp = kempe_component(start, a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == a else a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # simulate counts for elimination bonus\n                counts = {}\n                for i,x in enumerate(new_sol):\n                    col = x\n                    if i in comp:\n                        col = b if x == a else (a if x == b else x)\n                    counts[col] = counts.get(col,0)+1\n                bonus = -0.5 if counts.get(a,0)==0 or counts.get(b,0)==0 else 0.0\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b if best_b is not None else random.choice(b_choices)\n            comp = kempe_component(start, a, b, new_sol)\n            for v in comp:\n                if new_sol[v] == a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = a\n            move_tag = \"kempe-swap\"\n    else:\n        # Feasibility-preserving class-merge attempt if feasible, else conflict-driven recolor\n        # Check feasibility (no conflicts)\n        feasible = True\n        for u,v in edges:\n            if new_sol[u] == new_sol[v]:\n                feasible = False\n                break\n        if feasible and len(set(new_sol)) >= 2:\n            colors = list(set(new_sol))\n            a,b = random.sample(colors, 2)\n            # make a the minority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            ok = True\n            a_vertices = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(a_vertices)\n            for v in a_vertices:\n                # pick lowest-index color not in neighborhood (excluding a)\n                neigh = neighbor_colors(v, new_sol)\n                candidates = sorted([c for c in set(new_sol) if c != a and c not in neigh])\n                if not candidates:\n                    ok = False\n                    break\n                new_sol[v] = candidates[0]\n            if ok:\n                move_tag = \"class-merge\"\n            else:\n                # rollback not kept; choose a small kempe to diversify\n                start = random.randrange(n)\n                a2 = new_sol[start]\n                colset = list(set(new_sol))\n                b_choices = [c for c in colset if c != a2]\n                if b_choices:\n                    b2 = random.choice(b_choices)\n                    comp = []\n                    comp = [start]  # minimal perturb\n                    for v in comp:\n                        if new_sol[v] == a2:\n                            new_sol[v] = b2\n                        elif new_sol[v] == b2:\n                            new_sol[v] = a2\n                move_tag = \"diversify\"\n        else:\n            # conflict-driven recolor\n            if conflict_vertices:\n                v = random.choice(list(conflict_vertices))\n            else:\n                v = random.randrange(n)\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = random.randint(1, kmax)\n            new_sol[v] = best_c\n            move_tag = \"recolor-conflict\"\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","PERTURB_CODE":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def collect_conflicts(arr: List[int]):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    def kempe_swap_from(start: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    sol = sanitize(solution)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        conflicts = collect_conflicts(sol)\n        if conflicts and random.random() < 0.6:\n            # Focused kick on a conflict edge\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                colors = list(set(sol))\n                if len(colors) >= 2:\n                    b_choices = [c for c in colors if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: random Kempe or palette shake\n            start = random.randrange(n)\n            colors = list(set(sol))\n            if len(colors) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                kmax = max(sol)\n                if random.random() < 0.2:\n                    sol[start] = random.randint(1, kmax+1)\n                else:\n                    sol[start] = random.randint(1, kmax)\n    sol = canonicalize(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_CODE_PERF:Full re-eval is O(|E|) per move. Maintain adjacency lists, conflicts per vertex, and color-usage counts to compute delta in O(deg(v)).;E_OBJ_COUPLING_WEAK:Fixed BIG=1000 skews landscape. Use lexicographic objective (min conflicts, then colors) or adaptive penalty lambda that increases when conflicts persist and decreases when feasible.;E_COLOR_CANONICALIZATION_MISSING:Color labels drift and inflate groups_used. After each move, remap colors to a compact range and sort classes by size\/lex order to reduce symmetry.;NB_CODE_FAIL_LOCAL_OPT:Single-vertex random recolor is weak. Add conflict-driven recolor (pick conflicting vertex; assign lowest feasible color), Kempe-chain interchanges, color-class swaps, and class-merge attempts.;NB_COLOR_INFLATION:15% chance to add new color promotes higher k. Forbid adding colors unless stuck with persistent conflicts; prefer moves that reduce or maintain current max color.;NB_LACK_COLOR_REDUCTION:No operator to drop a color. Implement k-reduction: pick a color class; try to recolor its vertices into existing colors via greedy\/kempe; if successful, eliminate the class.;NB_TYPE_MISMATCH:generate_neighbour returns 3-tuple but type hints\/docstring ambiguous. Standardize to return (new_solution, nb_type, move_type) and ensure Heuristic unpacks accordingly.;NB_DOMAIN_AWARENESS_MISSING:Neighbor ignores graph structure. Bias selection by vertex conflict degree (higher priority) and saturation (DSATUR-like) to intensify search.;PERTURB_MISSING:Implement perturbation (e.g., random Kempe-chain of depth d, or recolor t highest-conflict vertices with random admissible colors). Schedule perturbation strength to increase on stagnation.;INIT_WEAK:No constructive start. Use DSATUR\/greedy largest-degree to build a low-k initial solution; optionally start with k=3 attempt then repair.;IO_SAMPLE_LOAD_FAIL:Loader expects str and calls .strip on list. Add type checks: if isinstance(sample, list) return as-is; only parse strings when needed.;HEURISTIC_ACCEPTANCE_POLICY_WEAK:For SA\/ILS, enforce lexicographic acceptance: first reduce conflicts; when conflicts=0, only accept moves that do not increase color count (or accept with very low prob).;TABU_MEMORY_DEFICIENT:In Tabu, store tabu on (vertex,color) assignments; add aspiration when a move reduces conflicts or color count. Add frequency-based diversification to escape cycles.;STOPPING_AND_TRACKING_UNSPECIFIED:Define termination by max iters without improvement and wall-iter cap. Track best feasible (conflicts=0) by minimal colors, and separately best infeasible with minimal conflicts.;PARAM_CONTROL_IN_OTHER_PARAMS_UNUSED:Expose seed, temperature\/cooling, perturb strength, tabu tenure via other_params and actually use them for reproducibility and tuning.;CONSTRAINT_GUARDRAILS_WEAK:Bound colors to <=n. Reject\/penalize moves that create empty color labels gaps; compress after each accepted move to keep groups_used faithful.;E_VALIDATION_EDGE_CASES:Evaluation only checks ints>=1; add guard for excessively large ints (cap at n) and non-list iterables. Return BIG for out-of-range.;DELTA_DATA_STRUCTURES_MISSING:Precompute adjacency list, current conflicts count, and per-color vertex counts; update incrementally on recolor for speed.;K_FIXTURE_PHASE:Implement a two-phase strategy: Phase 1 minimize conflicts under a fixed k; Phase 2 attempt k-1 with repair. Iterate k downward until infeasible.;SCORE_ALIGNMENT:Ensure best_score interprets lower-is-better and Heuristic consistently compares floats; avoid mixing penalties that invert preference.;RANDOMNESS_CONTROL:Use a local RNG seeded from other_params to avoid global random and ensure deterministic runs for testing.;TESTS_MISSING:Add unit tests: (1) known solution yields 3.0; (2) neighbor always changes a value; (3) evaluate penalizes conflicts; (4) k-reduction succeeds on trivial merges.;ERROR_HANDLING:Return original solution when neighbor generation fails; avoid None propagation. Validate input shapes in Heuristic and components before loop.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Heavy penalties for conflicts and invalid inputs.\n    # Graph edges (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return groups_used + conflicts * 1000.0\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution, \"Recolor\", \"SingleIndex\"\n    n = len(solution)\n    new_sol = solution.copy()\n    idx = random.randrange(n)\n    current_colors = set(new_sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Allow exploration: pick from existing colors, with small chance to add a new color\n    if random.random() < 0.15:\n        new_color = max_color + 1\n    else:\n        new_color = random.choice(list(current_colors))\n    # Ensure change\n    if new_color == new_sol[idx]:\n        # pick a different color deterministically if possible\n        choices = list(current_colors)\n        if new_sol[idx] in choices and len(choices) > 1:\n            choices.remove(new_sol[idx])\n            new_color = random.choice(choices)\n        else:\n            new_color = new_sol[idx] + 1\n    new_sol[idx] = new_color\n    return new_sol, \"Recolor\", \"SingleVertexRecolor\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n    n = len(solution)\n    new_sol = solution.copy()\n    steps = random.randint(2, max(3, n \/\/ 2))\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_colors = set(new_sol)\n        max_color = max(current_colors) if current_colors else 1\n        if random.random() < 0.2:\n            new_color = max_color + 1\n        else:\n            new_color = random.choice(list(current_colors))\n        if new_color == new_sol[idx]:\n            # force a different color\n            alt = list(current_colors)\n            if new_sol[idx] in alt and len(alt) > 1:\n                alt.remove(new_sol[idx])\n                new_color = random.choice(alt)\n            else:\n                new_color = new_sol[idx] + 1\n        new_sol[idx] = new_color\n    return new_sol\n","SAMPLE_SOL":[2,3,1,3,2,1,3,3,1]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\",\n\"FEEDBACK\":\"E_EVAL_RUNTIME_TYPEHINTS:typing.List imported but not required; some runners mis-handle typing and raise 'Type List cannot be instantiated'. Remove typing imports and annotations or restrict to builtin list[int]. EVAL_FIX:Drop 'from typing import List' and use def evaluate_solution(solution: list) -> float.\nE_EVAL_OBJECTIVE_LEX:Large 1e6 multiplier is arbitrary and brittle. Use exact lexicographic tuple or strictly separated objective. EVAL_FIX:Return (conflicts, groups_used) and compare tuples externally, or encode as conflicts*INF + groups_used with INF=sys.maxsize\/\/n to avoid numeric tuning.\nE_EVAL_VALIDATION_COST:Full scan validations each call. For iterative methods this is overhead. EVAL_FIX:Precompute edges, adjacency, and reuse; provide incremental delta evaluation for single-vertex recolors.\nE_REPR_CANONIZATION_MISMATCH:Evaluator counts unique colors; neighbor canonizes; other operators might not, causing objective bias from sparse labels. REPR_FIX:Standardize: either always canonize before evaluation or define objective as max(solution) to match k.\nNB_SIGNATURE_TYPE_HINT_BUG:generate_neighbour annotation invalid '-> (\\\"NB_Type\\\",\\\"Movement_Type\\\")' and contradicts return (new_solution, NB_Type, Movement_Type). NB_FIX:Use from typing import Tuple and annotate as Tuple[list,int|str,int|str] or simply return a 3-tuple without bad annotations.\nNB_ADJ_REBUILD:Adjacency rebuilt every call. NB_PERF_FIX:Hoist adjacency\/edges to module-level constants reused across calls.\nNB_MOVE_WEAK_CONFLICT:Single-vertex greedy recolor with smallest feasible color biases to local traps and cycling. NB_IMPROVE:Use DSATUR-like choice (max saturation, then degree), randomized tie-breaking, and evaluate best among candidate colors; optionally use min-conflicts with soft tabu tenure.\nNB_COLOR_REDUCTION_LIMITED:Only tries recolor from max color one vertex. NB_IMPROVE:Attempt multi-vertex Kempe chain interchange, recolor entire max color class, or try merge of two color classes via bipartite check on induced subgraph.\nNB_CANONIZE_SIDE_EFFECTS:Canonizing every neighbor obscures move identity and can break tabu attributes. NB_FIX:Defer canonization to post-iteration or only when conflict-free; maintain stable color IDs during conflict resolution.\nNB_RANDOMNESS_CONTROL:No RNG seeding parameter; reproducibility impossible. NB_FIX:Accept rng or seed in other_params and use random.Random instance.\nNB_FAILURE_INVALID_INPUT_PATH:On invalid input returns original solution but still tags as movement. NB_FIX:Return explicit NoOp with unchanged solution and NB_Type='NoOp', Movement='InvalidInput' to avoid false improvements.\nPERTURB_MISSING:$Perturb placeholder; no perturbation provided. PERTURB_FIX:Implement e.g., random k-vertex recolor, color-class shuffle, or multi-swap; ensure it preserves validity checks and exposes strength parameter.\nHEURISTIC_MISSING:Required Heuristic(...) not provided. HEUR_FIX:Implement SA\/ILS\/TS compatible Heuristic wrapper using given neighbor\/evaluator\/perturb hooks with cooling\/perturb\/acceptance, honoring 'less is better'.\nSAMPLE_EVAL_FAILURE:Runner error 'Type List cannot be instantiated' indicates environment tries to instantiate typing.List. ENV_FIX:Eliminate typing usage in code blocks; use builtin types only.\nOBJ_K_INFERENCE:Evaluator minimizes number of unique colors; if labels are sparse, k may be overstated. OBJ_FIX:Use k = max(solution) after optional canonization to align with chromatic number.\nEDGE_CONSTANT_DUP:Edges declared in both eval and neighbor, risk of drift. CONST_FIX:Define EDGES and ADJ as single shared constants to avoid inconsistency.\nDELTA_EVAL_OPPORTUNITY:Current neighbor recomputes conflicts from scratch. DELTA_FIX:Maintain per-vertex color counts to compute delta in O(deg(v)) for recolors.\nTABU\/INTENSIFY_ABSENT:No memory or intensification; high chance of cycling. IMPROVE:Integrate tabu tenure on (vertex,color), aspiration by best, and periodic color reduction attempts triggered by plateau length.\nCOLOR_ORDERING_STATIC:Always picks smallest feasible color; poor diversification. IMPROVE:Choose color with minimal projected conflicts and minimal class size to encourage balanced classes; random tie-break.\nVALIDITY_BOUND:Evaluator allows colors up to n; unnecessary. IMPROVE:Set upper bound to a small k_max (e.g., 4 or 5 here) or dynamically track max_color to constrain search.\nMOVE_RETURN_TYPES:NB returns string labels; downstream may expect enums or ints. IMPROVE:Standardize NB_Type\/Movement_Type to small ints for faster logging and compatibility.\nTEST_COVERAGE_GAP:No unit tests for edge\/conflict counting and neighbor moves. IMPROVE:Add tests on known solution [3,1,2,1,3,2,1,1,2] expecting score 3; add conflict-injected cases to validate conflict-driven recolor reduces conflicts.\nPERF_SCALING:O(|E|) per neighbor limits scalability. IMPROVE:Cache conflict counts, use event-driven updates, and restrict candidate vertices to conflict frontier queue.\nACCEPTANCE_POLICY_ABSENT:Heuristic wrapper not provided; neighbor alone cannot solve. IMPROVE:Implement simulated annealing with geometric cooling and reheats or ILS with kick perturbation and variable-depth descent.\nOUTPUT_CONSISTENCY:Return labels and use across components are inconsistent. IMPROVE:Define a shared dataclass-free constants block and avoid from typing usage to meet environment constraints.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Lexicographic objective via large penalty multiplier:\n    # primary: minimize edge conflicts; secondary: minimize number of colors.\n    # Returns BIG for invalid inputs.\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000_000_000.0\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1 or x > n:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic: conflicts dominate\n    return conflicts * 1_000_000.0 + float(groups_used)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Domain-aware neighbor: conflict-driven recolor if conflicts exist; otherwise color-reduction attempt.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution, \"Recolor\", \"NoOpInvalidInput\"\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        # Map colors to compact range 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a conflicting vertex with highest conflict degree (break ties randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Try smallest feasible color within current max_color\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden]\n        if feasible:\n            chosen = feasible[0]\n        else:\n            # No feasible within current palette; pick a random existing color different from current\n            palette = [c for c in current_colors if c != new_sol[v]] or [new_sol[v]]\n            chosen = random.choice(palette)\n        new_sol[v] = chosen\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: attempt to reduce max color by recoloring a vertex of the highest color\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        # Indices of vertices with max_color\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[v] = feasible[0]\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak that prefers lower colors but keeps within current palette\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                # Prefer the smallest non-forbidden if available else random palette color\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_sol[v] = feasible[0]\n                else:\n                    new_sol[v] = random.choice(palette)\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ColorReductionSingleVertex\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex perturbation: recolor a subset of vertices, prioritizing those that would be in conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Identify conflict degrees\n    conflict_deg = [0]*n\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    # Select t vertices: prioritize highest conflict; if no conflicts, random vertices including some from max color class\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    # If no conflicts, bias towards max color class to encourage palette reduction\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(set(new_sol))\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices with random feasible colors within current palette when possible\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick any different color from palette\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n    new_sol = canonize_colors(new_sol)\n    return new_sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_PARSE_BUG_EVAL:Function evaluate_solution.parse uses isinstance(solution, list) instead of isinstance(sol_str, list). Fix variable name to avoid always-false branch and potential misparsing.\nI_API_MISMATCH_NB:generate_neighbour returns 3-tuple (sol, NB_Type, Movement_Type) but SA\/ILS\/TS expect 1- or 2-tuples. Standardize to single return new_solution or update all heuristics to unpack consistently.\nI_API_MISMATCH_HEUR:Provided SA\/ILS\/TS signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement wrappers or refactor to unified Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nI_PERTURB_MISSING:Perturbation Function is placeholder ($Perturb). Implement concrete perturb_solution (e.g., k-vertex recolor on max-color class, Kempe-chain shake, or color class swap).\nE_TS_EVAL_UNPACK:Taboo_Search error 'cannot unpack non-iterable int' indicates it expects a tuple from evaluate_solution. Enforce scalar float fitness across all heuristics or adapt TS to handle scalar.\nE_SA_ILS_UNPACK:SA\/ILS 'too many values to unpack' shows hardcoded unpacking of generate_neighbour. Modify heuristics to accept either single solution or (solution, meta) with robust handling; prioritize consuming only the solution string.\nE_CONSISTENCY_SCORING:Heuristics must treat lower-is-better fitness. Verify no negation\/maximization is applied; remove any inversion to avoid selection errors.\nE_MOVE_OP_INERT:generate_neighbour DSATUR branch computes forbidden but ignores it when selecting best color; selection based solely on conflict count can reassign to same-conflict color. Enforce strict avoidance of forbidden colors and prefer colors with zero conflicts.\nE_NEW_COLOR_DEAD_CODE:Branch 'allow expanding palette by 1' never activates (best_c is never None). If expansion intended for feasibility, explicitly consider max_color+1 when all candidates yield conflicts worse than current.\nE_PLATEAU_ESCAPE_WEAK:Fallback random tweak lacks guidance; add Kempe chain move, color swap, and random-recolor only among feasible colors to reduce neutrality.\nE_COLOR_REDUCTION_LOCAL_OPT:Single-vertex recolor from max class may stall. Add multi-vertex recolor, greedy recolor of entire max-color class, and class merge attempts to force k reduction.\nE_DELTA_EVAL_ABSENT:Each neighbor triggers full conflict recomputation. Implement delta evaluation tracking per-vertex conflict counts to get O(deg(v)) updates.\nE_INIT_SOLUTION_MISSING:No constructive heuristic provided. Add DSATUR\/Greedy sequential coloring to seed feasible 3-color solutions quickly, improving convergence.\nE_STOPPING_CRITERIA_UNSPECIFIED:Heuristics lack termination controls aligned with conflicts->k lexicographic goal. Add hierarchical acceptance: first drive conflicts to zero, then only accept non-increasing k; define max iters\/time.\nR_REPR_NORMALIZE:Normalize\/validate input strings once; store as tuple[int] internally to avoid repeated parse\/encode overhead in hot loops.\nR_TABU_MEMORY_SPEC:Tabu list must store move attributes (vertex,color) rather than full solutions for memory efficiency; use aspiration based on better fitness.\nR_ACCEPTANCE_FUNC:For SA, temperature schedule and acceptance must act on scalar fitness; calibrate initial temp using fitness variance over sampled neighbors to avoid premature freezing.\nR_CONSTRAINT_SAFETY:Ensure all code avoids filesystem\/network\/OS calls per MAIN_CRITICAL_INSTRUCTION; remove sys.maxsize dependency if portability issues arise, or freeze BIG as a large literal.\nR_TEST_FIXTURE:Add unit tests: (1) parsing lists\/strings, (2) neighbor return type, (3) evaluation of known optimal [3,1,2,1,3,2,1,1,2] -> 3. Verify no conflicts get fitness < BIG and conflicts produce BIG-scale penalties.\nR_MOVE_SET_AUGMENT:Include swap-colors, move-to-lowest-feasible, and ejection chains to escape deep local minima; prioritize moves reducing max color cardinality.\nR_TIEBREAK_OBJECTIVE:When conflicts equal, break ties by minimizing future max color increase and degree-based priority (higher-degree vertices first).\nI_LOGGING_MINIMAL:Add lightweight counters only (iterations, accepted, improved) to avoid overhead; avoid heavy structures in hot path.\nI_COMPAT_UNIFIED_INTERFACES:Define strict interfaces: generate_neighbour(solution)->solution_str; evaluate_solution(solution)->float; perturb_solution(solution)->solution_str. Pass meta only via optional debug hooks, not return values.\nE_RESULT_REPRODUCIBILITY:Randomness uncontrolled. Inject seed in other_params and thread through RNG usage to enable reproducible runs.\nR_PALETTE_COMPACTION:After reaching zero conflicts, run deterministic compaction loop attempting to reassign max-color vertices greedily; if success reduces k, repeat; else perturb then retry.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1","EVAL_CODE":"import sys\n\ndef evaluate_solution(solution):\n    # Accepts string encoding: space or comma separated integers of length 9\n    # Returns float fitness: lower is better. Lexicographic (conflicts, k=max color)\n    # Strictly self-contained: embeds problem data\n    BIG = float(sys.maxsize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(solution, list):\n            return list(solution)\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None:\n        return BIG\n    if len(arr) != n:\n        return BIG\n    for x in arr:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Dominant objective\n        return float(conflicts) * (sys.maxsize \/\/ 32)\n    # Secondary: minimize number of colors; use k = max color to avoid sparse label bias\n    k = max(arr) if arr else 0\n    return float(k)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, NB_Type, Movement_Type)\n    # Domain-aware: conflict-driven recolor else color-reduction attempt\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\", \"InvalidInput\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a vertex with maximum conflict degree (tie-break randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Attempt DSATUR-like recolor: choose color minimizing resulting conflicts; prefer smaller color id\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        # Candidate colors within current palette plus possibly a new color (max_color+1) as last resort\n        candidate_colors = list(range(1, max_color + 1))\n        if not candidate_colors:\n            candidate_colors = [1]\n        best_c = None\n        best_conf = 10**9\n        for c in candidate_colors:\n            conf = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and (best_c is None or c < best_c)):\n                best_conf = conf\n                best_c = c\n        # If all within-palette colors conflict equally and equal to degree, allow expanding palette by 1\n        if best_conf > 0 and (max_color + 1) not in candidate_colors:\n            # only if current color also conflicts, try new color\n            best_c = best_c if best_c is not None else (max_color + 1)\n        new_sol[v] = best_c if best_c is not None else new_sol[v]\n        return encode(new_sol), \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: try to reduce palette by moving from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                # Choose smallest feasible to encourage palette compaction\n                new_sol[v] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak to escape plateaus\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[v] = random.choice(feasible)\n            elif palette:\n                new_sol[v] = random.choice(palette)\n        return encode(new_sol), \"Recolor\", \"ColorReductionSingleVertex\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex perturbation: recolor a subset of vertices prioritizing conflicts or max color class\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # choose t vertices\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","SAMPLE_SOL":"1 2 3 1 2 3 2 1 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; Vertices are 1..9 mapped to indices 0..8 internally.","Componente":null,"Version":3,"Feedback":"\"COMPONENT_VERSION\": \"1.0\"\n\"FEEDBACK\": \"E_OBJ_SCALING:Using BIG=1e9 couples objectives via floating penalty; risks temperature miscalibration and numeric masking. Use strict lexicographic objective (conflicts, k) with tuple compare to avoid tuning artifacts.; E_EVAL_COMPLEXITY:Full recomputation each step. Implement delta-evaluation for single-vertex recolor using adjacency to update only affected edges O(deg) instead of O(|E|).; E_PARSE_ROBUSTNESS:Silent fallback to inf hides root causes. Return structured error codes for length\/invalid types to surface failures during heuristic runs.; NB_SCOPE_LIMITED:Only single-vertex recolor limits escape from plateaus. Add Kempe-chain two-color component swaps and color-class swaps to enable non-local moves.; NB_EXPAND_PALETTE:Conflict-driven step may introduce new color increasing k without bounds. Enforce cap at current max_color and rely on Kempe moves or temporary aspiration to resolve conflicts; if expansion allowed, track and immediately trigger reduction phase.; NB_COLOR_REDUCTION_WEAK:Single move from max class then break may miss reducible vertices. Iterate through shuffled max_class and attempt multiple moves per step or greedy pass until no move.; SYM_COLOR_LABELS:Color symmetry unaddressed, causing duplicate states. Add canonical relabeling (e.g., remap colors to 1..t by first occurrence) after each move to reduce search space and improve tabu hashing.; INIT_CONSTRUCTIVE_MISSING:No constructive seeding. Add DSATUR\/greedy saturation initializer to produce low-conflict or 3-color candidate, accelerating convergence.; RAND_REPRODUCIBILITY:Unseeded randomness impedes diagnostics. Accept rng\/state in other_params and seed locally; expose MoveLabel with more detail to enable analysis.; OBJ_INTERFACE:Heuristics expect lower-is-better floats; mixing penalties with BIG impairs SA\/ILS temperature setting. Provide evaluate_solution_lex returning (conflicts, k) and a wrapper that maps to scalar via lexicographic compare in the heuristic core, not via BIG.; SA_ILS_RESULT_INF:inf indicates invalid solutions propagated or neighbor tuple mishandled. Ensure heuristics unpack generate_neighbour return as (sol, label) and validate evaluation != inf before acceptance.; TS_SIGNATURE_MISMATCH:Tabu Search signature does not match TARGET_HEURISTIC_GENERAL_SIGNATURE; also uses separate taboo params. Refactor to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb,other_params) and move taboo config into other_params.; TABU_MEMORY_DEFINITION:No definition of tabu attributes. Use tabu on (vertex,color) with tenure, aspiration on improved (conflicts,k), and short-term frequency-based diversification.; ACCEPTANCE_CRITERIA:No explicit acceptance for equal-cost moves; risk cycling. Add tie-breaking toward reduced k, fewer distinct colors, or recency-based diversification.; PERTURB_MISSING:$Perturb undefined. Provide perturbation that applies few Kempe interchanges or random recolors on max color class to escape local minima; intensity adaptive to stagnation.; TEMP_SCHEDULE:For SA, temperature not calibrated to move cost scale due to BIG penalties. Use objective as (conflicts,k) with staged SA: Stage 1 minimize conflicts only, Stage 2 reduce k given conflicts=0.; TERMINATION_AND_RESTARTS:No restart logic. Add ILS with bounded time per basin, record best, and restart from DSATUR + randomized tie breaks.; MOVE_LABEL_TELEMETRY:Labels too coarse. Emit (type, vertex, old->new, delta_conflicts, delta_k) to enable parameter tuning and debugging.; CONFLICT_VERTEX_SELECTION:Using max conflict degree only. Break ties by higher saturation degree, then degree, to prioritize impactful vertices.; FEASIBILITY_CHECK:Color-reduction phase allows recolor that may reintroduce conflicts when palette non-feasible fallback triggers. Enforce feasibility in reduction phase; if none feasible, attempt Kempe swap before random tweak.; COLOR_CAP_STRATEGY:Once conflict-free, fix target_k = max_color-1 and search within palette 1..target_k using guided moves; only accept steps that keep conflicts=0 to ensure monotonic k reduction.; LOCAL_BUNDLE_MOVES:Add multi-vertex recolor within an independent set or move entire small max color component to feasible lower colors to accelerate k drop.; DELTA_DATASTRUCTURES:Maintain per-vertex color counts among neighbors to compute delta conflicts in O(1) per candidate color; update incrementally after moves.; ASPIRATION_CRITERIA:Allow tabu override if move yields lex-better objective; strictly forbid worsening conflicts when conflicts=0 unless in perturbation mode.; NORMALIZE_RETURN_TYPES:Ensure generate_neighbour returns same representation type as accepted by evaluate_solution; avoid string encoding overhead by using list[int] internally and encode only at API boundaries.; STAGNATION_DETECTION:Track no-improvement iterations; trigger perturbation or increase diversification when threshold exceeded.; TEST_COVERAGE:Add unit tests: known 3-coloring => score 3; any equal-colored adjacent pair => BIG or conflicts>0; neighbor never returns infeasible type; tabu respects tenure.; PERFORMANCE_LOGGING:Record objective trajectory, k over time, conflict counts, and move acceptance ratios to detect premature convergence and parameter misfit.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; Vertices are 1..9 mapped to indices 0..8 internally.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Self-contained evaluation for the specified 9-vertex graph coloring\n    # Returns float fitness: lower is better.\n    # Primary objective: minimize number of edge conflicts (dominant, large penalty per conflict)\n    # Secondary objective: minimize max color id (k)\n    BIG = 1_000_000_000.0  # Large penalty multiplier per conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return conflicts * BIG\n\n    # No conflicts: minimize max color id (k)\n    k = max(arr) if arr else 0\n    return float(k)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_str, MoveLabel), where MoveLabel in {\"Recolor-ConflictDriven\",\"Recolor-ColorReduction\",\"NoOp\"}\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven single-vertex recolor aiming to reduce local conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        # Try colors within current palette first\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                # evaluate keeping same color only if needed for tie-break\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        # If all within-palette choices collide, consider expanding by one color\n        if best_conf > 0:\n            c = max_color + 1\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_color = c\n                best_conf = conf\n        new_sol[vtx] = best_color\n        return encode(new_sol), \"Recolor-ConflictDriven\"\n    else:\n        # No conflicts: try to reduce the maximum color id by moving vertices from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Feasible tweak within palette to create opportunities\n            vtx = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = random.choice(feasible)\n            elif palette:\n                new_sol[vtx] = random.choice(palette)\n        return encode(new_sol), \"Recolor-ColorReduction\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake to escape local minima\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # Select t vertices biased to conflicts; if none, bias to max color class\n    t = max(2, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices to random feasible colors within current palette; if none, random within palette\n    max_color = max(new_sol)\n    for v in chosen[:t]:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","SAMPLE_SOL":"1 2 3 1 2 3 2 1 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; vertices 1..9 mapped to positions 1..9 in the list.","Componente":null,"Version":4,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"E_OBJ_INCONSISTENCY:EXPECTED SCORE FROM KNOWN SOLUTION=3 conflicts with evaluate_solution returning 0.003 for k=3; clarify metric display vs internal objective to avoid misinterpretation.\nE_MISSING_COMPONENT:Perturbation Function undefined ($Perturb placeholder); add concrete perturb_solution to enable ILS\/SA escape from local minima.\nE_TS_SIG_MISMATCH:Tabu Search signature deviates from TARGET_HEURISTIC_GENERAL_SIGNATURE; remove parentheses in parameters and conform to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_API_CALLING_ERROR:Heuristic caller attempts to unpack non-iterable int (TS error message); standardize return types to (new_solution,new_best,new_best_score,meta) or use the provided general signature consistently.\nE_DUPLICATED_GRAPH_DATA:Edges and parse\/encode duplicated across components; centralize constants\/helpers to prevent drift and reduce maintenance risk.\nE_NEIGH_MOVE_WEAK:Conflict-driven move only recolors one vertex and never allows temporary palette expansion; introduce Kempe-chain swaps and 2-color local repairs to escape plateaus.\nE_COLOR_REDUCTION_GREEDY_SHORT:Color reduction tries a single feasible move from max color class; implement iterative elimination heuristic (try moving all vertices of max class, then drop class) per pass.\nE_NO_DELTA_EVAL:Each neighbour recomputation scans incident edges repeatedly; implement delta evaluation O(deg(v)) and return move delta to avoid O(|E|) rescoring.\nE_CANONICALIZATION_SIDE_EFFECT:Canonicalize after every move can disrupt memory\/tabu and hinder move reversal detection; restrict canonicalization to logging or when comparing solutions.\nE_DIVERSIFICATION_WEAK:Diversify step is random feasible recolor within palette, likely cycling; add strategic oscillation, ejection chains, or target freeing neighbors of max color to facilitate class elimination.\nE_NO_OP_STAGNATION:Frequent NoOp when reduction not possible; add perturb_solution (multi-vertex shake, randomized Kempe chain) and adaptive restarts.\nE_REPRODUCIBILITY:RNG not externally seeded; pass rng\/state via other_params to ensure deterministic runs when needed.\nE_ENCODING_OVERHEAD:String encode\/decode on each step adds overhead and GC churn; use list representation internally and only stringify at I\/O boundaries.\nE_TABU_DESIGN:Missing tabu attributes (tenure, aspiration, memory of color-class moves); implement tabu on (vertex,color) with aspiration based on conflicts-first then k.\nE_MOVE_SCOPE_LIMITED:Only recolor moves; add color-class merge attempts, swap of two colors in a subgraph, and greedy recolor ordering by saturation degree (DSATUR-inspired).\nE_INIT_STRATEGY:No construction heuristic; seed with DSATUR or greedy coloring to start near k=3 region, reducing SA\/ILS warm-up.\nE_TIE_BREAKING:Conflict-driven recolor picks smallest-color tie arbitrarily; prefer color minimizing future conflicts (estimate via neighbor colors\u2019 degrees) or use break ties by minimum increase in saturation of neighbors.\nE_TERMINATION:No clear stopping criteria based on no improvement or fixed budget; define max_iters, max_no_improve, and early stop on conflicts==0 and k==3.\nE_SCORING_PRECISION:Using 1\/1000 tie-break may collide if scaled; prefer tuple objective (conflicts,k) in control logic and only map to float for logging if required.\nR_PERTURB_ADD:Implement multi-vertex Kempe chain perturbation with bounded length L and acceptance if conflicts do not explode; use adaptive L when stagnating.\nR_DELTA_CACHE:Add adjacency lists and color counts per vertex to cache; maintain for O(1) feasibility checks and O(deg) delta conflict updates.\nR_CLASS_ELIM_CYCLE:Implement cycle: pick max color t, attempt to recolor its vertices via feasible colors < t using order by descending degree; if all moved, decrement palette.\nR_KEMPE_IMPLEMENT:Add Kempe chain interchange between two colors to reduce conflicts without increasing k and to free vertices from max color class.\nR_DSATSATUR_LOCAL:When conflicts>0, select vertex by highest conflict degree then highest saturation; examine candidate colors by minimal new conflicts.\nR_TABU_PARAMS:Set tabu_tenure=\u2308\u03b1\u00b7deg(v)\u2309 with \u03b1\u2208[1,2], list size bounded; aspiration if move yields better (conflicts,k) than best_score.\nR_SA_SCHEDULE:For SA, use temperature on conflicts primarily; accept k-increasing moves only when conflicts decrease or under controlled probability.\nR_LOGGING_MINIMAL:Track only (conflicts,k,best_k_iterations) and move labels; avoid heavy string states to keep overhead minimal.\nR_INTERFACE_CONSISTENCY:Ensure generate_neighbour returns (solution,label) and all heuristics expect and propagate labels; evaluation returns tuple (conflicts,k) for control, float only for external compatibility.\nR_TESTS:Add unit tests: verify known solution scores 0 conflicts and k=3; verify neighbor does not produce invalid colors; verify perturb can escape constructed traps.\nR_EXPECTED_SCORE_LABEL:Replace EXPECTED SCORE FROM KNOWN SOLUTION with EXPECTED_K=3 to eliminate ambiguity with evaluate_solution\u2019s float objective.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; vertices 1..9 mapped to positions 1..9 in the list.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Evaluate coloring for the fixed 9-vertex graph; lower is better.\n    # Objective: lexicographic (conflicts, k). Mapped to float as conflicts + k\/1000 to ensure conflicts dominate.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors to 1..t by first occurrence order to reduce symmetry\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest conflict vertex, recolor to minimize incident conflicts, no palette expansion\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: try to reduce max color by moving vertices from the highest color class to feasible lower colors\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Try a benign recolor within palette that keeps conflict-free if possible\n            # Pick a random vertex not in singleton color class to diversify\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex feasible-biased shake without introducing new colors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose t vertices biased by conflicts; ensure at least 3 perturbed\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","SAMPLE_SOL":"1 2 3 1 2 3 2 1 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Componente":null,"Version":5,"Feedback":"\"COMPONENT_VERSION\":\"1\"\n\"FEEDBACK\":\"OBJ_MISALIGN:EXPECTED SCORE FROM KNOWN SOLUTION is 3 but evaluate_solution returns conflicts + k\/1000; for [3,1,2,1,3,2,1,1,2] score is 0.003. Fix scoring docs, acceptance checks, and any success criteria using absolute value 0.003, not 3.\nNB_MOVE_SET_LIMITED:Neighbour only performs single-vertex recolors within current palette; lacks Kempe-chain moves, vertex swaps, and color-class merges. Add 1-1 swaps, 2-opt Kempe-chain interchanges, and class-merge attempts to escape plateaus.\nNB_CODE_FAIL_STAGNATION:Conflict-driven recolor may return effectively NoOp if no color reduces conflicts; also limits to existing colors. Allow temporary +1 color when stuck, or force-change to least-conflicting color with tie-breaking by highest saturation.\nNB_COLOR_REDUCTION_WEAK:Color reduction tries one vertex from max color class then stops. Implement full pass over the class using DSATUR ordering and try recoloring all vertices; attempt merging max color into lower colors via bipartite checks\/Kempe chains before giving up.\nNB_DIVERSIFICATION_INADEQUATE:Diversification recolors a single vertex within palette; weak for escaping local minima. Add multi-vertex perturbation (e.g., random Kempe-cycle flips on 2\u20134 vertices) and periodic large kicks.\nTABU_INVARIANCE_BROKEN:Canonicalize changes color labels post-move, breaking vertex-color tabu memories. Use permutation-invariant tabu attributes (e.g., tabu on vertex adjacency patterns or on unordered color-class IDs) or canonicalize before tabu bookkeeping uniformly.\nCANONICALIZE_SIDE_EFFECTS:Post-move canonicalization may mask neutrality\/NoOp moves and confuse acceptance logs. Normalize both current and candidate before evaluation and equality checks; log moves using vertex sets, not color IDs.\nRNG_REPRODUCIBILITY:random used without seeding. Accept seed via other_params and seed both Python and NumPy RNGs for reproducible runs.\nPERF_OVERHEAD:Adjacency is rebuilt on every neighbour call. Precompute adj and edges once and pass via other_params to cut O(|E|) overhead per move.\nPERTURB_MISSING:$Perturb placeholder; perturb_solution is undefined. Implement perturb as multi-vertex kick: pick t vertices in highest-conflict or max-color classes, apply Kempe-chain flips or introduce one new color then immediate reduction.\nSIGNATURE_MISMATCH_TS:Taboo_Search expects def TS(..., generate_neighbour(), evaluate_solution(), ...), not function refs, causing call\/return errors. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE with function references, not invoked functions.\nHEURISTIC_RETURNS_INVALID:SA\/ILS output (123123213, inf, ...) indicates not evaluating solutions and not returning parsable solution strings. Ensure returns are (best_solution_str, best_score_float, best_meta) with finite scores from evaluate_solution.\nACCEPTANCE_CRITERIA_UNDEFINED:SA lacks explicit \u0394-based acceptance and cooling; ILS lacks local search depth\/acceptance rules. Define SA with T0, alpha, stopping at Tmin; accept exp(-\u0394\/T). ILS: apply best-improvement descent to local optimum, perturb, accept if best improves or with probability based on \u0394.\nTABU_PARAMETERS_WEAK:No tabu attributes\/durations defined; aspiration missing. Use tabu on (vertex, color) moves, tenure in [7,15], aspiration if move beats global best.\nFEASIBILITY_REPAIR_MISSING:When conflicts>0, no dedicated repair heuristic beyond single recolor. Add reparation loop minimizing conflicts via steepest descent using saturation degree and Kempe flips until conflicts=0 before attempting k-reduction.\nSTOP_CRITERIA_UNSPECIFIED:Add max_iterations, max_no_improve, and early-stop when conflicts=0 and no further reduction feasible for k. Implement outer loop that decrements target k and restarts search.\nREPRESENTATION_GUARDRAILS:Currently allows unbounded color growth if perturb introduces colors. Constrain max color to k_target+1 during search; shrink aggressively after repairs.\nMETRICS_LOGGING_ABSENT:No trace of best score, conflicts, k, or move types. Log per-iter (conflicts, k, \u0394, move_label) for debugging and tuning.\nTEST_VALIDATION_MISSING:Add unit tests: (a) edges mapping equals problem E; (b) evaluate_solution(known_solution)==0.003; (c) neighbour never returns invalid length\/labels; (d) canonicalization preserves conflict count.\nCOOLING_SCHEDULE_DEFAULT:For SA, define robust schedule (e.g., T0 based on 95th percentile \u0394, alpha\u2208[0.90,0.99], reheating on stagnation) to prioritize conflict elimination then k-reduction.\nMOVE_SELECTION_HEURISTIC:Conflict-driven vertex pick uses max conflict only; refine with DSATUR tie-breakers (higher saturation, higher degree) to prioritize impactful recolors.\nRETURN_NOOP_HANDLING:Neighbour returns NoOp with unchanged solution; outer heuristics must detect and avoid infinite loops. On NoOp, force diversification or increase perturb strength adaptively.\nOBJECTIVE_SCALING:Penalty k\/1000 may be too small\/large depending on conflict landscape. Verify that any single conflict always dominates any k change; if not, scale to penalty = conflicts*1e6 + k to enforce lexicographic priority conflicts\u2192k.\nSTATE_VALIDATION:Strictly validate that all generated neighbours keep colors>=1 and length=9; discard invalid moves early and resample to prevent evaluation inf.\nSEED_EXPOSURE:Expose and record seed in best_meta for exact reproducibility of best runs.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN_9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest-conflict vertex; recolor within current palette minimizing new conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: attempt color reduction from highest color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Diversification: recolor a random vertex to a feasible alternative within palette\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Multi-vertex shake biased by conflicts; keeps palette size\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose a subset biased by conflicts (at least 3 vertices)\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","SAMPLE_SOL":"1 2 3 1 2 3 2 1 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Componente":null,"Version":6,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"R_REPR_INCONSISTENT:Heuristics emit concatenated int 312132112. Enforce SPACE_SEPARATED_INT_LIST_LEN_9 I\/O; validate and re-encode before evaluation.;E_OBJ_MISMATCH_EXPECTED:Expected score=3 vs current objective=0.003 for k=3. If target is chromatic number, return k when conflicts==0 else conflicts+penalty. Alternatively compute (conflicts, |colors|) lexicographically.;E_CANON_MISSING:Evaluation uses max(arr) without canonicalization, inflating k if gaps exist. Replace k=max(arr) with k=len(set(arr)) or canonicalize inside evaluate_solution.;E_PARSE_FRAGILE:Non-string non-sequence inputs (e.g., int) yield inf, breaking SA\/ILS. Add robust caster for digits-only strings and reject ints with clear error or auto-split by length 9.;NB_SCOPE_COUPLING:Edges duplicated in eval and neighbor risks drift. Centralize graph constants; pass via other_params to both functions.;NB_CODE_DET:Stochastic steps lack seed control. Add seed in other_params and local Random instance for reproducibility.;NB_CODE_PERF:Repeated set constructions in dsatur_key and conflict scans each call are O(m). Cache adj, neighbor color sets, and compute delta conflicts for single-vertex recolors to cut to O(deg).;NB_KEMPE_VALIDATION:kempe_flip lacks improvement check; may return lateral\/degrading moves outside metaheuristic policy. Gate Kempe returns by immediate delta-conflict improvement when in repair phase.;NB_COLOR_REDUCTION_STALL:ColorReduce attempts single-vertex from top class only. Add multi-vertex greedy recolor and sequence Kempe+recolor to fully empty top class in one neighbor generation.;NB_DIVERSIFY_WEAK:Random 1-1 swap is low-impact. Add multi-vertex color permutation within independent sets or random Kempe walk length>1 to escape plateaus.;NB_CANON_OSCILLATION:canonicalize by first occurrence can induce oscillations. Canonicalize by sorted color-class signature to stabilize.;PERTURB_MISSING:$Perturb undefined. Implement e.g., k-step random Kempe flips plus random recolor of top-conflict vertices with capped palette to force exploration.;H_GEN_SIG_VIOLATION:Heuristics (e.g., TS) do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).;TS_API_ERROR:Signature shows function calls in parameters and returns non-iterable int, causing unpack errors. Pass function objects, and return (best_solution,best_score,best_move,meta);SA_ILS_FAIL_INIT:inf scores indicate invalid representation propagation. Sanitize initial\/current solutions via parser+canonicalize before loop, and assert evaluate_solution!=inf.;OBJ_DRIVE_K:Current neighbor focuses on conflicts; k pressure weak once conflict-free. Add explicit move type to attempt palette reduction even with minor temporary conflicts if metaheuristic accepts.;INIT_CONSTRUCT_WEAK:No constructive DSATUR\/greedy initializer. Add DSATUR builder to rapidly reach feasible 3-coloring before improvement.;MOVE_DELTA_EVAL:Heuristics recompute full evaluate_solution each step. Maintain conflicts and per-vertex conflict degrees; update in O(deg) on moves.;CONSTRAINT_ENFORCE:MAIN_CRITICAL_INSTRUCTION satisfied, but add static checks that code contains no filesystem\/network\/os calls before execution.;RESULT_VALIDATION:After each accepted move, assert representation length==9, values>=1, and recompute k=len(set(arr)) for logging consistency.;PARAM_TUNING:Annealing schedule unspecified leading to stagnation. Provide T0, alpha, reheating option, and max non-improving steps in other_params.;STOP_CRITERIA:Use multi-criteria stopping (no improvement window, time\/iter cap, plateau counter) to avoid infinite loops on NoOp-heavy neighborhoods.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN_9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring with conflict-driven recolor,\n    # DSATUR-based color reduction, Kempe-chain swaps, and diversification.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        # Flip the (a,b)-Kempe component containing start\n        target_color = arr[start]\n        if target_color not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            new_arr[v] = a_color if arr[v] == b_color else (b_color if arr[v] == a_color else arr[v])\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair with recolor or Kempe swap\n    if total_conf > 0:\n        # Pick vertex with highest (conflict_deg, dsatur, degree)\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Try recoloring within current palette (steepest descent)\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe-chain swap with each neighbor color to reduce conflicts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change to least-conflicting color (even if not improving)\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction from highest color class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        # DSATUR order to try recoloring into lower palette\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Try Kempe swaps with colors < top to move vertices out of top class\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                if max(trial) <= top:  # keep palette size; reduction may follow in next steps\n                    trial = canonicalize(trial)\n                    if trial != arr:\n                        return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: 1-1 color swap between random adjacent pair if valid\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        # accept if no new conflicts are introduced for u,v\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor within palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake: biased selection + Kempe flips + random recolors.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Choose t vertices: bias to high conflicts then high color index\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Apply a sequence of random Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random recolors within palette; allow temporary use of max_color to diversify\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = [c for c in range(1, max_color + 1)]\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","SAMPLE_SOL":"3 1 2 1 3 2 1 1 2"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Componente":null,"Version":7,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_OBJ_MISALIGNED:Evaluator minimizes conflicts+(k)\/1000, but EXPECTED SCORE FROM KNOWN SOLUTION=3 contradicts objective (should be 0.003). Align metrics and acceptance tests to the evaluator.\\nE_INIT_INVALID:Heuristics returning inf indicate passing invalid solutions to evaluate_solution (wrong length or non-positive ints). Enforce SPACE_SEPARATED_INT_LIST_LEN_9 at all interfaces.\\nE_SIG_MISMATCH:Target heuristic signature is def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) but Tabu Search uses def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration). Remove parentheses in parameters and conform to TARGET_HEURISTIC_GENERAL_SIGNATURE.\\nE_RET_CONTRACT:Reported tuples like (123123213, inf, 123123213, inf) suggest wrong return schema. Standardize to (new_solution,best_solution,best_score,meta) with best_score consistent with evaluator\u2019s scale.\\nNB_CODE_FAIL_NOOP:generate_neighbour returns original unencoded solution on invalid parse (path returns solution,\\\"NoOp\\\"). Always return canonical encoded string to satisfy representation contract.\\nNB_CODE_OVER_RANDOM:Diversification uses unconstrained random swap; high chance of infeasible neighbors and wasted evaluations. Replace with guided swaps using conflict degrees or Kempe-based diversification to reduce expected conflicts.\\nNB_CODE_CANON_TABU_CONFLICT:Color canonicalization relabels classes every step, breaking move attributes for Tabu memory. Use canonicalization consistently across the entire search or switch Tabu attributes to vertex-color pairs invariant to relabeling.\\nNB_LOCAL_OPT_LIMITED:Single-vertex recolor considers only current palette; may stall when local minima require temporary color increase. Add temporary color introduction with immediate reduction via Kempe flips (allow k+1 for escape then reduce).\\nNB_COLOR_REDUCE_GREEDY:Color reduction only targets highest color class with min-feasible color; may miss multi-vertex sequences. Add batch reassignment via greedy recoloring with backtracking or multi-Kempe chains.\\nNB_KEMPE_SCOPE:Kempe flip starts from a single vertex; limited exploration. Add multiple random start vertices per color pair and try alternating BFS\/DFS orders for component discovery.\\nR_STR_INADEQUATE:Representation lacks explicit k bound; exploration drifts in palette size. Add max_colors parameter (target=3) to bias neighbor generation and reduction.\\nPERTURB_MISSING:Perturbation Function is undefined ($Perturb). Implement: (a) multi-vertex Kempe chain perturbation, (b) conflict-class ejection chain, (c) random color class merge then repair.\\nSA_PARAM_UNSET:Simulated Annealing settings absent; observed outputs suggest no temperature schedule. Define T0, alpha, iterations_per_T, and accept worse moves by exp(-delta\/T) respecting evaluator\u2019s small secondary term.\\nILS_WEAK_PERTURB:Iterated Local Search likely restarts without structured perturbation. Use controlled kick: perform r Kempe swaps targeting vertices with highest DSATUR.\\nTS_ATTR_ERROR:Tabu attribute design unspecified; coupled with canonicalization it leads to attribute misses. Use vertex->color tabu list with tenure in steps, aspiration by best_score strictly less.\\nEVAL_TIE_BREAK_SCALE:Penalty k\/1000 may be too small for some metaheuristics\u2019 numeric stability. Use lexicographic handling explicitly or increase separation (e.g., conflicts*1e6 + k) to prevent floating comparison glitches.\\nE_STOP_CRITERION:No termination conditions referenced. Add max_iters, stall_limit on best_score, and time cap for reproducibility.\\nE_SEED_CONTROL:Randomness uncontrolled; results not reproducible. Add seed in other_params and pass a Random instance to neighbor\/perturb to avoid global state.\\nE_START_CONSTRUCTIVE:No constructive initializer. Use DSATUR to build a 3-color feasible start: ensures zero conflicts and accelerates reduction phase.\\nE_VALIDATION_GUARD:Before evaluation, run a fast validator for length=9 and ints>=1 to avoid inf propagation and misleading logs.\\nLOGGING_MINIMAL:Movement_Type strings verbose but not structured. Log as op_code|vertex|from|to to enable automated analysis and Tabu checks.\\nACTION_PLAN:1) Fix signatures\/returns; 2) Implement Perturb; 3) Add DSATUR initializer; 4) Stabilize evaluator metric; 5) Rework Tabu attributes; 6) Guided diversification; 7) Parameterize SA\/ILS; 8) Seed control; 9) Strengthen color reduction with multi-Kempe\/backtracking.\\nTARGET_OUTCOME:Converge to known 3-color zero-conflict solution with best_score\u22480.003 consistently in <1e4 evaluations.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN_9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    # Objective: conflicts + (number_of_colors)\/1000 (minimize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Best recolor within current palette\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe swap\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: swap two vertices' colors if safe locally\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using Kempe flips and recolors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Random Kempe flips among chosen\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","SAMPLE_SOL":"1 2 3 1 2 3 2 1 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Componente":null,"Version":8,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"E_OBJ_SCALE:Penalty for new color is only 1e-3; still lexicographic but encourages temporary palette bloat. Tighten reduction policy or gate allow_new by stagnation or max_color cap.\nE_EVAL_COST:Each call recomputes conflicts O(|E|). Implement incremental delta-evaluation using adjacency to reduce to O(deg(v)) per move.\nE_PARSE_ROBUST:Silent inf on bad input masks bugs. Add strict validation errors in dev mode or return (score,reason) for diagnostics in wrapper (keep pure function for runtime).\nR_REPR_COLOR_CANON:Canonicalize after almost every move O(n). Cache mapping and avoid re-canon where structure-preserving moves don't change color set.\nNB_DATA_STRUCT:Edges used as list; adjacency and edge-set recomputed locally. Hoist adj and edge_set construction out and pass via other_params to avoid O(|E|) overhead per call.\nNB_ALLOW_NEW_COLOR:Unconditionally allow_new=True in repair biases to increasing colors. Restrict to when no recolor with <= current conflicts exists or after T failed repairs.\nNB_CONFLICT_SELECTION:Greedy pick single vertex by (conf_deg, dsatur). Use breakout tie-breaking over multiple top vertices, or min-conflict sampling to diversify.\nNB_KEMPE_LIMIT:Kempe explores only first 3 neighbor colors randomly. Explore all neighbor colors or select by estimated delta-conflict; add time budget not fixed count.\nNB_SWAP_TEST:Non-adjacent swap checks adjacency via tuple in list O(|E|). Use adjacency sets; current check misses paths; consider color swap neighborhoods or pairwise recolor rather than swap.\nNB_DSATUR_SAT:dsatur_key counts all neighbor colors, not saturation in partial assignment sense. For full-color states it becomes degree proxy; replace with count of conflicting colors during repair for better targeting.\nNB_COLOR_REDUCTION:Greedy reassignment uses min feasible color; add saturation ordering and try recoloring whole top color class via sequential DSATUR to maximize eliminations.\nNB_RANDOM_FALLBACK:Random feasible recolor may produce NOOP after canonicalization equals arr; pre-check to skip identity moves; also avoid reusing same move repeatedly by short-term memory.\nNB_CANON_COLLISIONS:Canonical relabel can inadvertently turn distinct neighbors into identical encodings, inflating NOOP. Track move ids or avoid canon when only relabeling within palette is irrelevant to evaluation.\nPERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Provide concrete perturbation: e.g., multi-vertex Kempe chain, randomized kick on highest-degree\/conflict vertices, or color-merge then repair.\nHEUR_SIGNATURE:Ensure Heuristic matches TARGET_HEURISTIC_GENERAL_SIGNATURE exactly; current Tabu implementation signature is mismatched causing unpack error. Standardize all metaheuristics to the shared signature.\nTS_PARAM_DEF:Tabu requires taboo_list_size and taboo_duration but signature must accept other_params dict; move TS-specific params into other_params and parse internally.\nTS_MEMORY:No tabu attribute recorded in neighbor tuple; add move encoding (vertex,color or Kempe pair) and hash solution for aspiration; maintain frequency-based long-term memory for diversification.\nSA_RESULTS_STAGNATE:SA returned identical start and best scores (0.003). Temperature\/cooling likely too aggressive or neighbor too conservative when conflict-free. Introduce reheating and color-reduction-focused neighborhoods at low T.\nILS_ACCEPTANCE:ILS best identical to seed; acceptance likely elitist only. Use perturb-repair with non-improving acceptance (e.g., LAHC or threshold). Increase perturb strength adaptively when no improvement in N iterations.\nOBJ_DRIVE_TO_K:When conflicts=0, drive explicit k-reduction: implement dedicated phase that repeatedly attempts color class elimination (merge highest color into lower via sequence of Kempe\/vertex reassignments) until stuck.\nSEARCH_ORDERING:Use ordering by vertex degree or DSATUR for recoloring attempts globally rather than per-vertex local choices to escape plateaus faster.\nSEED_QUALITY:Fixed seed [1,2,3,1,2,3,2,1,3] biases search; add randomized DSATUR seeding with tie-breaking to diversify restarts.\nRNG_CONTROL:random usage without seed control hurts reproducibility. Thread a rng object via other_params with explicit seed; avoid global random.\nSTOPPING_CRIT:No explicit stopping\/plateau detection included. Add max_evals, stall_limit, and adaptive operator selection (MAB\/ALNS scores) to focus on effective moves.\nMETRICS:Track and return (#conflicts, k, evals, improvements, operator usage) to diagnose operator efficacy; current logging \"Movement_Type\" too coarse.\nKNOWN_SOLUTION_UTIL:Known solution with k=3 exists; add target_k parameter to enable focused k=3 reduction once conflicts=0 with k<=4, and stop early on reaching eval=0.003.\nCOMPATIBILITY:Ensure no function accesses filesystem\/network\/OS; current components respect this\u2014preserve constraint when adding perturbation or logging.\nACTIONABLE_FIXES:\n- Gate allow_new by stagnation_counter>=alpha and max_color<=k_cap; otherwise forbid new colors.\n- Replace edges list with: adj=list-of-sets, edge_set=set; pass via other_params; reuse across calls.\n- Implement delta-eval: maintain current conflicts and per-vertex conflict counts; update in O(deg(v)) for recolor\/swap.\n- Expand color-reduction operator: attempt full recolor of highest color class using DSATUR heuristic; if success and class empty, drop color and canon once.\n- Add Perturbation: pick p vertices from highest color class \u222a highest degree; apply randomized Kempe flips and forced recolors; ensure perturb strength adapts up on stalls.\n- Standardize Heuristic(...) wrapper: unify SA\/ILS\/TS under the required signature; move algorithm-specific params into other_params; fix TS unpack bug.\n- Introduce aspiration in TS and short-term tabu on (vertex,color) assignments; tenure proportional to degree or dynamic.\n- Add reproducible rng: rng=random.Random(seed); pass via other_params and replace random.* calls with rng.*.\n- Implement stall-based operator adaptation: reward operators that lead to improvements; increase their selection probability; demote NOOP producers.\n- Enforce early K-phase: if conflicts==0, switch to reduction-only neighborhoods; if no reduction after R attempts, perform directed perturbation and resume.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN_9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph coloring evaluator\n    # Objective: minimize conflicts + (number_of_colors)\/1000\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator for 9-vertex graph coloring with repair, reduction, and diversification\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Return a valid canonical seed\n        seed = [1,2,3,1,2,3,2,1,3]\n        return encode(seed), \"Init|seed|-|-(valid)\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) Conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        from_c = new_sol[vtx]\n        best_c = from_c\n        best_add_conf = 10**9\n        # Try recolors within current palette first\n        for c in range(1, max_color + 1):\n            if c == from_c:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        # Optionally allow temporary color increase to escape\n        allow_new = True\n        if allow_new:\n            add_conf_new = 0  # new color causes no immediate conflicts\n            if add_conf_new < best_add_conf:\n                best_add_conf = add_conf_new\n                best_c = max_color + 1\n        if best_c != from_c:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"RC|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n        # Kempe swap attempts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != from_c})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:3]:\n            trial = kempe_flip(new_sol, from_c, c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KS|{vtx+1}|{from_c}|{c2}\"\n        # Fallback: force recolor to least conflicting within palette\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"RCF|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n\n    # 2) No conflicts: attempt color reduction from highest class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        # Greedy reassignment to lower colors\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                from_c = new_sol[vtx]\n                to_c = min(feasible)\n                new_sol[vtx] = to_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"CR|{vtx+1}|{from_c}|{to_c}\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KR|{vtx+1}|{top}|{c2}\"\n\n    # 3) Guided diversification: swap colors of two non-adjacent vertices if locally safe\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    for i in range(n):\n        for j in range(i+1, n):\n            u, v = vertices[i], vertices[j]\n            if u == v:\n                continue\n            if new_sol[u] == new_sol[v]:\n                continue\n            # Skip if adjacent\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            cu, cv = new_sol[u], new_sol[v]\n            trial = list(new_sol)\n            trial[u], trial[v] = cv, cu\n            ok = True\n            for w in adj[u]:\n                if trial[w] == trial[u]:\n                    ok = False\n                    break\n            if ok:\n                for w in adj[v]:\n                    if trial[w] == trial[v]:\n                        ok = False\n                        break\n            if ok:\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"SW|{u+1},{v+1}|{cu}|{cv}\"\n\n    # 4) Fallback: random feasible recolor within current palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                from_c = new_sol[vtx]\n                new_sol[vtx] = c\n                new_sol = canonicalize(new_sol)\n                if new_sol != arr:\n                    return encode(new_sol), f\"RD|{vtx+1}|{from_c}|{c}\"\n\n    return encode(new_sol), \"NOOP|-|-|-\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex Kempe-based shake and recolor\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Provide a valid perturbation seed\n        return encode([1,2,3,1,2,3,2,1,3])\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Select t vertices biased to high conflicts\/degree\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], len(adj[i]), -i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:2]:\n            trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n            if trial is not None:\n                new_sol = trial\n                break\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    # Optional class merge: try to eliminate highest color if exists\n    colors = sorted(set(new_sol))\n    if len(colors) > 1:\n        top = colors[-1]\n        verts = [i for i,c in enumerate(new_sol) if c == top]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {new_sol[u] for u in adj[v]}\n            targets = [c for c in colors[:-1] if c not in forbidden]\n            if targets:\n                new_sol[v] = random.choice(targets)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","SAMPLE_SOL":"1 2 3 1 2 3 2 1 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE; solution = [x1,x2,...,x9] with xi>=1 integers representing group labels for students 1..9.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Missing perturbation operator. Add multi-vertex kicks (e.g., Kempe-chain flips, color class swaps, random recolor of a conflicting subgraph) to escape local minima.\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor is too myopic. Add 2-opt-like moves: Kempe chains, pairwise color swaps, and color-class merge\/split to reduce k without conflicts.\nNB_COLOR_INFLATION:Allowing max_col+1 encourages new colors; once feasible, this increases k. Add mode that forbids introducing new colors when conflicts==0 and prioritize color-compaction moves.\nNB_SCOPE_LIMITED:Random single index selection slows convergence. Bias selection toward high-conflict vertices (degree-weighted or DSATUR-driven pick).\nNB_JSON_OVERHEAD:Movement_Type packs full solution JSON each step; heavy and redundant. Encode only delta (index, from, to), compute neighbor solution externally to reduce overhead.\nNB_RETURN_TYPE_ANN:Return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is invalid typing. Use '-> tuple[str,str]' or omit to avoid tooling\/type-checker issues.\nE_EVAL_PENALTY_SCALE:Fixed 100000 penalty can cause plateaus and mis-scaling across neighborhoods. Use lexicographic evaluation (conflicts first, then k), or adaptive penalty that decreases as conflicts drop.\nE_EVAL_TIEBREAK:No secondary criteria among equal k and conflicts. Add tie-breakers: sum of conflicts per vertex (for prospective moves), color-class balance, or max color label to steer compaction.\nE_TYPING_RUNTIME_ERR:'Type List cannot be instantiated; use list() instead' indicates runtime misuse of typing types by the runner or annotations causing eval issues. Remove 'from typing import List' and use built-in 'list' in annotations or 'from __future__ import annotations' to ensure no runtime instantiation.\nSIG_INCOMPLETE:Heuristic function not provided per required signature. Implement 'Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' coordinating construction, local search, and perturbation.\nINIT_CONSTRUCT_WEAK:No construction heuristic provided; random starts degrade performance. Add DSATUR\/greedy coloring to get feasible 3-color solutions quickly.\nCOLOR_COMPACTION_MISSING:No explicit color-reduction phase. Implement iterative color deletion: try to eliminate highest label by recoloring its vertices via BFS\/Kempe chains; if fail, restore.\nSTAGNATION_CTRL:No acceptance\/escape strategy specified. Add SA\/ILS: accept worsening moves with annealing schedule or record-to-record travel; incorporate iteration-based perturbation strength.\nTABU_ABSENT:For tabu search, no tenure\/aspiration. Add short-term tabu on (vertex,color) with aspiration if move improves k or conflicts.\nMOVE_PRIORITIZATION:Local conflicts minimization ignores impact on k. Use multi-criteria move scoring: primary minimize conflicts; if equal, minimize k; then minimize future conflicts (conflicts_if on neighbors).\nREPR_NORMALIZATION:Labels drift and fragment. Periodically relabel colors to a compact [1..k] and sort by class size to stabilize neighborhoods and cache keys.\nNEIGHBORHOOD_DIVERSITY:Single operator reduces exploration. Add: (a) swap two color classes on an induced subgraph, (b) recolor small vertex sets via local ILP or BFS on conflict graph, (c) path recolorings.\nE_CACHE_OMITTED:No caching of conflicts\/DSATUR degrees. Maintain adjacency lists and incremental conflict counts to update O(deg) per move, boosting iteration throughput.\nTERMINATION_CRITERIA:Unspecified stopping conditions. Add hybrid criteria: max evals, no-improvement budget, and early stop when k equals known lower bound (3).\nMETRICS_REPORTING:No logging of k_best, conflicts_best, time-to-feasible. Add lightweight counters to tune parameters and detect stagnation windows.\nKNOWN_SOL_USE:Known optimal k=3 available but unused. Set dynamic target k and run targeted recoloring to achieve k<=target; decrement target when feasible persists.\nTEST_HARNESS:Sample solution evaluation failed in multiple algorithms. Add unit tests for evaluate_solution and neighbor validity; fuzz test neighbors to ensure constraints and signature compliance.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE; solution = [x1,x2,...,x9] with xi>=1 integers representing group labels for students 1..9.","EVAL_CODE":"import random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Lower is better; heavy penalty ensures feasibility dominates\n    return num_groups + conflicts * 100000","NB_CODE":"import random\nimport json\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns two strings: (NB_Type, Movement_Type)\n    # Movement_Type encodes the neighbor solution and move details as JSON string.\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        return (\"InvalidInput\", json.dumps({\"solution\": solution}))\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Helper to count conflicts for a given index with a tentative color\n    def conflicts_if(idx0: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if u-1 == idx0:\n                if color == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx0:\n                if color == arr[u-1]:\n                    cnt += 1\n        return cnt\n    n = 9\n    idx = random.randrange(n)\n    cur_color = solution[idx]\n    max_col = max(solution)\n    candidate_colors = list(range(1, max_col + 2))\n    if cur_color in candidate_colors:\n        candidate_colors.remove(cur_color)\n    # Choose color minimizing new local conflicts (break ties randomly)\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        conf = conflicts_if(idx, c, solution)\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    new_color = random.choice(best_colors) if best_colors else cur_color\n    new_solution = solution[:]  # copy\n    new_solution[idx] = new_color\n    payload = {\n        \"solution\": new_solution,\n        \"move\": {\n            \"type\": \"SingleVertexRecolor\",\n            \"index\": idx+1,\n            \"from\": cur_color,\n            \"to\": new_color\n        }\n    }\n    return (\"SingleVertexRecolor\", json.dumps(payload, separators=(\",\", \":\")))","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return a simple default feasible-typed structure (fallback greedy attempt)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        base = default_solution()\n        return base\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    perturbed = solution[:]\n    max_col = max(perturbed)\n    # Number of vertices to perturb\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = perturbed[idx]\n        # Try colors 1..max_col+1 and pick one minimizing local conflicts; random tie-break\n        best_colors = []\n        best_conf = None\n        for c in range(1, max_col + 2):\n            if c == cur:\n                continue\n            conf = 0\n            for (u,v) in edges:\n                if u-1 == idx:\n                    if c == perturbed[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == perturbed[u-1]:\n                        conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        if best_colors:\n            perturbed[idx] = random.choice(best_colors)\n    return perturbed","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; semantics depend only on equality\/inequality.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\n\"E_OBJ_SCALE_MISMATCH:Known solution expected 3 but evaluate_solution returns 3003. Align objective units. If external expects k, set return = conflicts*10**9 + num_groups (or compress labels so max_label==k and drop *1000).\"\n\"E_TIE_BREAK_BIAS:Using max_label as tertiary tie-break encourages cosmetic relabels. Canonicalize labels to 1..k before scoring or eliminate max_label term to reduce noisy gradients.\"\n\"E_CANONICALIZE:Missing label compaction step. Add relabel(solution)->1..k mapping each evaluation to keep scores stable and aid neighborhood comparability.\"\n\"E_EVAL_COST:O(|E|) per evaluation; acceptable here but wasteful. Use move deltas carried in neighbor payload to compute conflicts and group changes incrementally.\"\n\"NB_API_MISMATCH:generate_neighbour returns (type, json_payload) but heuristics expect a solution or structured delta. Provide adapter or change to return (new_solution, delta) plain Python. Avoid JSON serialization in-core.\"\n\"NB_DELTA_MISSING:Payload lacks explicit conflict\/group delta. Include fields: d_conflicts, d_groups, changed_index, old_color, new_color to enable O(1) re-scoring.\"\n\"NB_CONFLICT_SELECTION:Weights include zero-conflict vertices even when conflicts>0. Restrict sampling to conflicted vertices for stronger descent; fallback to all only if none.\"\n\"NB_LOCAL_OPT:Recolor considers only single-vertex moves; add 2-vertex swap or pair recolor, and expanded Kempe chains to escape plateaus.\"\n\"NB_KEMPE_LIMITED:KempeFlip in feasible phase does not target color elimination. Add ColorClassElimination: pick a color with smallest support and greedily recolor its vertices to existing colors without creating conflicts.\"\n\"NB_NEW_COLOR_POLICY:Allowing new colors only with strict local conflict reduction is good, but add global guard to cap colors at k_best or k_current to avoid drift.\"\n\"NB_RANDOM_STATE:Random usage is implicit. Accept rng object in other_params to ensure reproducibility and deterministic benchmarking.\"\n\"PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Implement: (i) random Kempe flips with targeted color elimination attempts; (ii) multi-vertex recolor of top-conflict vertices; (iii) random color relabel + shake length parameter.\"\n\"HEUR_SIG_MISMATCH:Taboo_Search signature diverges from TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"TS_CALL_ERROR:Error 'too many values to unpack' indicates the heuristic expects generate_neighbour->solution. Fix by unpacking (nb_type, payload) then reading payload['newSolution'] or change generator to return new_solution directly.\"\n\"ILS_OUTPUT_ANOMALY:Iterated_Local_Search returned ('KempeFlip', 1e18, ...). This implies mis-parsed neighbour output and invalid best_score. Enforce consistent minimization semantics and parsing of generator returns.\"\n\"SA_STAGNATION:Simulated_Annealing ended at initial 3003; cooling\/acceptance likely too greedy or neighbor too weak. Increase uphill move allowance early (higher T0), adaptive reheats on stagnation, or widen neighborhood (multi-recolor).\"\n\"INIT_COMPRESS:Before search, remap labels to 1..k and optionally start from greedy DSATUR to reduce k faster than random seeds.\"\n\"MOVE_VALIDATION:Add fast feasibility check for edges incident to changed vertices only; avoid full scan when applying moves.\"\n\"COLOR_CAP:Maintain k_target = current best k and disallow introduction of new colors when conflicts=0 and k_current==k_target.\"\n\"STOPPING_CRITERIA:Introduce dual criteria: no improvement in k for X iterations triggers perturb; no improvement in score for Y iterations triggers reheating.\"\n\"LOG_STRUCT:Standardize move logs as dicts (type, idxs, old_colors, new_colors, d_conflicts, d_groups, new_score) to aid debugging and analytics.\"\n\"UNIT_TESTS:Add tests: (i) evaluation of known solution equals external expectation; (ii) generator preserves validity constraints; (iii) Kempe flip is involutive on component; (iv) color class elimination reduces or preserves k.\"\n\"METRIC_ALIGNMENT:If external scorer is k only, modify evaluate_solution to return conflicts*INF + k and handle feasibility-first acceptance; remove max_label term to prevent misaligned optimization.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; semantics depend only on equality\/inequality.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    max_label = max(solution)\n    # Lexicographic objective: minimize conflicts, then groups, then max label\n    # Scale to maintain strict priority\n    return conflicts * 1_000_000 + num_groups * 1_000 + max_label","NB_CODE":"import random\nimport json\n\n# Neighbor operator: conflict-biased recolor with compaction-aware policy and optional Kempe 2-color flip on demand\n# Returns (NB_Type, Movement_Type) where Movement_Type is a compact JSON delta including newSolution for direct use.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: vertex conflicts count\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Compute total conflicts and per-vertex conflicts\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    max_col = max(solution)\n\n    # Candidate recolor set policy\n    def best_recolor_for(idx, arr, allow_new_color):\n        cur = arr[idx]\n        best_colors = []\n        best_score = None\n        max_allowed = max(arr) + (1 if allow_new_color else 0)\n        for c in range(1, max_allowed + 1):\n            if c == cur:\n                continue\n            # local conflicts if set idx to c\n            conf = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        conf += 1\n            # tie-break: prefer smaller color to aid compaction\n            score = (conf, c)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            return random.choice(best_colors)\n        return cur\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-biased selection: weight by (1 + conflicts)^2\n        weights = [(1 + vc[i])**2 for i in range(n)]\n        # Normalize and sample\n        r = random.random() * sum(weights)\n        acc = 0.0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if acc >= r:\n                idx = i\n                break\n        # Allow introducing a new color only if it reduces immediate local conflicts strictly\n        cur = new_solution[idx]\n        # Evaluate best without new color\n        c_no_new = best_recolor_for(idx, new_solution, allow_new_color=False)\n        # Evaluate with potential new color\n        c_with_new = best_recolor_for(idx, new_solution, allow_new_color=True)\n        # Compute local conflicts for chosen candidates\n        def local_conf(idx, c, arr):\n            cnt = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        cnt += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        cnt += 1\n            return cnt\n        conf_no_new = local_conf(idx, c_no_new, new_solution)\n        conf_with_new = local_conf(idx, c_with_new, new_solution)\n        if conf_with_new < conf_no_new:\n            chosen = c_with_new\n        else:\n            chosen = c_no_new\n        new_solution[idx] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": chosen},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible: compaction-focused move. Try Kempe chain on two colors to enable class merge tendencies.\n        colors = list(sorted(set(new_solution)))\n        if len(colors) <= 1:\n            # trivial; just recolor different index to color 1\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            target = 1 if cur != 1 else (2 if 2 in colors else 1)\n            new_solution[idx] = target\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": target},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        # BFS over subgraph induced by colors {a,b}\n        comp = set()\n        stack = [start]\n        comp_colors = {i: new_solution[i] for i in cand_indices}\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        # Flip a<->b on the component\n        flipped = new_solution[:]\n        for i in comp:\n            flipped[i] = a if new_solution[i] == b else (b if new_solution[i] == a else new_solution[i])\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))","PERTURB_CODE":"import random\n\n# Multi-vertex perturbation combining: (1) random recolors within existing palette, (2) color-class swap,\n# and (3) Kempe chain flip on random color pair. Designed to escape local minima while preserving structure.\n\ndef perturb_solution(solution):\n    # Fallback default if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    n = 9\n    pert = solution[:]\n    colors = sorted(set(pert))\n\n    # Op1: recolor m random vertices to random existing colors minimizing local conflicts (no new colors)\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: color-class swap between two random colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random pair to perturb structure without introducing new colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        comp.add(v)\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    return pert","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; only equality matters. Labels may be non-contiguous; evaluation will canonicalize to 1..k.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_API_SIG_MISMATCH:Tabu\/heuristics must conform to TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses in parameters (no generate_neighbour()). Standardize all calls to pass functions, not results.\nE_NEIGHBOR_UNPACK:Heuristics are using the ('Type',payload) tuple directly. Extract payload.newSolution from JSON to obtain the neighbor solution; ignore the return-type label for evaluation.\nE_PERTURB_MISSING:'Perturbation Function' is placeholder. Implement a concrete perturbation (e.g., k-random-vertex recolor toward random existing colors or a random Kempe-chain flip with k in [2,4]) to enable ILS\/SA escape.\nNB_CODE_FAIL_ELIMINATION_FEAS:Zero-conf check is evaluated against the stale array; simultaneous reassignment can introduce conflicts among reassigned vertices. Apply assignments sequentially with array updates or solve as a local CSP (greedy with backtracking\/branch & bound on the target color class) before committing.\nNB_CODE_COST_HINT_INCORRECT:d_conflicts_hint derives single-vertex counts and is computed after mutation. Compute total delta via adjacency checks before applying the move, or drop the hint to avoid misleading meta-heuristics.\nNB_CODE_PERF:v_conflicts recomputes O(m) per vertex per call. Precompute adjacency lists; compute v_conflicts in O(sum deg)=O(m) and local_conf in O(deg(idx)) to reduce overhead.\nNB_DATA_DUP:Edge set duplicated in multiple components risks drift. Centralize edges in a shared constant imported into evaluation and neighbor generation.\nNB_MOVE_SET_LIMITED:Add swap-color move on a vertex pair and targeted Kempe flips seeded on highest-conflict vertices to diversify search; include color-class merge attempts with limited backtracking.\nE_INIT_POOR:Start from DSATUR\/greedy coloring to reach 3 colors quickly; seeds improve SA\/ILS convergence and reduce time in infeasible space.\nE_EVAL_TIEBREAK:Objective = conflicts*1e9+groups is fine; add secondary tie-break on color-class variance (minimize max class size) to aid elimination stability if needed.\nE_ACCEPTANCE_PROTOCOL:Ensure SA\/ILS compare evaluate_solution costs (lower is better); never accept moves that increase conflicts during feasible phase unless perturbation\/SA temperature explicitly allows.\nTS_SPEC_FIX:Tabu signature must be Heuristic-like. Define taboo keys on (vertex,color) for recolors and (color_a,color_b,component_seed) for Kempe; add aspiration when move improves best_score.\nTS_TENURE_TUNING:Use dynamic tenure ~ [5,10] or proportional to average degree; maintain frequency-based diversification to avoid cycling on 3-color plateaus.\nRANDOM_SEED:Expose other_params.seed for reproducibility; thread it into random module usage.\nLABEL_CANON_FREQ:Canonicalize labels after any color-elimination\/merge to keep palette compact and make subsequent elimination targeting consistent.\nTERMINATION_CRITERIA:Add stagnation limit (no improvement for T steps) and restart via perturbation; cap runtime\/iterations explicitly for stability.\nKNOWN_SOLUTION_USE:Inject known 3-color solution as an elite seed or apply path-relinking between current best and known to accelerate convergence to k=3.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; only equality matters. Labels may be non-contiguous; evaluation will canonicalize to 1..k.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Feasibility-first objective, then minimize k (groups)\n    # Scale to enforce strict priority\n    return conflicts * 10**9 + num_groups\n","NB_CODE":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: per-vertex conflicts with current color\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Helper: local conflicts if idx recolored to c\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict phase: operate on conflicted vertices only\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        # Weighted choice proportional to (1+vc)^2\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = sum(weights)\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Disallow introducing new colors in conflict reduction phase to avoid color drift\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        # Deltas\n        old_vc = vc[pick]\n        new_vc = local_conf(pick, chosen, new_solution)\n        d_conflicts = (new_vc - old_vc)  # each such edge counted once from this vertex perspective; total change is this difference\n        # Group delta\n        d_groups = 0\n        if chosen != cur:\n            if cur not in new_solution:\n                d_groups -= 1\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": cur, \"to\": chosen},\n            \"d_conflicts_hint\": d_conflicts,\n            \"d_groups_hint\": d_groups,\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt color-class elimination\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            # pick smallest color class to try eliminate\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            feasible = True\n            assignment = {}\n            for i in idxs:\n                # choose a color from other_colors that causes zero local conflicts if possible\n                zero_conf = [c for c in other_colors if local_conf(i, c, new_solution) == 0]\n                if zero_conf:\n                    # tie-break by color id to aid compaction\n                    assignment[i] = random.choice(zero_conf)\n                else:\n                    feasible = False\n                    break\n            if feasible:\n                # Apply reassignment\n                for i, c in assignment.items():\n                    new_solution[i] = c\n                # Remove target color label by canonical relabeling\n                # Canonicalize to 1..k\n                mapping = {}\n                next_c = 1\n                for idx in range(n):\n                    v = new_solution[idx]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[idx] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(assignment)},\n                    \"d_conflicts_hint\": 0,\n                    \"d_groups_hint\": -1,\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # If elimination fails or only one color, perform Kempe flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            # trivial recolor to color 1 if needed\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": tgt},\n                \"d_conflicts_hint\": 0,\n                \"d_groups_hint\": 0,\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"d_conflicts_hint\": 0,\n            \"d_groups_hint\": 0,\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Fallback if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random color pair\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k to keep palette compact post-perturb\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Labels arbitrary; only equality matters.","Componente":null,"Version":3,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"H_SIG_MISMATCH:Target heuristic must conform to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Tabu\/SA\/ILS runners violate signature; standardize wrappers.;H_MISSING_COMPONENT:Perturbation Function is undefined ($Perturb). Provide def perturb_solution(sol, intensity, rng) returning a valid LIST_INT_LEN9_POSITIVE.;NB_API_CONTRACT:generate_neighbour returns (type,json_payload) not a neighbor solution. Heuristic likely expects a solution object. Return the neighbor solution directly and expose metadata via a side-channel or structured dict.;NB_INVALID_INPUT_BRANCH:On invalid input returns ('InvalidInput',payload). This breaks downstream. Enforce validation before calls or return (solution, 'NoOp') with a flag to skip.;NB_NULL_MOVE:Branch len(colors)<=1 may return a no-op when cur==1. Force a change: introduce new color or recolor to a different existing color.;NB_CONFLICT_PHASE_LOCAL_OPT:Single-vertex recolor with random weighted pick is weak. Use steepest-descent min-conflicts: for each conflicted vertex, choose color minimizing conflicts; break ties by least-used color.;NB_COLOR_ELIM_STRATEGY_WEAK:Eliminating smallest color class greedily may fail. Use DSATUR-guided reassignment with Kempe-assisted moves; allow temporary conflicts with penalty then repair.;NB_KEMPE_COMPONENT_BUILD:Component expands on both colors regardless of adjacency alternation; acceptable but non-minimal. Improve by alternating-color BFS to restrict to the Kempe chain and reduce unnecessary flips.;NB_NOISE_CONTROL:Randomness unseeded; for reproducibility add rng parameter and avoid global random.;NB_MOVE_COST_AWARENESS:Neighbor selection ignores delta-cost. Compute and prefer neighbors with best delta under evaluate_solution to accelerate convergence.;E_EVAL_REDUNDANCY:Edges list rebuilt each call and random imported unused. Hoist edges\/adjacency to constants and drop unused imports to reduce overhead.;E_CANON_LABEL_DRIFT:Evaluation canonicalizes, but neighbor logic depends on raw labels (e.g., EliminateColor target). Canonicalize after every accepted move to stabilize labels and avoid tabu\/key mismatches.;R_TABU_LABELING:Arbitrary labels hamper tabu. Maintain compact 1..k labeling consistently to avoid false positives in memory structures.;SA_RESULT_INCONSISTENT:SA output duplicates current\/best with same score. Verify acceptance criterion uses evaluate_solution and records best independently from current.;ILS_RESULT_BROKEN:ILS returns 'KempeFlip' with LARGE cost (1e18) indicating neighbor not evaluated. Fix: always evaluate neighbor via evaluate_solution and accept if better; integrate perturb_solution between local searches.;TS_FAIL_SIG:Tabu signature mismatch with TARGET_HEURISTIC_GENERAL_SIGNATURE caused runtime error. Conform to the general signature and pass taboo params via other_params.;TS_MOVE_ENCODING:If tabu uses raw solutions, label permutations will pollute memory. Tabu should store canonicalized moves (vertex,color) or conflict pairs instead of full solutions.;OBJ_WEIGHTING:Penalty 1e9 is fine but hard-coded. Expose as parameter to allow tuning; keep integer arithmetic.;TEST_VALIDATION:Add unit tests asserting: valid neighbor representation; conflicts non-increasing in feasible phase; EliminateColor never introduces conflicts; no-op moves prevented.;PERTURB_SPECIFIC:Implement multi-start Kempe-chain flips on high-degree\/conflicted vertices and random color-swap of a small subset (size 2\u20133) to escape local minima.;VND_SUGGESTION:Add Variable Neighborhood Descent: sequence [single-vertex recolor, Kempe flip, pairwise swap of two vertices] until no improvement.;COLOR_LOWER_BOUND:Compute heuristic lower bound (clique size\/omega or degree+1 bound) to stop early at k=3 for this graph; integrate into acceptance to avoid unnecessary search.;INIT_CONSTRUCTIVE:Use DSATUR to generate a high-quality initial solution (k\u22483) before metaheuristics.;DELTA_CACHE:Maintain adjacency and per-vertex conflict counts to compute O(\u0394) deltas per move, avoiding full evaluate_solution calls.;MOVE_REJECTION_RATE:Track and cap consecutive non-improving random moves; increase perturbation intensity adaptively when plateau detected.;PARAM_SANITY:Ensure score is minimized (no negation); avoid returning move names as solutions.;OUTPUT_CONSISTENCY:Standardize neighbor return to {'solution':list,'move':{...}} and ensure heuristic consumes .solution only for evaluation.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Labels arbitrary; only equality matters.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    return conflicts * 10**9 + num_groups\n","NB_CODE":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-reduction phase: recolor a conflicted vertex using existing palette\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = float(sum(weights))\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Choose color minimizing local conflicts; break ties by smaller color id, then random among equals\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": int(cur), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt to eliminate a color class sequentially (safe greedy)\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            # Process vertices in an order that prefers easier reassignments first\n            idxs.sort(key=lambda i: sum(1 for nb in adj[i] if new_solution[nb] in other_colors))\n            work = new_solution[:]\n            success = True\n            recolored = []\n            for i in idxs:\n                zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n                if zero_conf:\n                    # prefer smallest color id to compact\n                    choice = min(zero_conf)\n                    work[i] = choice\n                    recolored.append((i, choice))\n                else:\n                    success = False\n                    break\n            if success:\n                # Commit and canonicalize 1..k\n                new_solution = work\n                mapping = {}\n                next_c = 1\n                for i in range(n):\n                    v = new_solution[i]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[i] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Kempe chain flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": int(cur), \"to\": int(tgt)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for v in adj[u]:\n                if new_solution[v] == a or new_solution[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; canonicalization in evaluation removes label bias.","Componente":null,"Version":4,"Feedback":"COMPONENT_VERSION: 1.0\nFEEDBACK:\nE_PERTURB_MISSING:Perturbation function undefined ($Perturb). Define a non-trivial perturb_solution to escape plateaus (e.g., k-vertex random recolor constrained to existing palette, or multi-step Kempe flips).\nE_Tabu_API_MISMATCH:Tabu search signature incompatible. Align function to TARGET_HEURISTIC_GENERAL_SIGNATURE or add a thin adapter. Ensure generate_neighbour and evaluate_solution are passed as callables, not called in the signature.\nE_EVAL_SCALE:Hard-coded 1e9 weight risks accidental arithmetic coupling and obscures progress. Use lexicographic objective (conflicts, num_groups) with a comparator, or reduce weight to 1e6 and verify no overflow\/precision issues. If framework requires scalar, document constant and unit-test boundary cases.\nE_EVAL_CANON_COST:Canonicalize executed every evaluation; avoid repeated remapping by storing canonical solutions at the search level and doing incremental update on neighbors when labels unchanged. Provide a canonicalize_once at initialization and maintain mapping during moves.\nE_EVAL_VALIDATION_SILENT:Invalid inputs return LARGE without diagnostics. Add lightweight code-level assertions\/unit tests externally; within heuristic guard early to avoid exploring invalid states.\nNB_CODE_FAIL_LOCAL_OPT:Min-conflicts phase selects a single most-conflicted vertex; this can thrash. Add steepest-descent over multiple conflicted vertices per step or break ties using degree or conflict delta to maximize reduction.\nNB_COLOR_INTRO_POLICY:When no improving color, code introduces a new color too eagerly. Restrict new color introduction to explicit diversification\/perturbation phases to preserve k-minimization pressure; in min-conflicts use only existing palette or Kempe moves.\nNB_ELIM_ORDERING:EliminateColor orders vertices by increasing count of neighbors in other_colors. This may pick hard-to-recolor first. Reorder by increasing available zero-conf colors (compute domain sizes), then by degree; fallback to lookahead (1-ply) to avoid early failure.\nNB_ELIM_GREEDY_FAIL:Greedy zero-conf reassignment can dead-end. Add backtracking with small depth (e.g., depth-2 DFS) or use a flow\/matching formulation to reassign the target color class safely.\nNB_KEMPE_SELECTION:Kempe pair (a,b) chosen uniformly. Bias selection to involve the rarest color (min cardinality) and its most interfering neighbor color to increase chances of eliminating a color.\nNB_KEMPE_SCOPE:Kempe component built correctly for the induced subgraph, but lacks acceptance criterion. Evaluate flip impact; accept only if it does not increase conflicts or if in diversification mode with probabilistic acceptance.\nNB_NOOP_PAYLOAD:On invalid input returns (\"NoOp\", payload). Ensure caller handles and does not count as a valid neighbor. Add a fallback to a safe random valid move to guarantee progress.\nR_INIT_HEURISTIC:No constructive initializer specified. Seed with DSATUR or Welsh-Powell to reduce starting conflicts and colors, improving convergence speed.\nSA_SCHEDULE_WEAK:Annealing config not shown; result indicates no improvement. Implement geometric cooling with reheats; accept uphill moves only on conflicts dimension, keep k-minimization primarily downhill.\nILS_RETURN_INVALID:ILS returning 1e18 suggests evaluate_solution fed non-canonical or invalid neighbor payload. Ensure Heuristic uses the \"newSolution\" from generate_neighbour payload, not the tuple header, and always re-canonicalize inputs.\nTABU_MOVE_ENCODING:Generate_neighbour returns (Type, JSON). Tabu should key on actual move attributes or solution hash; current unpack error indicates mis-integration. Standardize neighbor interface to return a concrete solution plus metadata.\nTABU_LIST_SCOPE:Tabu tenure unspecified. Use attribute-based tabu on (vertex,color) with aspiration if a move reduces conflicts or k; maintain a rolling hash (Zobrist) for fast repetition detection.\nE_REPRESENTATION_LABEL:Evaluation canonicalizes, but neighbor phases also canonicalize, causing redundant relabeling and noise for move attributes. Canonicalize only at evaluation or at entry\/exit of Heuristic; keep internal labels stable to exploit caching.\nE_CACHE_MISSING:No memoization of evaluations. Add lightweight cache keyed by tuple(solution) for short-lived windows to avoid recomputing conflicts on revisits, especially under tabu\/ILS.\nE_LOCAL_DELTA:Current neighbor recomputes local conflicts per query. Maintain per-vertex conflict counts and update them incrementally after a recolor to O(deg) instead of scanning neighbors repeatedly.\nE_STOP_CRITERIA:No explicit convergence\/plateau criteria described. Add counters for no-improvement steps, time\/iteration caps per phase, and adaptive switches between A\/B\/C phases.\nR_MOVE_SET_AUGMENT:Augment neighborhood with swap-based moves: (1) exchange colors of two vertices, (2) recolor small induced subgraphs via 2-opt on conflicts, (3) merge-split a color class then repair to target color reduction.\nR_FEAS_REPAIR:When conflicts>0, integrate limited-depth repair (GRASP-like): pick conflicted vertex by highest conflict-degree, try colors in order of least-conflicting with randomization (alpha) to diversify.\nR_COLOR_BOUND:Tighten target by using lower bounds (clique number or heuristic max-clique) to stop early once k hits bound; helps acceptance and termination decisions.\nR_METRICS:Track separate metrics: conflicts, k, moves since last k-improvement, time per eval. Use them to adaptively intensify (more EliminateColor) or diversify (more Kempe\/perturb).\nTEST_COVERAGE:Add unit tests: (1) evaluate_solution([3,1,2,1,3,2,1,1,2])==3; (2) neighbor never increases conflicts in phases B\/C; (3) EliminateColor succeeds only when conflicts stay zero; (4) Kempe flip preserves feasibility when starting feasible.\nINSTR_COMPAT:Ensure all components adhere to MAIN_CRITICAL_INSTRUCTION by avoiding filesystem\/network\/OS access; keep randomness seeded via in-memory parameters to enable reproducibility.","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; canonicalization in evaluation removes label bias.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Primary objective: conflicts -> weight 1e9, Secondary: number of groups\n    return conflicts * 10**9 + num_groups\n","NB_CODE":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with payload to avoid breaking callers\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    ncolors = sorted(set(cur))\n\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Always attempt a real change; three phases\n    # Phase A: If conflicts exist, do min-conflicts steepest descent recolor\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Pick the most conflicted vertex; tie-break by random among them\n        maxc = max(vc[i] for i in conflicted)\n        cand = [i for i in conflicted if vc[i] == maxc]\n        pick = random.choice(cand)\n        palette = sorted(set(cur))\n        # Try all existing colors and also allow introducing a new color only if no existing color reduces local conflicts\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(pick, c, cur)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = random.choice(best_colors)\n        if chosen == cur[pick]:\n            # Force change: if best is current color, pick another best among equals or introduce a new color id\n            alts = [c for c in best_colors if c != cur[pick]]\n            if alts:\n                chosen = random.choice(alts)\n            else:\n                chosen = max(palette) + 1\n        new_solution = cur[:]\n        new_solution[pick] = chosen\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(pick+1), \"from\": int(cur[pick]), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; try to eliminate a color using safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n        # Order by increasing saturation to ease reassignment\n        idxs.sort(key=lambda i: sum(1 for nb in adj[i] if cur[nb] in other_colors))\n        work = cur[:]\n        recolored = []\n        success = True\n        for i in idxs:\n            zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n            if zero_conf:\n                choice = min(zero_conf)\n                work[i] = choice\n                recolored.append((i, choice))\n            else:\n                success = False\n                break\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two colors to diversify without introducing conflicts\n    colors = sorted(set(cur))\n    if len(colors) < 2:\n        # Force an actual change: recolor a random vertex to a new color id 2\n        idx = random.randrange(n)\n        newc = 2 if cur[idx] != 2 else 1\n        new_solution = cur[:]\n        new_solution[idx] = newc\n        new_solution = canonicalize(new_solution)\n        payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    a, b = random.sample(colors, 2)\n    cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n    start = random.choice(cand_indices)\n    # Build Kempe component (alternating colors a\/b)\n    comp = set()\n    stack = [start]\n    while stack:\n        u = stack.pop()\n        if u in comp:\n            continue\n        comp.add(u)\n        for v in adj[u]:\n            if cur[v] == a or cur[v] == b:\n                if v not in comp:\n                    stack.append(v)\n    flipped = cur[:]\n    for i in comp:\n        flipped[i] = b if flipped[i] == a else a\n    flipped = canonicalize(flipped)\n    payload = {\n        \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n        \"newSolution\": flipped,\n    }\n    return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = min(4, n)\n    m = random.randint(2, m)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        elif choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        pert[idx] = choice\n\n    # Op2: random color-class swap (shuffle labels to diversify)\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; evaluation canonicalizes to 1..k to remove label bias.","Componente":null,"Version":5,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_PERTURB_UNDEFINED:$Perturb placeholder. Implement def perturb_solution(sol,other_params): multi-scale kicks (e.g., 1-3 random Kempe flips on rare color pairs; random reassignment of top-2 conflict vertices; color-class split-merge) with acceptance preserving feasibility when possible.\nE_TS_SIGNATURE_MISMATCH:Taboo_Search signature deviates from TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt Tabu internals (tabu tenure, list size) via other_params.\nE_TS_RETURN_PROTOCOL:Heuristic must return (best_solution,best_score,meta). Current TS error 'too many values to unpack' indicates inconsistent return arity. Fix to strict tuple or dict meta only.\nE_INIT_INADEQUATE:No constructive init specified. Add DSATUR\/greedy-by-degree initializer to hit k=3 quickly and reduce SA burn-in and TS tenure pressure.\nE_EVAL_SCALARIZATION:Magic 1e6 weight couples objectives. Replace with lexicographic compare in the driver or return (conflicts,groups) and compare tuples; if numeric mandatory, verify 1e6 > maxGroups(=9) and keep as constant; document to avoid silent regressions.\nE_EVAL_DUP_COST:Edges\/adjacency rebuilt in each call. Hoist static graph\/adjacency to module scope; cache deg, neighbors to cut repeated allocations.\nE_LABEL_CANON_OVERUSE:Neighbour function canonicalizes on every move causing plateaus and noise. Defer canonicalization to evaluation (already present) and keep raw labels inside search; only canon when recording best.\nNB_CODE_FAIL_LOCAL_OPT:Recolor phase ranks by (delta,-deg,color) but ignores global delta on total conflicts. Incorporate true delta using local counts; when ties, prefer moves reducing future palette (e.g., move toward rare colors).\nNB_CONFLICT_TIE_STRATEGY:Pure steepest-descent increases cycling risk. Add randomized tie-breaking probability p_walk (e.g., 0.1) to perform sideways\/random improving-worse moves ala WalkSAT to escape short cycles.\nNB_DOMAIN_ORDERING_LIMITED:EliminateColor backtracking depth-2 may fail even when feasible. Increase to depth-4 adaptively when idxs<=4; otherwise use bipartite matching per color class to check reassignment feasibility.\nNB_KEMPE_UNEVALUATED:KempeFlip is generated without conflict delta check. Compute delta; accept only non-worsening in feasible state and prefer improving components; retry up to R attempts before giving up.\nNB_COLOR_PAIR_SELECTION:Partner selection by raw neighbor frequency can be myopic. Use cut-size between color classes; select pair (a,b) maximizing edges across (a,b) to increase chance of improvement.\nNB_INCREMENTAL_DATA:Maintain per-color counts and per-vertex neighbor-color histograms to compute deltas O(1) per trial recolor; avoid recomputing local_conf loops.\nRANDOMNESS_CONTROL:Seed not exposed. Add rng in other_params and use rng.random\/rng.randrange deterministically for reproducibility.\nSA_SCHEDULE_UNSPECIFIED:Define geometric cooling T_{t+1}=alpha*T_t, alpha in [0.90,0.99], reheats on stagnation; scale T0 by average positive delta from 100 sampled moves.\nILS_WEAK_PERTURB:ILS meta reports KempeFlip with LARGE score\u2014indicates failure to handle evaluation\/cost properly. Ensure ILS accepts move only if eval returns lower scalar; on stagnation apply stronger perturbation size ~ceil(0.1*n).\nTABU_TENURE_TUNING:Expose tenure = c1 + rand[0,c2] scaled by degree; use aspiration if candidate beats best_score; prevent forbidding canonically equivalent label swaps by storing tabu as (vertex,old_color)->iteration.\nSTOPPING_CRITERIA:Define max_iters, max_no_improve, and wall-clock guards; return last best with meta including iters, improves, conflicts trajectory.\nDIVERSIFICATION:When best_score unchanged for L iterations, inject frequency-based penalties on colors\/vertices; or restart from DSATUR with different tie-breaking.\nSOLUTION_REPR_RISK:Positive integers with arbitrary labels can drift upward. Enforce palette compression after accepted moves (not on trial) to keep small labels; or map via a stable relabel routine.\nOUTPUT_INTEGRATION:All heuristics must treat lower=better; ensure no accidental sign inversions; always compare using evaluate_solution and avoid mixing raw conflicts and scalar scores.\nUNIT_TESTS_MISSING:Add tests: (a) known 3-color solution returns 3; (b) any edge endpoints equal increases score by >=1e6; (c) neighbour validity preserves list length and positivity; (d) EliminateColor never increases conflicts in feasible state; (e) KempeFlip non-worsening enforcement.\nPERF_METRICS:Add counters for eval_calls, move_trials, acceptance_rate; print or return in meta for tuning.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; evaluation canonicalizes to 1..k to remove label bias.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups. 1e6 keeps headroom and clear separation.\n    return conflicts * 10**6 + num_groups\n","NB_CODE":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, do steepest-descent recolor within existing palette (no new colors)\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Rank by conflicts then degree (higher first), break ties randomly\n        best_improve = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            # Try all existing colors (no new color introduction here)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                score = (delta, -deg[i], c)\n                if (best_improve is None) or (score < best_improve):\n                    best_improve = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_improve:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            new_solution = canonicalize(new_solution)\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Fallback if no alternative found (shouldn't happen): random conflicted vertex recolor to any existing color\n        i = random.choice(conflicted)\n        alts = [c for c in colors if c != cur[i]]\n        c = random.choice(alts) if alts else cur[i]\n        new_solution = cur[:]\n        new_solution[i] = c\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorFallback\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # Order by domain size (available zero-conf colors), then by degree descending\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n        success = True\n        # Limited backtracking depth-2: try up to two choices when domain size > 1\n        def try_reassign(pos, arr, rec):\n            if pos == len(idxs):\n                return True, arr, rec\n            i = idxs[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            # Try up to two options to avoid combinatorial blowup\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(0, work, [])\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip biased by rarest color; accept non-worsening conflicts (feasible stays feasible)\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        rare = min(colors, key=lambda c: (counts[c], c))\n        # pick partner color that interacts most with rare (rough heuristic)\n        freq = {c: 0 for c in colors}\n        for u in range(n):\n            if cur[u] == rare:\n                for v in adj[u]:\n                    freq[cur[v]] += 1\n        partners = [c for c in colors if c != rare]\n        if partners:\n            b = min(partners, key=lambda c: (-freq[c], c))\n        else:\n            b = random.choice(colors)\n        a = rare\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component (alternating colors a\/b)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        flipped = canonicalize(flipped)\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    new_solution = canonicalize(new_solution)\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # allow diversification if only one color exists\n        pert[idx] = choice\n\n    # Op2: random color-class relabeling (swap two labels) to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution=[x1,...,x9] with xi>=1 integers (1-indexed students). Labels arbitrary; evaluation canonicalizes to 1..k.","Componente":null,"Version":6,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"F_HEURISTIC_SIGNATURE_MISMATCH\":\"Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure all orchestrators (SA\/ILS\/TS) wrap to this signature to prevent unpacking errors.\"\n\"F_TABU_SIG_ERROR\":\"Taboo_Search fails: too many values to unpack. Align TS to TARGET_HEURISTIC_GENERAL_SIGNATURE or provide an adapter. Explicitly remove extra parameters from direct signature.\"\n\"F_PERTURB_ABSENT\":\"Perturbation Function unresolved ($Perturb). Provide a concrete, parameterized perturbation with strength control and repeatability.\"\n\"F_NEIGH_RET_PAYLOAD_BLOAT\":\"generate_neighbour returns (Type, JSON). Heuristic expects a neighbor solution object. Provide a thin adapter that extracts payload['newSolution'] and ignores verbose metadata during main loop.\"\n\"F_NEIGH_STOCHASTIC_NO_SEED\":\"Randomness without seed control impedes reproducibility. Inject PRNG from Heuristic via other_params['rng'] and remove direct random module use.\"\n\"F_NEIGH_LOCAL_OPT_SCOPE\":\"Recolor step considers only existing palette; when palette is suboptimal, exploration stalls. Add temporary new color insertion when stuck with conflicts to escape plateaus.\"\n\"F_NEIGH_KEMPE_TARGETING_WEAK\":\"Kempe pair chosen by cut-size only. Add conflict-guided and color-class-elimination-biased selection; prioritize pairs touching conflicted vertices or smallest color class boundary.\"\n\"F_NEIGH_BACKTRACK_CAP_TOO_LOW\":\"max_depth=4 may block feasible eliminations. Implement iterative deepening with time\/iteration budget, or use BFS domain filtering with Hall check on tiny subinstances.\"\n\"F_NEIGH_DOMAIN_HEURISTIC_CRUDE\":\"domain_size counts zeros only; add tie-break by impact on neighbors (sum of new local conflicts if others move), or use saturation degree (DSATUR-like).\"\n\"F_NEIGH_REDUNDANT_CANON\":\"Canonicalize on output only; internal moves compare raw labels causing palette drift. Maintain a compact label map every T steps to reduce degeneracy.\"\n\"F_EVAL_SCALAR_COUPLING\":\"conflicts*1e6+groups fixes weight. Use adaptive penalty: weight = max(1e6, alpha*iters or based on recent feasibility) to intensify feasibility early, palette minimization later.\"\n\"F_INIT_WEAK\":\"No constructive initializer specified. Use DSATUR\/greedy with largest-degree ordering to quickly reach low-conflict feasible 3-color solutions.\"\n\"F_MOVE_SET_INCOMPLETE\":\"Add color-merge attempt with targeted recoloring (try remove smallest class using BFS recolor + limited Kempe flips). Add swap of two color labels to compress palette variance.\"\n\"F_CYCLE_HANDLING_LIMITED\":\"p_walk=0.1 only for conflicts. Add Tabu memory on recent vertex-color assignments and accept non-improving Kempe flips under aspiration criteria.\"\n\"F_TERMINATION_CRITERIA_UNSPECIFIED\":\"Define clear stop rules: max_evals, max_no_improve, time budget. Track best_score and stagnation windows for adaptive perturb strength.\"\n\"F_INTENSIFY_DIVERSIFY_BALANCE\":\"No adaptive schedule. Implement oscillation: increase perturb strength after W no-improve, reset after improvement; reduce temperature-like acceptance over time.\"\n\"F_SCORING_NO_TIEBREAK\":\"When conflicts equal, tie-break on groups then color-class variance; prioritize solutions with fewer colors and more balanced classes during search.\"\n\"F_SA_ILS_STAGNATION\":\"Results show immediate 3 with identical solutions; risk of false convergence. Inject restarts from diversified seeds and record-keeping of distinct labelings (canonical forms) to avoid revisiting.\"\n\"F_DATA_HARDCODED_DUP\":\"Edges embedded in multiple components. Centralize in evaluate_solution and pass adjacency to neighbor via closure or other_params to prevent drift.\"\n\"F_VALIDATION_OVERHEAD\":\"Repeated validation each call adds cost. In Heuristic main loop, validate once and assume invariants; assert in debug mode only.\"\n\"F_OUTPUT_CANON_ENFORCE\":\"Ensure Heuristic returns canonicalized best solution to avoid label-bias in reported k; enforce via final canonicalization step.\"\n\"I_SPEC_ADAPTER_GEN_NEIGH\":\"Implement adapter def wrapped_generate_neighbour(sol): typ,p=json.loads(...); return p['newSolution'].\"\n\"I_SPEC_PERTURB_IMPL\":\"Provide perturb_solution: random multi-Kempe flips seeded on conflicted components, or vertex ejection from smallest color class with strength s in [1..L].\"\n\"I_SPEC_INIT_DS\":\"Add DSATUR initializer with tie-breaks (degree, saturation, residual domain) to reduce initial conflicts and palette size.\"\n\"I_SPEC_TABU_FIX\":\"Refactor Tabu to signature: Heuristic(..., other_params={'iterations':I,'tabu_tenure':T,'list_size':L}); maintain tabu list of (vertex,color) with aspiration if best improves.\"\n\"I_SPEC_METRICS\":\"Track evaluations\/sec, conflict trajectory, palette size over time; abort if no improvement in R evaluations and auto-increase perturb strength.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE. solution=[x1,...,x9] with xi>=1 integers (1-indexed students). Labels arbitrary; evaluation canonicalizes to 1..k.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","NB_CODE":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    # Keep internal labels as-is to reduce churn; only canonicalize outputs\n    cur = solution[:]\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, steepest-descent recolor within existing palette\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        best_score = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                # Tie-break toward rarer colors to aid palette compression\n                rarity = sum(1 for v in cur if v == c)\n                score = (delta, -deg[i], rarity, c)\n                if (best_score is None) or (score < best_score):\n                    best_score = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_score:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            # With small probability perform a random sideways step to avoid cycles\n            p_walk = 0.1\n            if random.random() < p_walk:\n                i = random.choice(conflicted)\n                alts = [c for c in colors if c != cur[i]] or [cur[i]]\n                c = random.choice(alts)\n                new_solution = cur[:]\n                new_solution[i] = c\n                payload = {\n                    \"move\": {\"type\": \"RandomWalkRecolor\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n                    \"newSolution\": canonicalize(new_solution),\n                }\n                return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n\n        # limited backtracking depth up to 4 or len(idxs)\n        max_depth = min(4, len(idxs))\n\n        def try_reassign(order, pos, arr, rec):\n            if pos == len(order):\n                return True, arr, rec\n            if pos >= max_depth and any(local_conf(i, target, arr) == 0 for i in order[pos:]):\n                # cutoff heuristic beyond depth\n                return False, arr, rec\n            i = order[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(order, pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(idxs, 0, work, [])\n        if success:\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip; choose pair by cut-size to bias improvement\n    if len(colors) >= 2:\n        # compute cut sizes between colors\n        cut = {a: {b: 0 for b in colors} for a in colors}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in colors for b in colors if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Componente":null,"Version":7,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_GEN_NEIGH_RET:Function returns (move_type,json_payload) instead of a LIST_INT_LEN9_POSITIVE. This breaks heuristic contracts and leads to 1e18 evaluations. Fix: return only the canonicalized neighbor solution; move metadata should be optional second return guarded by caller expectations or removed.\nE_GEN_NEIGH_CANON_OUT:Canonicalized solution is embedded in payload but not returned as the actual neighbor. Fix: new_solution = canonicalize(...); return new_solution.\nE_GEN_NEIGH_IFACE_INCONSISTENT:Different heuristics expect different arities; keep generate_neighbour(solution)->neighbor only. If diagnostics are needed, expose a separate debug generator.\nE_GEN_NEIGH_RANDOM_RNG:Uses global random without seed control. Add rng in other_params and thread it through to ensure reproducibility and testability.\nE_GEN_NEIGH_MINCONFLICTS_TIEBREAK:Min-conflicts recolor ignores palette reduction. Add tie-break: prefer colors that reduce |palette| and prefer reusing existing low-count colors.\nE_GEN_NEIGH_NEW_COLOR:Introducing a new color increases objective; restrict to when stuck (no improving recolor) and only if conflicts strictly decrease.\nE_GEN_NEIGH_ELIM_COLOR_GREEDY:Greedy zero-conflict reassignment may fail early; add backtracking (small DFS) or order by DSATUR to increase success rate. If fail, avoid returning a worse neighbor.\nE_GEN_NEIGH_KEMPE_ACCEPT:Kempe flip is unconditional; gate it by non-worsening evaluation or probabilistic acceptance with temperature passed via other_params to avoid random deterioration.\nE_GEN_NEIGH_KEMPE_PAIR_SEL:Cut-size bias may trap; diversify by occasionally selecting least-cut pairs or pairs involving smallest color class.\nE_GEN_NEIGH_COST_INC:vc and local_conf recomputed from scratch; cache adjacency and maintain incremental conflict counts after a move to reduce O(m) per step to O(deg(v)).\nE_EVAL_SCALARIZATION:1e6 weight is safe but coarse; for small n ok, but prefer return (conflicts,num_groups) and let heuristic compare tuples to avoid magic constants.\nE_EVAL_CANON_COST:Canonicalize on every call adds overhead; either canonicalize once per move in neighbour or cache canonical mapping if labels unchanged.\nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Provide perturb_solution with controlled strength (e.g., k vertex recolors biased to conflicted vertices, or a few Kempe flips).\nE_INIT_SOLUTION:Sample solution is 3-color valid but no initializer provided. Add DSATUR\/greedy constructive to quickly reach k=3 and reduce SA burn-in.\nE_HEURISTIC_SIGNATURE:Ensure Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) is respected; do not pass generate_neighbour() or evaluate_solution() with parentheses (functions, not results).\nE_TS_IFACE:Taboo_Search failure indicates unpacking mismatch and wrong signature. Standardize TS to accept function handles and have generate_neighbour return only a neighbor; maintain tabu on moves or attributes (e.g., (vertex,old_color)).\nE_OBJECTIVE_DIRECTION:Confirm all metaheuristics treat lower scores as better; remove any maximization logic or negate only when truly maximizing.\nE_LABEL_BIAS:Despite canonicalization inside evaluation, neighbour sometimes introduces new colors arbitrarily. Enforce relabeling to 1..k after each move to stabilize search space and tabu attributes.\nE_STOPPING_CRITERIA:Add early-stop upon reaching 0 conflicts and k=3 (known optimum) to save iterations.\nR_IMPROVEMENT_OPERATORS:Add 1-vertex swap to smallest feasible color, pair-exchange (color swap for non-adjacent vertices), and small Kempe BFS limited to conflicted subgraphs to intensify.\nR_DIVERSIFICATION:Introduce perturbation that merges two colors then repairs (hill-climb) to escape local minima on 4-color plateaus.\nR_PARAMETERIZATION:Expose probabilities (new color, Kempe) and max attempts in other_params for adaptive tuning.\nR_TESTS:Unit-test generate_neighbour to assert output type, length, domain, and non-worsening when conflicts>0 in Phase A.\nR_METRICS:Track (conflicts,k,move_type,delta) to detect operator utility; prune operators with consistently non-improving deltas.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","NB_CODE":"import random\nimport json\n\ndef generate_neighbour(solution):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = solution[:]\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: Resolve conflicts via min-conflicts recolor within palette; allow occasional new color to escape\n    palette = sorted(set(cur))\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if conflicted:\n            i = random.choice(conflicted)\n            curc = cur[i]\n            best = []\n            best_val = None\n            # Try existing colors first\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                score = (conf, -deg[i], c)\n                if best_val is None or score < best_val:\n                    best_val = score\n                    best = [c]\n                elif score == best_val:\n                    best.append(c)\n            # With small probability, introduce a new color to break deadlocks\n            if random.random() < 0.1:\n                newc = max(palette) + 1\n                best.append(newc)\n            to_color = random.choice(best) if best else curc\n            new_solution = cur[:]\n            new_solution[i] = to_color\n            payload = {\n                \"move\": {\"type\": \"MinConflictsRecolor\", \"index\": int(i+1), \"from\": int(curc), \"to\": int(to_color)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Attempt to eliminate smallest color class via greedy safe reassignment\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        other = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_zero(i, arr):\n            return [c for c in other if local_conf(i, c, arr) == 0]\n\n        order = sorted(idxs, key=lambda i: (len(domain_zero(i, cur)), -deg[i]))\n        work = cur[:]\n        feasible = True\n        for i in order:\n            zeros = domain_zero(i, work)\n            if not zeros:\n                feasible = False\n                break\n            work[i] = random.choice(zeros)\n        if feasible:\n            payload = {\n                \"move\": {\"type\": \"EliminateColorGreedy\", \"removed\": int(target), \"recolored\": len(order)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two random colors biased by cut-size\n    if len(palette) >= 2:\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(palette, 2)\n        cand = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand) if cand else random.randrange(n)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Degenerate: single color, force recolor\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Componente":null,"Version":8,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"H_SIG_MISMATCH:Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Implement this wrapper and route to SA\/ILS\/TS via other_params['method'] to stop unpacking errors.\nH_API_CONTRACT:Heuristic must return (new_solution,new_best,new_best_score,meta) or at least (solution,score) consistently. Current external runners expect tuple; fix all algorithms to return uniform tuple and never plain int to avoid 'cannot unpack non-iterable int' fault.\nALG_SIG_FIX:Refactor SA\/ILS\/TS to accept passed function handles without calling them in the signature. Remove parentheses in parameters and call inside body. Example: use generate_neighbour(sol) not generate_neighbour().\nPERTURB_MISSING:perturb_solution undefined ('$Perturb'). Provide a concrete perturbation operator (e.g., multi-vertex recolor + Kempe-chain shuffle) and wire into ILS and Heuristic.\nNB_REBUILD_COST:generate_neighbour rebuilds adj and edges each call. Hoist static data to outer scope or other_params cache. Reduces O(|E|) overhead per neighbor.\nE_SCALAR_WEIGHT:Penalization 10^6 is arbitrary but fine; ensure acceptance checks compare full evaluate_solution values to align with objective. Avoid local custom tuples in Kempe acceptance; call evaluate_solution for consistency.\nNB_PHASE_A_LOCAL:Min-conflicts picks most-conflicted vertex but only explores existing palette except rare new color case. Add exploration to try introducing a new color only if conflicts decrease; also try trying all colors up to k+1 bounded to degree+1 to escape traps.\nNB_CODE_FAIL_LOCAL_OPT:Local_conf-based tie-break ignores potential global conflict creation on neighbors. Add delta-evaluation using incident edges to compute true evaluate delta; accept strictly best delta.\nNB_PHASE_B_BACKTRACK:Backtracking lacks depth\/iteration caps; worst-case exponential. Add node\/order heuristic (e.g., highest-degree in target class) and limit recursion with cutoff and iterative deepening.\nNB_KEMPE_ACCEPT:Uses custom base_score tuple not evaluate_solution; can accept non-improving group count under zero conflicts. Replace with new_eval = evaluate_solution(flipped); accept if new_eval <= cur_eval.\nNB_RANDOM_FALLBACK:Random recolor can introduce conflicts from a previously feasible state. Guard by accepting fallback only if evaluate(flipped) <= current; otherwise resample or return current.\nNONDET_SEED:Stochastic behavior is non-reproducible. Add RNG seed in other_params and thread through all random calls via a Random instance to enable deterministic runs.\nINIT_FEASIBILITY:Default seed is feasible 3-coloring; ensure Heuristic canonicalizes and validates input then falls back to default if invalid. Expose a generator for multiple diverse feasible starts (e.g., greedy coloring with random tie-breaks).\nE_CANON_DUP:Canonicalization performed in both evaluation and neighbor; acceptable but redundant. Ensure neighbor returns canonicalized labels once; avoid double work in loops by operating on canonicalized state internally and returning once.\nINCR_EVAL:Current evaluation recomputes conflicts O(|E|). Implement delta-evaluation for neighbor moves using incident edges; cache color counts to O(deg(v)) updates.\nREPRESENTATION_TIGHTEN:Restrict colors to 1..k where k = current max to maintain tighter search space; prohibit gaps by canonicalization on every accepted move.\nSA_DESIGN:Define temperature schedule and acceptance using evaluate_solution; ensure loop decreases temp to MIN_TEMP, and returns best found. Remove tuple unpacking mismatches and ensure consistent tuple return.\nILS_DESIGN:Define accept criterion based on evaluate delta; apply perturb_solution only when plateau detected; ensure iterations passed via other_params. Return best across all local searches.\nTS_MEMORY:Tabu search must maintain tabu list keyed by (vertex,color) moves with tenure taboo_duration; aspiration if evaluate improves best. Ensure taboo_list_size not misused; use queue or aging counters.\nTERM_CRITERIA:Add robust stopping criteria: max_iters, max_no_improve, time budget (if allowed). Expose via other_params and enforce in Heuristic wrapper.\nVALIDATION_GUARD:Before applying neighbor\/perturbation, validate solution shape and coerce via default feasible to prevent LARGE sentinel propagations.\nTEST_BENCH:Add unit checks: evaluate(known)=3, neighbor preserves or reduces evaluate on average, Heuristic reaches score 3 from random starts within N iters. Report failure rates for tuning.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    cur = solution[:]\n    cur = canonicalize(cur)\n\n    cur_conf = count_conflicts(cur)\n\n    # Phase A: If conflicts exist, perform min-conflicts recolor on a conflicted vertex\n    if cur_conf > 0:\n        conflicted = [i for i in range(n) if any(cur[i] == cur[j] for j in adj[i])]\n        if conflicted:\n            # choose a most-conflicted vertex (break ties randomly)\n            maxc = -1\n            cand = []\n            for i in conflicted:\n                lc = local_conf(i, cur[i], cur)\n                if lc > maxc:\n                    maxc = lc\n                    cand = [i]\n                elif lc == maxc:\n                    cand.append(i)\n            i = random.choice(cand)\n            palette = sorted(set(cur))\n            best_colors = []\n            best_score = None\n            curc = cur[i]\n            # try recoloring to existing colors (excluding current)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                # tie-break: prefer colors that may reduce palette size by emptying current color class\n                will_empty = 1 if sum(1 for v in cur if v == curc) == 1 else 0\n                score = (conf, -will_empty, c)\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_colors = [c]\n                elif score == best_score:\n                    best_colors.append(c)\n            # If no alternative in palette (degenerate), allow introducing a new color only if it strictly reduces conflicts locally\n            if not best_colors:\n                newc = max(palette) + 1\n                if local_conf(i, newc, cur) < local_conf(i, curc, cur):\n                    best_colors = [newc]\n                else:\n                    # no improving move found; return same solution\n                    return cur\n            newc = random.choice(best_colors)\n            nxt = cur[:]\n            nxt[i] = newc\n            nxt = canonicalize(nxt)\n            return nxt\n\n    # Phase B: Attempt to eliminate the smallest color class without creating conflicts\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        others = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # simple backtracking up to limited depth\n        order = sorted(idxs, key=lambda i: (sum(1 for c in others if local_conf(i, c, cur) == 0), -len(adj[i])))\n        assign = {}\n\n        def dfs(k, arr):\n            if k == len(order):\n                return arr\n            i = order[k]\n            zeros = [c for c in others if local_conf(i, c, arr) == 0]\n            random.shuffle(zeros)\n            for c in zeros:\n                arr2 = arr[:]\n                arr2[i] = c\n                res = dfs(k+1, arr2)\n                if res is not None:\n                    return res\n            return None\n\n        attempt = dfs(0, cur[:])\n        if attempt is not None:\n            attempt = canonicalize(attempt)\n            return attempt\n\n    # Phase C: Kempe chain flip between two colors; accept only if non-worsening\n    if len(palette) >= 2:\n        # compute cut sizes\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        pairs.sort(key=lambda t: (-t[2], t[0], t[1]))\n        base_score = (count_conflicts(cur), len(set(cur)))\n        for a, b, _ in pairs:\n            # build Kempe component from a random seed in (a,b)\n            cand = [i for i, c in enumerate(cur) if c == a or c == b]\n            if not cand:\n                continue\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if cur[v] == a or cur[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            flipped = cur[:]\n            for i in comp:\n                flipped[i] = b if flipped[i] == a else a\n            flipped = canonicalize(flipped)\n            new_score = (count_conflicts(flipped), len(set(flipped)))\n            if new_score <= base_score:\n                return flipped\n\n    # Fallback: slight random recolor within palette (keeps feasibility if no conflicts)\n    i = random.randrange(n)\n    palette = sorted(set(cur))\n    if len(palette) == 1:\n        cur[i] = 2 if cur[i] == 1 else 1\n    else:\n        alt = [c for c in palette if c != cur[i]]\n        cur[i] = random.choice(alt)\n    return canonicalize(cur)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n    pert = canonicalize(pert)\n\n    # Op1: Merge two random colors (if >=2) by recoloring smaller class into best-fitting other colors, then repair greedily\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        counts = {c: sum(1 for v in pert if v == c) for c in colors}\n        a, b = sorted(random.sample(colors, 2), key=lambda c: counts[c])  # a is smaller\n        targets = [i for i, c in enumerate(pert) if c == a]\n        random.shuffle(targets)\n        for i in targets:\n            palette = [x for x in colors if x != a]\n            best = None\n            best_c = None\n            for c in palette:\n                conf = local_conf(i, c, pert)\n                sc = (conf, c)\n                if best is None or sc < best:\n                    best = sc\n                    best_c = c\n            if best_c is None:\n                best_c = b\n            pert[i] = best_c\n        # remove empty color by canonicalization\n        pert = canonicalize(pert)\n\n    # Op2: Random recolor k vertices towards minimal local conflict within current palette\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        palette = sorted(set(pert))\n        curc = pert[i]\n        best = None\n        best_cs = []\n        for c in palette:\n            conf = local_conf(i, c, pert)\n            sc = (conf, c)\n            if best is None or sc < best:\n                best = sc\n                best_cs = [c]\n            elif sc == best:\n                best_cs.append(c)\n        choice = random.choice(best_cs)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        pert[i] = choice\n\n    # Op3: One Kempe chain flip to diversify\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    return canonicalize(pert)\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
