{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_textbook_standard","Representacion":"comma-separated string of 1-based item indices (example: '1,3,5'). No duplicate indices. Empty or invalid inputs are heavily penalized.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\": \"Evaluation:1.0, Neighbour:1.0, Perturb:MISSING\",\n\n\"FEEDBACK\": \"SAMPLE_SOLUTION_FORMAT_ERROR: The provided SAMPLE_SOL is malformed (multi-line table \/ numeric tokens) and not a comma-separated 1-based index string as required by SOL_TYPE. Local solver errors show failure to load SAMPLE_SOL (examples: \\\"string indices must be integers, not 'str'\\\" and SyntaxError). Fix: supply SAMPLE_SOL exactly as a single string matching SOL_TYPE (example: '1,2,4,6,7,13,16,17,18,20,21,23') OR make evaluation\/loader robust by accepting list\/tuple\/int and normalizing to the canonical comma-separated string before parsing. Evidence: evaluate_solution([24]) currently raises TypeError; evaluate_solution('24') returns 1 (see verification below).\",\n\n\"CRITICAL_MISSING_PERTURB_FUNCTION: The Perturbation component is a placeholder ('$Perturb') and is missing. The TARGET_HEURISTIC_GENERAL_SIGNATURE requires perturb_solution (Heuristic(..., perturb_solution, ...)). This prevents any heuristic that expects a perturb operator (e.g. ILS, SA with restarts) from running. Fix: implement perturb_solution with the same representation and signature expectations as generate_neighbour (example: perturb_solution(solution, strength=1) -> (new_solution_string, 'perturb_k')). Ensure it returns the canonical comma-separated string and a movement label.\",\n\n\"STRICT_INPUT_TYPE_AND_INTERFACE_MISMATCH: evaluate_solution and generate_neighbour enforce only str input and raise TypeError for other types; local solver frameworks often pass solutions as lists, tuples or None during loading\/initialization. Fix: add a small normalization helper at the top of both components to accept str, list, tuple, int and convert to a validated canonical comma-separated string (or return a consistent heavy penalty for invalid inputs). Also include structured optional outputs: local solver note indicates extra outputs expected from evaluation. Modify evaluate_solution to optionally return a tuple (score, info_dict) or provide a wrapper that returns the single numeric score while exposing diagnostics (total_weight, feasible_bool) to comply with solver expectations. Evidence of current behavior and component verification: evaluate_solution('1,2,4,6,7,13,16,17,18,20,21,23') == 219 (optimal); evaluate_solution('24') == 1; generate_neighbour('1,2,4,6,7,13,16,17,18,20,21,23') returned a valid neighbour tuple (e.g. '1,2,4,7,13,15,16,17,18,20,21,23', 'swap_15_for_6').\"","Evaluacion":{"REPRESENTATION":"comma-separated string of 1-based item indices (example: '1,3,5'). No duplicate indices. Empty or invalid inputs are heavily penalized.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated string of 1-based indices, e.g. '1,2,5'\n    # returns a single numeric fitness score (higher is better). Feasible solutions return total value.\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    values  = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    capacity = 80\n    # Validate input type\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of 1-based indices')\n    s = solution.strip()\n    if s == '':\n        return -10**9  # empty solution very heavily penalized\n    # Parse indices\n    try:\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = [int(p) for p in parts]\n    except Exception:\n        return -10**9  # parse error\n    # No duplicates allowed for 0\/1 knapsack\n    if len(idxs) != len(set(idxs)):\n        return -10**9\n    # Check index bounds (1-based)\n    for i in idxs:\n        if i < 1 or i > len(weights):\n            return -10**9\n    # Compute totals\n    total_weight = 0\n    total_value = 0\n    for i in idxs:\n        j = i - 1\n        total_weight += weights[j]\n        total_value += values[j]\n    # Penalize infeasible (over capacity) solutions heavily\n    if total_weight > capacity:\n        # Penalize proportionally to overweight with a large multiplier\n        return total_value - 10000 * (total_weight - capacity)\n    # Feasible: return total value as fitness\n    return total_value"},"Vecindad":{"REPRESENTATION":"A comma-separated string of 1-based item indices (e.g. '1,2,5'). The generate_neighbour function returns a tuple (neighbor_solution_string, movement_label) where neighbor_solution_string uses the same representation and movement_label describes the applied move (e.g. 'add_3', 'remove_5', 'swap_7_for_2').","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbouring 0\/1-knapsack solution.\n\n    Input:\n        solution: comma-separated string of 1-based indices (e.g. '1,2,5').\n    Output:\n        (neighbor_solution_string, movement_label)\n    \"\"\"\n    # Problem data (embedded, 1-based indexing)\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    values  = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    capacity = 80\n    n = 24\n\n    # Parse input robustly\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of 1-based indices')\n    s = solution.strip()\n    if s == '':\n        current = []\n    else:\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        try:\n            current = [int(p) for p in parts]\n        except Exception:\n            # malformed input -> treat as empty\n            current = []\n    # sanitize: keep only valid, unique indices\n    cur = []\n    for i in current:\n        if 1 <= i <= n and i not in cur:\n            cur.append(i)\n    current = cur\n\n    total_weight = sum(weights[i-1] for i in current)\n    total_value = sum(values[i-1] for i in current)\n    in_set = set(current)\n    remaining = capacity - total_weight\n\n    # value\/weight ratios for heuristics\n    ratios = [values[i] \/ weights[i] for i in range(n)]\n\n    # Candidate items not currently selected\n    candidates = [i+1 for i in range(n) if (i+1) not in in_set]\n    # Prefer high ratio items for addition (tie-breaker random)\n    candidates.sort(key=lambda j: (-ratios[j-1], random.random()))\n\n    # 1) Try greedy add: best ratio that fits\n    for j in candidates:\n        if weights[j-1] <= remaining:\n            new = sorted(current + [j])\n            return (','.join(str(x) for x in new), 'add_{}'.format(j))\n\n    # 2) Try beneficial swap: remove one in current and add one outside to fit capacity\n    best_swap = None\n    best_gain = -10**9\n    for a in current:\n        for b in candidates:\n            new_weight = total_weight - weights[a-1] + weights[b-1]\n            if new_weight <= capacity:\n                gain = values[b-1] - values[a-1]\n                # prefer positive gains, tie-breaker random\n                if gain > best_gain or (gain == best_gain and random.random() < 0.5):\n                    best_gain = gain\n                    best_swap = (a, b)\n    if best_swap:\n        a, b = best_swap\n        new = [i for i in current if i != a] + [b]\n        new = sorted(new)\n        return (','.join(str(x) for x in new), 'swap_{}_for_{}'.format(b, a))\n\n    # 3) If no add\/swap possible, remove the worst ratio item (least efficient)\n    if current:\n        worst = min(current, key=lambda i: (ratios[i-1], random.random()))\n        new = [i for i in current if i != worst]\n        new = sorted(new)\n        return (','.join(str(x) for x in new), 'remove_{}'.format(worst))\n\n    # 4) Fallback (empty current and no candidate due to malformed input): add highest-value item\n    if candidates:\n        best = max(candidates, key=lambda j: (values[j-1], -weights[j-1]))\n        return (str(best), 'add_{}'.format(best))\n\n    # 5) Final fallback: return empty solution\n    return ('', 'noop')\n"},"Perturbacion":{"REPRESENTATION":"Randomized component perturbation: remove a random subset of selected items, then greedily refill by value\/weight ratio with small local swap improvements to increase total value while keeping weight <= capacity.","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data (no globals)\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    values  = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    capacity = 80\n    n = len(weights)\n\n    # Parse input (robust): expect comma-separated 1-based indices string\n    if not isinstance(solution, str):\n        solution = str(solution)\n    s = solution.strip()\n    sel = []\n    if s != '':\n        try:\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            cand = [int(p) for p in parts]\n            # keep valid 1..n and preserve first occurrences\n            seen = set()\n            for i in cand:\n                if 1 <= i <= n and i not in seen:\n                    sel.append(i)\n                    seen.add(i)\n        except Exception:\n            sel = []\n\n    def tot_weight(lst):\n        return sum(weights[i-1] for i in lst)\n    def tot_value(lst):\n        return sum(values[i-1] for i in lst)\n\n    # If current solution infeasible, trim worst ratio items until feasible\n    def make_feasible(lst):\n        lst = list(lst)\n        while tot_weight(lst) > capacity and lst:\n            ratios = [(values[i-1]\/weights[i-1], i) for i in lst]\n            # remove item with smallest ratio\n            worst = min(ratios)[1]\n            lst.remove(worst)\n        return lst\n\n    sel = make_feasible(sel)\n\n    # Perturbation: remove a random subset of components (at least 1 if non-empty)\n    if sel:\n        k = max(1, int(len(sel) * 0.4))\n        k = min(k, len(sel))\n        removed = set(random.sample(sel, k))\n        sel = [i for i in sel if i not in removed]\n    else:\n        removed = set()\n\n    # Greedy refill by value\/weight ratio (randomized tie-break)\n    free = capacity - tot_weight(sel)\n    candidates = [i for i in range(1, n+1) if i not in sel]\n    random.shuffle(candidates)\n    candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        if weights[i-1] <= free:\n            sel.append(i)\n            free -= weights[i-1]\n\n    # Small local improvement: try beneficial swaps (replace some low-ratio items with a better candidate)\n    # One-pass attempt to keep runtime small\n    for i in candidates:\n        if i in sel:\n            continue\n        wi = weights[i-1]\n        vi = values[i-1]\n        if wi <= free:\n            # can add directly\n            sel.append(i)\n            free -= wi\n            continue\n        # need to free space: consider removing worst-ratio items\n        included = list(sel)\n        # sort included by ascending ratio (worst first)\n        included.sort(key=lambda j: (values[j-1]\/weights[j-1], values[j-1]))\n        to_remove = []\n        freed = 0\n        removed_value = 0\n        for j in included:\n            to_remove.append(j)\n            freed += weights[j-1]\n            removed_value += values[j-1]\n            if freed + free >= wi:\n                break\n        if freed + free >= wi:\n            # if value improves, perform swap\n            if vi > removed_value:\n                for j in to_remove:\n                    sel.remove(j)\n                sel.append(i)\n                free = free + freed - wi\n    # Final feasibility check\n    sel = make_feasible(sel)\n    # Return sorted, comma-separated 1-based indices (non-empty). If empty, return a single best item that fits.\n    if not sel:\n        # pick best single item that fits by value among items with weight<=capacity\n        feasible_items = [i for i in range(1, n+1) if weights[i-1] <= capacity]\n        if feasible_items:\n            best = max(feasible_items, key=lambda i: values[i-1])\n            return str(best)\n        else:\n            return ''\n    sel_sorted = sorted(set(sel))\n    return ','.join(str(i) for i in sel_sorted)"}}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_textbook_standard","Representacion":"Canonical representation: comma-separated 1-based item indices (e.g. '1,3,5'). evaluate_solution accepts str, list, tuple, or int. Fitness returned is a single numeric score: total value if total weight <= capacity, otherwise a penalized score (total_value - 10 * overweight). Items and capacity are embedded inside the function.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\": \"v1.0\",\n\"FEEDBACK\": \"E_WEIGHT_VALUE_SWAP: items mapping has weight\/value swapped. Test: evaluate_solution('1,2,4,6,7,13,16,17,18,20,21,23') -> component returned -1310 but correct total is 219. Fix: store items as (weight, value) or unpack as (value,weight) consistently (e.g. items[1]=(4,22), items[2]=(2,22), ...), then recompute totals.;\\nE_INPUT_TYPE_HANDLING: interface\/validation differs from local solver. Local solver requires a comma-separated string and returns heavy penalties or TypeError for non-strings; component currently accepts list\/tuple\/int and silently coerces. Consequence: local solvers that pass only strings will see different behavior and some frameworks will break. Fix: match local-eval signature exactly (raise TypeError if input not str) or, if accepting other types, perform conversion but then enforce identical penalty\/exception behavior as the canonical evaluator.;\\nE_DUPLICATES_AND_OUT_OF_RANGE: duplicate and out-of-range handling is inconsistent. Local evaluator rejects duplicates and out-of-range indices with a heavy penalty (-1e9). Component ignores out-of-range entries and counts duplicates (leading to inflated weight\/value or silent acceptance). Test: '1,1,2' -> component returned 10 (counts duplicate) vs local -1e9 (reject). Fix: detect duplicates and out-of-range indices and return same heavy penalty\/exception as the local solver (no silent filtering).;\\nE_OVERWEIGHT_PENALTY_MISMATCH: overweight penalty magnitude differs and will alter search pressure. Local solver returns total_value - 10000*(overweight) for infeasible solutions; component uses total_value - 10*(overweight). Test: optimal (with swapped weights) became negative because penalty scheme is inconsistent. Fix: align penalty multiplier with local solver (use 10000) or document and justify changed scale\u2014prefer matching local solver for compatibility with provided local solvers.\"\n\n","Evaluacion":{"REPRESENTATION":"Canonical representation: comma-separated 1-based item indices (e.g. '1,3,5'). evaluate_solution accepts str, list, tuple, or int. Fitness returned is a single numeric score: total value if total weight <= capacity, otherwise a penalized score (total_value - 10 * overweight). Items and capacity are embedded inside the function.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"Evaluate a knapsack solution.\n    solution: str (comma-separated indices), list\/tuple of ints, or single int.\n    Returns a single numeric fitness.\n    Embedded instance: 24 items (index, weight, value) and capacity 80.\n    Feasible solutions (total weight <= capacity) return total value.\n    Infeasible solutions return total_value - 10*(overweight) as a penalty.\n    \"\"\"\n    # Normalization helper: accept str, list, tuple, int\n    def _normalize(sol):\n        if sol is None:\n            return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            return [int(p) for p in parts]\n        if isinstance(sol, (list, tuple)):\n            return [int(p) for p in sol]\n        if isinstance(sol, int):\n            return [int(sol)]\n        raise TypeError('Unsupported solution type: %s' % type(sol))\n\n    # Problem data (embedded locally per CRITICAL_INSTRUCTIONS)\n    items = {\n        1: (22, 4),\n        2: (22, 2),\n        3: (4, 11),\n        4: (5, 2),\n        5: (6, 24),\n        6: (14, 5),\n        7: (15, 12),\n        8: (12, 24),\n        9: (3, 21),\n        10: (10, 20),\n        11: (7, 21),\n        12: (3, 23),\n        13: (23, 13),\n        14: (21, 21),\n        15: (7, 5),\n        16: (19, 8),\n        17: (20, 5),\n        18: (22, 8),\n        19: (6, 20),\n        20: (19, 9),\n        21: (14, 4),\n        22: (24, 15),\n        23: (24, 8),\n        24: (1, 6)\n    }\n    capacity = 80\n    n = len(items)\n\n    # Parse and validate\n    try:\n        picked = _normalize(solution)\n    except Exception as e:\n        # invalid input type -> heavy penalty\n        return -1e9\n\n    # Validate indices: filter out-of-range entries and convert to ints\n    valid_picked = []\n    for idx in picked:\n        try:\n            idxi = int(idx)\n        except Exception:\n            continue\n        if 1 <= idxi <= n:\n            valid_picked.append(idxi)\n        # out-of-range indices ignored (could alternatively penalize)\n\n    total_weight = 0\n    total_value = 0\n    for i in valid_picked:\n        w, v = items[i]\n        total_weight += w\n        total_value += v\n\n    if total_weight <= capacity:\n        return total_value\n    else:\n        overweight = total_weight - capacity\n        penalty = 10 * overweight\n        return total_value - penalty\n"},"Vecindad":{"REPRESENTATION":"Comma-separated 1-based item indices string (canonical: sorted unique integers, no spaces). Examples: '', '24', '1,2,4,6'. Internal problem size N=24.","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbour for a 24-item knapsack representation.\n\n    Input normalization: accepts str, int, list or tuple. Returns a canonical\n    comma-separated string of sorted unique indices (1..24) and a movement label.\n    Movement labels: 'add_X', 'remove_X', 'swap_A_for_B', 'noop'.\n    \"\"\"\n    N = 24\n\n    def _normalize(sol):\n        # Accept None, int, str, list, tuple. Return (canonical_str, list_of_ints_sorted)\n        if sol is None:\n            return \"\", []\n        if isinstance(sol, int):\n            lst = [sol]\n        elif isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                lst = []\n            else:\n                parts = [p.strip() for p in s.split(\",\") if p.strip() != \"\"]\n                lst = []\n                for p in parts:\n                    try:\n                        lst.append(int(p))\n                    except Exception:\n                        # ignore non-integer tokens\n                        continue\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for p in sol:\n                try:\n                    lst.append(int(p))\n                except Exception:\n                    # try to parse strings like ' 3 '\n                    if isinstance(p, str):\n                        try:\n                            lst.append(int(p.strip()))\n                        except Exception:\n                            continue\n                    else:\n                        continue\n        else:\n            raise TypeError(\"Unsupported solution type: expected str, int, list, tuple or None\")\n        # filter to valid 1..N and unique-preserving then sort\n        seen = set()\n        filtered = []\n        for v in lst:\n            if 1 <= v <= N and v not in seen:\n                filtered.append(v)\n                seen.add(v)\n        filtered.sort()\n        canonical = \",\".join(str(x) for x in filtered)\n        return canonical, filtered\n\n    canonical, current = _normalize(solution)\n    full_set = set(range(1, N + 1))\n    current_set = set(current)\n    outside = list(full_set - current_set)\n\n    # Edge cases\n    if not current and not outside:\n        return \"\", \"noop\"\n\n    # Choose move type\n    if not current:\n        move = 'add'\n    elif not outside:\n        move = 'remove'\n    else:\n        move = random.choice(['add', 'remove', 'swap'])\n\n    if move == 'add':\n        added = random.choice(outside)\n        new = current + [added]\n        label = f\"add_{added}\"\n    elif move == 'remove':\n        removed = random.choice(current)\n        new = [x for x in current if x != removed]\n        label = f\"remove_{removed}\"\n    else:  # swap\n        removed = random.choice(current)\n        added = random.choice(outside)\n        new = [x for x in current if x != removed] + [added]\n        label = f\"swap_{added}_for_{removed}\"\n\n    new_sorted = sorted(set(new))\n    neighbor = \",\".join(str(x) for x in new_sorted)\n    return neighbor, label\n"},"Perturbacion":{"REPRESENTATION":"Canonical comma-separated string of 1-based item indices (e.g. '1,2,4,6'). Accepts input as str, list, tuple or int. Output of perturb_solution is a tuple: (new_solution_string, move_label).","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    \"\"\"Perturb a solution represented as a comma-separated string or as a list\/tuple\/int.\n\n    Args:\n        solution: str|list|tuple|int representing selected item indices.\n\n    Returns:\n        (new_solution_string, move_label) where new_solution_string is a canonical\n        comma-separated string (no spaces) and move_label describes the perturbation.\n    \"\"\"\n    def normalize(sol):\n        if sol is None:\n            return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == '':\n                return []\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            return parts\n        if isinstance(sol, (list, tuple)):\n            return [str(x) for x in sol]\n        if isinstance(sol, int):\n            return [str(sol)]\n        # fallback for other types\n        return [str(sol)]\n\n    seq = normalize(solution)\n    n = len(seq)\n    # handle trivial cases\n    if n == 0:\n        return ('', 'noop_empty')\n    if n == 1:\n        return (','.join(seq), 'noop_single')\n\n    # determine perturbation strength\n    k = random.randint(1, max(1, n \/\/ 2))\n    seq2 = seq[:]\n\n    op = random.choice(['swap', 'reverse', 'rotate', 'multi_swap'])\n    if op == 'swap':\n        i, j = random.sample(range(n), 2)\n        seq2[i], seq2[j] = seq2[j], seq2[i]\n        label = f'swap_pos_{i}_{j}'\n    elif op == 'reverse':\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        seq2[i:j+1] = list(reversed(seq2[i:j+1]))\n        label = f'reverse_{i}_{j}'\n    elif op == 'rotate':\n        shift = random.randint(1, n - 1)\n        seq2 = seq2[shift:] + seq2[:shift]\n        label = f'rotate_{shift}'\n    else:  # multi_swap\n        for _ in range(k):\n            i, j = random.sample(range(n), 2)\n            seq2[i], seq2[j] = seq2[j], seq2[i]\n        label = f'multi_swap_{k}'\n\n    return (','.join(seq2), label)"}}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_textbook_standard","Representacion":"A solution is a comma-separated string of 1-based item indices, e.g. '1,2,5'. The evaluator rejects non-strings (TypeError), duplicate indices or out-of-range indices with a heavy penalty (-1e9). Fitness = total_value - 10000 * max(0, total_weight - capacity). Items are embedded as (weight, value).","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\": \"v1.0.0\",\n\"FEEDBACK\": \"EVAL_MISMATCH: Component 'Evaluation Function' embeds an incorrect items mapping (weights\/values swapped and many entries differ). Concrete evidence: testing the known optimal string '1,2,4,6,7,13,16,17,18,20,21,23' produces 219 with the authoritative evaluator but -1,389,920 with the component evaluator, proving the mapping is wrong. Fix: replace the embedded items dict with the canonical weights and values (or use the provided weights and values arrays) so total_weight=80 and total_value=219 for the known solution. Use the same data source\/format across all components to avoid divergence.\\n\\nEVAL_ERROR_HANDLING: The component evaluator raises TypeError\/ValueError in some parse cases but the local solver and provided EVAL_CODE expect robust, numeric penalties (e.g. return -1e9) rather than thrown exceptions. This mismatch causes the local solver to crash on malformed or empty inputs. Fix: standardize on the local-solver contract: accept only str inputs but return numeric penalties for empty\/parse\/invalid\/duplicate\/out-of-range cases (return -1e9) instead of raising exceptions. Document exact penalty value and keep it identical to the solver's expected constant.\\n\\nNEIGHBOUR_INCOMPAT: The neighbour generator is overly strict and inconsistent with the evaluator and solver. It currently (a) raises ValueError on duplicate or out-of-range indices (but evaluator penalizes instead), (b) embeds a different items mapping (same data mismatch), and (c) uses an unusual annotated signature -> (\\\"NB_Type\\\",\\\"Movement_Type\\\") which is nonstandard and confusing for integrators. Fixes: 1) Remove raises for user-supplied solutions \u2014 make generate_neighbour tolerant and produce a valid neighbour string or return a standardized error tuple; 2) Use the canonical item data (same as evaluator) or accept a single shared data argument; 3) Adopt a plain, documented signature def generate_neighbour(solution): returning (neighbour_str, move_tag) if the solver expects extra output. Ensure behaviour (penalty vs exception) matches the evaluator\/solver contract.\\n\\nSAMPLE_SOL_AND_PERTURB_MISSING: The SAMPLE_SOL block and the perturbation component are malformed\/absent and are causing parser errors seen in the logs (e.g. 'string indices must be integers, not \\\"str\\\"' and 'invalid syntax'). The sample solution must be provided as a single comma-separated string (e.g. '1,2,4,6,7,13,16,17,18,20,21,23') not multiline table text. The placeholder \\\"$Perturb\\\" must be implemented or removed. Fix: 1) Provide SAMPLE_SOL as a single CSV string matching SOL_TYPE, 2) implement perturb_solution (or document that perturbation is not used) with the same input\/output contract as other components, and 3) run an integration test that loads SAMPLE_SOL, calls evaluate_solution(SAMPLE_SOL) and generate_neighbour(SAMPLE_SOL) to verify no exceptions and expected numeric\/tuple outputs before handing to the local solver.\"\n\n","Evaluacion":{"REPRESENTATION":"A solution is a comma-separated string of 1-based item indices, e.g. '1,2,5'. The evaluator rejects non-strings (TypeError), duplicate indices or out-of-range indices with a heavy penalty (-1e9). Fitness = total_value - 10000 * max(0, total_weight - capacity). Items are embedded as (weight, value).","EVAL_CODE":"import re\n\ndef evaluate_solution(solution):\n    \"\"\"Evaluate a comma-separated string of item indices for the embedded 24-item knapsack.\n\n    Args:\n        solution: str, comma-separated 1-based indices like '1,2,5'. Empty string '' means select no items.\n\n    Returns:\n        numeric fitness = total_value - 10000 * overweight\n        or -1e9 for duplicate\/out-of-range indices.\n\n    Raises:\n        TypeError if solution is not a str.\n        ValueError if indices are not integers.\n    \"\"\"\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of indices')\n\n    s = solution.strip()\n    if s == \"\":\n        selected = []\n    else:\n        parts = re.split(r\"\\s*,\\s*\", s)\n        try:\n            selected = [int(p) for p in parts if p != \"\"]\n        except Exception:\n            raise ValueError('solution contains non-integer tokens')\n\n    # Embedded problem data: index -> (weight, value)\n    items = {\n        1: (22, 4),\n        2: (22, 2),\n        3: (4, 11),\n        4: (5, 2),\n        5: (6, 24),\n        6: (14, 5),\n        7: (15, 12),\n        8: (12, 24),\n        9: (3, 21),\n        10: (10, 20),\n        11: (7, 21),\n        12: (3, 23),\n        13: (23, 13),\n        14: (21, 21),\n        15: (7, 5),\n        16: (19, 8),\n        17: (20, 5),\n        18: (22, 8),\n        19: (6, 20),\n        20: (19, 9),\n        21: (14, 4),\n        22: (24, 15),\n        23: (24, 8),\n        24: (1, 6),\n    }\n    capacity = 80\n\n    # Reject duplicates or out-of-range indices with heavy penalty\n    if len(selected) != len(set(selected)):\n        return -10**9\n    for idx in selected:\n        if idx not in items:\n            return -10**9\n\n    total_weight = sum(items[i][0] for i in selected)\n    total_value = sum(items[i][1] for i in selected)\n    overweight = max(0, total_weight - capacity)\n    return total_value - 10000 * overweight\n"},"Vecindad":{"REPRESENTATION":"Comma-separated string of selected item indices (1-based), e.g. '1,2,5'. Empty string denotes no items selected.","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a single-step neighbour for a knapsack selection represented as a comma-separated string of indices.\n\n    - Input must be a str (matching local evaluator interface). Raises TypeError for non-str.\n    - Rejects duplicate or out-of-range indices with ValueError (keeps behaviour strict and predictable).\n    - Returns (neighbour_solution_str, movement_type) where movement_type in {'add','remove','swap'}.\n\n    The item set and capacity are embedded (24 items, capacity 80) to keep the function self-contained and compatible\n    with the provided sample instance.\n    \"\"\"\n    # Embedded problem data (index -> (weight, value)) from SAMPLE_SOL (index weight value)\n    items = {\n        1: (22, 4), 2: (22, 2), 3: (4, 11), 4: (5, 2), 5: (6, 24), 6: (14, 5), 7: (15, 12), 8: (12, 24),\n        9: (3, 21), 10: (10, 20), 11: (7, 21), 12: (3, 23), 13: (23, 13), 14: (21, 21), 15: (7, 5),\n        16: (19, 8), 17: (20, 5), 18: (22, 8), 19: (6, 20), 20: (19, 9), 21: (14, 4), 22: (24, 15),\n        23: (24, 8), 24: (1, 6)\n    }\n    max_idx = max(items.keys())\n\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of indices')\n\n    s = solution.strip()\n    if s == '':\n        current = []\n    else:\n        try:\n            parts = [p for p in s.split(',') if p != '']\n            current = [int(p) for p in parts]\n        except Exception:\n            raise ValueError('solution string must contain integers separated by commas')\n\n    # Validate duplicates and range (strict handling)\n    if len(current) != len(set(current)):\n        raise ValueError('solution contains duplicate indices')\n    for idx in current:\n        if idx < 1 or idx > max_idx:\n            raise ValueError('index out of range in solution')\n\n    current_set = set(current)\n    all_indices = set(range(1, max_idx + 1))\n    not_included = list(all_indices - current_set)\n\n    # Decide move type\n    possible_moves = []\n    if len(not_included) > 0:\n        possible_moves.append('add')\n    if len(current) > 0:\n        possible_moves.append('remove')\n    if len(not_included) > 0 and len(current) > 0:\n        possible_moves.append('swap')\n\n    if not possible_moves:\n        # No possible move (shouldn't happen because either add or remove is possible unless max_idx==0)\n        return (solution, 'none')\n\n    move = random.choice(possible_moves)\n\n    if move == 'add':\n        pick = random.choice(not_included)\n        new_set = set(current)\n        new_set.add(pick)\n        new_list = sorted(new_set)\n        neighbour = ','.join(str(i) for i in new_list)\n        return (neighbour, 'add')\n\n    if move == 'remove':\n        pick = random.choice(current)\n        new_set = set(current)\n        new_set.remove(pick)\n        new_list = sorted(new_set)\n        neighbour = ','.join(str(i) for i in new_list)\n        return (neighbour, 'remove')\n\n    # swap\n    remove_choice = random.choice(current)\n    add_choice = random.choice(not_included)\n    new_set = set(current)\n    new_set.remove(remove_choice)\n    new_set.add(add_choice)\n    new_list = sorted(new_set)\n    neighbour = ','.join(str(i) for i in new_list)\n    return (neighbour, 'swap')"},"Perturbacion":{"REPRESENTATION":"Inputs accepted: comma-separated indices string (e.g. '1,2,5') or a list\/tuple of ints. Returns same type as input. Items embedded: 24 items, capacity=80. Internal item tuples are (weight,value).","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data (from SAMPLE_SOL). items[index] = (weight, value)\n    items = {\n        1: (4, 22), 2: (2, 22), 3: (11, 4), 4: (2, 5), 5: (24, 6), 6: (5, 14),\n        7: (12, 15), 8: (24, 12), 9: (21, 3), 10: (20, 10), 11: (21, 7), 12: (23, 3),\n        13: (13, 23), 14: (21, 21), 15: (5, 7), 16: (8, 19), 17: (5, 20), 18: (8, 22),\n        19: (20, 6), 20: (9, 19), 21: (4, 14), 22: (15, 24), 23: (8, 24), 24: (6, 1)\n    }\n    capacity = 80\n\n    # Parse input and remember type\n    input_was_str = False\n    if isinstance(solution, str):\n        input_was_str = True\n        s = solution.strip()\n        if s == \"\":\n            sel = []\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            sel = [int(p) for p in parts]\n    elif isinstance(solution, (list, tuple)):\n        sel = list(solution)\n    else:\n        raise TypeError('solution must be a comma-separated string or a list\/tuple of ints')\n\n    # Sanitize: keep ints, in-range, remove duplicates (preserve order)\n    n = len(items)\n    cleaned = []\n    seen = set()\n    for x in sel:\n        try:\n            xi = int(x)\n        except Exception:\n            continue\n        if 1 <= xi <= n and xi not in seen:\n            cleaned.append(xi)\n            seen.add(xi)\n    sel = cleaned\n\n    def total_weight(selection):\n        return sum(items[i][0] for i in selection)\n    def total_value(selection):\n        return sum(items[i][1] for i in selection)\n\n    tw = total_weight(sel)\n\n    # If overweight, remove low-value-density items first\n    if tw > capacity:\n        # compute value\/weight ratios for current items (lower is worse)\n        ratios = [(items[i][1] \/ items[i][0] if items[i][0] > 0 else float('inf'), i) for i in sel]\n        ratios.sort()  # ascending -> worst first\n        for _, i in ratios:\n            if i in sel:\n                sel.remove(i)\n                tw -= items[i][0]\n            if tw <= capacity:\n                break\n        # if still overweight, remove random items until feasible\n        while tw > capacity and sel:\n            r = random.choice(sel)\n            sel.remove(r)\n            tw -= items[r][0]\n    else:\n        # Not overweight: either greedily add high density items or perform a small random swap\n        avail = [i for i in range(1, n + 1) if i not in sel]\n        if random.random() < 0.6:\n            # greedy add by value\/weight density\n            avail.sort(key=lambda i: items[i][1] \/ items[i][0] if items[i][0] > 0 else float('inf'), reverse=True)\n            for i in avail:\n                if tw + items[i][0] <= capacity:\n                    sel.append(i)\n                    tw += items[i][0]\n        else:\n            # small random perturbation: remove up to 2 items and try to add alternatives\n            rcount = 1 if len(sel) <= 1 else random.randint(1, min(2, len(sel)))\n            if sel:\n                to_remove = random.sample(sel, rcount)\n                for i in to_remove:\n                    if i in sel:\n                        sel.remove(i)\n                        tw -= items[i][0]\n                add_candidates = [i for i in range(1, n + 1) if i not in sel]\n                random.shuffle(add_candidates)\n                for j in add_candidates:\n                    if tw + items[j][0] <= capacity:\n                        sel.append(j)\n                        tw += items[j][0]\n                        if len(sel) >= len(to_remove):\n                            break\n\n    # Small random local flips to maintain diversity\n    for idx in range(len(sel)):\n        if random.random() < 0.05:\n            avail = [a for a in range(1, n + 1) if a not in sel]\n            if avail:\n                new = random.choice(avail)\n                old = sel[idx]\n                sel[idx] = new\n                if total_weight(sel) > capacity and random.random() < 0.7:\n                    # revert with some probability if infeasible\n                    sel[idx] = old\n\n    # Final sanitization: unique, in-range\n    final = []\n    seen = set()\n    for x in sel:\n        xi = int(x)\n        if 1 <= xi <= n and xi not in seen:\n            final.append(xi)\n            seen.add(xi)\n\n    if input_was_str:\n        return ','.join(str(x) for x in final)\n    return final\n"}}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard","Representacion":"Comma-separated 1-based customer indices (e.g. \"1,2,5\"). Empty string allowed and yields 0.0.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\": \"v1.0\"\n\n\"FEEDBACK\": \"E_SAMPLE_SOL_PARSE_ERROR: The provided Sample Solution block is malformed (contains a stray table\/lines after the single value). Result: local solver reports SyntaxError and 'string indices must be integers, not \\\"str\\\"'. Fix: replace the entire Sample Solution with a single comma-separated string that matches SOL_TYPE (e.g. \\\"24\\\" or \\\"1,2,5\\\"). Ensure the loader receives exactly a string literal, no extra rows\/columns or embedded ASCII tables.\\nE_PERTURB_MISSING: The Perturbation Function is a placeholder \\\"$Perturb\\\" (absent). Local solvers expect a perturb_solution component. Fix: implement perturb_solution(currentSolution, strength, other_params) -> string (same representation) or provide a wrapper that calls generate_neighbour multiple times; include signature and return type consistent with TARGET_HEURISTIC_GENERAL_SIGNATURE.\\nE_EVAL_OUTPUT_MISMATCH: evaluate_solution currently returns a single float and uses an extremely large PENALTY_BASE (1e9). The local solver notes say extra outputs are expected. This mismatch causes integration fragility and numerical instability. Fix: (a) either document\/adhere to the solver API and return the expected tuple (fitness, total_weight, feasible) or supply an adapter wrapper that returns just the numeric fitness to the solver; (b) reduce penalty scale to a safe, solver-appropriate value (e.g. 1e6) or use explicit feasibility flag instead of punitive arithmetic; (c) validate by calling evaluate_solution('24') and evaluate_solution('') \u2014 current test returned 1.0 and 0.0 respectively, confirming numeric behavior but not multi-output contract.\\nE_NEIGHBOUR_SIGNATURE_AND_META: generate_neighbour compiles and runs but uses an unusual return-annotation and silent token filtering (ignores invalid tokens). This caused ambiguous loader behavior in some runs. Fix: (a) remove nonstandard annotation to avoid tooling confusion: def generate_neighbour(solution):; (b) strictly validate\/raise on invalid solution strings instead of silently ignoring tokens; (c) document and standardize the meta tuple format and types the local solver expects (e.g. return (neighbour_string, {'nb_type':'bitflip','move':'add'}) ); (d) optionally provide deterministic behavior or seed control for reproducible tests. Example observed behavior (from local execution): generate_neighbour('24') produced neighbors such as '4,24' and meta ('bitflip','add'), demonstrating add-move behavior but also showing the need to standardize meta structure.\"\n\n","Evaluacion":{"REPRESENTATION":"Comma-separated 1-based customer indices (e.g. \"1,2,5\"). Empty string allowed and yields 0.0.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated string of 1-based customer indices\n    # Returns: numeric fitness = revenue if feasible; large penalty if infeasible\/invalid.\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n    PENALTY_BASE = 1000000000.0\n\n    # Validate input type\n    if not isinstance(solution, str):\n        return -PENALTY_BASE\n\n    # Parse comma-separated indices\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    # empty selection -> zero revenue, feasible\n    if parts == []:\n        return 0.0\n\n    ids = []\n    for p in parts:\n        try:\n            i = int(p)\n        except Exception:\n            return -PENALTY_BASE\n        if i < 1 or i > 24:\n            return -PENALTY_BASE\n        ids.append(i)\n\n    # no duplicates allowed\n    if len(set(ids)) != len(ids):\n        return -PENALTY_BASE\n\n    # compute revenue and weight\n    total_rev = 0\n    total_w = 0\n    for i in ids:\n        total_rev += values[i-1]\n        total_w += weights[i-1]\n\n    # feasible -> return revenue as fitness\n    if total_w <= capacity:\n        return float(total_rev)\n\n    # infeasible -> heavy penalty proportional to excess capacity\n    excess = total_w - capacity\n    return float(total_rev) - PENALTY_BASE * excess\n"},"Vecindad":{"REPRESENTATION":"Stochastic local neighbour: try a single-item add move (if it fits), else attempt a 1-for-1 swap that yields feasibility, else remove a random selected item. Returns (neighbour_solution_string, (NB_Type, Movement_Type)). Solution format is comma-separated 1-based indices (empty string = empty selection).","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data embedded (no globals)\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n\n    # Robust parsing of comma-separated 1-based indices\n    if not isinstance(solution, str):\n        solution = str(solution)\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    ids = []\n    for p in parts:\n        try:\n            i = int(p)\n        except Exception:\n            # ignore invalid tokens\n            continue\n        if 1 <= i <= 24:\n            ids.append(i)\n    ids_set = set(ids)\n\n    def total_weight(s):\n        return sum(weights[i-1] for i in s)\n\n    cur_w = total_weight(ids_set)\n\n    # 1) Try single-item add move (randomized order)\n    candidates = [i for i in range(1, 25) if i not in ids_set]\n    random.shuffle(candidates)\n    for j in candidates:\n        if cur_w + weights[j-1] <= capacity:\n            newset = sorted(ids_set | {j})\n            neigh = \",\".join(str(x) for x in newset)\n            return neigh, (\"bitflip\", \"add\")\n\n    # 2) Try 1-for-1 swap (remove one selected, add one outside)\n    if ids_set:\n        outs = list(ids_set)\n        ins = [i for i in range(1, 25) if i not in ids_set]\n        random.shuffle(outs)\n        random.shuffle(ins)\n        for out in outs:\n            for inn in ins:\n                new_w = cur_w - weights[out-1] + weights[inn-1]\n                if new_w <= capacity:\n                    newset = set(ids_set)\n                    newset.remove(out)\n                    newset.add(inn)\n                    neigh = \",\".join(str(x) for x in sorted(newset))\n                    return neigh, (\"swap\", \"replace\")\n\n    # 3) Fallback: remove a random selected item (if any)\n    if ids_set:\n        rem = random.choice(list(ids_set))\n        newset = set(ids_set)\n        newset.remove(rem)\n        neigh = \",\".join(str(x) for x in sorted(newset))\n        return neigh, (\"bitflip\", \"remove\")\n\n    # 4) If empty and no add found (very unlikely), return empty\/no-op\n    return \"\", (\"noop\", \"none\")\n"},"Perturbacion":{"REPRESENTATION":"Comma-separated 1-based item indices (string). The perturbation applies a small randomized change: remove, add, swap, or greedy add, while attempting to restore feasibility by removing low value\/weight items if overweight. Empty string denotes selecting no items.","PERTURB_CODE":"def perturb_solution(solution):\n    import random\n    # Problem data embedded\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n\n    # Parse input safely\n    if not isinstance(solution, str):\n        return \"\"\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    ids = []\n    for p in parts:\n        try:\n            i = int(p)\n        except Exception:\n            return \"\"\n        if i < 1 or i > 24:\n            return \"\"\n        ids.append(i)\n    # remove duplicates if any (defensive)\n    ids = list(dict.fromkeys(ids))\n\n    # helper: compute total weight\n    def total_weight(sel):\n        return sum(weights[i-1] for i in sel)\n\n    # helper: repair overweight by removing lowest value\/weight ratio items\n    def repair(sel):\n        while total_weight(sel) > capacity and sel:\n            # compute ratio value\/weight, remove item with smallest ratio (least efficient)\n            ratios = [(values[i-1] \/ float(weights[i-1]), i) for i in sel]\n            ratios.sort()  # ascending, smallest first\n            remove_i = ratios[0][1]\n            sel.remove(remove_i)\n        return sel\n\n    # begin perturbation\n    universe = list(range(1, 25))\n    present = ids[:]  # current selection\n    absent = [i for i in universe if i not in present]\n\n    # choose small perturbation\n    ops = ['remove', 'add', 'swap', 'greedy_add']\n    # bias toward small change\n    op = random.choices(ops, weights=[3,3,2,2], k=1)[0]\n\n    if op == 'remove' and present:\n        k = 1 if random.random() < 0.75 else 2\n        k = min(k, len(present))\n        for _ in range(k):\n            # remove a random item (prefer low ratio)\n            ratios = [(values[i-1] \/ float(weights[i-1]), i) for i in present]\n            # sometimes remove random, sometimes worst\n            if random.random() < 0.6:\n                # remove worst ratio\n                ratios.sort()\n                rem = ratios[0][1]\n            else:\n                rem = random.choice(present)\n            present.remove(rem)\n\n    elif op == 'add' and absent:\n        k = 1\n        candidates = absent[:]\n        # try to add an item likely to improve value: pick by high value\/weight\n        candidates.sort(key=lambda i: values[i-1]\/float(weights[i-1]), reverse=True)\n        for i in candidates:\n            if i in present:\n                continue\n            present.append(i)\n            if total_weight(present) > capacity:\n                # undo if it causes overweight and try next\n                present.remove(i)\n                continue\n            break\n\n    elif op == 'swap' and present and absent:\n        # remove one (low ratio) and add one (high ratio)\n        ratios_present = [(values[i-1]\/float(weights[i-1]), i) for i in present]\n        ratios_present.sort()\n        to_remove = ratios_present[0][1]\n        candidates = absent[:]\n        candidates.sort(key=lambda i: values[i-1]\/float(weights[i-1]), reverse=True)\n        present.remove(to_remove)\n        added = False\n        for i in candidates:\n            present.append(i)\n            if total_weight(present) <= capacity:\n                added = True\n                break\n            present.remove(i)\n        if not added:\n            # revert removal if no feasible add found\n            present.append(to_remove)\n\n    elif op == 'greedy_add' and absent:\n        # greedily add high ratio items until capacity\n        candidates = absent[:]\n        candidates.sort(key=lambda i: values[i-1]\/float(weights[i-1]), reverse=True)\n        for i in candidates:\n            if total_weight(present) + weights[i-1] <= capacity:\n                present.append(i)\n\n    # final repair to ensure feasibility (remove low ratio items if still overweight)\n    present = repair(present)\n\n    # return sorted, comma-separated string (stable order: increasing index)\n    present_sorted = sorted(set(present))\n    if not present_sorted:\n        return \"\"\n    return \",\".join(str(i) for i in present_sorted)\n"}}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard","Representacion":"Comma-separated 1-based item indices as a string (e.g. \"1,4,7\") or a list\/tuple of ints. There are 24 items (indexed 1..24) with embedded (weight,value) pairs; knapsack capacity = 80.","Componente":null,"Version":1,"Feedback":"\"v1.0\",\n\"EVAL_INCONSISTENT: Evaluation function uses a wrong items mapping (weight\/value swapped and values don't match MATH_DATA). Evidence: evaluate_solution('24') -> 6.0 but expected 1.0 (MATH_DATA: v24=1,w24=6); evaluate_solution('1,2') -> 6.0 but expected 44. Root cause: items dict is {index: (22,4),...} documented as (weight,value) but actually contains the original value then weight (and values are wrong). Fix: replace the embedded items mapping with correct (weight,value) pairs derived from MATH_DATA (e.g. item1 -> (4,22), item2 -> (2,22), ...), or better: embed two arrays weights and values and compute totals as weight = weights[idx-1], value = values[idx-1]. Also align error\/penalty semantics with LOCAL_SOLVER (use the same heavy infeasible penalty and invalid-input penalties expected by the solver).\"\n\n\"SAMPLE_SOL_PARSE_ERROR: Local solver errors indicate sample-solution format mismatch and parser fragility (reports: 'string indices must be integers, not \\\"str\\\"' and 'invalid syntax'). Diagnosis: sample solution provided as multi-line\/text block or non-canonical type; component functions expect a single comma-separated string and in some places assume 'solution' is str. Fix: normalize and validate sample solution at load-time: accept both string and list\/tuple\/int by coercing to canonical comma-separated string; ensure sample file only supplies one-line SOL_TYPE. Add robust parsing that strips newlines and rejects extra metadata before attempting to parse indices. Provide an explicit loader wrapper that transforms any incoming SOL_TYPE to the canonical string before handing to evaluate_solution or generate_neighbour.\"\n\n\"NEIGHBOUR_INTERFACE_MISMATCH: generate_neighbour currently requires a string input and returns (neighbour_string, (nb_type,movement_type)) which is mostly OK but can break the LOCAL_SOLVER if it passes list\/tuple inputs or expects different meta format. Evidence: generate_neighbour('') -> ('6',('bitflip','add')) deterministic; generate_neighbour('24') -> ('',('bitflip','remove')) (removal left empty). Fixes: (1) accept list\/tuple\/int inputs and coerce to canonical string internally; (2) document and match the solver's expected meta tuple schema exactly (names and types), or provide a thin wrapper that exposes only (neighbour_string, nb_meta_dict) if solver expects dicts. Also avoid raising on non-string input\u2014return a clear ValueError code consistent with the solver's error-handling policy.\"\n\n\"MISSING_PERTURB_AND_SIGNATURE_GAPS: The system expects a perturb_solution component and the target Heuristic signature Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Current components: perturb is a placeholder ($Perturb) and evaluate\/neighbour do not strictly match the solver's error\/penalty behavior. Fix: implement perturb_solution with the same input\/output contract as generate_neighbour (canonical string in, (string,meta) out). Ensure all components return types exactly as the LOCAL_SOLVER expects (string for SOL_TYPE, float fitness for evaluate_solution; use the solver's penalty constants). Provide small wrapper\/adaptor functions to guarantee compatibility rather than changing the solver.\"","Evaluacion":{"REPRESENTATION":"Comma-separated 1-based item indices as a string (e.g. \"1,4,7\") or a list\/tuple of ints. There are 24 items (indexed 1..24) with embedded (weight,value) pairs; knapsack capacity = 80.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a candidate knapsack selection.\n\n    Args:\n        solution: either a string of comma-separated 1-based indices (e.g. '1,4,7'),\n                  or a list\/tuple of integers.\n\n    Returns:\n        A single numeric fitness (float). If total weight <= capacity the fitness is\n        the total value. If infeasible (weight > capacity) a linear penalty is\n        applied: fitness = total_value - PENALTY_PER_UNIT * (weight - capacity).\n\n    Notes:\n        - Item data and capacity are embedded and self-contained in this function.\n        - Invalid indices raise ValueError.\n    \"\"\"\n    # Embedded problem data: {index: (weight, value)}\n    items = {\n        1: (22, 4), 2: (22, 2), 3: (4, 11), 4: (5, 2), 5: (6, 24), 6: (14, 5),\n        7: (15, 12), 8: (12, 24), 9: (3, 21), 10: (10, 20), 11: (7, 21), 12: (3, 23),\n        13: (23, 13), 14: (21, 21), 15: (7, 5), 16: (19, 8), 17: (20, 5), 18: (22, 8),\n        19: (6, 20), 20: (19, 9), 21: (14, 4), 22: (24, 15), 23: (24, 8), 24: (1, 6)\n    }\n    capacity = 80\n    PENALTY_PER_UNIT = 1e6\n\n    # Parse solution into list of ints\n    if solution is None:\n        selected = []\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            selected = []\n        else:\n            # accept commas or semicolons as separators\n            parts = [p.strip() for p in s.replace(';', ',').split(',') if p.strip() != '']\n            try:\n                selected = [int(p) for p in parts]\n            except Exception:\n                raise ValueError('solution string must contain comma-separated integers')\n    elif isinstance(solution, (list, tuple)):\n        selected = list(solution)\n    else:\n        raise ValueError('unsupported solution type; provide string or list of ints')\n\n    # Validate indices\n    for idx in selected:\n        if not isinstance(idx, int):\n            raise ValueError('solution indices must be integers')\n        if idx < 1 or idx > len(items):\n            raise ValueError('index out of range: %s' % idx)\n\n    # Compute totals\n    total_weight = 0\n    total_value = 0\n    for idx in selected:\n        w, v = items[idx]\n        total_weight += w\n        total_value += v\n\n    if total_weight <= capacity:\n        return float(total_value)\n    else:\n        # Strong linear penalty for infeasible solutions\n        return float(total_value - PENALTY_PER_UNIT * (total_weight - capacity))\n"},"Vecindad":{"REPRESENTATION":"Comma-separated integer indices 1..24 (e.g. \"1,3,5\"). Empty string denotes empty selection.","NB_CODE":"import random\nimport hashlib\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbour of a knapsack selection for a 24-item instance.\n\n    Representation: comma-separated integers 1..24. Empty string means no items.\n    Returns: (neighbour_string, (nb_type, movement_type))\n    Deterministic: seeded by hash of input solution for reproducibility.\n    \"\"\"\n    # Problem-size encoded internally (no globals)\n    n = 24\n\n    if solution is None:\n        solution = ''\n    if not isinstance(solution, str):\n        raise ValueError('solution must be a string of comma-separated integers')\n\n    s = solution.strip()\n    if s == '':\n        selected = set()\n    else:\n        tokens = [t.strip() for t in s.split(',') if t.strip() != '']\n        selected = set()\n        try:\n            for tk in tokens:\n                v = int(tk)\n                if v < 1 or v > n:\n                    raise ValueError('index out of range 1..%d' % n)\n                selected.add(v)\n        except Exception as e:\n            raise ValueError('Invalid solution format: expected comma-separated integers 1..%d' % n) from e\n\n    # deterministic RNG seeded from solution for reproducible neighbour generation\n    seed = int(hashlib.sha256(solution.encode('utf-8')).hexdigest(), 16) & 0xFFFFFFFF\n    rnd = random.Random(seed)\n\n    # choose feasible operations\n    ops = []\n    if len(selected) < n:\n        ops.append('add')\n    if len(selected) > 0:\n        ops.append('remove')\n    if 0 < len(selected) < n:\n        ops.append('swap')\n    ops.append('perturb')\n\n    op = rnd.choice(ops)\n\n    neighbour = set(selected)\n    meta = ('unknown', 'unknown')\n\n    if op == 'add':\n        choices = [i for i in range(1, n + 1) if i not in neighbour]\n        if not choices:\n            # fallback to remove if nothing to add\n            out = rnd.choice(list(neighbour))\n            neighbour.remove(out)\n            meta = ('bitflip', 'remove')\n        else:\n            pick = rnd.choice(choices)\n            neighbour.add(pick)\n            meta = ('bitflip', 'add')\n\n    elif op == 'remove':\n        out = rnd.choice(list(neighbour))\n        neighbour.remove(out)\n        meta = ('bitflip', 'remove')\n\n    elif op == 'swap':\n        out = rnd.choice(list(neighbour))\n        ins_choices = [i for i in range(1, n + 1) if i not in neighbour]\n        ins = rnd.choice(ins_choices)\n        neighbour.remove(out)\n        neighbour.add(ins)\n        meta = ('swap', 'exchange')\n\n    else:  # perturb\n        # small random perturbation (1-2 changes) for diversification\n        strength = 1 if rnd.random() < 0.7 else 2\n        for _ in range(strength):\n            if rnd.random() < 0.5 and len(neighbour) < n:\n                choices = [i for i in range(1, n + 1) if i not in neighbour]\n                if choices:\n                    neighbour.add(rnd.choice(choices))\n            elif len(neighbour) > 0:\n                neighbour.remove(rnd.choice(list(neighbour)))\n        meta = ('perturb', 'multi')\n\n    # canonical string representation (sorted, comma-separated). Empty string for empty set.\n    if len(neighbour) == 0:\n        nb_str = ''\n    else:\n        nb_str = ','.join(str(i) for i in sorted(neighbour))\n\n    return nb_str, meta\n"},"Perturbacion":{"REPRESENTATION":"Comma-separated item indices as integers, e.g. \"24\" or \"1,2,5\" (empty string denotes no items).","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    \"\"\"Perturb a solution given as a comma-separated string of integer item indices.\n\n    Behaviour:\n    - Parses the input string into a list of unique positive integers.\n    - Applies a single small perturbation: add, remove, swap, or mutate (\u00b11\/\u00b12).\n    - Ensures the returned solution is a non-empty comma-separated string of integers.\n\n    Args:\n        solution: str (e.g. '1,2,5' or '24' or '')\n    Returns:\n        str: perturbed solution in the same representation (no spaces, comma-separated).\n    \"\"\"\n    # Normalize input\n    if solution is None:\n        s = \"\"\n    else:\n        s = str(solution).strip()\n    if s == \"\":\n        # Start from a small default single-item solution\n        return \"1\"\n\n    # Parse and validate tokens (must be integers)\n    tokens = [tok.strip() for tok in s.split(',') if tok.strip() != \"\"]\n    try:\n        ints = []\n        for t in tokens:\n            # raise on non-integer\n            v = int(t)\n            if v < 1:\n                raise ValueError\n            ints.append(v)\n    except Exception:\n        raise ValueError(\"Invalid solution string: must be comma-separated positive integers\")\n\n    # Preserve order, remove duplicates\n    seen = set()\n    ints = [x for x in ints if not (x in seen or seen.add(x))]\n\n    if not ints:\n        return \"1\"\n\n    max_idx = max(ints)\n\n    # Choose operation probabilistically, adapt to current length\n    ops = [\"remove\", \"add\", \"swap\", \"mutate\"]\n    if len(ints) <= 1:\n        weights = [0, 3, 0, 2]\n    else:\n        weights = [1, 3, 2, 2]\n    op = random.choices(ops, weights=weights, k=1)[0]\n\n    if op == \"remove\":\n        # remove a random element (keep at least one element)\n        if len(ints) > 1:\n            idx = random.randrange(len(ints))\n            ints.pop(idx)\n        else:\n            # fallback to add if removal would make empty\n            op = \"add\"\n\n    if op == \"add\":\n        # try to add a new small-index item not already present\n        upper = max(10, int(max_idx * 1.2) + 3)\n        candidate = random.randint(1, upper)\n        tries = 0\n        while candidate in ints and tries < 10:\n            candidate = random.randint(1, upper)\n            tries += 1\n        if candidate in ints:\n            candidate = max_idx + 1\n        ints.append(candidate)\n\n    if op == \"swap\":\n        if len(ints) >= 2:\n            i, j = random.sample(range(len(ints)), 2)\n            ints[i], ints[j] = ints[j], ints[i]\n        else:\n            # fallback: add a new index\n            ints.append(max_idx + 1)\n\n    if op == \"mutate\":\n        i = random.randrange(len(ints))\n        delta = random.choice([-2, -1, 1, 2])\n        newv = ints[i] + delta\n        if newv < 1:\n            newv = 1\n        # avoid creating a duplicate; if duplicate, append a new index instead\n        if newv in ints:\n            newv = max_idx + 1\n        ints[i] = newv\n\n    # Final normalization: remove duplicates while preserving first occurrences\n    seen = set()\n    out = []\n    for v in ints:\n        if v not in seen:\n            seen.add(v)\n            out.append(v)\n\n    # Ensure non-empty\n    if not out:\n        out = [1]\n\n    return \",\".join(str(int(x)) for x in out)\n"}}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard","Representacion":"Packed knapsack instance: 24 items (values,weights) and capacity=80. evaluate_solution accepts str\/list\/tuple\/int, treats indices as 1-based, disallows duplicates (0\/1 knapsack), returns total value for feasible solutions or large negative penalty for infeasible\/invalid inputs.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\": \"v1.0\"\n\n\"FEEDBACK\": \"SAMPLE_SOL_SYNTAX_ERROR: Sample Solution block is not a valid SOL_TYPE or a valid Python literal (contains table lines like '1 22 4', stray lines and tokens such as '$resultadosHC'). This produced SyntaxError when solvers compiled SAMPLE_SOL. FIX: replace the block with a single SOL_TYPE-compliant string (e.g. \\\"1,5,13\\\") or a simple Python list [1,5,13] when a literal is required. Remove table rows, capacity line, and any non-data tokens.\\nSAMPLE_SOL_PARSING_MISMATCH: Different local solvers reported \\\"string indices must be integers, not 'str'\\\" indicating inconsistent loader expectations (some code expects a dict\/JSON, others a plain SOL_TYPE string). FIX: standardize the supplied sample to the engine API \u2014 either (A) provide only the SOL_TYPE string (\\\"1,2,5\\\") if the system expects a solution string, or (B) provide a clear dict with instance+solution: {'values':[...],'weights':[...],'capacity':80,'solution':\\\"1,2,5\\\"} \u2014 and document which the local solver will consume.\\nGENERATE_NEIGHBOUR_SIGNATURE: generate_neighbour uses ambiguous annotations\/accepted-input heuristics that may be rejected by minimal parsers or mismatch expected signature. Local solver expects the exact callable signature. FIX: remove annotations and enforce exact header: def generate_neighbour(solution): and guarantee the return is (neighbour_string, (NB_Type, Movement_Type)) where neighbour_string is a canonical comma-separated sorted string (\\\"\\\" for empty) and NB_Type\/Movement_Type are plain strings. Also ensure no reliance on fragile input parsing: explicitly validate and normalize input to 1..24 indices only.\\nEVALUATION_BEHAVIOR_TESTED: I executed the provided evaluate_solution implementation: '' -> 0.0; None -> -1e9; '1,2,3' -> 48.0; '24' -> 1.0; [1,1] (duplicates) -> -1e9; '1,25' (out of range) -> -1e9. IMPLICATIONS & FIXES: the function is permissive but failure modes must be documented. Make penalties explicit and stable (e.g. use -1e9 for invalid input, -1e6 for overweight) and document that the function returns a float revenue for feasible solutions. Also add a thin wrapper that accepts only the SOL_TYPE string to avoid loader mismatches.\"","Evaluacion":{"REPRESENTATION":"Packed knapsack instance: 24 items (values,weights) and capacity=80. evaluate_solution accepts str\/list\/tuple\/int, treats indices as 1-based, disallows duplicates (0\/1 knapsack), returns total value for feasible solutions or large negative penalty for infeasible\/invalid inputs.","EVAL_CODE":"import re\n\ndef evaluate_solution(solution):\n    \"\"\"Evaluate a 0\/1 knapsack solution.\n    - Accepts: string (e.g. \"1,2,3\" or \"1 2 3\"), list\/tuple of ints\/strs, or single int.\n    - Indices are 1-based (1..24).\n    - Returns: float total value if weight <= capacity.\n    - If overweight: returns heavy negative penalty; invalid input or duplicates: heavier penalty.\n    \"\"\"\n    # embedded problem data (values, weights)\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n    PENALTY_INFEASIBLE = -1e6\n    PENALTY_INVALID = -1e9\n\n    try:\n        if solution is None:\n            return float(PENALTY_INVALID)\n\n        # normalize to list of integers (1-based indices)\n        idxs = []\n        if isinstance(solution, str):\n            s = solution.strip()\n            if s == \"\":\n                return 0.0\n            parts = re.findall(r'-?\\d+', s)\n            if not parts:\n                return float(PENALTY_INVALID)\n            idxs = [int(p) for p in parts]\n        elif isinstance(solution, int):\n            idxs = [int(solution)]\n        elif isinstance(solution, (list, tuple)):\n            for e in solution:\n                if isinstance(e, int):\n                    idxs.append(e)\n                elif isinstance(e, str):\n                    parts = re.findall(r'-?\\d+', e)\n                    if not parts:\n                        return float(PENALTY_INVALID)\n                    idxs.extend(int(p) for p in parts)\n                else:\n                    return float(PENALTY_INVALID)\n        else:\n            return float(PENALTY_INVALID)\n\n        # enforce 0\/1 knapsack (no duplicates)\n        if len(idxs) != len(set(idxs)):\n            return float(PENALTY_INVALID)\n\n        total_w = 0\n        total_v = 0\n        n = len(values)\n        for idx in idxs:\n            if not (1 <= idx <= n):\n                return float(PENALTY_INVALID)\n            i = idx - 1\n            total_w += weights[i]\n            total_v += values[i]\n\n        if total_w > capacity:\n            # heavy infeasible penalty; include overflow to break ties\n            return float(PENALTY_INFEASIBLE - (total_w - capacity))\n\n        return float(total_v)\n    except Exception:\n        return float(PENALTY_INVALID)\n"},"Vecindad":{"REPRESENTATION":"Solutions are sets of 1-based item indices encoded as a comma-separated string (e.g. '1,2,5') or as a list\/tuple of ints. generate_neighbour accepts string\/list\/tuple\/int and returns (neighbour_string,(NB_Type,Movement_Type)).","NB_CODE":"import random\nimport re\n\n# generate_neighbour: robust neighbour generator for the 24-item knapsack instance\n# Signature required by the system:\n# def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Return (neighbour_solution_string, (NB_Type, Movement_Type)).\n\n    - Accepts solution as string (e.g. '1,2,5' or '1 2 5' or '[1,2]'), list\/tuple\/set of ints, or single int.\n    - Produces a canonical comma-separated sorted string of 1-based indices (\"\" for empty set).\n    - Embedded instance data (n=24, weights\/values\/capacity) are present for compatibility but not used by the neighbour generator itself.\n    \"\"\"\n\n    # Embedded problem data (internal, no globals):\n    n = 24\n    # values (second column in SAMPLE_SOL lines) and weights (third column)\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n\n    # Normalizer: coerce many input forms to a list of ints\n    def _normalize(sol):\n        if sol is None:\n            return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            # remove surrounding brackets\/parens\n            s = re.sub(r'^[\\[\\(\\{]+|[\\]\\)\\}]+$', '', s)\n            # unify separators to commas\n            s = re.sub(r'\\s+', ',', s)\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            out = []\n            for p in parts:\n                try:\n                    out.append(int(p))\n                except:\n                    # ignore non-integers robustly\n                    continue\n            return out\n        if isinstance(sol, (list, tuple, set)):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except:\n                    continue\n            return out\n        # try to coerce single value to int\n        try:\n            return [int(sol)]\n        except:\n            return []\n\n    current_list = _normalize(solution)\n    # enforce valid index range\n    current = set(i for i in current_list if 1 <= i <= n)\n    all_items = set(range(1, n + 1))\n    excluded = all_items - current\n\n    # Choose an operation with simple heuristics ensuring feasibility of chosen op\n    if len(current) == 0:\n        op = 'add'\n    elif len(excluded) == 0:\n        # all items included: must remove or swap\n        op = random.choice(['remove', 'swap'])\n    else:\n        # weighted stochastic choice favoring small perturbations\n        r = random.random()\n        if r < 0.45:\n            op = 'add'\n        elif r < 0.8:\n            op = 'remove'\n        elif r < 0.95:\n            op = 'swap'\n        else:\n            op = 'toggle'\n\n    neighbour = set(current)\n\n    if op == 'add':\n        # pick one excluded to add\n        pick = random.choice(list(excluded))\n        neighbour.add(pick)\n    elif op == 'remove':\n        # pick one included to remove\n        pick = random.choice(list(current))\n        neighbour.discard(pick)\n    elif op == 'swap':\n        # remove one included and add one excluded\n        remove_pick = random.choice(list(current))\n        add_pick = random.choice(list(excluded))\n        neighbour.discard(remove_pick)\n        neighbour.add(add_pick)\n    elif op == 'toggle':\n        # flip a random index (may add or remove)\n        idx = random.randint(1, n)\n        if idx in neighbour:\n            neighbour.discard(idx)\n        else:\n            neighbour.add(idx)\n    else:\n        # fallback: single-bit flip of a random index\n        idx = random.randint(1, n)\n        if idx in neighbour:\n            neighbour.discard(idx)\n        else:\n            neighbour.add(idx)\n\n    # produce canonical comma-separated sorted string\n    if len(neighbour) == 0:\n        neighbour_str = \"\"\n    else:\n        neighbour_str = \",\".join(str(i) for i in sorted(neighbour))\n\n    # Meta tuple: first element is a high-level neighbour family, second is specific movement\n    meta = (\"set_move\", op)\n    return neighbour_str, meta\n"},"Perturbacion":{"REPRESENTATION":"Canonical solution = sorted comma-separated item indices (e.g. \"1,3,5\"). Items indexed 1..24 with embedded (value,weight) from the instance; capacity = 80. Empty string denotes empty solution.","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data (values, weights) index 1..24; capacity C\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    C = 80\n\n    # Robust parsing: accept str, list, tuple, set, int, None\n    cur = set()\n    if solution is None:\n        cur = set()\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s == '':\n            cur = set()\n        else:\n            toks = [t for t in s.replace(',', ' ').split() if t]\n            for t in toks:\n                try:\n                    i = int(t)\n                    if 1 <= i <= len(weights):\n                        cur.add(i)\n                except:\n                    continue\n    elif isinstance(solution, (list, tuple, set)):\n        for t in solution:\n            try:\n                i = int(t)\n                if 1 <= i <= len(weights):\n                    cur.add(i)\n            except:\n                continue\n    else:\n        try:\n            i = int(solution)\n            if 1 <= i <= len(weights):\n                cur = set([i])\n        except:\n            cur = set()\n\n    def total_weight(s):\n        return sum(weights[i-1] for i in s)\n\n    def total_value(s):\n        return sum(values[i-1] for i in s)\n\n    # If infeasible, remove lowest value\/weight-ratio items until feasible\n    w = total_weight(cur)\n    if w > C:\n        items = sorted(list(cur), key=lambda i: (values[i-1]\/weights[i-1], weights[i-1]))\n        idx = 0\n        while w > C and idx < len(items):\n            rm = items[idx]\n            if rm in cur:\n                cur.remove(rm)\n                w -= weights[rm-1]\n            idx += 1\n\n    not_in = [i for i in range(1, len(weights)+1) if i not in cur]\n    remaining = C - total_weight(cur)\n\n    # Choose a small random perturbation: add, remove, or swap\n    ops = ['add', 'remove', 'swap']\n    op = random.choice(ops)\n\n    if op == 'add' and not_in:\n        candidates = [i for i in not_in if weights[i-1] <= remaining]\n        if candidates:\n            cur.add(random.choice(candidates))\n        else:\n            # fallback: try a swap to potentially fit a better item\n            if cur and not_in:\n                rem = min(cur, key=lambda i: values[i-1]\/weights[i-1])\n                cur.remove(rem)\n                remaining = C - total_weight(cur)\n                candidates = [i for i in not_in if weights[i-1] <= remaining]\n                if candidates:\n                    cur.add(random.choice(candidates))\n    elif op == 'remove' and cur:\n        cur.remove(random.choice(list(cur)))\n    elif op == 'swap' and cur and not_in:\n        rem = random.choice(list(cur))\n        cur.remove(rem)\n        remaining = C - total_weight(cur)\n        candidates = [i for i in not_in if weights[i-1] <= remaining]\n        if candidates:\n            cur.add(random.choice(candidates))\n        else:\n            # if swap failed to add, try to re-add the removed item if it still fits\n            if weights[rem-1] <= C - total_weight(cur):\n                cur.add(rem)\n\n    # Return canonical sorted comma-separated string, empty string for none\n    if not cur:\n        return ''\n    return ','.join(str(i) for i in sorted(cur))"}}
