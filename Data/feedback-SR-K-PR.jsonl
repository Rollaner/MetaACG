{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST: list of unique 1-based customer indices selected (x_i=1 iff index present). Deterministic tie-break handled externally via lexicographic order.","Componentes":{"REPRESENTATION":"INDEX_LIST: list of unique 1-based customer indices selected (x_i=1 iff index present). Deterministic tie-break handled externally via lexicographic order.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Return a cost (lower is better). Feasible: -revenue. Infeasible: large positive penalty.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n    if not isinstance(solution, list):\n        return 10**18\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**18\n        if idx < 1 or idx > n:\n            return 10**18\n        if idx in seen:\n            return 10**18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n    capacity = 304\n    if weight <= capacity:\n        return -revenue\n    overflow = weight - capacity\n    return 10**12 + overflow","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(gallons[i-1] for i in sol)\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        # Drop items with lowest value density first until feasible\n        w = total_weight(sol)\n        if w <= capacity:\n            return sol\n        density = {i: prices[i-1] \/ gallons[i-1] for i in sol}\n        order = sorted(sol, key=lambda i: (density[i], i))  # low density, tie by index\n        sol_set = set(sol)\n        for i in order:\n            if w <= capacity:\n                break\n            sol_set.remove(i)\n            w -= gallons[i-1]\n        return sorted(sol_set)\n\n    cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n    in_set = set(cur)\n    out_set = [i for i in range(1, n+1) if i not in in_set]\n\n    move_choices = []\n    if out_set:\n        move_choices.append(\"add\")\n    if in_set:\n        move_choices.append(\"drop\")\n    if in_set and out_set:\n        move_choices.append(\"swap\")\n    if not move_choices:\n        return (cur, \"FeasibleNB\", \"none\")\n\n    move = random.choice(move_choices)\n    nb = cur.copy()\n\n    if move == \"add\":\n        i = random.choice(out_set)\n        nb.append(i)\n        nb = sorted(set(nb))\n        if total_weight(nb) > capacity:\n            nb = repair_feasible(nb)\n    elif move == \"drop\":\n        i = random.choice(list(in_set))\n        nb.remove(i)\n    else:  # swap\n        i_out = random.choice(list(in_set))\n        i_in = random.choice(out_set)\n        nb.remove(i_out)\n        nb.append(i_in)\n        nb = sorted(set(nb))\n        if total_weight(nb) > capacity:\n            nb = repair_feasible(nb)\n\n    return (nb, \"FeasibleNB\", move)","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(gallons[i-1] for i in sol)\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        w = total_weight(sol)\n        if w <= capacity:\n            return sol\n        density = {i: prices[i-1] \/ gallons[i-1] for i in sol}\n        order = sorted(sol, key=lambda i: (density[i], i))\n        sol_set = set(sol)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in sol_set:\n                sol_set.remove(i)\n                w -= gallons[i-1]\n        return sorted(sol_set)\n\n    pert = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    k = max(3, n \/\/ 8)\n    for _ in range(k):\n        op = random.random()\n        if op < 0.4 and pert:\n            # drop\n            i = random.choice(pert)\n            pert.remove(i)\n        elif op < 0.8:\n            # add\n            candidates = [i for i in range(1, n+1) if i not in pert]\n            if candidates:\n                pert.append(random.choice(candidates))\n                pert = sorted(set(pert))\n        else:\n            # swap\n            in_set = pert\n            out_set = [i for i in range(1, n+1) if i not in pert]\n            if in_set and out_set:\n                i_out = random.choice(in_set)\n                i_in = random.choice(out_set)\n                pert.remove(i_out)\n                pert.append(i_in)\n                pert = sorted(set(pert))\n\n    if total_weight(pert) > capacity:\n        pert = repair_feasible(pert)\n    return pert","SAMPLE_SOL":"[17,22,19,1,15,4,10,20,16,3,2,14,11,24,12,6,8,7,5,9]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\",\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Type annotations misused. 'List()' is not instantiable. Replace all 'List()' with 'list()' and keep 'from typing import List' only for annotations.\nSIG_MISMATCH_SA:Signature uses callable invocations; must pass function references. Use def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).\nSIG_MISMATCH_ILS:Signature uses callable invocations and wrong param order. Use def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate).\nSIG_MISMATCH_TS:Signature uses callable invocations and inconsistent naming. Use def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_tenure).\nFUNC_PASSING_ERROR:Do not write generate_neighbour() \/ evaluate_solution() in parameters; remove parentheses to avoid early execution and type errors.\nEVAL_KNOWN_SOLUTION_CHECK:Evaluation of provided reference solution passes feasibility and cost-sign checks; evaluator consistent with target objective.\nPERTURB_MISSING:No perturbation provided. Implement def perturb_solution(sol,k): perform k random 1-1 swaps\/adds\/drops while maintaining feasibility.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood is shallow and random. Add deterministic best-improving 1-add, 1-drop, 1-1 swap; include 2-1 and 1-2 exchanges for stronger local optimality.\nNB_PERF_ISSUE:Repeated O(|sol|) weight recomputation via total_weight. Maintain (revenue,weight) deltas for O(1) evaluation per move; precompute arrays for p[i], w[i].\nNB_REPAIR_BIAS:Density-based repair after random add\/swap can undo promising structure and inject stochastic bias. Prefer generating only moves that keep feasibility (check w+\u0394w<=C) or use controlled penalty acceptance with bounded infeasibility.\nTIEBREAK_NOT_ENFORCED:Lexicographic tie-break among maximizers not implemented. On equal cost, select solution with lexicographically smaller sorted INDEX_LIST.\nINIT_HEURISTIC_WEAK:No constructive start specified. Build initial solution via greedy by value density with feasibility; then run local improvement.\nR_CANONICALIZATION_MISSING:Ensure solutions are sorted unique INDEX_LIST before storing\/evaluating to avoid duplicates and unstable hashing.\nE_PENALTY_SCALE:Static 1e12 penalty dwarfs objective and prevents gradient in infeasible region. Use adaptive penalty: base_penalty = alpha*max_p_sum with alpha in [5,50], or Lagrangian-style penalty that scales with overflow.\nRANDOMNESS_NONDETERMINISTIC:No RNG control. Set explicit seed and expose it in params for reproducibility.\nACCEPTANCE_RULE_EQCOST:SA\/ILS\/TS acceptance on equal cost should apply lexicographic tie-break; do not accept strictly worse equal-cost moves unless diversification is intended and controlled.\nTS_MEMORY_BLOAT:Tabu on full solutions is expensive. Store tabu attributes on moves (added\/dropped indices) with fixed tenure; ensure canonical solution representation for hashing.\nTS_ASPIRATION_CRITERION_MISSING:Add aspiration to override tabu if a move yields a strictly better cost (or equal cost with lexicographic improvement).\nSA_TEMP_SCHEDULE:Cooling unspecified. Use geometric cooling T<-T*gamma with calibrated gamma in [0.95,0.995]; enforce MIN_TEMP stop; scale initial T using cost std of a sample of neighbors.\nILS_PERTURB_SCALE:Fix perturbation strength relative to n (e.g., k=max(1,ceil(0.05*n))) and adapt if stagnation persists.\nE_CODE_COST_SIGN:Maintain consistent 'lower is better' convention; always return -revenue for feasible solutions and strictly positive for infeasible; avoid sentinel -inf\/inf in heuristic loops.\nCACHE_EVALS:Memoize evaluate_solution on tuples for TS and ILS to reduce repeated computation overhead; ensure no side effects.\nMOVE_GENERATION_ORDER:Use deterministic ordering (by index) for best-improvement scans to align with tie-break and reproducibility.\nSTOPPING_CRITERIA:Define clear iteration\/time\/plateau limits; for SA\/TS include stall counters to trigger perturbation\/diversification.\nSCALING_AND_BOUNDS:Precompute upper bounds via fractional knapsack for pruning in local search or to guide aspiration and acceptance thresholds.\nKNOWN_SOLUTION_ASSERT:Integrate an automated unit test that evaluates the provided reference solution and asserts evaluator correctness without revealing its details during runs.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST: sorted unique list of 1-based customer indices selected (x_i=1 iff index present).","Componentes":{"REPRESENTATION":"INDEX_LIST: sorted unique list of 1-based customer indices selected (x_i=1 iff index present).","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Return a cost (lower is better). Feasible: -revenue. Infeasible: positive penalty with overflow gradient.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n    # Validate\n    if not isinstance(solution, list):\n        return 10**18\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**18\n        if idx < 1 or idx > n:\n            return 10**18\n        if idx in seen:\n            return 10**18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n    capacity = 304\n    if weight <= capacity:\n        return -revenue\n    overflow = weight - capacity\n    base_penalty = 20 * sum(prices)  # 5740\n    return base_penalty + overflow\n","NB_CODE":"import math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Best-improvement feasible neighborhood with lexicographic tie-break\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        # sorted unique and valid range\n        s = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= n))\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(gallons[i-1] for i in sol)\n\n    def total_revenue(sol: List[int]) -> int:\n        return sum(prices[i-1] for i in sol)\n\n    cur = canonical(solution)\n    cur_w = total_weight(cur)\n    cur_rev = total_revenue(cur)\n\n    # If overweight (should not happen normally), repair greedily by removing lowest density\n    if cur_w > capacity:\n        dens = sorted(cur, key=lambda i: (prices[i-1]\/gallons[i-1], i))\n        sset = set(cur)\n        for i in dens:\n            if cur_w <= capacity:\n                break\n            sset.remove(i)\n            cur_w -= gallons[i-1]\n            cur_rev -= prices[i-1]\n        cur = sorted(sset)\n\n    best = cur\n    best_rev = cur_rev\n    best_move = (\"none\")\n\n    in_set = set(cur)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # 1-add moves\n    for i in out_list:\n        nw = cur_w + gallons[i-1]\n        if nw <= capacity:\n            nrev = cur_rev + prices[i-1]\n            if nrev > best_rev or (nrev == best_rev and [*cur, i] and sorted([*cur, i]) < best):\n                best = sorted([*cur, i])\n                best_rev = nrev\n                best_move = \"add\"\n\n    # 1-drop moves\n    for i in cur:\n        nrev = cur_rev - prices[i-1]\n        if nrev > best_rev or (nrev == best_rev and sorted([j for j in cur if j != i]) < best):\n            best = sorted([j for j in cur if j != i])\n            best_rev = nrev\n            best_move = \"drop\"\n\n    # 1-1 swap moves\n    for i_out in cur:\n        for i_in in out_list:\n            nw = cur_w - gallons[i_out-1] + gallons[i_in-1]\n            if nw <= capacity:\n                nrev = cur_rev - prices[i_out-1] + prices[i_in-1]\n                cand = sorted([j for j in cur if j != i_out] + [i_in])\n                if nrev > best_rev or (nrev == best_rev and cand < best):\n                    best = cand\n                    best_rev = nrev\n                    best_move = \"swap\"\n\n    # 2-1 exchanges (drop two, add one)\n    lc = len(cur)\n    for a_idx in range(lc):\n        i1 = cur[a_idx]\n        for b_idx in range(a_idx+1, lc):\n            i2 = cur[b_idx]\n            base_w = cur_w - gallons[i1-1] - gallons[i2-1]\n            base_rev = cur_rev - prices[i1-1] - prices[i2-1]\n            if base_w < 0:\n                continue\n            for i_in in out_list:\n                nw = base_w + gallons[i_in-1]\n                if nw <= capacity:\n                    nrev = base_rev + prices[i_in-1]\n                    cand = sorted([j for j in cur if j not in (i1, i2)] + [i_in])\n                    if nrev > best_rev or (nrev == best_rev and cand < best):\n                        best = cand\n                        best_rev = nrev\n                        best_move = \"2-1\"\n\n    # 1-2 exchanges (drop one, add two)\n    lo = len(out_list)\n    for i_out in cur:\n        base_w = cur_w - gallons[i_out-1]\n        base_rev = cur_rev - prices[i_out-1]\n        for x in range(lo):\n            i_in1 = out_list[x]\n            for y in range(x+1, lo):\n                i_in2 = out_list[y]\n                nw = base_w + gallons[i_in1-1] + gallons[i_in2-1]\n                if nw <= capacity:\n                    nrev = base_rev + prices[i_in1-1] + prices[i_in2-1]\n                    cand = sorted([j for j in cur if j != i_out] + [i_in1, i_in2])\n                    if nrev > best_rev or (nrev == best_rev and cand < best):\n                        best = cand\n                        best_rev = nrev\n                        best_move = \"1-2\"\n\n    return (best, \"FeasibleNB\", best_move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        return sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= n))\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(gallons[i-1] for i in sol)\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        w = total_weight(sol)\n        if w <= capacity:\n            return canonical(sol)\n        # remove lowest density first\n        sol = canonical(sol)\n        dens = sorted(sol, key=lambda i: (prices[i-1]\/gallons[i-1], i))\n        keep = set(sol)\n        for i in dens:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    pert = canonical(solution)\n    k = max(2, n \/\/ 6)\n    for _ in range(k):\n        r = random.random()\n        in_set = set(pert)\n        out_list = [i for i in range(1, n+1) if i not in in_set]\n        if r < 0.34 and pert:\n            # drop\n            idx = random.randrange(len(pert))\n            del pert[idx]\n        elif r < 0.68 and out_list:\n            # add if feasible else skip\n            i = random.choice(out_list)\n            if total_weight(pert) + gallons[i-1] <= capacity:\n                pert.append(i)\n                pert = sorted(set(pert))\n        else:\n            # swap\n            if pert and out_list:\n                i_out = random.choice(pert)\n                i_in = random.choice(out_list)\n                cand = sorted([j for j in pert if j != i_out] + [i_in])\n                if total_weight(cand) <= capacity:\n                    pert = cand\n    if total_weight(pert) > capacity:\n        pert = repair_feasible(pert)\n    return canonical(pert)\n","SAMPLE_SOL":"[]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0\",\n\"FEEDBACK\":\"E_LOCAL_ERR_SIG:Heuristic signatures incorrectly use parentheses on callable parameters (e.g., generate_neighbour()). Pass callables without calling them and match TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\\nE_LOCAL_ERR_TYPING:Runtime attempted to instantiate typing.List (error: 'Type List cannot be instantiated'). Remove typing.List() constructions; use list() for empty lists and [] literals; avoid using typing.* as constructors anywhere.\\nE_LOCAL_ERR_CALLING:Do not call passed-in function parameters at signature level. Inside Heuristic, invoke generate_neighbour(solution) etc. Only pass references to SA\/ILS\/TS wrappers.\\nE_PERTURB_ABSENT:Perturbation function is missing ($Perturb placeholder). Implement a concrete perturb_solution(solution, strength, rng) with reproducible RNG and without filesystem\/OS calls.\\nE_IO_INDEXING:Index base inconsistency detected between components. Representation requires 1-based INDEX_LIST. Enforce canonical 1-based mapping at all IO boundaries and reject\/repair 0-based inputs deterministically.\\nE_TIEBREAK_INCOMPLETE:Lexicographic tie-break not uniformly enforced. Replace ad-hoc checks with a single comparator: if new_cost < best_cost or (new_cost == best_cost and new_sol < best_sol): accept.\\nE_NB_CODE_BUG:Expression 'if nrev == best_rev and [*cur, i] and sorted([*cur, i]) < best' uses a redundant boolean mid-term. Remove the '[*cur, i] and' segment; it is non-functional and obscures intent.\\nE_NB_PERF:Neighborhood is O(n^3) due to nested 1-2\/2-1 loops. Add pruning by: (a) precompute residual capacity and skip infeasible adds by lower bound on minimal gallon, (b) maintain incremental delta weight\/revenue, (c) bound by best possible add using sorted-by-price upper envelope to early break.\\nE_NB_SCOPE:Missing stronger exchanges. Add 2-2 swaps with weight-feasible pruning and a bounded candidate list (e.g., top-k by price or price\/weight) to improve local optimality without full combinatorial blowup.\\nE_REPAIR_POLICY:Overweight repair removes by lowest density; may trap in poor basins. Use multi-remove with best-improvement under feasibility or Lagrangian-weighted score p_i - \u03bb w_i (tune \u03bb via subgradient) to produce higher-quality repairs deterministically.\\nE_EVAL_COST_CONSISTENCY:Evaluation returns negative revenue for feasible and large positive penalties for infeasible. Ensure all heuristics compare costs (lower is better) and never mix with raw revenue. Initialize best_score to +inf and convert objective consistently to cost.\\nE_EVAL_PENALTY_SCALE:Flat base_penalty dominates overflow gradient, reducing guidance near feasibility. Increase overflow coefficient (e.g., base_penalty + \u03b1*overflow with \u03b1 >> max price, or quadratic overflow) to strengthen gradient without dwarfing feasible cost comparisons.\\nE_LEX_CANONICALIZE:Always canonicalize solutions by sorted unique 1-based indices before evaluation and neighborhood generation to guarantee deterministic tie-break and avoid duplicate states.\\nE_SA_PARAM:Provide temperature schedule consistent with cost minimization. Example: T0 set by target acceptance of uphill \u0394 (p_accept=0.8), cooling geometric with factor in [0.90,0.99], stop MIN_TEMP where no accepts occur. Ensure accept if \u0394 < 0 or rand < exp(-\u0394\/T).\\nE_ILS_ACCEPT:Define acceptance by cost with deterministic tie-break. Use iterated local search with controlled perturbation strength growing on stagnation; reset to best if no improvement in k iterations.\\nE_TS_TABU:Tabu search requires attribute-based tabu entries (moves or items), aspiration if new_cost < best_cost, and short-term tabu tenure ~O(sqrt(n)). Ensure tabu does not store entire solutions.\\nE_UNIT_TESTS:Add unit tests: (1) invalid indices, duplicates, and non-int entries must return large positive cost; (2) feasibility boundary cases; (3) lexicographic tie equality; (4) neighborhood never returns heavier-than-capacity.\\nE_RNG_REPRO:Inject rng seed via other_params to ensure reproducibility and deterministic benchmarking.\\nE_MEMORY:Avoid copying full lists in tight loops. Use preallocated arrays and small diff operations; reuse buffers for candidate construction to reduce GC overhead.\\nE_STOPPING:Define stopping based on max iterations without improvement and wall-iteration budgets; log best_cost trace for diagnostics only via in-memory structures (no IO).\\nEVAL_CORRECTNESS_ASSERT:Using the provided evaluate_solution, verified that a feasible candidate consistent with the problem definition yields a strictly better cost than its immediate infeasible\/neighboring variants; evaluation monotonicity and feasibility checks behave as expected.\\nACTIONABLE_FIX_ORDER:1) Correct signatures and remove typing.List instantiation. 2) Implement perturb_solution and RNG wiring. 3) Canonicalize 1-based representation at all boundaries and enforce lex tie-break uniformly. 4) Optimize neighborhood with incremental deltas and pruning; add 2-2 limited exchange. 5) Refine penalty scaling for stronger infeasible guidance. 6) Add unit tests and deterministic seeds. 7) Re-run SA\/ILS\/TS with cost-consistent acceptance and stopping.\\nCOMPLEXITY_NOTES:Current NB worst-case ~O(n^3). With pruning and incremental updates target ~O(n^2) per iteration; SA\/ILS outer loops should cap total evaluations within budget constraints.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST: sorted unique 1-based indices of selected customers.","Componentes":{"REPRESENTATION":"INDEX_LIST: sorted unique 1-based indices of selected customers.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Cost function (lower is better). Feasible: -revenue. Infeasible: large positive penalty with overflow gradient.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    # Validate and canonicalize to sorted unique 1-based indices\n    if not isinstance(solution, list):\n        return 10**18\n    s = []\n    seen = set()\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**18\n        if x < 1 or x > n:\n            return 10**18\n        if x not in seen:\n            seen.add(x)\n            s.append(x)\n    s.sort()\n\n    revenue = 0\n    weight = 0\n    for idx in s:\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    capacity = 304\n    if weight <= capacity:\n        return -revenue\n\n    overflow = weight - capacity\n    # Strong penalty: base + linear and quadratic overflow\n    base_penalty = 10**6\n    return base_penalty + 1000 * overflow + overflow * overflow","NB_CODE":"import math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic, lexicographically-tiebroken best-improvement neighborhood over feasible solutions\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        # Sorted unique and valid 1-based indices\n        s = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                s.append(x)\n        s.sort()\n        return s\n\n    def totals(sol: List[int]):\n        w = 0\n        r = 0\n        for i in sol:\n            j = i - 1\n            w += gallons[j]\n            r += prices[j]\n        return w, r\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        # Lagrangian-guided removal: remove items with smallest (p - lambda*w)\n        s = canonical(sol)\n        w, r = totals(s)\n        if w <= capacity:\n            return s\n        avg_p = sum(prices) \/ n\n        avg_w = sum(gallons) \/ n\n        lam = avg_p \/ max(1.0, avg_w)\n        items = list(s)\n        # sort by (p - lam*w), then by index for determinism (remove worst first)\n        items_sorted = sorted(items, key=lambda i: (prices[i-1] - lam * gallons[i-1], i))\n        kept = set(items)\n        for i in items_sorted:\n            if w <= capacity:\n                break\n            if i in kept:\n                kept.remove(i)\n                w -= gallons[i-1]\n        return sorted(kept)\n\n    cur = repair_feasible(canonical(solution))\n    cur_w, cur_rev = totals(cur)\n\n    best = cur\n    best_rev = cur_rev\n    best_move = \"none\"\n\n    in_set = set(cur)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # Helper: lex-accept if better revenue or equal revenue but lexicographically smaller\n    def consider(cand: List[int], nrev: int, move_name: str):\n        nonlocal best, best_rev, best_move\n        if nrev > best_rev or (nrev == best_rev and cand < best):\n            best = cand\n            best_rev = nrev\n            best_move = move_name\n\n    # 1-add moves\n    residual = capacity - cur_w\n    for i in out_list:\n        wi = gallons[i-1]\n        if wi <= residual:\n            nrev = cur_rev + prices[i-1]\n            cand = cur.copy()\n            # insert maintaining order\n            lo, hi = 0, len(cand)\n            while lo < hi:\n                mid = (lo + hi) \/\/ 2\n                if cand[mid] < i:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            cand.insert(lo, i)\n            consider(cand, nrev, \"add\")\n\n    # 1-drop moves\n    for idx, i in enumerate(cur):\n        nrev = cur_rev - prices[i-1]\n        cand = cur[:idx] + cur[idx+1:]\n        consider(cand, nrev, \"drop\")\n\n    # 1-1 swap moves\n    for idx_out, i_out in enumerate(cur):\n        w_out = gallons[i_out-1]\n        r_out = prices[i_out-1]\n        base_w = cur_w - w_out\n        base_r = cur_rev - r_out\n        residual2 = capacity - base_w\n        for i_in in out_list:\n            wi = gallons[i_in-1]\n            if wi <= residual2:\n                nrev = base_r + prices[i_in-1]\n                # build candidate without full sort: remove position and insert i_in\n                cand = cur[:idx_out] + cur[idx_out+1:]\n                # insert maintaining order\n                lo, hi = 0, len(cand)\n                while lo < hi:\n                    mid = (lo + hi) \/\/ 2\n                    if cand[mid] < i_in:\n                        lo = mid + 1\n                    else:\n                        hi = mid\n                cand.insert(lo, i_in)\n                consider(cand, nrev, \"swap\")\n\n    # Limited 2-2 swaps: try pairs of out items among top-k by price and pairs of in items among smallest by price\n    k = min(8, len(out_list))\n    top_out = sorted(out_list, key=lambda i: (-prices[i-1], gallons[i-1], i))[:k]\n    # choose up to k in-set items with smallest price (more likely candidates to drop)\n    top_in = sorted(cur, key=lambda i: (prices[i-1], gallons[i-1], i))[:min(k, len(cur))]\n    li = len(top_in)\n    lo = len(top_out)\n    for a in range(li):\n        i1 = top_in[a]\n        w1 = gallons[i1-1]\n        r1 = prices[i1-1]\n        for b in range(a+1, li):\n            i2 = top_in[b]\n            w2 = gallons[i2-1]\n            r2 = prices[i2-1]\n            base_w = cur_w - w1 - w2\n            base_r = cur_rev - r1 - r2\n            resid = capacity - base_w\n            if resid <= 0:\n                continue\n            for x in range(lo):\n                j1 = top_out[x]\n                wj1 = gallons[j1-1]\n                if wj1 >= resid:\n                    # need at least two adds to fit, skip pair if single already exceeds\n                    pass\n                for y in range(x+1, lo):\n                    j2 = top_out[y]\n                    wj2 = gallons[j2-1]\n                    nw = base_w + wj1 + wj2\n                    if nw <= capacity:\n                        nrev = base_r + prices[j1-1] + prices[j2-1]\n                        # construct candidate\n                        cand_set = []\n                        rem = set((i1, i2))\n                        for t in cur:\n                            if t not in rem:\n                                cand_set.append(t)\n                        # insert j1 and j2 maintaining order\n                        for add_item in (j1, j2):\n                            lo2, hi2 = 0, len(cand_set)\n                            while lo2 < hi2:\n                                mid2 = (lo2 + hi2) \/\/ 2\n                                if cand_set[mid2] < add_item:\n                                    lo2 = mid2 + 1\n                                else:\n                                    hi2 = mid2\n                            cand_set.insert(lo2, add_item)\n                        consider(cand_set, nrev, \"2-2\")\n\n    return (best, \"FeasibleNB\", best_move)","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                s.append(x)\n        s.sort()\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        w = 0\n        for i in sol:\n            w += gallons[i-1]\n        return w\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        s = canonical(sol)\n        w = total_weight(s)\n        if w <= capacity:\n            return s\n        # remove by lowest (p - lambda*w)\n        avg_p = sum(prices) \/ n\n        avg_w = sum(gallons) \/ n\n        lam = avg_p \/ max(1.0, avg_w)\n        order = sorted(s, key=lambda i: (prices[i-1] - lam * gallons[i-1], i))\n        keep = set(s)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    base = canonical(solution)\n    # Deterministic RNG seed derived from solution contents for reproducibility\n    seed = 1469598103934665603\n    for i in base:\n        seed ^= (i * 1099511628211) & 0xFFFFFFFFFFFFFFFF\n        seed &= 0xFFFFFFFFFFFFFFFF\n    rng = random.Random(seed)\n\n    pert = base[:]\n    k = max(3, n \/\/ 5)\n    for _ in range(k):\n        in_set = set(pert)\n        out_list = [i for i in range(1, n+1) if i not in in_set]\n        move = rng.random()\n        if move < 0.33 and pert:\n            # drop random\n            j = rng.randrange(len(pert))\n            pert.pop(j)\n        elif move < 0.66 and out_list:\n            # add random if feasible\n            i = rng.choice(out_list)\n            if total_weight(pert) + gallons[i-1] <= capacity:\n                # insert maintaining order\n                lo, hi = 0, len(pert)\n                while lo < hi:\n                    mid = (lo + hi) \/\/ 2\n                    if pert[mid] < i:\n                        lo = mid + 1\n                    else:\n                        hi = mid\n                pert.insert(lo, i)\n        else:\n            # swap\n            if pert and out_list:\n                i_out = rng.choice(pert)\n                i_in = rng.choice(out_list)\n                cand = [x for x in pert if x != i_out]\n                # insert maintaining order\n                lo, hi = 0, len(cand)\n                while lo < hi:\n                    mid = (lo + hi) \/\/ 2\n                    if cand[mid] < i_in:\n                        lo = mid + 1\n                    else:\n                        hi = mid\n                cand.insert(lo, i_in)\n                if total_weight(cand) <= capacity:\n                    pert = cand\n\n    if total_weight(pert) > capacity:\n        pert = repair_feasible(pert)\n    return canonical(pert)","SAMPLE_SOL":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,20,22,23,24]"},"Version":2,"Feedback":"COMPONENT_VERSION: v1.0\nFEEDBACK:\n- FIX_SIG_ERROR: Target heuristics incorrectly call function parameters in signatures. Replace e.g. \"def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)\" with \"def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor)\".\n- FIX_TYPING_INSTANTIATION: \"Type List cannot be instantiated\" indicates use of typing.List() as a constructor. Replace any \"List()\" with \"list()\". Use \"from typing import List\" only for annotations, not instantiation.\n- FIX_LOCAL_API_CONSISTENCY: Conform to the enforced signature \"def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params)\". All algorithms (SA, ILS, TS) must wrap to this unified entry point.\n- FIX_EVAL_ORIENTATION: Mixed objective conventions cause incorrect acceptance decisions. Use one evaluation convention consistently. Recommendation: adopt the COMPONENTS Evaluation Function (lower is better, feasible = -revenue; infeasible = large positive penalty) across all heuristics and neighborhood logic. Do not mix with PROBLEM_DEF.EVAL_CODE during search.\n- FIX_REP_CANONICALIZATION: Ensure every entrypoint canonicalizes to sorted unique 1-based indices before evaluation and neighbor generation to satisfy SOL_TYPE and tiebreak rules deterministically.\n- MISSING_PERTURB_FN: \"Perturbation Function: $Perturb\" is undefined. Provide a deterministic, capacity-aware perturbation (e.g., multi-swap + guided add\/drop) and pass it as a callable to heuristics.\n- NB_CODE_FAIL_LOCAL_OPT: Neighborhood currently repairs feasibility only once at the start. Enforce feasibility during move generation to avoid exploring illegal states and ensure consistent delta costs. For infeasible starts, repair before evaluating any move.\n- NB_SCOPE_LIMITED: 2-2 swaps are restricted to top-k by price, which can miss high-density items. Extend candidate pool using price\/weight density and include bounded 2-1 and 1-2 exchanges to escape local maxima under capacity.\n- NB_DELTA_EVAL: Current neighbor evaluation recomputes totals frequently. Implement incremental deltas (track current weight\/revenue; update by added\/dropped items) to reduce per-move cost from O(n) to O(1) per 1-move and O(1)\u2013O(2) per swap.\n- LEX_TIEBREAK_ENFORCEMENT: Ensure tie-handling is centralized: if nrev == best_rev, accept lexicographically smaller candidate. Validate with unit tests for add, drop, swap to avoid nondeterminism.\n- SA_PARAM_FLOW: Temperature schedule not specified. Add parameters (TEMP, MIN_TEMP, cooling_factor) with monotone cooling and reheating guard for stagnation. Acceptance uses cost difference \u0394 = new_cost - cur_cost; accept if \u0394 < 0 or exp(-\u0394\/T) > u.\n- TS_TABU_KEY: Tabu list should store normalized moves (e.g., dropped indices, added indices) not entire solutions to reduce memory and improve generalization. Include aspiration if a move yields strictly better best_score.\n- ILS_ACCEPT: Acceptance criterion unspecified. Use \"better or equal cost OR probabilistic accept based on perturbation strength\" to avoid cycling; include a max no-improve counter to trigger intensification.\n- PENALTY_SCALING: Infeasible penalty in COMPONENTS is base 1e6 + 1000*overflow + overflow^2. Verify this dominates any feasible cost magnitude to prevent accepting infeasible states. With max revenue < 600, current scaling is safe; retain.\n- DATA_PRECOMPUTE: Precompute arrays for prices, gallons, densities, and bitset membership for O(1) lookups within loops. Avoid reconstructing sets\/lists per move; maintain mutable structures with rollback or copy-on-write only when necessary.\n- KNOWN_CHECK_FORMAT: The provided KNOWN_SOLUTION uses 0-based indices contrary to SOL_TYPE (1-based). Shift by +1 for validation. Post-shift, the evaluation using the COMPONENTS evaluator is feasible and consistent with the provided expected score.\n- UNIT_TESTS_MIN: Add minimal tests:\n  - \"EVAL_FEASIBLE_SIGN\": verify empty set cost == 0.\n  - \"EVAL_INFEASIBLE_PENALTY\": verify adding a clearly overweight set yields cost > 1e6.\n  - \"NB_MOVE_IMPROVE\": verify that an available profitable add under capacity is generated and selected.\n  - \"LEX_TIE\": verify lexicographic preference on equal revenue solutions.\n- R_STR_INADEQUATE: Pure INDEX_LIST without fast membership incurs O(log n) insert with manual binary search repeatedly. Maintain both a sorted list and a boolean inclusion array for O(1) membership and O(log n) insertion positions via bisect to improve throughput.\n- CODE_SAFETY: Ensure no functions access filesystem, network, or OS commands per MAIN_CRITICAL_INSTRUCTION. Keep all randomness via a passed-in RNG object to enable reproducibility and testability.\n- SAMPLE_SOLUTION_EVAL: The provided sample solution is feasible at capacity and can serve as a baseline for correctness tests; add an automated check in CI to assert evaluator returns the expected sign and cost.\n- CORRECTED_STUBS_SA: \n  - \"FIX_CODE_SIG_SA:def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor, rng): pass\"\n  - \"FIX_CODE_SIG_TS:def TS(solution, best_sol, best_score, generate_neighbour, evaluate_solution, iterations, tabu_list_size, tabu_tenure, rng): pass\"\n  - \"FIX_CODE_SIG_ILS:def ILS(solution, best_sol, best_score, generate_neighbour, perturb_solution, evaluate_solution, iterations, acceptance_rate, rng): pass\"\n- PERTURB_IMPL_SUGGESTION: \"PERTURB_LNS:k=3-5 random in-set removals biased to low density + greedy reinsert by density under capacity; if stuck, perform a 1-2 or 2-1 exchange.\"\n- PERFORMANCE_TARGET: Aim for O(n + M log n) per iteration where M is the number of considered moves; with delta evaluation and bounded neighborhood (k\u22488\u201312), per-iteration runtime remains stable and scalable."}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST of unique 1-based attraction indices (set semantics, no duplicates).","Componentes":{"REPRESENTATION":"INDEX_LIST of unique 1-based attraction indices (set semantics, no duplicates).","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    # Scores (v_i) for attractions 1..24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_score = 0\n    seen = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > 24:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_score += scores[idx - 1]\n    return float(total_score)\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Times (t_i) for attractions 1..24\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return float(1e9)\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n    capacity = 3040\n    if total_time <= capacity:\n        # Minimization fitness for SA: use negative of objective\n        return float(-obj)\n    overflow = total_time - capacity\n    # Strong penalty (minimization): large positive cost reduced slightly by obj\n    penalty = 1_000_000.0 + overflow\n    return float(penalty - obj)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _canonicalize(sol: List[int]) -> List[int]:\n    # Ensure uniqueness and sorted order for stability\n    return sorted(set(int(i) for i in sol if isinstance(i, int) and 1 <= i <= 24))\n\ndef _random_add(sol: List[int]) -> Tuple[List[int], str, str]:\n    available = [i for i in range(1, 25) if i not in sol]\n    if not available:\n        return sol[:], \"IndexSet\", \"NoMove\"\n    choice = random.choice(available)\n    new_sol = sol[:] + [choice]\n    return _canonicalize(new_sol), \"IndexSet\", \"Add\"\n\ndef _random_remove(sol: List[int]) -> Tuple[List[int], str, str]:\n    if not sol:\n        return sol[:], \"IndexSet\", \"NoMove\"\n    idx = random.randrange(len(sol))\n    new_sol = sol[:]\n    new_sol.pop(idx)\n    return _canonicalize(new_sol), \"IndexSet\", \"Remove\"\n\ndef _random_swap(sol: List[int]) -> Tuple[List[int], str, str]:\n    # If empty, fallback to add\n    base = _canonicalize(sol)\n    if len(base) == 0:\n        return _random_add(base)\n    in_set = base\n    out_set = [i for i in range(1, 25) if i not in in_set]\n    if not out_set:\n        # All items present; fallback to remove\n        return _random_remove(in_set)\n    remove_item = random.choice(in_set)\n    add_item = random.choice(out_set)\n    new_sol = [x for x in in_set if x != remove_item] + [add_item]\n    return _canonicalize(new_sol), \"IndexSet\", \"Swap\"\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (neighbor_solution: List[int], NB_Type: str, Movement_Type: str)\n    NB_Type encodes the representation family; Movement_Type encodes the operator used.\n    \"\"\"\n    sol = _canonicalize(solution if isinstance(solution, list) else [])\n    move = random.random()\n    if move < 0.34:\n        return _random_add(sol)\n    elif move < 0.67:\n        return _random_remove(sol)\n    else:\n        return _random_swap(sol)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _canonicalize(sol: List[int]) -> List[int]:\n    return sorted(set(int(i) for i in sol if isinstance(i, int) and 1 <= i <= 24))\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-kick perturbation: apply K random moves (mix of add\/remove\/swap) to escape local optima.\n    Returns a new solution (List[int]) respecting INDEX_LIST semantics.\n    \"\"\"\n    sol = _canonicalize(solution if isinstance(solution, list) else [])\n    K = 5 + random.randint(0, 5)\n    for _ in range(K):\n        r = random.random()\n        if r < 0.33:\n            # add\n            available = [i for i in range(1, 25) if i not in sol]\n            if available:\n                sol.append(random.choice(available))\n        elif r < 0.66:\n            # remove\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        else:\n            # swap\n            if sol:\n                in_set = _canonicalize(sol)\n                out_set = [i for i in range(1, 25) if i not in in_set]\n                if out_set:\n                    remove_item = random.choice(in_set)\n                    add_item = random.choice(out_set)\n                    sol = [x for x in in_set if x != remove_item] + [add_item]\n        sol = _canonicalize(sol)\n    return _canonicalize(sol)\n","SAMPLE_SOL":"[17,22,16,1,10,15,4,20,19,3,14,24,2,11,12,21,6,8,23,5]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0-crit\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERROR_0:Type List cannot be instantiated; replace all usages of `List()` (typing.List) with `list()` or `[]`. Do not instantiate from typing module.\nFIX_LOCAL_SOLVER_ERROR_1:Signature misuse; pass callables not invoked functions. Change SA\/ILS\/TS params from `generate_neighbour()`\/`evaluate_solution()` to `generate_neighbour`\/`evaluate_solution`.\nFIX_LOCAL_SOLVER_ERROR_2:Unify heuristic signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE. Current SA\/ILS\/TS signatures diverge and break the runner.\nFIX_LOCAL_SOLVER_ERROR_3:Perturbation missing. Implement `perturb_solution(solution, strength, rng)` returning a valid INDEX_LIST; currently `$Perturb` placeholder crashes ILS.\nEVAL_INCONSISTENCY:Two different evaluate behaviors (Problem_DEF returns -inf on invalid; Component eval returns large positive penalty). Standardize on minimization fitness with strong positive penalties and never return -inf to avoid NaN\/ordering issues.\nEVAL_VALIDATION:Ensure invalid indices or duplicates return a large positive cost (not -inf) to keep comparator consistent in SA\/ILS\/TS.\nEVAL_UNIT_TEST:Add a regression test comparing objective and evaluate sign consistency on the provided reference solution to assert correctness before running heuristics.\nREP_SET_SEMANTICS:Canonicalization sorts every neighbor O(k log k); avoid sorting in the hot path. Maintain both (list, set) pair and update incrementally to O(1) membership and O(1) add\/remove.\nNB_CODE_FAIL_LOCAL_OPT:Operators limited to uniform add\/remove\/swap; exploration weak. Add ratio-guided add (argmax v_i\/t_i among available) and swap-2 for intensified local search.\nNB_TIME_AWARE:When overweight, bias remove towards worst v_i\/t_i to quickly restore feasibility; current remove is random and slow to repair.\nDELTA_EVAL_MISSING:Full re-evaluation is O(k) per move. Return move delta metadata from neighbor and compute objective\/time deltas incrementally to cut cost to O(1).\nINIT_REPAIR_ABSENT:No feasibility repair for arbitrary starts. Add deterministic repair that drops worst v_i\/t_i until time <= capacity to prevent early heavy penalties.\nSEED_CONTROL_MISSING:Add `rng` or `seed` via other_params for reproducibility; current random usage is uncontrolled.\nLOGGING_CONTRACT:Neighbor returns (sol, NB_Type, Move_Type) but heuristics likely ignore NB metadata. Extend heuristics to record NB_Type\/Move_Type as extra outputs as expected by the local evaluator.\nTS_TABU_STRUCT:Do not use typing.List for tabu structure. Use deque or list with tuples of moves; add aspiration (accept if strictly better than best_score) and tenure decay.\nSA_TEMP_SCHEDULE:Use geometric cooling with reheats or adaptive schedule based on acceptance rate; current fixed cooling_factor risks premature freezing.\nILS_PERTURB_STRENGTH:Parameterize perturbation strength (e.g., number of random swaps\/add-removes) and use acceptance based on best_score with occasional worsening acceptance to escape basins.\nBOUNDS_CHECK:Neighbor must strictly output 1..24 unique ints; add final clamp and duplicate filter to avoid invalid states leaking into the solver.\nCOMPLEXITY_NOTE:Canonicalize + full eval yields avoidable O(k log k) + O(k) per step. With set+delta, target O(1) per move for both membership and evaluation updates.\nCONSISTENT_COST_CONVENTION:Heuristics must treat \u201cbest\u201d as minimal cost (negated objective). Initialize best_score to +inf; update when new_cost < best_score to avoid inversion bugs.\nRUNTIME_ASSERTS:Add lightweight asserts in debug mode: capacity feasibility after repair, no duplicates, indices in range, and monotone best_score updates to catch silent errors early.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST: list[int] of unique 1-based indices in [1,24]. Set semantics; order ignored; no duplicates.","Componentes":{"REPRESENTATION":"INDEX_LIST: list[int] of unique 1-based indices in [1,24]. Set semantics; order ignored; no duplicates.","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    # Scores (v_i) for attractions 1..24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_score = 0\n    seen = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > 24:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_score += scores[idx - 1]\n    return float(total_score)\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization fitness for SA\/ILS\/TS runners\n    # Times (t_i) for attractions 1..24\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Validate and compute objective\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return 1_000_000_000.0  # large positive penalty for invalid solutions\n\n    # Compute total time\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n\n    if total_time <= capacity:\n        # Feasible: minimize negative objective\n        return float(-obj)\n\n    # Infeasible: strong positive penalty, slightly offset by obj\n    overflow = total_time - capacity\n    penalty = 1_000_000.0 + float(overflow) - obj\n    if penalty <= 0.0:\n        penalty = 1_000_000.0 + float(overflow)  # ensure positive cost\n    return float(penalty)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution: List[int], NB_Type: str, Movement_Type: str)\n    NB_Type encodes representation; Movement_Type encodes operator used.\n    \"\"\"\n    # Problem data embedded\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Canonicalize input to unique valid indices\n    if isinstance(solution, list):\n        base = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        base = []\n    seen = set()\n    canon = []\n    for i in base:\n        if i not in seen:\n            canon.append(i)\n            seen.add(i)\n\n    # Utility: compute total time quickly\n    total_time = 0\n    for i in canon:\n        total_time += times[i - 1]\n\n    # Helper operators\n    def add_random(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        candidates = [i for i in range(1, 25) if i not in present]\n        if not candidates:\n            return sol[:], \"NoMove\"\n        choice = random.choice(candidates)\n        return sol + [choice], \"Add\"\n\n    def add_ratio_guided(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        best = None\n        best_ratio = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_ratio:\n                best_ratio = r\n                best = i\n        if best is None:\n            return sol[:], \"NoMove\"\n        return sol + [best], \"AddRG\"\n\n    def remove_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return sol[:], \"NoMove\"\n        j = random.randrange(len(sol))\n        new_sol = sol[:]\n        new_sol.pop(j)\n        return new_sol, \"Remove\"\n\n    def remove_worst_ratio(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return sol[:], \"NoMove\"\n        worst_idx = 0\n        worst_ratio = float('inf')\n        for k, i in enumerate(sol):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_ratio:\n                worst_ratio = r\n                worst_idx = k\n        new_sol = sol[:]\n        new_sol.pop(worst_idx)\n        return new_sol, \"RemoveWR\"\n\n    def swap_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return add_random(sol)[0], \"Add\"\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return remove_random(sol)\n        rem = random.choice(sol)\n        add = random.choice(outside)\n        new_sol = [x for x in sol if x != rem] + [add]\n        return new_sol, \"Swap\"\n\n    def swap_two(sol: List[int]) -> Tuple[List[int], str]:\n        if len(sol) < 2:\n            return swap_random(sol)\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if len(outside) < 2:\n            return swap_random(sol)\n        rem = random.sample(sol, 2)\n        add = random.sample(outside, 2)\n        pool = [x for x in sol if x not in rem] + add\n        return pool, \"Swap2\"\n\n    # Choose move with feasibility awareness\n    overweight = total_time > capacity\n    u = random.random()\n    if overweight:\n        # Prefer removals when overweight\n        if u < 0.6:\n            neigh, mv = remove_worst_ratio(canon)\n        elif u < 0.85:\n            neigh, mv = remove_random(canon)\n        else:\n            neigh, mv = swap_random(canon)\n    else:\n        if u < 0.35:\n            neigh, mv = add_ratio_guided(canon)\n        elif u < 0.6:\n            neigh, mv = add_random(canon)\n        elif u < 0.85:\n            neigh, mv = swap_random(canon)\n        else:\n            neigh, mv = swap_two(canon)\n\n    # Final uniqueness clamp (preserve order of first occurrence)\n    seen2 = set()\n    final = []\n    for i in neigh:\n        if 1 <= i <= 24 and i not in seen2:\n            final.append(i)\n            seen2.add(i)\n\n    return final, \"IndexList\", mv\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-kick perturbation combining add\/remove\/swap with guided steps\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    if isinstance(solution, list):\n        sol = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        sol = []\n    # Deduplicate preserving order\n    seen = set()\n    sol_clean = []\n    for i in sol:\n        if i not in seen:\n            sol_clean.append(i)\n            seen.add(i)\n    sol = sol_clean\n\n    K = 6 + random.randint(0, 6)\n\n    def add_best_ratio(sol_: List[int]) -> List[int]:\n        present = set(sol_)\n        best = None\n        best_r = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_r:\n                best_r = r\n                best = i\n        return sol_ + [best] if best is not None else sol_\n\n    def remove_worst_ratio(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return sol_\n        worst_idx = 0\n        worst_r = float('inf')\n        for k, i in enumerate(sol_):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_r:\n                worst_r = r\n                worst_idx = k\n        out = sol_[:]\n        out.pop(worst_idx)\n        return out\n\n    def swap_random(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return sol_\n        present = set(sol_)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return sol_\n        rem = random.choice(sol_)\n        add = random.choice(outside)\n        return [x for x in sol_ if x != rem] + [add]\n\n    for _ in range(K):\n        r = random.random()\n        if r < 0.34:\n            sol = add_best_ratio(sol)\n        elif r < 0.67:\n            sol = remove_worst_ratio(sol)\n        else:\n            sol = swap_random(sol)\n        # Deduplicate and clamp\n        seen2 = set()\n        tmp = []\n        for i in sol:\n            if 1 <= i <= 24 and i not in seen2:\n                tmp.append(i)\n                seen2.add(i)\n        sol = tmp\n\n    return sol\n","SAMPLE_SOL":"[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_SIG:Function signatures are invalid. Stop calling callables in the signature. Use def SA(solution,best,best_score,generate_neighbour,evaluate_solution,other_params) and do not write generate_neighbour() in the def line.\nFIX_LIST_INSTANTIATION:Error 'Type List cannot be instantiated' indicates use of typing.List() as a constructor. Replace all List() with list() and keep 'from typing import List' only for type hints.\nALIGN_GENERAL_SIGNATURE:Unify SA\/ILS\/TS to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Map SA\/ILS\/TS args into other_params dict.\nCALLABLE_PASSING:Pass functions as callables (generate_neighbour, evaluate_solution, perturb_solution) without invoking them at call sites; only invoke inside the heuristic loop.\nPERTURB_MISSING:Missing perturbation function. Add def perturb_solution(sol, intensity, rng): perform k in {2..4} removals of worst ratio items and add best ratio items while preserving feasibility.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood lacks targeted exchanges. Add 1-1 and 1-2 exchanges guided by delta cost\/time feasibility; include drop-add pairs that reduce cost when overweight.\nNB_REPAIR_MISSING:When an Add makes solution infeasible, run greedy repair: iteratively remove item with lowest score\/time until total_time <= capacity.\nREPR_CANONICALIZATION:Order is irrelevant (set semantics). Canonicalize neighbor output by sorting unique indices to avoid duplicate states via permutations; improves Tabu hashing and cache hits.\nEVAL_MINIMIZATION_CONSISTENCY:Use evaluate_solution exclusively for comparisons (lower is better). Never compare raw objective_function outputs inside heuristics.\nSEED_CONTROL:Expose RNG seed via other_params['seed'] and use rng = random.Random(seed). Ensure reproducibility for SA\/ILS\/TS.\nSA_ACCEPT_RULE:Use Metropolis acceptance: accept if dE < 0 else exp(-dE\/T) > U. Geometric cooling: T *= alpha (alpha in [0.90,0.99]) until MIN_TEMP. Ensure T, MIN_TEMP, alpha in other_params.\nTS_TABU_DESIGN:Tabu list should store moves (removed,added) or attributes (indices toggled). Tenure ~ 7\u201315. Aspiration: allow tabu if strictly improves best_score.\nILS_ACCEPTANCE:After local search, accept perturbed solution if better (lower cost) or with probability p=other_params['accept_prob'] under worse cost; iterate fixed 'iterations'.\nE_CODE_PERF:Avoid recomputing total_time from scratch. Maintain cost and time incrementally when applying a move using precomputed times\/scores arrays.\nDATA_SCOPE:Cache scores and times once at module scope and pass references to operators to prevent repeated allocations in hot loops.\nNB_MOVE_DISTRIBUTION:Current overweight bias is good, but probabilities are ad-hoc. Increase removal probability to >=0.7 when overweight; prioritize RemoveWR then 1-1 swap that decreases time and increases score ratio.\nTABU_CONFLICT:If using canonical sort, adjust Tabu attributes to be item sets (frozenset) rather than position-based to reflect set semantics.\nVALIDATION_KNOWN_SOLUTION:Provided external validation solution fails objective_function validation (indexing off-spec). Convert to 1-based unique indices to enable correctness checks.\nPIPELINE_SANITY_CHECK:Sample solution evaluates feasible with finite negative cost, confirming evaluate_solution consistency. Use it as a smoke test in CI.\nOUTPUT_AUDIT:Ensure heuristics return (best_solution,best_score,extras) where extras includes NB_Type and Movement_Type logs; local solver expects extra outputs.\nERROR_HANDLING:On invalid neighbor (duplicates\/out-of-range), immediately resample or repair before evaluation to avoid wasting iterations on guaranteed-penalty states.\nPARAM_BOUNDS:Validate other_params (iterations>0, alpha in (0,1), MIN_TEMP>0, taboo_list_size>=1). Fail fast with descriptive exceptions to prevent silent no-ops.\nTESTS_MINIMAL:Add unit tests for generate_neighbour, perturb_solution, and evaluate_solution; assert feasibility preservation and monotonic time repair under NB_REPAIR_MISSING fix.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST: list[int] of unique 1-based indices in [1,24]; set semantics (order ignored); no duplicates.","Componentes":{"REPRESENTATION":"INDEX_LIST: list[int] of unique 1-based indices in [1,24]; set semantics (order ignored); no duplicates.","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    # Scores (v_i) for attractions 1..24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    # Validate representation: list of unique 1-based integers\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_score = 0\n    seen = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > 24:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_score += scores[idx - 1]\n    return float(total_score)\n\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns a minimization fitness for SA\/ILS\/TS.\n    Feasible solutions: cost = -objective (since we maximize objective).\n    Infeasible or invalid: large positive penalty.\n    \"\"\"\n    # Times (t_i) for attractions 1..24\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Validate and compute objective\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return 1_000_000_000.0  # invalid representation penalty\n\n    # Compute total time\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n\n    if total_time <= capacity:\n        # Feasible: minimize negative objective\n        return float(-obj)\n\n    # Infeasible: strong positive penalty, slightly offset by obj but ensure positive\n    overflow = total_time - capacity\n    penalty = 1_000_000.0 + float(overflow) - obj\n    if penalty <= 0.0:\n        penalty = 1_000_000.0 + float(overflow)\n    return float(penalty)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution: List[int], NB_Type: str, Movement_Type: str)\n    NB_Type encodes representation; Movement_Type encodes operator used.\n    Representation: INDEX_LIST of unique 1-based indices in [1,24].\n    Canonicalization: sort unique indices to avoid permutation duplicates.\n    Includes feasibility-aware behavior and greedy repair after Add moves.\n    \"\"\"\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Canonicalize input: keep valid, unique indices\n    if isinstance(solution, list):\n        base = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        base = []\n    seen = set()\n    canon = []\n    for i in base:\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    # Canonical sort to set semantics\n    canon.sort()\n\n    # Utility: compute total time\n    def total_time(sol: List[int]) -> int:\n        tt = 0\n        for i in sol:\n            tt += times[i - 1]\n        return tt\n\n    # Greedy repair to restore feasibility by removing lowest score\/time ratio\n    def repair_feasible(sol: List[int]) -> List[int]:\n        tt = total_time(sol)\n        if tt <= capacity:\n            return sol\n        sol2 = list(sol)\n        while tt > capacity and sol2:\n            worst_idx = 0\n            worst_ratio = float('inf')\n            for k, i in enumerate(sol2):\n                r = scores[i - 1] \/ float(times[i - 1])\n                if r < worst_ratio:\n                    worst_ratio = r\n                    worst_idx = k\n            removed = sol2.pop(worst_idx)\n            tt -= times[removed - 1]\n        # Final canonicalization\n        sol2 = sorted(set(sol2))\n        return sol2\n\n    # Operators\n    def add_random(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        candidates = [i for i in range(1, 25) if i not in present]\n        if not candidates:\n            return list(sol), \"NoMove\"\n        choice = random.choice(candidates)\n        out = list(sol) + [choice]\n        return out, \"Add\"\n\n    def add_ratio_guided(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        best = None\n        best_ratio = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_ratio:\n                best_ratio = r\n                best = i\n        if best is None:\n            return list(sol), \"NoMove\"\n        out = list(sol) + [best]\n        return out, \"AddRG\"\n\n    def remove_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return list(sol), \"NoMove\"\n        j = random.randrange(len(sol))\n        out = list(sol)\n        out.pop(j)\n        return out, \"Remove\"\n\n    def remove_worst_ratio(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return list(sol), \"NoMove\"\n        worst_idx = 0\n        worst_ratio = float('inf')\n        for k, i in enumerate(sol):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_ratio:\n                worst_ratio = r\n                worst_idx = k\n        out = list(sol)\n        out.pop(worst_idx)\n        return out, \"RemoveWR\"\n\n    def swap_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return add_random(sol)[0], \"Add\"\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return remove_random(sol)\n        rem = random.choice(sol)\n        add = random.choice(outside)\n        out = [x for x in sol if x != rem] + [add]\n        return out, \"Swap\"\n\n    def swap_improve_time_or_ratio(sol: List[int]) -> Tuple[List[int], str]:\n        # Try a targeted 1-1 swap that improves ratio or reduces time\n        if not sol:\n            return add_ratio_guided(sol)\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return list(sol), \"NoMove\"\n        best_out = list(sol)\n        best_gain = -1e18\n        base_time = total_time(sol)\n        for rem in sol:\n            for add in outside:\n                new_time = base_time - times[rem - 1] + times[add - 1]\n                gain = (scores[add - 1] - scores[rem - 1])\n                # Prefer swaps that reduce time when overweight or improve score\/time ratio otherwise\n                ratio_gain = (scores[add - 1] \/ float(times[add - 1])) - (scores[rem - 1] \/ float(times[rem - 1]))\n                merit = gain + 0.5 * ratio_gain - max(0, new_time - capacity)\n                if merit > best_gain:\n                    best_gain = merit\n                    best_out = [x for x in sol if x != rem] + [add]\n        return best_out, \"SwapGuided\"\n\n    # Choose move with feasibility awareness\n    overweight = total_time(canon) > capacity\n    u = random.random()\n    if overweight:\n        # Prefer removals when overweight\n        if u < 0.7:\n            neigh, mv = remove_worst_ratio(canon)\n        elif u < 0.9:\n            neigh, mv = swap_improve_time_or_ratio(canon)\n        else:\n            neigh, mv = remove_random(canon)\n    else:\n        if u < 0.35:\n            neigh, mv = add_ratio_guided(canon)\n        elif u < 0.6:\n            neigh, mv = add_random(canon)\n        elif u < 0.85:\n            neigh, mv = swap_improve_time_or_ratio(canon)\n        else:\n            neigh, mv = swap_random(canon)\n\n    # If we just performed an Add that made it infeasible, repair greedily\n    if mv in (\"Add\", \"AddRG\"):\n        neigh = repair_feasible(neigh)\n\n    # Final canonicalization: sort unique indices within [1,24]\n    final = sorted({i for i in neigh if isinstance(i, int) and 1 <= i <= 24})\n\n    return final, \"IndexList\", mv\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-kick perturbation combining guided removals and additions.\n    - Deduplicate and canonicalize input\n    - Apply K in [6..12] kicks of:\n      * remove worst ratio\n      * add best ratio\n      * random swap\n    - Greedy feasibility repair if overweight\n    - Canonicalize (sorted unique) at end\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Clean and canonicalize input\n    if isinstance(solution, list):\n        sol = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        sol = []\n    sol = sorted(set(sol))\n\n    def total_time(sol_: List[int]) -> int:\n        tt = 0\n        for i in sol_:\n            tt += times[i - 1]\n        return tt\n\n    def add_best_ratio(sol_: List[int]) -> List[int]:\n        present = set(sol_)\n        best = None\n        best_r = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_r:\n                best_r = r\n                best = i\n        return sol_ + [best] if best is not None else list(sol_)\n\n    def remove_worst_ratio(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return list(sol_)\n        worst_idx = 0\n        worst_r = float('inf')\n        for k, i in enumerate(sol_):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_r:\n                worst_r = r\n                worst_idx = k\n        out = list(sol_)\n        out.pop(worst_idx)\n        return out\n\n    def swap_random(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return list(sol_)\n        present = set(sol_)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return list(sol_)\n        rem = random.choice(sol_)\n        add = random.choice(outside)\n        return [x for x in sol_ if x != rem] + [add]\n\n    def repair_feasible(sol_: List[int]) -> List[int]:\n        tt = total_time(sol_)\n        if tt <= capacity:\n            return sorted(set(sol_))\n        out = list(sol_)\n        while tt > capacity and out:\n            worst_idx = 0\n            worst_r = float('inf')\n            for k, i in enumerate(out):\n                r = scores[i - 1] \/ float(times[i - 1])\n                if r < worst_r:\n                    worst_r = r\n                    worst_idx = k\n            rem = out.pop(worst_idx)\n            tt -= times[rem - 1]\n        return sorted(set(out))\n\n    K = 6 + random.randint(0, 6)\n    for _ in range(K):\n        r = random.random()\n        if r < 0.34:\n            sol = add_best_ratio(sol)\n        elif r < 0.67:\n            sol = remove_worst_ratio(sol)\n        else:\n            sol = swap_random(sol)\n        # Clamp to valid domain and canonicalize during perturbation\n        sol = sorted({i for i in sol if isinstance(i, int) and 1 <= i <= 24})\n        # Light repair if clearly overweight to avoid excessive penalties\n        if total_time(sol) > capacity and len(sol) >= 2:\n            sol = repair_feasible(sol)\n\n    # Final canonicalization\n    sol = sorted(set(sol))\n    return sol\n","SAMPLE_SOL":[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23]},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0-crit\"\n\"FEEDBACK\":\n- \"E_LOCAL_SOLVER_TYPEHINT:Type List cannot be instantiated => You are instantiating typing.List or using it as a default (e.g., param=List()). Replace with built-in list() or [] and keep typing only in annotations. Remove any List() calls.\"\n- \"E_SIGNATURE_MISMATCH_SA:Your SA signature deviates from TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement as def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass function references (no parentheses).\"\n- \"E_SIGNATURE_MISMATCH_ILS:Your ILS signature includes generate_neighbour() and perturb_solution() with parentheses. Pass function objects, not calls. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE.\"\n- \"E_SIGNATURE_MISMATCH_Tabu:Your TS signature has parentheses on function params and inconsistent naming. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE; include taboo list params inside other_params.\"\n- \"E_PARAM_CALLABLES:Do not write generate_neighbour() or evaluate_solution() in parameter lists or calls where references are needed. Use generate_neighbour and evaluate_solution.\"\n- \"E_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Provide a concrete perturbation, e.g., k-shake with remove_worst_ratio + add_ratio_guided + greedy repair.\"\n- \"E_INDEX_BASE_MISMATCH_KNOWN:The provided known solution uses 0-based indices but the representation and evaluator require 1-based unique indices. Convert by +1 per index before evaluation to validate correctness.\"\n- \"E_EVAL_DUPLICATION:Two evaluate_solution definitions exist (penalty schemes differ). Deduplicate to a single source of truth to avoid inconsistencies. Keep feasibility => cost=-objective; infeasible => large positive penalty.\"\n- \"E_HEURISTIC_MIN_CONVENTION:Ensure all acceptance and best tracking logic minimize cost (negative objective). Never compare raw objective inside SA\/ILS\/TS; compare costs returned by evaluate_solution.\"\n- \"NB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to single add\/remove\/swap. This can stall. Add 1-1 and 2-1 exchanges, multi-add with greedy repair, and small-k VND to escape shallow basins.\"\n- \"NB_GUIDANCE_WEAK:swap_improve_time_or_ratio merit mixes units arbitrarily. Normalize or use Lagrangian score s_i - \u03bb t_i with adaptive \u03bb (e.g., from current slack) to guide swaps.\"\n- \"NB_REPAIR_COST:Greedy repair recomputes ratios O(n) per removal. Precompute v\/t ratios and maintain total time to remove in O(n) once; for repeated runs, use a heap keyed by ratio.\"\n- \"R_STR_INADEQUATE:Set-as-sorted-list canonicalization forces O(n log n) every step. Maintain a boolean mask of size 24 for membership and keep an auxiliary sorted list only when exporting.\"\n- \"E_CODE_PERF:total_time recomputed O(n) every neighbor. Track delta_time and delta_score for add\/remove\/swap to get O(1) neighbor evaluation; defer full recompute to periodic checks.\"\n- \"E_Tabu_CONFIG:\u2018Taboo_Search\u2019 label and \u2018taboo_*\u2019 params inconsistent with standard \u2018Tabu\u2019. Standardize to tabu tenure, list as FIFO with aspiration by better cost; hash moves as (removed,added) pairs.\"\n- \"SA_TEMP_SCHEDULE:Single geometric cooling risks premature freezing. Use reheating or adaptive cooling on stall; cap inner iterations proportional to |N|.\"\n- \"ILS_ACCEPTANCE:\u2018aceptance_rate\u2019 misspelled and ambiguous. Implement Metropolis-style acceptance on cost difference or threshold-accepting; make criterion explicit and consistent.\"\n- \"STOPPING_CRITERIA:Undefined. Add max_iters, max_no_improve, and time budget; ensure deterministic seed support for reproducibility.\"\n- \"ASSERTS_AND_TESTS:Add unit tests: representation validator, objective vs evaluator sign, feasibility penalty positivity, and neighbor invariants (1..24, uniqueness, feasibility post-repair).\"\n- \"REPRO_SEEDS:Set random.seed in local solver to ensure repeatable diagnostics; expose seed via other_params.\"\n- \"SCALING_READINESS:Abstract problem data (scores,times,capacity) out of operators to avoid duplication and enable reuse; pass as immutable context.\"\n\n"}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST: list of unique 1-based attraction indices selected (e.g., [1,5,9]).","Componentes":{"REPRESENTATION":"INDEX_LIST: list of unique 1-based attraction indices selected (e.g., [1,5,9]).","EVAL_CODE":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution):\n    # Validate type\n    if not isinstance(solution, list):\n        return float('-inf')\n    # Internal data\n    scores: List[int] = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times: List[int] = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    # Objective helper\n    def objective_function(sol: List[int]) -> float:\n        seen: Set[int] = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int):\n                return float('-inf')\n            if idx < 1 or idx > 24:\n                return float('-inf')\n            if idx in seen:\n                return float('-inf')\n            seen.add(idx)\n            total += scores[idx - 1]\n        return float(total)\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return float('-inf')\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n    capacity = 3040\n    if total_time <= capacity:\n        return float(obj)\n    overflow = total_time - capacity\n    penalty = 100000.0 + overflow\n    return float(obj - penalty)","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure working on a copy and normalized to unique valid indices within [1,24]\n    if not isinstance(solution, list):\n        current: List[int] = []\n    else:\n        # Deduplicate while preserving order\n        seen = set()\n        current = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                current.append(x)\n    n_items = 24\n    # Define possible moves: add, remove, swap\n    moves = []\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) > 0:\n        moves.append(\"remove\")\n    if 0 < len(current) < n_items:\n        moves.append(\"swap\")\n    if not moves:\n        # Fallback: start with a single random item\n        new_sol = [random.randint(1, n_items)]\n        return (new_sol, \"INDEX_LIST\", \"init\")\n    move = random.choice(moves)\n    new_sol = current.copy()\n    if move == \"add\":\n        available = [i for i in range(1, n_items + 1) if i not in set(new_sol)]\n        if available:\n            new_sol.append(random.choice(available))\n    elif move == \"remove\":\n        if new_sol:\n            idx = random.randrange(len(new_sol))\n            new_sol.pop(idx)\n    else:  # swap\n        if new_sol and len(new_sol) < n_items:\n            in_set = set(new_sol)\n            out_items = [i for i in range(1, n_items + 1) if i not in in_set]\n            if out_items:\n                # replace a random position with a random outside item\n                pos = random.randrange(len(new_sol))\n                new_sol[pos] = random.choice(out_items)\n                # ensure no duplicates (rare but safe)\n                dedup_seen = set()\n                dedup = []\n                for x in new_sol:\n                    if x not in dedup_seen:\n                        dedup_seen.add(x)\n                        dedup.append(x)\n                new_sol = dedup\n    return (new_sol, \"INDEX_LIST\", move)","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: perform k random edits (add\/remove\/swap)\n    n_items = 24\n    if not isinstance(solution, list):\n        sol: List[int] = []\n    else:\n        # Normalize: keep unique, valid indices\n        seen = set()\n        sol = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                sol.append(x)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        moves = []\n        if len(sol) < n_items:\n            moves.append(\"add\")\n        if len(sol) > 0:\n            moves.append(\"remove\")\n        if 0 < len(sol) < n_items:\n            moves.append(\"swap\")\n        if not moves:\n            sol = [random.randint(1, n_items)]\n            continue\n        move = random.choice(moves)\n        if move == \"add\":\n            available = [i for i in range(1, n_items + 1) if i not in set(sol)]\n            if available:\n                sol.append(random.choice(available))\n        elif move == \"remove\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if sol and len(sol) < n_items:\n                in_set = set(sol)\n                out_items = [i for i in range(1, n_items + 1) if i not in in_set]\n                if out_items:\n                    pos = random.randrange(len(sol))\n                    sol[pos] = random.choice(out_items)\n                    # Deduplicate after swap\n                    dedup_seen = set()\n                    dedup = []\n                    for x in sol:\n                        if x not in dedup_seen:\n                            dedup_seen.add(x)\n                            dedup.append(x)\n                    sol = dedup\n    return sol","SAMPLE_SOL":"[17, 22, 1, 16, 10, 15, 4, 20, 19, 3, 14, 2, 24, 11, 7, 12, 18, 6, 8, 23]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_CRASH:Type List cannot be instantiated; replace typing.List\/typing.Tuple constructions with built-in list\/tuple and never call typing aliases. Example: use list() not List().;E_SIG_CALLABLES:Heuristic signatures show generate_neighbour() and evaluate_solution() with parentheses; pass callables by reference (generate_neighbour, evaluate_solution) not invoked at signature\/call sites.;E_ILS_MISSING_PERTURB:Perturbation Function is undefined ($Perturb placeholder); define a concrete perturb_solution(solution, strength, rng) and pass it by reference to ILS.;E_TARGET_SIG_MISMATCH:TREATED Heuristic wants Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) but per-algorithm signatures differ; normalize to a single general dispatcher or adapt wrappers to the TARGET_HEURISTIC_GENERAL_SIGNATURE.;E_INDEXING_MISMATCH:KNOWN_SOLUTION uses 0-based indices while evaluation enforces 1..24; standardize to 1-based in all components or convert before evaluation to avoid silent -inf.;E_DUP_HANDLING:generate_neighbour deduplication after swap may reorder implicitly and hides duplicate-creation bugs; enforce set semantics up-front and validate in tests rather than post-hoc dedup within neighbour.;E_FEASIBILITY_STRATEGY:Neighbour moves are unconstrained; feasibility is only handled via large penalty in evaluation, causing poor search guidance; add feasibility-preserving moves or a repair step.;E_MOVE_SET_WEAK:Only add\/remove\/random swap; lacks targeted exchanges (1\u20131, 2\u20131, 1\u20132) which are critical in 0\/1 knapsack landscapes; add k-exchange with delta-evaluation.;E_COST_SIGN_CONFLICT:Framework expects \u201cbest as lesser cost\u201d; current evaluate_solution returns positive score for feasible solutions; wrap objective as cost=-score for solvers minimizing cost and keep penalty consistent in cost space.;E_RECOMP_COST:Full recomputation O(k) per neighbor for score\/time; switch to delta updates using precomputed arrays and maintain (score,time) in state to achieve O(1) updates for add\/remove and O(1) for 1\u20131 swaps.;E_RANDOM_BIAS:add chooses uniformly from remaining items; this biases toward low v\/t; bias add selection by value-to-time ratio or use roulette wheel by normalized efficiency.;E_SA_COOLING:No concrete cooling or acceptance controls documented; ensure Metropolis acceptance uses cost with temperature schedule T<-alpha*T, with reheating safeguards if stagnation.;E_TABU_MEMORY:Missing tabu attribute definition; store attribute as item index added\/removed and prohibit reversing moves for tabu_duration; add aspiration when a move yields a new best cost.;E_INIT_SOL:No construction heuristic; random init degrades performance; seed with greedy by value-to-time ratio with simple capacity-respecting fill, then local-optimize.;E_EVAL_VALIDATION:objective_function returns -inf on invalid inputs but local solvers don\u2019t prevalidate; add early guards to drop\/repair invalid moves before evaluation to avoid wasted iterations.;E_PARAM_RANGES:No bounds\/validation for TEMP, MIN_TEMP, cooling_factor, iterations; enforce sane defaults (e.g., TEMP>0, 0<cooling_factor<1, MIN_TEMP<<TEMP).;R_FIX_LIST_ERROR:Search all solver code for List() or Tuple() and replace with list() \/ tuple(); remove any attempts to instantiate typing.List.;R_SIG_FIX:Refactor solver interfaces to accept callables without parentheses and pass parameters explicitly; e.g., def SA(solution,best_sol,best_cost,gen_nb,eval_fn,temp,min_temp,cooling).;R_DEFINE_PERTURB:Implement perturb_solution with strength-driven random k-exchange or guided shake (e.g., remove r items with lowest marginal ratio and add r from top ratio), ensure feasibility via repair.;R_ADD_FEASIBLE_MOVES:Add feasibility-preserving add\/remove guided by time capacity: reject add if time exceeds capacity, or immediately repair by removing worst items until feasible.;R_DELTA_EVAL:Maintain (score,time,set_bits) in state; for add i: score+=v[i], time+=t[i]; for remove i: score-=v[i], time-=t[i]; for swap i->j: score+=v[j]-v[i], time+=t[j]-t[i]; complexity O(1).;R_MOVE_EXPANSION:Add targeted exchanges: (1\u20131) choose i in set, j not in set maximizing \u0394= v[j]-v[i] under time; (2\u20131)\/(1\u20132) for escaping local minima; implement bounded neighborhood sampling for O(n log n) per iteration.;R_GREEDY_SEED:Build initial solution by sorting items by v\/t descending and adding while feasible; then perform best-improvement hill-climb with 1\u20131 swaps.;R_TABU_DETAILS:Use short-term tabu list on items or moves, size ~O(sqrt(n)); aspiration if candidate improves best cost; diversify by penalizing frequently selected items.;R_SA_TUNING:Set initial T so acceptance rate ~0.8 for uphill moves; geometric cooling 0.95\u20130.99; reheat if no improvement in X iterations.;R_ACCEPTANCE_ILS:For ILS use accept-if-better or accept-with-prob based on cost gap; limit perturbation strength to escape but preserve structure.;R_REPAIR_HEURISTIC:On infeasible neighbor, remove items with lowest v\/t until time<=capacity; alternative: drop items with lowest marginal contribution v - lambda*t where lambda tuned.;R_CACHE_ARRAYS:Precompute v,t,ratio arrays; avoid recreating lists\/sets per neighbor; reuse buffers to minimize allocations.;R_RANDOM_SEED:Control RNG via seed in other_params for reproducibility and verifiability.;R_TEST_SUITE:Add unit tests: indexing validity, duplicate rejection, feasibility after moves, delta-eval correctness, and solver convergence on small instances.;ASSERT_CORRECTNESS:Independent evaluation against the provided evaluator confirms internal consistency of the evaluation logic when indices are standardized; ensure all components use the same indexing convention and cost sign before benchmarking.;LOCAL_SOLVER_EXTRA_OUTPUTS:Augment solvers to return (best_solution,best_cost,iterations,feasible_time,final_temp or tabu_stats) to align with evaluation\/diagnostics requirements.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float('inf')\n    # Internal data (scores v_i and times t_i)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    # Objective helper (sum of selected scores)\n    def objective_function(sol):\n        total = 0\n        seen = set()\n        for idx in sol:\n            if not isinstance(idx, int):\n                return float('-inf')\n            if idx < 1 or idx > n_items:\n                return float('-inf')\n            if idx in seen:\n                return float('-inf')\n            seen.add(idx)\n            total += scores[idx - 1]\n        return float(total)\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return float('inf')\n    # Compute total time\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n    capacity = 3040\n    # Cost convention: minimize cost; feasible cost = -objective\n    if total_time <= capacity:\n        return float(-obj)\n    # Infeasible: strong positive penalty to be worse than any feasible\n    overflow = total_time - capacity\n    penalty = 100000.0 + float(overflow)\n    return float(penalty)","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to a valid unique list within [1,24]\n    n_items = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    if isinstance(solution, list):\n        seen = set()\n        current = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                current.append(x)\n    else:\n        current = []\n    # Helper: compute time and feasibility\n    cur_time = 0\n    for i in current:\n        cur_time += times[i - 1]\n    # Helper: repair to feasibility by removing worst efficiency items if needed\n    def repair(sol):\n        total_t = 0\n        for k in sol:\n            total_t += times[k - 1]\n        if total_t <= capacity:\n            return sol\n        # Remove items with lowest value-to-time ratio until feasible\n        ratios = [(idx, scores[idx - 1] \/ times[idx - 1]) for idx in sol]\n        # Sort ascending by ratio (worst first)\n        ratios.sort(key=lambda x: x[1])\n        keep = set(sol)\n        for idx, _ in ratios:\n            if total_t <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                total_t -= times[idx - 1]\n        # Preserve original relative order\n        new_sol = []\n        seen_local = set()\n        for x in sol:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n    # Candidate moves: add, remove, swap (1-1)\n    moves = []\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) > 0:\n        moves.append(\"remove\")\n    if 0 < len(current) < n_items:\n        moves.append(\"swap\")\n    if not moves:\n        # Initialize with a single random valid item\n        item = random.randint(1, n_items)\n        return ([item], \"INDEX_LIST\", \"init\")\n    move = random.choice(moves)\n    new_sol = list(current)\n    if move == \"add\":\n        present = set(new_sol)\n        candidates = [i for i in range(1, n_items + 1) if i not in present]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n            new_sol = repair(new_sol)\n    elif move == \"remove\":\n        if new_sol:\n            pos = random.randrange(len(new_sol))\n            new_sol.pop(pos)\n            # Already feasible by construction after removal\n    else:  # swap 1-1\n        if new_sol:\n            present = set(new_sol)\n            outside = [i for i in range(1, n_items + 1) if i not in present]\n            if outside:\n                pos = random.randrange(len(new_sol))\n                out_item = random.choice(outside)\n                new_sol[pos] = out_item\n                # Ensure uniqueness\n                dedup_seen = set()\n                dedup = []\n                for x in new_sol:\n                    if x not in dedup_seen:\n                        dedup_seen.add(x)\n                        dedup.append(x)\n                new_sol = repair(dedup)\n    return (new_sol, \"INDEX_LIST\", move)","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Normalize input\n    n_items = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    if isinstance(solution, list):\n        seen = set()\n        sol = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                sol.append(x)\n    else:\n        sol = []\n    # Helper: feasibility repair removing lowest ratio items\n    def repair(sol_local):\n        total_t = 0\n        for k in sol_local:\n            total_t += times[k - 1]\n        if total_t <= capacity:\n            return sol_local\n        ratios = [(idx, scores[idx - 1] \/ times[idx - 1]) for idx in sol_local]\n        ratios.sort(key=lambda x: x[1])\n        keep = set(sol_local)\n        for idx, _ in ratios:\n            if total_t <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                total_t -= times[idx - 1]\n        new_sol = []\n        seen_local = set()\n        for x in sol_local:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n    # Perform k random edits to escape local minima\n    k = random.randint(3, 6)\n    for _ in range(k):\n        moves = []\n        if len(sol) < n_items:\n            moves.append(\"add\")\n        if len(sol) > 0:\n            moves.append(\"remove\")\n        if 0 < len(sol) < n_items:\n            moves.append(\"swap\")\n        if not moves:\n            sol = [random.randint(1, n_items)]\n            continue\n        m = random.choice(moves)\n        if m == \"add\":\n            present = set(sol)\n            candidates = [i for i in range(1, n_items + 1) if i not in present]\n            if candidates:\n                sol.append(random.choice(candidates))\n                sol = repair(sol)\n        elif m == \"remove\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if sol:\n                present = set(sol)\n                outside = [i for i in range(1, n_items + 1) if i not in present]\n                if outside:\n                    pos = random.randrange(len(sol))\n                    sol[pos] = random.choice(outside)\n                    # Deduplicate and repair\n                    dedup_seen = set()\n                    dedup = []\n                    for x in sol:\n                        if x not in dedup_seen:\n                            dedup_seen.add(x)\n                            dedup.append(x)\n                    sol = repair(dedup)\n    return sol","SAMPLE_SOL":[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23]},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_API_ARITY: generate_neighbour returns (new_sol, 'INDEX_LIST', move). Solvers expect 2 values. Remove 'INDEX_LIST' and return exactly (new_sol, move).\nE_INIT_RETURN_ARITY: In init path, returns ([item], 'INDEX_LIST', 'init'). Must return only (new_sol, move). Ensure consistency across all branches.\nE_PERTURB_ABSENT: Perturbation function missing. Provide def perturb_solution(solution, strength, rng): with k-exchange (random remove-add with repair) and no external side effects.\nE_INDEX_BASE_MISMATCH: KNOWN_SOLUTION uses 0-based indices while evaluation and operators expect 1..24. Standardize to 1-based or add a wrapper to convert 0-based -> 1-based before evaluation.\nE_EVAL_DUPLICATION: Objective\/evaluation defined in two places with slightly different conventions. Risk of drift. Centralize objective\/times\/scores and expose a single evaluate_solution cost function used everywhere.\nE_COST_CONVENTION_CHECK: Heuristics require minimization; internal evaluate returns -obj for feasible and +penalty for infeasible, while external EVAL_CODE returns raw objective with penalty subtraction. Ensure solvers consistently use the minimization version.\nE_SIGNATURE_CONSISTENCY: Target signature shows functions passed as callables; ensure solvers pass function objects (not invoked) and respect return types. Align SA\/ILS\/TS drivers with the general signature to avoid unpack errors.\nNB_REPAIR_BIAS: Repair removes lowest value\/time greedily, which can cause search stagnation. Add 1-1, 2-1, and 1-2 exchanges with feasibility-aware selection to escape local minima.\nNB_MOVE_SET_INCOMPLETE: Only add\/remove\/1-1 swap implemented. Add drop-add (ejection chain), multi-add with subsequent repair, and time-aware best-improving swap to increase neighborhood strength.\nNB_EVAL_DELTA: Each neighbor recomputes time\/feasibility in O(k). Maintain running totals and prefetch times\/scores to evaluate add\/remove\/swap in O(1) using deltas.\nNB_RANDOM_SEEDING: No RNG control. Thread non-determinism hurts reproducibility. Inject rng from other_params and avoid global random calls.\nINIT_HEURISTIC_WEAK: Random single-item init harms convergence. Replace with greedy ratio fill (v\/t) with tie-break by absolute v, then local improvement; guarantees a strong feasible baseline.\nR_INDEX_LIST_ORDER_IRRELEVANT: Representation preserves order though set semantics apply. Normalize to sorted unique list to stabilize hashing\/tabu and duplicate detection.\nILS_ACCEPTANCE_RULE: Not specified. Add acceptance criteria (e.g., accept if better or with probability exp(-(delta)\/T) when using penalties) to prevent premature convergence.\nTS_TABU_PARAMS: Tabu duration\/size unspecified relative to problem size. Set tabu tenure \u2248 [7..15] and list size O(n) with aspiration for strictly better solutions.\nE_TIME_CAPACITY_REPAIR: repair() sorts full list each call O(k log k). Cache ratios and update incrementally or maintain a heap of worst ratios for O(log k) deletions.\nE_VALIDATION_STRICTNESS: objective_function returns -inf for invalid; internal evaluate maps to +inf. Ensure solvers guard against inf and skip\/penalize invalid neighbors instead of attempting unpack\/assignment.\nTEST_COVERAGE_GAP: No unit tests for neighbor arity, feasibility after moves, and perturb effect. Add asserts: shape, uniqueness, bounds, feasibility, and monotonic penalty behavior.\nACTIONABLE_PATCH_NB: Change signature to def generate_neighbour(solution): return (new_sol, move). Remove representation token. Ensure all branches return tuple length 2 and uniqueness within [1,24].\nACTIONABLE_PATCH_PERTURB: def perturb_solution(sol, strength, rng): perform k=random.randint(1,strength) random removals; then add best ratio items until near capacity; finally apply 1-1 best-improving swap attempts.\nACTIONABLE_PATCH_INIT: Build initial solution by descending v\/t, skip items exceeding capacity; then attempt greedy fill by best absolute v within remaining time; finalize with local 1-1 improvements.\nEVAL_CORRECTNESS_ASSERTION: Cross-check evaluation with standardized indices and consistent cost convention before running solvers to prevent silent scoring mismatches.\nPERF_HINT_CACHING: Store scores, times, and capacity as closed-over constants; avoid reconstructing lists in hot paths; replace loops with sum of pre-fetched values or maintained aggregates.\nLOGGING_MINIMAL: Add lightweight counters (evals, accepted moves, improved moves) to diagnose stagnation and calibrate temperature\/tenure\/strength without verbose output.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Minimization cost: feasible -> negative objective; infeasible -> large positive penalty\n    # Internal data (embedded constants)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n    # Validate type and contents\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_score = 0.0\n    total_time = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n_items:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        total_score += float(scores[idx - 1])\n        total_time += times[idx - 1]\n    if total_time <= capacity:\n        return float(-total_score)\n    overflow = total_time - capacity\n    penalty = 100000.0 + float(overflow)\n    return float(penalty)","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal constants\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n\n    # Normalize input -> unique 1..n list\n    if isinstance(solution, list):\n        seen = set()\n        current = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                current.append(x)\n    else:\n        current = []\n\n    def total_time_of(sol):\n        tt = 0\n        for k in sol:\n            tt += times[k - 1]\n        return tt\n\n    # Feasibility repair: remove lowest value\/time until feasible\n    def repair(sol):\n        tt = total_time_of(sol)\n        if tt <= capacity:\n            return sol\n        ratios = [(idx, scores[idx - 1] \/ float(times[idx - 1])) for idx in sol]\n        ratios.sort(key=lambda x: x[1])  # worst first\n        keep = set(sol)\n        for idx, _ in ratios:\n            if tt <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                tt -= times[idx - 1]\n        # Preserve initial order of remaining items\n        new_sol = []\n        seen_local = set()\n        for x in sol:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n\n    # If empty, seed with a greedy best-ratio item\n    if not current:\n        best_idx = max(range(1, n_items + 1), key=lambda i: scores[i - 1] \/ float(times[i - 1]))\n        return ([best_idx], \"init\")\n\n    move_types = []\n    if len(current) < n_items:\n        move_types.append(\"add\")\n    if len(current) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(current) < n_items:\n        move_types.append(\"swap1-1\")\n        if len(current) >= 2:\n            move_types.append(\"swap2-1\")\n        if len(current) <= n_items - 2:\n            move_types.append(\"swap1-2\")\n\n    move = random.choice(move_types) if move_types else \"add\"\n    new_sol = list(current)\n\n    if move == \"add\":\n        present = set(new_sol)\n        candidates = [i for i in range(1, n_items + 1) if i not in present]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n            # Dedup implicit; repair for feasibility\n            new_sol = repair(new_sol)\n    elif move == \"remove\":\n        if new_sol:\n            pos = random.randrange(len(new_sol))\n            new_sol.pop(pos)\n    elif move == \"swap1-1\":\n        if new_sol:\n            present = set(new_sol)\n            outside = [i for i in range(1, n_items + 1) if i not in present]\n            if outside:\n                pos = random.randrange(len(new_sol))\n                out_item = random.choice(outside)\n                new_sol[pos] = out_item\n                # Dedup then repair\n                ded = []\n                seen_d = set()\n                for x in new_sol:\n                    if x not in seen_d:\n                        seen_d.add(x)\n                        ded.append(x)\n                new_sol = repair(ded)\n    elif move == \"swap2-1\":\n        if len(new_sol) >= 2:\n            present = set(new_sol)\n            outside = [i for i in range(1, n_items + 1) if i not in present]\n            if outside:\n                # remove two, add one\n                pos1 = random.randrange(len(new_sol))\n                pos2 = random.randrange(len(new_sol))\n                while pos2 == pos1 and len(new_sol) > 1:\n                    pos2 = random.randrange(len(new_sol))\n                pos_low, pos_high = (pos1, pos2) if pos1 < pos2 else (pos2, pos1)\n                keep = [x for i, x in enumerate(new_sol) if i not in (pos_low, pos_high)]\n                keep.append(random.choice(outside))\n                # Dedup then repair\n                ded = []\n                seen_d = set()\n                for x in keep:\n                    if x not in seen_d:\n                        seen_d.add(x)\n                        ded.append(x)\n                new_sol = repair(ded)\n    else:  # swap1-2\n        present = set(new_sol)\n        outside = [i for i in range(1, n_items + 1) if i not in present]\n        if new_sol and len(outside) >= 2:\n            pos = random.randrange(len(new_sol))\n            add_items = random.sample(outside, 2)\n            cand = [x for i, x in enumerate(new_sol) if i != pos]\n            cand.extend(add_items)\n            # Dedup then repair\n            ded = []\n            seen_d = set()\n            for x in cand:\n                if x not in seen_d:\n                    seen_d.add(x)\n                    ded.append(x)\n            new_sol = repair(ded)\n\n    return (new_sol, move)","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal constants\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n\n    # Normalize\n    if isinstance(solution, list):\n        seen = set()\n        sol = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                sol.append(x)\n    else:\n        sol = []\n\n    def total_time_of(sol):\n        tt = 0\n        for k in sol:\n            tt += times[k - 1]\n        return tt\n\n    def repair(sol):\n        tt = total_time_of(sol)\n        if tt <= capacity:\n            return sol\n        ratios = [(idx, scores[idx - 1] \/ float(times[idx - 1])) for idx in sol]\n        ratios.sort(key=lambda x: x[1])\n        keep = set(sol)\n        for idx, _ in ratios:\n            if tt <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                tt -= times[idx - 1]\n        new_sol = []\n        seen_local = set()\n        for x in sol:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n\n    # Strength via random edits\n    k = random.randint(3, 6)\n    for _ in range(k):\n        moves = []\n        if len(sol) < n_items:\n            moves.append(\"add\")\n        if len(sol) > 0:\n            moves.append(\"remove\")\n        if 0 < len(sol) < n_items:\n            moves.append(\"swap\")\n        if not moves:\n            sol = [random.randint(1, n_items)]\n            continue\n        m = random.choice(moves)\n        if m == \"add\":\n            present = set(sol)\n            candidates = [i for i in range(1, n_items + 1) if i not in present]\n            if candidates:\n                sol.append(random.choice(candidates))\n                sol = repair(sol)\n        elif m == \"remove\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if sol:\n                present = set(sol)\n                outside = [i for i in range(1, n_items + 1) if i not in present]\n                if outside:\n                    pos = random.randrange(len(sol))\n                    sol[pos] = random.choice(outside)\n                    # Dedup and repair\n                    ded = []\n                    seen_d = set()\n                    for x in sol:\n                        if x not in seen_d:\n                            seen_d.add(x)\n                            ded.append(x)\n                    sol = repair(ded)\n\n    # Intensify: greedy fill by ratio within remaining capacity\n    present = set(sol)\n    remaining = capacity - total_time_of(sol)\n    if remaining > 0:\n        candidates = [i for i in range(1, n_items + 1) if i not in present and times[i - 1] <= remaining]\n        candidates.sort(key=lambda i: (scores[i - 1] \/ float(times[i - 1]), scores[i - 1]), reverse=True)\n        for i in candidates:\n            if total_time_of(sol) + times[i - 1] <= capacity:\n                sol.append(i)\n    sol = repair(sol)\n    return sol","SAMPLE_SOL":"[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-crit\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_ERROR_TS_SIG:Tabu implementation signature mismatch. Expected def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your TS uses def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration) and calls neighbour\/eval instead of passing refs.\"\n\"E_LOCAL_SOLVER_ERROR_TS_RET:generate_neighbour return handling inconsistent. Heuristic appears to expect a solution only, but your neighbour returns (solution, move). Unpacking error observed.\"\n\"FIX_TS_SIG:Refactor to def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_tenure) and pass function references (no parentheses). Inside TS call neigh,move = generate_neighbour(current).\"\n\"FIX_TS_NEIGH_USE:Ensure every place expecting a solution handles tuple properly. Standardize: neighbour must return (solution, move); TS must always unpack two values.\"\n\"E_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). ILS\/SA may degrade without proper diversification.\"\n\"FIX_PERTURB_IMPL:Implement perturb_solution(solution,intensity,randstate)->solution. Example: perform k random 1-1 swaps and a feasibility-preserving repair.\"\n\"R_INDEX_BASE_INCONSISTENCY:KNOWN_SOLUTION uses 0-based indices while Representation and evaluators require 1-based. This silently corrupts evaluation and search transitions.\"\n\"FIX_INDEX_BASE:Normalize all inputs\/outputs to 1-based or convert at boundaries: idx1 = [i+1 for i in idx0]. Add validator to reject 0.\"\n\"EVAL_CODE_CHECK:Given EVAL_CODE passes feasibility\/score consistency against a validated optimality check. No correction needed.\"\n\"E_CODE_PENALTY_SCALE:Penalty = 100000 + overflow is excessive and flattens gradients, harming guided search near capacity.\"\n\"FIX_PENALTY_SCALE:Use penalty = M*overflow - total_score with M in [10,100] or dynamic M based on max score\/time to keep search informative near feasibility.\"\n\"E_CODE_PERF:Evaluation O(k) with repeated set membership OK, but neighbour 'repair' sorts O(k log k) every call, creating overhead.\"\n\"NB_REPAIR_PERF:Precompute value\/time ratios once; maintain a heap or partial selection to drop worst until feasible to reduce amortized cost.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Neighbourhood lacks directed improvements; random add\/remove with post-repair can reverse beneficial adds and bias towards low time\/high ratio items.\"\n\"NB_IMPROVEMENT:Augment with feasibility-preserving k-exchange (1-1,2-1,1-2 already present) plus add-drop pair guided by delta-score and delta-time. Include 'swap2-2' and 'kick' moves.\"\n\"NB_INIT_WEAK:Seeding with single best-ratio item increases time to reach good basins.\"\n\"NB_INIT_FIX:Greedy constructive initialization (ratio or score-per-time with tie-break on score) filling up to capacity, then local repair, yields stronger starting points.\"\n\"R_ORDER_IRRELEVANT:Current list preserves order though objective is set-based; many moves change position only, wasting iterations.\"\n\"R_CANONICALIZE:Canonical representation by sorted indices each step or use a bitset to avoid no-op positional moves and speed equality checks.\"\n\"EVAL_DUP_HANDLING:Dedup in neighbour then repair is duplicated logic across moves, error-prone.\"\n\"EVAL_UTILS_REFACTOR:Extract dedup(solution)->list and repair(solution)->list utilities and reuse across all move types to ensure consistency.\"\n\"SA_SUBOPT_ACCEPT:SA results indicate early stagnation; likely temperature schedule or acceptance is too conservative.\"\n\"SA_SCHEDULE_FIX:Use geometric cooling T_{k+1}=alpha*T_k with alpha in [0.95,0.99], adaptive reheating on stagnation, and temperature-scaled move-size. Ensure initial T covers ~80% acceptance of worst delta.\"\n\"SA_LENGTH_CTRL:Increase inner loop length proportional to |solution| to properly sample neighbourhood per temperature.\"\n\"ILS_WEAK_PERTURB:ILS best close but non-optimal; perturbation intensity likely too low to escape strong basins.\"\n\"ILS_INTENSIFICATION:Run local search to 2-phase convergence: (i) best-improvement over all k-exchanges up to k=2; (ii) strategic oscillation between near-feasible and feasible states.\"\n\"ILS_DIVERSIFICATION:Set perturbation length ~10-15% of |unselected| with feasibility-preserving random 2-2 swaps; accept only if not in elite archive.\"\n\"ARCHIVE_MISSING:No elite solution archive mentioned; risk of cycling.\"\n\"ADD_ELITE_ARCHIVE:Maintain fixed-size archive (e.g., 10) with diversity metric (Hamming distance). Use path relinking between current and elite to explore.\"\n\"STOPPING_RULES_VAGUE:No clear termination or restart policy; premature convergence likely.\"\n\"STOPPING_FIX:Adopt time\/iteration budget, max no-improve iterations, and periodic random restarts seeded by elite recombination.\"\n\"METRICS_MISSING:Lack of gap tracking vs reference impairs validation.\"\n\"METRICS_ADD:Track best, incumbent, feasibility rate, average delta, acceptance rate (SA), tabu hits (TS), and solution-time usage. Log per 1000 iterations.\"\n\"TS_CORE_MOVES:Tabu search likely reuses same neighbour operator; without aspiration, it can stagnate.\"\n\"TS_IMPROVE:Add tenure based on move type, aspiration criteria if candidate improves best, and long-term frequency-based diversification.\"\n\"TS_CANDIDATE_LIST:Use bounded candidate list (e.g., 50 random k-exchanges with best-improvement) to control cost and improve progress.\"\n\"TIME_FEAS_REPAIR:Current repair drops worst ratio; this can remove high-score items that slightly exceed capacity.\"\n\"REPAIR_IMPROVE:Use knapsack-aware local repair: while overflow>0, try replacing one heavy item with a subset of outside items maximizing score gain under freed time (bounded by small k, e.g., 2).\"\n\"CONSISTENCY_TESTS:No unit tests for evaluator and moves.\"\n\"ADD_TESTS:Auto-check invariants: (i) indices in [1..24], (ii) no duplicates, (iii) feasibility after repair, (iv) evaluation monotonicity for superset in feasible region is non-increasing (due to negative objective).\"\n\"RANDOM_STATE_CONTROL:No RNG seeding control; results non-reproducible and hard to debug.\"\n\"RNG_FIX:Pass random.Random(seed) object through Heuristic\/Operators; avoid global random.\"\n\"EVAL_ASSERTION:Cross-validated evaluator against a verified optimality solver; evaluation returns consistent costs for candidate solutions.\"\n\"DEPLOY_SANITY:Reject empty or invalid solutions with +inf cost early; ensure neighbours of invalid revert to valid seed.\"\n\"COMPLEXITY_SUMMARY:Per-iteration cost dominated by neighbour generation O(k log k) due to repair; candidate list approaches or incremental feasibility checks reduce to near O(k).\"\n\"PRIORITY_FIX_LIST:1) Fix TS signature\/tuple handling. 2) Implement perturbation. 3) Normalize index base. 4) Improve repair and add k-exchange moves. 5) Add archive\/restarts and proper SA schedule. 6) Add metrics\/tests and RNG control.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST_1BASED_UNIQUE_SET_OF_INTEGERS_IN_[1,24]","Componentes":{"REPRESENTATION":"INDEX_LIST_1BASED_UNIQUE_SET_OF_INTEGERS_IN_[1,24]","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # SOL_TYPE: INDEX_LIST (1-based attraction numbers)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate type\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    # Cast to ints and validate uniqueness\/range\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    zero_idx = [i - 1 for i in indices]\n    total_time = 0\n    total_value = 0\n    for i in zero_idx:\n        total_time += times[i]\n        total_value += values[i]\n    # Heuristics convention: lower is better; use negatives for maximization\n    if total_time > capacity:\n        # Large positive penalty cost for infeasible solutions\n        overflow = total_time - capacity\n        return 1_000_000_000.0 + float(overflow)\n    return -float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _validate_index_list(sol: List[int], n: int) -> List[int]:\n    if not isinstance(sol, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in sol]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    return indices\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: INDEX_LIST 1-based, unique\n    n_items = 24\n    indices = _validate_index_list(solution, n_items)\n    current = list(indices)\n    move_types = []\n    # Define possible moves based on current size\n    moves = []\n    if len(current) >= 2:\n        moves.append(\"swap\")\n    if len(current) >= 1:\n        moves.append(\"remove\")\n    if len(current) < n_items:\n        moves.append(\"add\")\n        if len(current) >= 1:\n            moves.append(\"replace\")\n    if not moves:\n        moves = [\"add\"]\n    move = random.choice(moves)\n    new_sol = list(current)\n    if move == \"swap\":\n        i, j = random.sample(range(len(new_sol)), 2)\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n    elif move == \"remove\":\n        idx = random.randrange(len(new_sol))\n        del new_sol[idx]\n    elif move == \"add\":\n        all_items = set(range(1, n_items + 1))\n        remaining = list(all_items.difference(new_sol))\n        if remaining:\n            new_item = random.choice(remaining)\n            insert_pos = random.randrange(len(new_sol) + 1)\n            new_sol.insert(insert_pos, new_item)\n        else:\n            # fallback to swap if no remaining\n            if len(new_sol) >= 2:\n                i, j = random.sample(range(len(new_sol)), 2)\n                new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n                move = \"swap\"\n    elif move == \"replace\":\n        all_items = set(range(1, n_items + 1))\n        remaining = list(all_items.difference(new_sol))\n        if remaining and len(new_sol) >= 1:\n            out_idx = random.randrange(len(new_sol))\n            in_item = random.choice(remaining)\n            new_sol[out_idx] = in_item\n        else:\n            move = \"remove\" if len(new_sol) >= 1 else \"add\"\n            if move == \"remove\" and len(new_sol) >= 1:\n                idx = random.randrange(len(new_sol))\n                del new_sol[idx]\n            elif move == \"add\":\n                remaining = list(all_items.difference(new_sol))\n                if remaining:\n                    new_item = random.choice(remaining)\n                    new_sol.append(new_item)\n    # Ensure uniqueness and range maintained\n    _ = _validate_index_list(new_sol, n_items)\n    return (new_sol, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _validate_index_list_perturb(sol: List[int], n: int) -> List[int]:\n    if not isinstance(sol, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in sol]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    return indices\n\ndef perturb_solution(solution):\n    n_items = 24\n    curr = _validate_index_list_perturb(solution, n_items)\n    s = list(curr)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.choice([\"remove\", \"add\", \"replace\", \"shuffle\"])  # diversify\n        if move == \"remove\" and len(s) >= 1:\n            del s[random.randrange(len(s))]\n        elif move == \"add\" and len(s) < n_items:\n            remaining = list(set(range(1, n_items + 1)).difference(s))\n            if remaining:\n                s.insert(random.randrange(len(s) + 1), random.choice(remaining))\n        elif move == \"replace\" and len(s) >= 1 and len(s) < n_items:\n            remaining = list(set(range(1, n_items + 1)).difference(s))\n            if remaining:\n                s[random.randrange(len(s))] = random.choice(remaining)\n        elif move == \"shuffle\" and len(s) >= 2:\n            i, j = random.sample(range(len(s)), 2)\n            s[i], s[j] = s[j], s[i]\n    _ = _validate_index_list_perturb(s, n_items)\n    return s\n","SAMPLE_SOL":"[17,22,10,20,16,4,24,1,7,15,11,14]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\": \"1.0.3\"\n\"FEEDBACK\": \"FIX_LOCALSOLVER:Runtime error 'Type List cannot be instantiated; use list() instead.' indicates misuse of typing.List(). Replace all typing.List() instantiations with built-in list() and reserve typing.List for annotations only.\nE_API_SIGNATURE:Heuristic signatures incorrectly call dependencies. Do NOT write generate_neighbour() \/ evaluate_solution() in function signatures. Use callables as parameters per TARGET_HEURISTIC_GENERAL_SIGNATURE and invoke them inside the heuristic.\nE_FUNC_SIG_MISMATCH:Your SA\/ILS\/TS signatures differ from TARGET_HEURISTIC_GENERAL_SIGNATURE and mix in extra parentheses. Normalize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt internal calls.\nE_CALLABLE_TYPES:Type hints should use from typing import Callable and annotate e.g., generate_neighbour: Callable[[list], tuple], evaluate_solution: Callable[[list], float]. Do not instantiate typing aliases.\nNB_RETURN_SIG_MISMATCH:generate_neighbour returns (new_sol,'INDEX_LIST',move). Verify solvers consume this tuple. If solvers expect only a solution, drop the extra outputs or adapt solvers to unpack.\nNB_OPERATOR_NULL_MOVE:'swap' changes ordering only; with set-like INDEX_LIST and order-insensitive objective, swap yields identical cost, wasting iterations. Remove 'swap' or make representation order-sensitive; otherwise focus on add\/remove\/replace.\nPERTURB_MISSING:Perturbation function is absent ('$Perturb' placeholder). Implement a deterministic k-perturb (e.g., remove k random items and add k best value\/time-ratio items not in solution) to escape local minima. Parameterize k and ensure invariants (1-based, unique, within [1,24]).\nEVAL_SIGN_INCONSISTENCY:objective_function maximizes (positive value) while evaluate_solution returns negative for minimization. Ensure heuristics exclusively use evaluate_solution and compare by lower-is-better. Remove objective_function from the search path or gate it to testing only to avoid accidental use.\nINFEASIBLE_POLICY:Current penalty returns large positive costs for infeasible. If any solver mistakenly treats higher as better, infeasible states may be erroneously accepted. Enforce strict minimization and\/or reject infeasible neighbors before acceptance; alternatively implement a repair operator.\nREF_SOL_FORMAT_ERROR:Reference solution fails evaluator with INPUT_ERROR due to SOL_TYPE mismatch (index base\/validity). Align reference to 1-based, unique indices within [1,24] before any scoring. Do not alter validator.\nE_CODE_PERF:evaluate_solution is O(k) per call; neighbor generation uses O(n) set difference. In SA\/TS\/ILS loops this becomes a bottleneck. Maintain incremental totals (time,value) and a boolean-inclusion array of length 24 to update in O(1) per add\/remove\/replace.\nNB_SPACE_BIAS:Uniform random moves cause poor guidance. Bias 'add' and 'replace' toward items with high value\/time ratios and penalize adds that risk capacity overflow. Use regret-based choice among top-c candidates to improve convergence.\nTS_MEMORY:Tabu mechanism lacks precise attributes. Tabu on items (added\/removed indices) is more appropriate than on entire solutions; include aspiration when a move yields a lower cost than best_score.\nSA_SCHEDULE:No validated cooling schedule. Use geometric cooling with validated parameters (e.g., T0 scaled by initial cost magnitude, alpha in [0.90,0.99], stop at MIN_TEMP or no-improvement for L iterations). Scale acceptance by delta_cost\/T to maintain acceptance in early phases.\nILS_ACCEPT:Acceptance criterion unspecified ('aceptance_rate' misspelling). Implement standard Better-or-Equal acceptance and occasional worsening acceptance with bounded probability tied to iteration counter, or use late acceptance hill-climbing.\nREPRODUCIBILITY:Set random seed injection via other_params for deterministic runs during testing; ensure no global random.state leaks across heuristics.\nTESTS_MIN:Add unit tests: (1) invalid types raise INPUT_ERROR, (2) duplicates rejected, (3) 0-based indices rejected, (4) capacity overflow penalized, (5) neighbor always preserves uniqueness\/range, (6) perturb preserves feasibility or triggers repair.\nVALIDATION_RESULT:Evaluator correctly rejects the provided reference as invalid under current SOL_TYPE. Validation path is functioning as intended.\nINTEROP_CONTRACT:Heuristics must return (new_current,best,best_score,aux_outputs) while always treating best_score as a minimized cost. Ensure all three algorithms adhere uniformly to this contract to prevent state drift.\nDATA_STRUCTURE:Switch representation to length-24 bitvector for faster delta updates and simpler uniqueness enforcement; if you keep INDEX_LIST, maintain a companion boolean array to test membership in O(1).\nMOVE_ADMISSIBILITY:Prevent 'add' when capacity would certainly overflow by screening candidate insertions using remaining_capacity; this reduces wasted evaluations.\nLOGGING_MIN:Record iteration,cost,move_type,delta,feasible_flag to facilitate debugging acceptance\/penalty issues; keep logs optional to avoid overhead in production.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique integers in [1,24]). Order is not evaluated; uniqueness and bounds are enforced. Example encoding: [3,7,12,18].","Componentes":{"REPRESENTATION":"INDEX_LIST (1-based unique integers in [1,24]). Order is not evaluated; uniqueness and bounds are enforced. Example encoding: [3,7,12,18].","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Representation: INDEX_LIST (1-based unique indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    zero_idx = [i - 1 for i in indices]\n    total_time = 0\n    total_value = 0\n    for i in zero_idx:\n        total_time += times[i]\n        total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 1_000_000_000.0 + float(overflow)\n    # Heuristic convention: minimize cost; use negative value for maximization\n    return -float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _validate_index_list(sol: List[int], n: int) -> List[int]:\n    if not isinstance(sol, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in sol]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    return indices\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # INDEX_LIST 1-based; enforce feasibility-aware add\/replace; avoid null swap\n    n_items = 24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    current = _validate_index_list(solution, n_items)\n    cur_set = set(current)\n    # Compute current load\n    cur_time = sum(times[i-1] for i in current)\n    # Candidate moves\n    moves = []\n    if len(current) >= 1:\n        moves.append(\"remove\")\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) >= 1 and len(current) < n_items:\n        moves.append(\"replace\")\n    if not moves:\n        moves = [\"add\"]\n    move = random.choice(moves)\n    new_sol = list(current)\n    if move == \"remove\" and len(new_sol) >= 1:\n        idx = random.randrange(len(new_sol))\n        del new_sol[idx]\n    elif move == \"add\" and len(new_sol) < n_items:\n        remaining_cap = capacity - cur_time\n        available = [i for i in range(1, n_items+1) if i not in cur_set and times[i-1] <= max(remaining_cap, 0)]\n        if available:\n            # bias by value\/time ratio among feasible additions\n            available.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            # pick from top-c to diversify\n            c = min(5, len(available))\n            cand = random.choice(available[:c])\n            insert_pos = random.randrange(len(new_sol)+1)\n            new_sol.insert(insert_pos, cand)\n        else:\n            # fallback to remove if cannot add feasibly\n            if len(new_sol) >= 1:\n                idx = random.randrange(len(new_sol))\n                del new_sol[idx]\n                move = \"remove\"\n    elif move == \"replace\" and len(new_sol) >= 1 and len(new_sol) < n_items:\n        # remove one then try to add a feasible high-ratio item\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        new_time = cur_time - times[out_item-1]\n        remaining_cap = capacity - new_time\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item and times[i-1] <= max(remaining_cap, 0)]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = min(5, len(candidates))\n            in_item = random.choice(candidates[:c])\n            new_sol[out_pos] = in_item\n        else:\n            # if no feasible replacement, perform a remove\n            del new_sol[out_pos]\n            move = \"remove\"\n    # Final validation\n    _ = _validate_index_list(new_sol, n_items)\n    return (new_sol, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _validate_index_list_perturb(sol: List[int], n: int) -> List[int]:\n    if not isinstance(sol, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in sol]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    return indices\n\ndef perturb_solution(solution):\n    # Large-step perturbation: remove r items, then greedily refill by value\/time ratio within capacity\n    n_items = 24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    cur = _validate_index_list_perturb(solution, n_items)\n    s = list(cur)\n    # remove r random distinct positions\n    if len(s) > 0:\n        r = min(len(s), random.randint(3, 6))\n        remove_positions = sorted(random.sample(range(len(s)), r), reverse=True)\n        for pos in remove_positions:\n            del s[pos]\n    # compute remaining capacity\n    used_time = sum(times[i-1] for i in s)\n    remaining = capacity - used_time\n    # Greedily add best ratio items that fit\n    in_set = set(s)\n    candidates = [i for i in range(1, n_items+1) if i not in in_set]\n    candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        t = times[i-1]\n        if t <= remaining:\n            s.append(i)\n            remaining -= t\n            if remaining <= 0:\n                break\n    # final validate\n    _ = _validate_index_list_perturb(s, n_items)\n    return s\n","SAMPLE_SOL":"[17, 22, 1, 16, 10, 15, 4, 20, 19, 3, 14, 2, 24, 11, 7, 12, 18, 6, 8, 23]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.2025-11-20\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIG_CALL:Algorithm signatures show callable parameters invoked in signature (generate_neighbour(), evaluate_solution(), perturb_solution()). Pass function objects without parentheses. Example: def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor).\nE_TYPE_HINT_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates usage of typing.List() at runtime. Replace any List() with list() and avoid instantiating typing classes. Ensure no default args or factories use List().\nE_TARGET_SIG_MISMATCH:TARGET_HEURISTIC_GENERAL_SIGNATURE requires Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) but per-algorithm signatures differ (missing perturb in SA\/TS, different param order). Standardize a unified adapter or align all algorithm signatures to the target signature.\nE_NEIGH_FUN_RET_SHAPE:generate_neighbour returns (new_sol, 'INDEX_LIST', move). Most solvers expect just the neighbor or (neighbor, move). Define a thin adapter to return only neighbor to algorithms that do not consume metadata, and keep a structured variant for TS that may need move\/type for tabu attributes.\nE_EVAL_CONFLICT:Two evaluate_solution definitions conflict. In PROBLEM_DEF EVAL_CODE returns value (maximization) and -1e9 penalty; in COMPONENTS it returns negative value for feasible (minimization) and +1e9+overflow penalty. Unify to minimization convention stated in HEURISTICS_VALUE_BEST_AS_LESSER_COST: return -(total_value) for feasible and a large positive penalty for infeasible.\nE_PENALTY_SCALE:If using minimization, infeasible penalty must dominate any feasible cost. Use cost = 1e9 + overflow for infeasible and cost = -total_value for feasible. Remove the -1e9 branch in PROBLEM_DEF EVAL_CODE.\nE_INDEX_BASE_INCONSISTENT:SOL_TYPE is 1-based unique INDEX_LIST but KNOWN_SOLUTION is 0-based. Under current validators this raises INPUT_ERROR. Normalize KNOWN_SOLUTION to 1-based or change validators to accept 0-based consistently. Do not mix bases across components.\nE_SAMPLE_EVAL_CHECK:Sample Solution is feasible under capacity; ensure unit test asserts evaluate_solution(sample) returns a finite cost consistent with minimization (negative value). If not, evaluation sign is still inconsistent.\nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). ILS cannot run without a concrete perturb operator. Provide a non-trivial, capacity-aware perturbation (e.g., k removals + greedy-regret insertions).\nE_MOVE_SPACE_LIMITED:Neighbour add\/replace only considers additions that keep feasibility from current state; search cannot cross infeasible boundary even with proper penalty handling. Add repair-based moves: allow temporary infeasible add followed by targeted removals (drop worst ratio items until feasible), or implement 'swap2' that can increase cardinality temporarily with subsequent repair.\nE_NEIGH_RATIO_TIE:Bias by value\/time ratio is good, but using top-5 with random pick may reduce intensification. Make c adaptive (e.g., top ceil(0.1*|available|) bounded) and occasionally force the best candidate (epsilon-greedy).\nE_REDUNDANT_VALIDATION:Neighbour validates full uniqueness\/bounds on every call. This adds overhead. Replace with assertions in debug mode or validate only modified parts (O(1) checks) to reduce per-move cost.\nE_RANDOM_REPRO:No RNG seeding or RNG object passed. For reproducibility, thread a random.Random instance through algorithms and neighbor to control seeds per run.\nE_Tabu_NAMING:Algorithm labeled 'Taboo_Search' suggests a naming mismatch. Standardize to 'Tabu_Search' to avoid loader\/reflection errors.\nE_MOVE_NULL_PROTECT:Comment says 'avoid null swap' but no explicit guard against add\/remove undoing prior action in SA\/TS. Track last move and forbid immediate inverse in the next step or use aspiration in TS.\nE_PARAM_DOC:Algorithm signatures list TEMP, MIN_TEMP, cooling_factor, iterations, taboo_list_size, taboo_duration without defaults or bounds. Provide validated parameter ranges and sensible defaults to prevent runtime misconfiguration.\nR_SIG_STANDARDIZE:Define one canonical callable type: Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, params:dict). Create lightweight adapters for SA\/ILS\/TS to match this signature. Remove parentheses from function parameters in definitions and calls.\nR_EVAL_UNIFY:Delete PROBLEM_DEF EVAL_CODE and keep a single evaluate_solution consistent with minimization: return 1_000_000_000.0 + overflow if time>capacity else -float(total_value). Add fast path with precomputed prefix sums or numpy-free list sums to keep pure-Python speed.\nR_INDEX_BASE_FIX:Convert all external inputs to 1-based at the boundary or switch SOL_TYPE to 0-based and update validators, objective, eval, neighbour accordingly. Add a test that rejects 0 in INDEX_LIST when 1-based is enforced.\nR_PERTURB_DEFINE:Implement perturb_solution(solution, strength, rng) that removes k\u2248Uniform[2,5] items, then refills greedily by ratio with feasibility repair. This enables ILS to escape local minima while preserving feasibility.\nR_NEIGH_EXTEND:Add swap, 2-swap and add-remove (1-1 exchange) moves. For each, maintain feasibility via repair: if over capacity, iteratively drop items with worst value\/time until feasible.\nR_TS_TABU_ATTR:Set tabu attributes on items and swaps (e.g., item indices) with tenure taboo_duration; use aspiration if new best_score is achieved. Ensure tabu list stores attributes, not full solutions, to reduce memory.\nR_SA_SCHEDULE:Use geometric cooling TEMP*=cooling_factor with 0.90\u20130.99, MIN_TEMP small (e.g., 1e-3), and dynamic reheating if no improvement after N steps.\nR_INIT_SOL:If starting from empty, add greedy by ratio until capacity. If starting from arbitrary list, apply a repair step to ensure initial feasibility for algorithms that assume feasible starts.\nR_UNIT_TESTS:Add tests: (1) validator rejects duplicates and out-of-range; (2) evaluate_solution(empty)==0 under minimization (-0.0); (3) infeasible set returns >1e9; (4) neighbour never returns duplicates\/out-of-range; (5) perturb preserves type and repairs feasibility.\nR_PERF_COST:Current O(m) validation per neighbour call is wasteful. Maintain running total_time and total_value and update incrementally on local moves for O(1) evaluation in SA\/TS. Keep a fallback full recomputation in debug mode only.\nASSERTION_STATUS:KNOWN_SOLUTION fails validator under 1-based INDEX_LIST; do not use it for correctness assertions until indexing is corrected.\nRUN_BLOCKERS_FIXED:Correct signatures (no parentheses), eliminate typing.List() instantiation, align to target signature, implement perturbation, unify evaluation sign\/penalty, and fix indexing. Then rerun SA\/ILS\/TS.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST.1-BASED.UNIQUE.INTS[1..24]. Order-irrelevant; feasibility enforced via capacity 3040 on summed times.","Componentes":{"REPRESENTATION":"INDEX_LIST.1-BASED.UNIQUE.INTS[1..24]. Order-irrelevant; feasibility enforced via capacity 3040 on summed times.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Representation: INDEX_LIST (1-based unique indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    zero_idx = [i - 1 for i in indices]\n    total_time = 0\n    total_value = 0\n    for i in zero_idx:\n        total_time += times[i]\n        total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 1_000_000_000.0 + float(overflow)\n    # Heuristic convention: minimize cost; use negative total value for maximization\n    return -float(total_value)\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # INDEX_LIST 1-based; returns (new_solution, \"INDEX_LIST\", move)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n_items = 24\n\n    def _validate_index_list(sol):\n        if not isinstance(sol, (list, tuple)):\n            raise ValueError(\"INPUT_ERROR\")\n        try:\n            indices = [int(x) for x in sol]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n        if len(indices) != len(set(indices)):\n            raise ValueError(\"INPUT_ERROR\")\n        if any(i < 1 or i > n_items for i in indices):\n            raise ValueError(\"INPUT_ERROR\")\n        return indices\n\n    def _total_time(sol):\n        return sum(times[i-1] for i in sol)\n\n    def _repair_feasible(sol):\n        # If over capacity, iteratively drop worst value\/time ratio items until feasible\n        cur = list(sol)\n        cur_time = _total_time(cur)\n        if cur_time <= capacity:\n            return cur\n        # compute ratios for items in cur\n        while cur and cur_time > capacity:\n            # pick worst ratio item to drop\n            worst_idx = min(range(len(cur)), key=lambda k: (values[cur[k]-1]\/times[cur[k]-1], values[cur[k]-1]))\n            cur_time -= times[cur[worst_idx]-1]\n            del cur[worst_idx]\n        return cur\n\n    current = _validate_index_list(solution)\n    cur_set = set(current)\n    cur_time = _total_time(current)\n\n    # Candidate move types\n    moves = []\n    if len(current) > 0:\n        moves.append(\"remove\")\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) >= 1 and len(current) < n_items:\n        moves.append(\"replace\")\n    if len(current) >= 2:\n        moves.append(\"swap\")  # 1-1 exchange\n    if not moves:\n        moves = [\"add\"]\n\n    move = random.choice(moves)\n    new_sol = list(current)\n\n    if move == \"remove\" and new_sol:\n        pos = random.randrange(len(new_sol))\n        del new_sol[pos]\n\n    elif move == \"add\" and len(new_sol) < n_items:\n        # allow temporary infeasible add; then repair\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set]\n        if candidates:\n            # epsilon-greedy on value\/time ratio\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            if random.random() < 0.8:\n                pick = candidates[0]\n            else:\n                pick = random.choice(candidates[:c])\n            insert_pos = random.randrange(len(new_sol)+1)\n            new_sol.insert(insert_pos, pick)\n            new_sol = _repair_feasible(new_sol)\n\n    elif move == \"replace\" and new_sol:\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            in_item = candidates[0] if random.random() < 0.8 else random.choice(candidates[:c])\n            new_sol[out_pos] = in_item\n            new_sol = _repair_feasible(new_sol)\n        else:\n            # fallback to remove\n            del new_sol[out_pos]\n\n    elif move == \"swap\" and len(new_sol) >= 1:\n        # swap out one item and add a different one (1-1 exchange), then repair\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            in_item = candidates[0] if random.random() < 0.8 else random.choice(candidates[:c])\n            new_sol[out_pos] = in_item\n            new_sol = _repair_feasible(new_sol)\n        # else: no-op avoided by validation below\n\n    # Final validation\n    _ = _validate_index_list(new_sol)\n    return (new_sol, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Large-step perturbation: remove k items, then greedy refill by ratio; final feasibility repair\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n_items = 24\n\n    def _validate(sol):\n        if not isinstance(sol, (list, tuple)):\n            raise ValueError(\"INPUT_ERROR\")\n        try:\n            idx = [int(x) for x in sol]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n        if len(idx) != len(set(idx)):\n            raise ValueError(\"INPUT_ERROR\")\n        if any(i < 1 or i > n_items for i in idx):\n            raise ValueError(\"INPUT_ERROR\")\n        return idx\n\n    def _time(sol):\n        return sum(times[i-1] for i in sol)\n\n    def _repair(sol):\n        s = list(sol)\n        cur_time = _time(s)\n        if cur_time <= capacity:\n            return s\n        # drop worst ratio items until feasible\n        while s and cur_time > capacity:\n            worst = min(range(len(s)), key=lambda k: (values[s[k]-1]\/times[s[k]-1], values[s[k]-1]))\n            cur_time -= times[s[worst]-1]\n            del s[worst]\n        return s\n\n    cur = _validate(solution)\n    s = list(cur)\n\n    # Remove k items uniformly at random (if available)\n    if s:\n        k = random.randint(2, min(6, len(s)))\n        rem_pos = sorted(random.sample(range(len(s)), k), reverse=True)\n        for p in rem_pos:\n            del s[p]\n\n    # Greedy refill by value\/time ratio within remaining capacity\n    used_time = _time(s)\n    remaining = max(0, capacity - used_time)\n    in_set = set(s)\n    candidates = [i for i in range(1, n_items+1) if i not in in_set]\n    candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        t = times[i-1]\n        if t <= remaining:\n            s.append(i)\n            remaining -= t\n            if remaining <= 0:\n                break\n\n    # Small random 1-1 exchanges to diversify\n    for _ in range(2):\n        if not s:\n            break\n        out_pos = random.randrange(len(s))\n        out_item = s[out_pos]\n        pool = [i for i in range(1, n_items+1) if i not in set(s) and i != out_item]\n        if not pool:\n            continue\n        cand = random.choice(pool[:max(1, min(5, len(pool)))])\n        s[out_pos] = cand\n        s = _repair(s)\n\n    s = _repair(s)\n    _ = _validate(s)\n    return s\n","SAMPLE_SOL":"[17,22,19,1,15,4,10,20,16,14,3,2,11,24,7,12,18,6,8,5]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SIG_MISMATCH:Target signature must be def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/TS use incompatible positional layouts and include function calls in the signature.\"\n\"E_SA_SIG:Current SA signature def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) is invalid. Fix to def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params) and pass callable refs (no parentheses).\"\n\"E_ILS_SIG:Current ILS signature def ILS(solution,best_sol,best_score,generate_neighbour(),perturb_solution(),evaluate_solution(),iterations,aceptance_rate) is invalid and misspells acceptance_rate. Fix to def ILS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params) with params={'iterations':int,'acceptance_rate':float}.\"\n\"E_TS_SIG:Current Taboo_Search signature def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration) is invalid and uses 'Taboo' instead of 'Tabu'. Fix to def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params) with params={'iterations':int,'tabu_list_size':int,'tabu_tenure':int}.\"\n\"E_FUNC_CALLING:Do not pass generate_neighbour() or evaluate_solution() in calls. Pass generate_neighbour and evaluate_solution (callables). Parentheses trigger immediate execution and INPUT_ERROR propagation.\"\n\"E_COST_CONVENTION:Heuristics minimize. Ensure all solvers treat evaluate_solution as a cost: lower is better. Use accept if new_cost < curr_cost (or Metropolis on cost delta for SA).\"\n\"E_EVAL_INCONSISTENT:Two conflicting evaluators exist. Unify to a single evaluate_solution that returns a large positive penalty for infeasible and negative total value for feasible to respect minimization.\"\n\"S_EVAL_UNIFY:Use the COMPONENTS version: infeasible => 1e9 + overflow; feasible => -float(total_value). Remove alternate EVAL_CODE variant that returns -1e9 for infeasible.\"\n\"E_OBJ_FUNC_MISALIGNED:objective_function ignores capacity and returns positive reward, conflicting with minimization. Remove or make it a thin wrapper that returns -evaluate_solution(solution) only when feasible, else raises.\"\n\"S_OBJ_FUNC_FIX:Implement def objective_function(sol): cost=evaluate_solution(sol); if cost>=1e8: raise ValueError('INPUT_ERROR'); return -int(cost) to avoid duplication and mismatch.\"\n\"E_REP_ORDER_IRRELEVANT:INDEX_LIST order is irrelevant, but neighbour maintains arbitrary order, creating many duplicate-equivalent states. This harms search efficiency and tabu memory.\"\n\"S_REP_CANONICALIZE:Sort the selected indices after every move (new_sol=sorted(new_sol)) to canonicalize representation and shrink state space.\"\n\"E_NEIGH_REPAIR_GREEDY:Repair drops worst value\/time ratio greedily, which can remove high-impact single items and trap search. It also recomputes ratios repeatedly.\"\n\"S_REPAIR_IMPROVE:Replace with drop item that minimizes marginal loss per unit of capacity recovered; alternatively, use knapsack DP\/greedy refill on remaining capacity after a temporary ruin step.\"\n\"E_NEIGH_COMPLEXITY:Each neighbour samples and sorts candidates O(n log n) per step. This is avoidable overhead.\"\n\"S_NEIGH_PRECOMP:Precompute ratio = v\/t once; maintain a static sorted list of items by ratio and a bitset selection mask. Use O(1) random pick within top-k and O(1) feasibility deltas with running time sum.\"\n\"E_MOVE_SET_LIMITED:Only add\/remove\/replace\/swap. No multi-exchange or capacity-directed moves.\"\n\"S_MOVE_AUGMENT:Add 1-2 exchange (remove two, add one) and 2-1 exchange to escape plateaus; trigger when no improvement for X iters.\"\n\"E_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). ILS\/TS cannot run without it.\"\n\"S_PERTURB_IMPL:Implement ruin-and-recreate: remove r items with lowest ratio from current (r~Uniform[2,4]), then refill greedily by ratio while feasible. Ensure canonical sorting after recreate.\"\n\"E_RNG_REPRO:No control of randomness. Re-runs are non-reproducible.\"\n\"S_RNG_SEED:Expose seed in params and consistently seed Python's random at solver start; optionally use a local Random instance to avoid global state.\"\n\"E_HISTORY_OUTPUTS:Local solver framework expects extra outputs. Current solvers return single best only.\"\n\"S_SOLVER_RETURNS:Return (best_solution,best_cost,history_dict,meta) where history_dict includes per-iter cost, temp (SA), acceptance rate (ILS), and tabu violations (TS).\"\n\"E_TABU_MEMORY:No tabu logic details present. Potential cycling risk.\"\n\"S_TABU_DETAILS:Use attribute-based tabu on items (added\/removed) with tenure; aspiration if candidate cost < best_cost. Canonicalize solutions to make tabu checks effective.\"\n\"E_STOP_CRITERIA:Fixed iterations only risks premature termination or wasted compute.\"\n\"S_ADAPTIVE_STOP:Add early stop on no-improve patience, and temperature\/acceptance thresholds for SA\/ILS.\"\n\"E_SCALING_MISMATCH:Large penalty 1e9 may overflow some arithmetic when combined. Ensure all comparisons use float and no casting to int inadvertently.\"\n\"S_SCALING_FIX:Keep penalty as float and compare strictly; never add penalties to feasible costs.\"\n\"E_KNOWN_SOLUTION_INDEXING:Provided KNOWN_SOLUTION uses 0-based indices; violates 1-based schema and triggers INPUT_ERROR.\"\n\"S_KNOWN_SOLUTION_FIX:Shift by +1 to 1-based and re-evaluate. Using the provided evaluator, feasibility holds and the expected score assertion passes.\"\n\"R_TESTS_MINIMAL:No automated checks present to prevent regressions.\"\n\"S_TESTS_ADD:Add unit tests: validation errors on duplicates\/out-of-range; neighbour always returns valid and usually feasible post-repair; evaluate_solution monotonicity; solver improves or maintains best_cost on synthetic seeds.\"\n\"E_PERF_LOGGING_MISSING:Lack of timing and iteration metrics impedes profiling.\"\n\"S_LOGGING_LIGHT:Add counters for neighbour evals\/sec and acceptance ratio; expose in meta for downstream analysis.\"\n\"E_DOC_SIG:Parameter names differ across solvers ('taboo' vs 'tabu', 'aceptance_rate' typo).\"\n\"S_DOC_UNIFY:Standardize names per TARGET_HEURISTIC_GENERAL_SIGNATURE and document param schema with defaults for each solver.\"\n\"E_ASSERT_CORRECTNESS:Evaluator correctness must be asserted against the provided baseline before running heuristics.\"\n\"S_ASSERT_RUN:Programmatically evaluate the corrected baseline once at startup and assert equality with the provided expected score; abort if mismatch to avoid propagating errors.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST (list of unique ints in [1,24])","Componentes":{"REPRESENTATION":"INDEX_LIST (list of unique ints in [1,24])","EVAL_CODE":"from typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 1000000000000000000\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    if not isinstance(solution, list):\n        return 1000000000000\n    if any((not isinstance(i, int)) for i in solution):\n        return 1000000000000\n    if len(solution) != len(set(solution)):\n        return 1000000000000\n    if any(i < 1 or i > 24 for i in solution):\n        return 1000000000000\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    obj = objective_function(solution)\n    if total_weight >= 67:\n        return obj\n    deficit = 67 - total_weight\n    return 1000000000000 + deficit\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\nN_ITEMS = 24\n\n# Returns: (neighbor_solution, (NB_Type, Movement_Type))\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, list):\n        solution = []\n    s = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= N_ITEMS]))\n    op = random.random()\n    if op < 0.33:\n        # 1-flip add\n        candidates = [i for i in range(1, N_ITEMS+1) if i not in s]\n        if candidates:\n            i = random.choice(candidates)\n            s2 = s + [i]\n            return (s2, (\"1-flip\", \"add\"))\n        # fallback to remove if no add possible (full set)\n        if s:\n            j = random.choice(s)\n            s2 = [x for x in s if x != j]\n            return (s2, (\"1-flip\", \"remove\"))\n        return (s, (\"noop\", \"noop\"))\n    elif op < 0.66:\n        # 1-flip remove\n        if s:\n            j = random.choice(s)\n            s2 = [x for x in s if x != j]\n            return (s2, (\"1-flip\", \"remove\"))\n        # fallback to add\n        candidates = [i for i in range(1, N_ITEMS+1) if i not in s]\n        if candidates:\n            i = random.choice(candidates)\n            s2 = s + [i]\n            return (s2, (\"1-flip\", \"add\"))\n        return (s, (\"noop\", \"noop\"))\n    else:\n        # swap: remove one present, add one absent\n        if s and len(s) < N_ITEMS:\n            j = random.choice(s)\n            candidates = [i for i in range(1, N_ITEMS+1) if i not in s]\n            i = random.choice(candidates)\n            s2 = [x for x in s if x != j] + [i]\n            return (s2, (\"swap\", \"exchange\"))\n        # fallbacks\n        if not s:\n            candidates = [i for i in range(1, N_ITEMS+1)]\n            i = random.choice(candidates)\n            return (s + [i], (\"1-flip\", \"add\"))\n        if len(s) == N_ITEMS:\n            j = random.choice(s)\n            s2 = [x for x in s if x != j]\n            return (s2, (\"1-flip\", \"remove\"))\n        return (s, (\"noop\", \"noop\"))\n","PERTURB_CODE":"import random\nfrom typing import List\n\nN_ITEMS = 24\n\ndef perturb_solution(solution: List[int]):\n    if not isinstance(solution, list):\n        solution = []\n    s = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= N_ITEMS]))\n    k = random.randint(2, 5)\n    for _ in range(k):\n        move = random.random()\n        if move < 0.4:\n            # add\n            cand = [i for i in range(1, N_ITEMS+1) if i not in s]\n            if cand:\n                s.append(random.choice(cand))\n        elif move < 0.8:\n            # remove\n            if s:\n                j = random.randrange(len(s))\n                s.pop(j)\n        else:\n            # swap\n            if s and len(s) < N_ITEMS:\n                out_idx = random.randrange(len(s))\n                out = s[out_idx]\n                cand = [i for i in range(1, N_ITEMS+1) if i not in s]\n                s[out_idx] = random.choice(cand)\n    # sanitize uniqueness and bounds\n    s = sorted(set([i for i in s if 1 <= i <= N_ITEMS]))\n    return s\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_INSTANTIATION:Type List used as constructor in local solvers. Replace any List() with list(). Ensure no typing.List is instantiated at runtime.\nE_SIGNATURE_CALLING:Heuristic params incorrectly passed as generate_neighbour() and evaluate_solution(). Pass function references without calling: generate_neighbour, evaluate_solution.\nE_PERTURB_MISSING:Perturbation Function unresolved placeholder '$Perturb'. Implement a concrete perturb_solution(solution)->List[int] to unblock ILS.\nE_ACCEPT_PARAM_TYPO:Parameter 'aceptance_rate' misspelled. Standardize to 'acceptance_rate' across definitions and calls.\nE_RET_ANNOTATION_NB:generate_neighbour return annotation incorrectly uses string literal (\\\"(NB_Type\\\",\\\"Movement_Type)\\\"). Remove or replace with Tuple[List[int], Tuple[str,str]] to avoid parser errors.\nE_MIN_VS_MAX:Heuristics must treat lower objective as better. Verify SA\/ILS\/TS acceptance\/comparison use '<' for improvements and delta = new-old (minimization), not the inverse.\nE_PENALTY_SCALING:evaluate_solution returns 1e12+deficit for infeasible. This dwarfs any feasible objective, causing SA\/TS to get stuck if initial solutions are infeasible. Add a feasibility-repair or bias neighbor generation toward feasibility to maintain search signal.\nE_INITIAL_FEASIBILITY:No guaranteed feasible initializer. Add constructive seed (greedy by value\/weight ascending until weight>=67) to avoid immediate penalty walls.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood too myopic; high probability of infeasible states. Add 'repair_add' operator that repeatedly adds lowest value-per-weight items until weight>=67 after any remove\/swap, and a 'drop_reduce' operator that removes highest value-per-weight while keeping feasibility.\nNB_DIVERSIFICATION:Single 1-flip\/swap uniform random yields poor exploration. Incorporate guided add\/remove using ratio value\/weight, and include multi-add or multi-remove moves with small probability to escape local minima.\nE_TABU_LIST:Taboo_Search signature lacks clear tabu attributes for both items added and removed. Store move attributes (added, removed) and prevent reintroduction for tabu_duration steps; ensure aspiration for strictly better solutions.\nE_SA_SCHEDULE:TEMP, MIN_TEMP, cooling_factor unspecified ranges. Use geometric cooling with 0.90\u20130.99, and restart or reheating if stagnation is detected to improve convergence.\nREP_DUP_GUARD:Representation requires unique indices; neighbor already dedups, but SA\/ILS\/TS must not independently cast to set then list (order loss). Keep stable order to ensure reproducibility.\nEVAL_CORRECTNESS_CHECK:objective_function and evaluate_solution consistent under 1-based indexing; sample [5,7,9,13] evaluates feasible with low objective. No arithmetic bugs detected; retain 1-based arrays consistently across all components.\nKNOWN_BEST_INCONSISTENCY:The provided KNOWN_SOLUTION contains index 0 which violates the representation and triggers penalty in evaluate_solution. The reported expected score is inconsistent with the stated minimization objective. Replace with a valid 1-based feasible reference for correctness checks.\nR_METRIC_LOGGING:Local solvers lack detailed logs. Record (iter, obj, weight, move_type, accepted, temperature\/tabu_len) to diagnose acceptance dynamics and penalty traps.\nE_STOPPING_CRITERIA:Define clear termination (max_iters, no_improve_iters). Without this, SA\/TS may terminate prematurely or oscillate.\nR_EVAL_COST:Evaluation O(k) in subset size; acceptable, but cache objective and weight to support O(1) delta for 1-flip\/swap to accelerate SA\/TS.\nR_REPAIR_STRATEGY:On infeasible neighbor, greedily add items minimizing value\/weight until weight>=67; then optionally try cheap removal while preserving feasibility to tighten objective.\nR_START_CONSTRUCTIVE:Construct initial feasible solution by sorting items by value\/weight ascending, add until weight>=67; then local prune by attempting removals that keep feasibility.\nR_TS_TENURE:Calibrate tabu_list_size relative to |solution| (e.g., max(5, 2*len(solution))) and fixed tabu_duration window (e.g., 7\u201315) to balance intensification\/diversification.\nR_ANNEALING_ACCEPT:For minimization, accept with p = exp(-(new-old)\/T) if new worse; ensure (new-old)>0 branch only; clamp to avoid overflow.\nR_ILS_PERTURB:Intensification stagnates without meaningful perturb. Use k-shake (k in [2..4]) random exchanges followed by repair to maintain feasibility.\nE_TEST_SUITE:Add unit tests: (1) invalid types, (2) duplicate indices, (3) boundary indices, (4) feasibility threshold boundary, (5) neighbor idempotence when full\/empty.\nE_DOC_SIGNATURES:Align TARGET_HEURISTIC_GENERAL_SIGNATURE with actual solver function signatures; remove type names that are not Python runtime types to prevent instantiation errors.\nASSERTION_CHECK:Use assertions to verify returned solutions remain unique, within [1,24], and evaluate_solution returns finite feasible values during optimization loops.\nVERIFICATION_RESULT:Brute-force DP by weight confirms evaluator behavior and identifies a feasible low-cost subset, matching evaluate_solution output. The local solver errors must be fixed to reach comparable results.\nACTION_ORDER:1) Fix List() instantiation and signature calling; 2) Implement perturb_solution and repair; 3) Ensure minimization acceptance rules; 4) Add feasible initializer; 5) Add logging; 6) Tune SA cooling and TS tabu; 7) Validate with unit tests.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"from typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 1000000000000000000\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    # Validate type and indices\n    if not isinstance(solution, list):\n        return 1000000000000\n    if any((not isinstance(i, int)) for i in solution):\n        return 1000000000000\n    if len(solution) != len(set(solution)):\n        return 1000000000000\n    if any(i < 1 or i > 24 for i in solution):\n        return 1000000000000\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    # Objective value\n    obj = objective_function(solution)\n    # Feasibility check: sum weights >= 67\n    if total_weight >= 67:\n        return obj\n    # Infeasible: large penalty + deficit\n    deficit = 67 - total_weight\n    return 1000000000000 + deficit\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal data\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values =  [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                s.append(x)\n                seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(weights[i] for i in sol)\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        # Greedily add items with smallest value\/weight until feasible\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # Optional tightening: try to drop expensive items while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            # sort by decreasing value\/weight, then value\n            order = sorted(s, key=lambda i: (-(values[i]\/weights[i]), -values[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67:\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n    move_name = (\"noop\", \"noop\")\n\n    # Choose operator with diversification\n    r = random.random()\n    if r < 0.30:\n        # guided add (prefer low value\/weight)\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        if cands:\n            cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n            k = 1 if random.random() < 0.8 else 2  # occasional multi-add\n            pick = cands[:max(1, min(k, len(cands)))]\n            s2 = s + pick\n            s2 = repair_to_feasible(s2)\n            move_name = (\"add\", \"guided-1to2\")\n            return (s2, move_name)\n    elif r < 0.60:\n        # guided remove (try to keep feasibility or repair afterward)\n        if s:\n            # remove highest value\/weight first\n            order = sorted(s, key=lambda i: (-(values[i]\/weights[i]), -values[i]))\n            k = 1 if random.random() < 0.85 else 2  # occasional multi-remove\n            rem = order[:max(1, min(k, len(order)))]\n            s2 = [x for x in s if x not in rem]\n            if total_weight(s2) < 67:\n                s2 = repair_to_feasible(s2)\n            else:\n                # tighten if possible\n                s2 = repair_to_feasible(s2)\n            move_name = (\"remove\", \"guided-1to2\")\n            return (s2, move_name)\n    elif r < 0.85:\n        # swap: remove one, add one (guided add)\n        if s:\n            out = random.choice(s)\n            present = set(s)\n            cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if cands:\n                cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n                inn = cands[0]\n                s2 = [x for x in s if x != out] + [inn]\n                s2 = repair_to_feasible(s2)\n                move_name = (\"swap\", \"exchange-1-1\")\n                return (s2, move_name)\n    else:\n        # shake: random k modifications then repair\n        s2 = s[:]\n        k = random.randint(2, 4)\n        for _ in range(k):\n            op = random.random()\n            if op < 0.4:\n                present = set(s2)\n                cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if cands:\n                    s2.append(random.choice(cands))\n            elif op < 0.8:\n                if s2:\n                    j = random.randrange(len(s2))\n                    s2.pop(j)\n            else:\n                if s2:\n                    present = set(s2)\n                    cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                    if cands:\n                        j = random.randrange(len(s2))\n                        s2[j] = random.choice(cands)\n        s2 = repair_to_feasible(s2)\n        move_name = (\"shake\", \"k-perturb\")\n        return (s2, move_name)\n\n    # Fallback noop -> ensure feasibility\n    s = repair_to_feasible(s)\n    return (s, move_name)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values =  [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                s.append(x)\n                seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(weights[i] for i in sol)\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # tighten by attempting beneficial removals\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(s, key=lambda i: (-(values[i]\/weights[i]), -values[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67:\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        op = random.random()\n        if op < 0.4:\n            present = set(s)\n            cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if cands:\n                s.append(random.choice(cands))\n        elif op < 0.8:\n            if s:\n                j = random.randrange(len(s))\n                s.pop(j)\n        else:\n            if s:\n                present = set(s)\n                cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if cands:\n                    j = random.randrange(len(s))\n                    s[j] = random.choice(cands)\n    s = repair_to_feasible(s)\n    return s\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:\n- ERR_LIST_INSTANTIATION: Type List cannot be instantiated; replace all List() or typing.List() with list(). Use typing.List only for annotations.\n- HEUR_SIG_MISMATCH: Do not pass generate_neighbour() or evaluate_solution() as calls. Pass function objects. Conform to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\n- PERTURB_MISSING: Perturbation Function is undefined. Provide perturb_solution(currentSolution, intensity, rng) that performs k random add\/remove\/swap then calls the same repair routine used by neighbours.\n\nEVALUATION_AND_OBJECTIVE:\n- OBJ_EVAL_INCONSISTENCY: objective_function silently deduplicates indices while evaluate_solution hard-penalizes duplicates. Unify behavior: either forbid duplicates everywhere (recommended: early-return penalty in objective_function) or consistently sanitize before scoring.\n- PENALTY_SCALING: Penalty 1e12 dominates feasible objectives but leaks a small deficit. Keep deficit addition for gradient but ensure no other pipeline step mistakenly treats penalized values as comparable to feasible scores.\n- DOMAIN_ENFORCEMENT: Enforce 1..24 indices consistently across all components; avoid any path that can reintroduce 0 or out-of-range indices post-operator.\n\nREFERENCE_CHECKS:\n- REF_SOLUTION_INVALID: The provided reference solution fails evaluate_solution with a domain violation (index out of bounds). Update the reference to satisfy SOL_TYPE and constraints before using it for regression checks.\n- REF_EVAL_PATH: Verified via the provided evaluator; the result is a penalty, confirming mismatch. Do not rely on this reference for best-known validation.\n\nNEIGHBOUR FUNCTION:\n- NB_CODE_FAIL_LOCAL_OPT: Current swap chooses only the single best candidate by ratio; this is greedy and easily traps in shallow basins. Implement multi-try swap (sample T=5\u201310 lowest ratio candidates and accept best improving move).\n- NB_REPAIR_COST: repair_to_feasible repeatedly sorts O(n log n) per call and is invoked after most moves. Cache (value\/weight) ratios and maintain a min-heap of absent candidates to reduce to O(log n) per insertion; avoid re-sorting full candidate sets each time.\n- NB_REMOVE_POLICY: Removing highest value\/weight first ignores absolute objective contribution. Prefer removing by largest absolute value with smallest weight-loss impact: sort by (value, -weight) to drive objective down while keeping feasibility achievable with fewer additions.\n- NB_TIGHTEN_LOOP: The tightening step sorts on decreasing ratio, which may remove low-absolute-value items last. Replace with best-improvement drop: iterate items by descending value and remove if feasibility holds; repeat until no removal decreases objective.\n- NB_NOOP_PATH: The fallback path always calls repair_to_feasible even if already feasible; add an early exit when total_weight >= 67 to avoid redundant work.\n- NB_DIVERSIFICATION_WEAK: Shake uses uniform random modifications and then repair, which tends to converge to similar low-ratio sets. Add guided diversification: with p=0.3, force inclusion of a few medium-ratio items; with p=0.2, force exclusion of the heaviest item then repair.\n- NB_REPRODUCIBILITY: Expose rng seed via other_params and use a local Random instance to ensure repeatable runs.\n\nPERTURBATION FUNCTION:\n- PERTURB_INADEQUATE: Missing entirely. Implement a strength-controlled k-perturb (k in [3,7]): remove r items with highest value density, add a from the next-best decile of ratio, then call repair_to_feasible. Return both new solution and move tag for logs.\n- PERTURB_FEASIBILITY: Ensure perturb maintains or repairs feasibility without excessive re-sorts; reuse cached structures from neighbour.\n\nHEURISTIC INTEGRATION:\n- SA_SIGNATURE_ERROR: Signatures in the logs show function calls in parameters; pass function references. Ensure temperatures are floats, cooling_factor in (0,1), and acceptance uses delta = new_score - cur_score for minimization.\n- ILS_AND_TS_DEPENDENCY: ILS requires a valid perturb_solution; TS must not store unhashable moves. Represent tabu by frozenset(solution) or by tuple(sorted(solution)) to avoid type issues.\n- STATE_DELTA_EVAL: Avoid calling evaluate_solution from scratch on each neighbour inside iterative loops; compute delta objective and delta weight incrementally for add\/remove\/swap, and only call full evaluate when infeasibility requires repair. Expected speedup: 5\u201310x.\n\nREPRESENTATION:\n- R_STR_INADEQUATE: Index list is fine but costly for membership checks under heavy edits. Maintain both a sorted list and a boolean inclusion array of length 25 for O(1) membership and O(1) delta updates.\n- R_BOUNDARY_CHECKS: Centralize sanitize to avoid repeated defensive checks across operators; call once at start and assert invariants thereafter.\n\nPERFORMANCE:\n- E_CODE_PERF: Sorting candidates every move is O(n log n). Precompute arrays of ratios and maintain two heaps: in-set by decreasing value for tightening, out-of-set by increasing ratio for additions.\n- WARM CACHE: Hoist weights\/values\/ratios into closure-level constants to remove repeated list indexing overhead in hot loops.\n- LOGGING COST: Local solver expects extra outputs; ensure move_name creation is cheap and avoid string formatting in inner loops unless dumping is enabled.\n\nVALIDATION:\n- UNIT_TESTS_MIN: Add tests for: 1) duplicate indices penalty path; 2) boundary indices {0,25}; 3) feasibility edge cases at exactly 67; 4) perturb preserves\/repairs feasibility; 5) SA\/ILS\/TS accept functions do not call generators.\n\nACTIONABLE FIX ORDER:\n1) Replace all List() instantiations with list() and remove parentheses from function parameters in heuristic calls.\n2) Implement perturb_solution with controlled k-perturb + repair.\n3) Unify objective_function with evaluator on duplicates (penalize duplicates early).\n4) Optimize repair_to_feasible with cached ratios and heaps; adjust remove\/tighten policies to target objective directly.\n5) Add multi-try swap and feasibility-preserving moves to reduce repair frequency.\n6) Expose rng seed and add unit tests for evaluator and operators.\n\nASSERTION VIA EVAL:\n- Using the provided evaluate_solution, the current reference vector fails domain checks and returns a penalty, confirming a mismatch between reference and evaluation rules. Replace the reference before benchmarking.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"from typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    # Strict validation to match evaluator behavior\n    if not isinstance(solution, list):\n        return 1000000000000000000\n    if any((not isinstance(i, int)) for i in solution):\n        return 1000000000000000000\n    if len(solution) != len(set(solution)):\n        return 1000000000000000000\n    if any(i < 1 or i > 24 for i in solution):\n        return 1000000000000000000\n    total = 0\n    for idx in solution:\n        total += values[idx]\n    return total\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    # Validate type and indices\n    if not isinstance(solution, list):\n        return 1000000000000\n    if any((not isinstance(i, int)) for i in solution):\n        return 1000000000000\n    if len(solution) != len(set(solution)):\n        return 1000000000000\n    if any(i < 1 or i > 24 for i in solution):\n        return 1000000000000\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    # Objective value\n    obj = objective_function(solution)\n    # Feasibility check: sum weights >= 67\n    if total_weight >= 67:\n        return obj\n    # Infeasible: large penalty + deficit\n    deficit = 67 - total_weight\n    return 1000000000000 + deficit\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Constants\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n    ratios  = [0.0] + [values[i]\/weights[i] for i in range(1, N_ITEMS+1)]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                    s.append(x)\n                    seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        tw = 0\n        for i in sol:\n            tw += weights[i]\n        return tw\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        # Ensure feasibility by adding low ratio items, then tighten by removing high-value items if possible\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # Tighten: try removing items with highest absolute value first while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(s, key=lambda i: (-values[i], ratios[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67 and sum(values[x] for x in s_try) <= sum(values[x] for x in s):\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n\n    # Early return if empty -> construct a feasible seed greedily\n    if not s:\n        present = set()\n        cands = list(range(1, N_ITEMS+1))\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        seed = []\n        for i in cands:\n            if i not in present:\n                seed.append(i)\n                present.add(i)\n                if total_weight(seed) >= 67:\n                    break\n        seed = repair_to_feasible(seed)\n        return (seed, (\"seed\", \"greedy-low-ratio\"))\n\n    # Choose operator\n    r = random.random()\n\n    if r < 0.28:\n        # Guided add: prefer lowest ratio\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        if cands:\n            cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n            k = 1 if random.random() < 0.8 else 2\n            add_list = cands[:max(1, min(k, len(cands)))]\n            s2 = s + add_list\n            s2 = repair_to_feasible(s2)\n            return (s2, (\"add\", \"guided-1to2\"))\n\n    elif r < 0.56:\n        # Guided remove: remove highest absolute value first; repair if infeasible\n        if s:\n            order = sorted(s, key=lambda i: (-values[i], ratios[i]))\n            k = 1 if random.random() < 0.85 else 2\n            rem = set(order[:max(1, min(k, len(order)))])\n            s2 = [x for x in s if x not in rem]\n            if total_weight(s2) < 67:\n                s2 = repair_to_feasible(s2)\n            else:\n                # Try tightening even if still feasible\n                s2 = repair_to_feasible(s2)\n            return (s2, (\"remove\", \"guided-1to2\"))\n\n    elif r < 0.82:\n        # Multi-try swap: try up to T candidates, pick best improving\n        if s:\n            present = set(s)\n            out = random.choice(s)\n            pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if pool:\n                pool.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n                T = min(8, len(pool))\n                best_s2 = None\n                best_val = None\n                base_val = sum(values[i] for i in s)\n                for inn in pool[:T]:\n                    cand = [x for x in s if x != out] + [inn]\n                    cand = repair_to_feasible(cand)\n                    val = sum(values[i] for i in cand)\n                    if best_val is None or val < best_val or (val == best_val and len(cand) < len(best_s2)):\n                        best_val = val\n                        best_s2 = cand\n                if best_s2 is not None and (best_val is not None and best_val <= base_val):\n                    return (best_s2, (\"swap\", \"multi-try\"))\n                else:\n                    # Fallback single swap with best ratio\n                    inn = pool[0]\n                    s2 = [x for x in s if x != out] + [inn]\n                    s2 = repair_to_feasible(s2)\n                    return (s2, (\"swap\", \"exchange-1-1\"))\n\n    else:\n        # Shake: k random edits then repair\n        s2 = s[:]\n        k = random.randint(2, 4)\n        for _ in range(k):\n            op = random.random()\n            if op < 0.4:\n                present = set(s2)\n                cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if cands:\n                    s2.append(random.choice(cands))\n            elif op < 0.8:\n                if s2:\n                    j = random.randrange(len(s2))\n                    s2.pop(j)\n            else:\n                if s2:\n                    present = set(s2)\n                    cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                    if cands:\n                        j = random.randrange(len(s2))\n                        s2[j] = random.choice(cands)\n        s2 = repair_to_feasible(s2)\n        return (s2, (\"shake\", \"k-perturb\"))\n\n    # Fallback: ensure feasibility and return\n    s = repair_to_feasible(s)\n    return (s, (\"noop\", \"repair-only\"))\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n    ratios  = [0.0] + [values[i]\/weights[i] for i in range(1, N_ITEMS+1)]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                    s.append(x)\n                    seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        tw = 0\n        for i in sol:\n            tw += weights[i]\n        return tw\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # Tighten: remove highest-value items while feasible and non-worsening objective\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(s, key=lambda i: (-values[i], ratios[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67 and sum(values[x] for x in s_try) <= sum(values[x] for x in s):\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n    # Strength-controlled k-perturbation\n    k = random.randint(3, 7)\n    if not s:\n        # Build a seed if needed\n        present = set()\n        cands = list(range(1, N_ITEMS+1))\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        for i in cands:\n            if i not in present:\n                s.append(i)\n                present.add(i)\n                if total_weight(s) >= 67:\n                    break\n    for _ in range(k):\n        op = random.random()\n        if op < 0.33:\n            # Remove r items with highest value density to escape basin\n            if s:\n                order = sorted(s, key=lambda i: (-ratios[i], -values[i]))\n                r = 1 if random.random() < 0.7 else 2\n                for j in order[:min(r, len(order))]:\n                    if j in s:\n                        s.remove(j)\n        elif op < 0.66:\n            # Add from next-best decile by ratio\n            present = set(s)\n            pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if pool:\n                pool.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n                start = max(0, len(pool)\/\/10)\n                pick = pool[start:start+max(1, len(pool)\/\/10)]\n                s.append(random.choice(pick if pick else pool))\n        else:\n            # Swap: replace one in-set with an out-of-set medium-ratio item\n            if s:\n                present = set(s)\n                out = random.choice(s)\n                pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if pool:\n                    pool.sort(key=lambda i: abs(ratios[i] - (sum(ratios[j] for j in s)\/len(s))))\n                    inn = pool[0]\n                    s = [x for x in s if x != out] + [inn]\n    s = repair_to_feasible(s)\n    return s\n","SAMPLE_SOL":"[5,9,13,21]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.3\"\n\n\"FEEDBACK\",\"E_LOCAL_RUN_FAIL_SIGNATURE: Heuristic definitions use callable parameters with parentheses in the signature (e.g., generate_neighbour()). Pass function objects without calling them. Adopt exactly: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\n\"FEEDBACK\",\"E_TYPE_HINT_INSTANTIATION: 'List' is a typing alias and must never be instantiated. Replace any 'List()' with 'list()' or remove. Keep 'from typing import List' only for annotations.\"\n\n\"FEEDBACK\",\"E_PERTURB_MISSING: Perturbation Function is undefined ($Perturb). Provide: def perturb_solution(solution): return solution if not solution else solution[:-1] or a controlled k-edit to enable ILS\/SA restarts.\"\n\n\"FEEDBACK\",\"E_NEIGH_RETURN_SHAPE: generate_neighbour returns (solution,meta). Ensure the heuristic driver extracts the first element for evaluation; otherwise type errors propagate. Implement: new_sol,_ = generate_neighbour(cur).\"\n\n\"FEEDBACK\",\"E_OBJ_EVAL_DIVERGENCE: OBJ_CODE is laxer than evaluate_solution (no index\/type\/dup checks). Unify to the strict version to avoid silent objective under-\/over-counting. Use one shared validation routine.\"\n\n\"FEEDBACK\",\"E_SEED_CONTROL: Randomness is uncontrolled. Add an optional rng\/seed in other_params and thread it through generate_neighbour to ensure reproducibility and debuggability.\"\n\n\"FEEDBACK\",\"E_PERF_WEIGHT_RECOMP: total_weight is recomputed in loops (repair\/tighten). Maintain incremental (weight,value) to get O(1) updates instead of O(k) rescans. Cache ratios once.\"\n\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: 'repair_to_feasible' adds lowest ratio items greedily, then removes highest value items. This can oscillate and stall. Replace with constrained drop-while-feasible pass that tries removing items with lowest marginal penalty per released weight (value\/weight ascending).\"\n\n\"FEEDBACK\",\"R_MOVE_SET_INCOMPLETE: Only 1-1 swap and 1-2 add\/remove. Add targeted k-exchange: remove up to 2 items, add 1 (and vice versa), pick best-improving under feasibility. This sharply reduces local minima.\"\n\n\"FEEDBACK\",\"R_TIEBREAK_SUBOPTIMAL: Candidate sort key (ratios, values, -weights) may over-prefer heavy low-ratio items, inflating cover. For minimizing value with weight >= threshold, use key=(ratio asc, weight desc, value asc) for add; for drop, key=(value\/weight desc, value desc).\"\n\n\"FEEDBACK\",\"R_MULTI_TRY_SWAP_BIAS: base picks a single 'out' uniformly, explores few 'in'. Improve by trying top-m outs by worst ratio or highest value, cross with top-n ins by best ratio; select best-improving pair.\"\n\n\"FEEDBACK\",\"R_SHAKE_INTENSITY: k in [2,4] is weak for escaping deep basins. Make k adaptive to stagnation (e.g., k=min(6,2+stall\/\/T)), and always repair once after batch edits.\"\n\n\"FEEDBACK\",\"E_CONSTRAINT_DIRECTION_CHECK: Minimization with sum(weights) >= 67 is correct; ensure no hidden assumptions of <= in any move filters. Verify feasibility after every operator.\"\n\n\"FEEDBACK\",\"E_UNIT_TESTS_MISSING: Add tests for type, bounds, duplicates, feasibility boundary (exact 67), and infeasible penalties. Execute evaluator on these to prevent regression.\"\n\n\"FEEDBACK\",\"E_DRIVER_INTERFACE: Local solver error strings show mismatched signatures for SA\/ILS\/TS. Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE and internally adapt to each metaheuristic, e.g., SA(..., generate_neighbour, evaluate_solution, perturb_solution, {'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}).\"\n\n\"FEEDBACK\",\"R_SA_ACCEPTANCE: For SA, acceptance should compare costs (lower is better). Implement standard Metropolis with temperature schedule; ensure you pass solutions not meta tuples.\"\n\n\"FEEDBACK\",\"R_ILS_ACCEPTANCE: Define acceptance on non-worsening or a small-probability worsening; ensure perturbation is stronger than a single local move to be meaningful.\"\n\n\"FEEDBACK\",\"R_TS_MEMORY: Tabu needs tabu on items or moves, not whole solutions. Store recently added\/removed indices with tenure; aspirate if strictly improving cost.\"\n\n\"FEEDBACK\",\"E_COMPLEXITY_NOTE: Current neighbour generation worst-case O(n log n) from sorts plus repeated feasibility repairs per candidate. Reduce by precomputing sorted candidate lists and maintaining a lazy invalidation set.\"\n\n\"FEEDBACK\",\"R_INITIALIZATION: If currentSolution is empty or infeasible, build a feasible seed via minimal-value cover: greedily add by lowest value\/weight until reaching threshold, then drop redundant items while feasible using the improved drop rule.\"\n\n\"FEEDBACK\",\"EVAL_ASSERTION: Evaluator correctly penalizes invalid types\/indices\/duplicates and infeasibility. Verified locally against a reference input set; keep these guards to prevent gaming.\"\n\n\"FEEDBACK\",\"REF_INPUT_FORMAT_ERROR: The provided reference solution in metadata does not comply with index bounds. Ensure test harness validates indices in [1..24] before use; do not rely on objective fallbacks.\"\n\n\"FEEDBACK\",\"R_STOPPING_CRITERIA: Add stagnation-based stopping (no improvement in X iterations) and time cap. Persist best-so-far separately from current to avoid loss on perturb.\"\n\n\"FEEDBACK\",\"R_LOGGING: Log tuples (iter, cost, weight, |sol|, move_type). This enables diagnosing operator efficacy and tuning probabilities.\"\n\n\"FEEDBACK\",\"R_PARAMETER_TUNING: Increase swap T beyond 8 adaptively when pool is small; decrease when large. Calibrate add\/remove probabilities based on recent improvements (e.g., multi-armed bandit weighting).\"\n\n\"FEEDBACK\",\"R_SAFE_GUARDS: In repair loops, add iteration caps to avoid infinite cycles and always return a sanitized list. Validate that generate_neighbour never returns None.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST; solution is a Python list of unique integers in [1,24], each integer i indicates x_i = 1. Empty list allowed. Example: [2,3,10,16,17,22]","Componentes":{"REPRESENTATION":"INDEX_LIST; solution is a Python list of unique integers in [1,24], each integer i indicates x_i = 1. Empty list allowed. Example: [2,3,10,16,17,22]","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 10**18\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    if not isinstance(solution, list):\n        return 10**12\n    if any((not isinstance(i, int)) for i in solution):\n        return 10**12\n    if len(solution) != len(set(solution)):\n        return 10**12\n    if any(i < 1 or i > 24 for i in solution):\n        return 10**12\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    obj = objective_function(solution)\n    if total_weight >= 67:\n        return obj\n    deficit = 67 - total_weight\n    return 10**12 + deficit\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n# generate_neighbour returns: (neighbor_solution, NB_Type, Movement_Type)\n# NB_Type in {\"1-Flip\",\"Swap\",\"Add\",\"Remove\"}; Movement_Type describes the action\n\ndef generate_neighbour(solution: List[int]):\n    n_items = 24\n    sol_set = set(solution if isinstance(solution, list) else [])\n    current = [i for i in sol_set if isinstance(i, int) and 1 <= i <= n_items]\n    move = None\n    # Choose move type with simple logic to ensure validity\n    moves = [\"Add\", \"Remove\", \"Swap\"]\n    if len(current) == 0:\n        move = \"Add\"\n    elif len(current) == n_items:\n        move = \"Remove\"\n    else:\n        move = random.choice(moves)\n    new_sol = current.copy()\n    if move == \"Add\":\n        candidates = [i for i in range(1, n_items+1) if i not in sol_set]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n        nb_type = \"Add\"\n        movement = \"insert_one_index\"\n    elif move == \"Remove\":\n        if new_sol:\n            j = random.choice(new_sol)\n            new_sol.remove(j)\n        nb_type = \"Remove\"\n        movement = \"delete_one_index\"\n    else:  # Swap\n        if new_sol and len(new_sol) < n_items:\n            out_idx = random.choice(new_sol)\n            candidates = [i for i in range(1, n_items+1) if i not in sol_set]\n            if candidates:\n                in_idx = random.choice(candidates)\n                new_sol.remove(out_idx)\n                new_sol.append(in_idx)\n        nb_type = \"Swap\"\n        movement = \"swap_out_in\"\n    new_sol = sorted(set(new_sol))\n    return new_sol, nb_type, movement\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n_items = 24\n    sol_set = set(solution if isinstance(solution, list) else [])\n    current = [i for i in sol_set if isinstance(i, int) and 1 <= i <= n_items]\n    new_sol = set(current)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n_items)\n        if idx in new_sol:\n            new_sol.remove(idx)\n        else:\n            new_sol.add(idx)\n    return sorted(new_sol)\n","SAMPLE_SOL":"[2,3,10,16,17,22]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG:Heuristic signatures mismatch TARGET_HEURISTIC_GENERAL_SIGNATURE; remove parentheses from function parameters and pass callables, e.g., def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor). \nE_TYPE_HINT_MISUSE:Error 'Type List cannot be instantiated; use list() instead' indicates List() called as a constructor; use list() and reserve typing.List only for annotations. \nE_FUNC_NAME_MISMATCH:Your solvers show SA\/ILS\/TS custom signatures; standardize to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) as required. \nE_PERTURB_MISSING:'Perturbation Function' is undefined ($Perturb placeholder); implement a deterministic, reproducible perturb_solution(solution,rng,k) that applies k random Add\/Remove\/Swap moves. \nE_KNOWN_BEST_INPUT_INVALID:KNOWN_SOLUTION violates representation constraints (contains out-of-domain index); correct to unique integers in [1,24]. \nE_EVAL_INCONSISTENCY:EXPECTED_SCORE_FROM_KNOWN_SOLUTION disagrees with evaluate_solution() when validated; re-derive expected score from evaluate_solution to keep tests consistent. \nE_OBJ_DIR:Ensure all solvers treat 'less is better'; acceptance tests and best updates must use new_cost < best_cost throughout. \nE_INIT_POLICY:No feasible-construction step; infeasible starts will be heavily penalized and stall. Add greedy repair: iteratively add items minimizing value\/weight until sum(weights) >= 67. \nE_MOVE_SET_WEAK:Neighbourhood lacks a true 1-Flip toggle; current Add\/Remove\/Swap under-explores boundary states. Add 1-Flip that toggles a single index with repair to maintain feasibility. \nNB_CODE_FAIL_LOCAL_OPT:Swap is unconstrained and may generate equivalent states; augment with cost-improving biased selection (remove item with highest value\/weight among included, add item with lowest value\/weight among excluded). \nE_CODE_PERF:Full re-evaluation is O(n) per move; maintain (total_weight,total_value) incrementally to achieve O(1) updates for Add\/Remove\/Swap\/Flip, with lazy validation. \nR_STR_INADEQUATE:Sorted(set(...)) in generate_neighbour destroys sequence information needed for reproducible reverse moves; keep list order and track membership via a set for O(1) checks. \nE_RANDOMNESS:Unseeded global RNG impedes reproducibility; pass rng=random.Random(seed) through Heuristic and all operators. \nE_TABU_SPEC:Tabu search lacks well-defined attributes and aspiration; store tabu on moved indices (in_idx,out_idx) with tenure, and use aspiration if a move yields a global best. \nE_SA_COOLING:Cooling parameters unspecified; use geometric schedule T <- alpha*T with calibrated alpha in [0.90,0.99], stopping at MIN_TEMP and\/or no-improvement budget. \nE_ILS_ACCEPT:ILS acceptance unspecified; implement simulated annealing\u2013style acceptance or threshold-accepting; define iteration and acceptance-rate properly. \nE_CONSTRAINT_HANDLING:Moves can break feasibility without repair; implement two-phase evaluation: (1) fast infeasible penalty, (2) deterministic repair that adds cheapest items; avoid random retries. \nE_TERMINATION:No stopping criteria tied to evaluations; cap by max_iterations and max_no_improve to ensure predictable runtime. \nE_SCORING_SHAPE:objective_function ignores duplicates silently but evaluate_solution penalizes them; enforce identical validation in both to avoid silent mis-scoring. \nS_FIX_SIGNATURES:Refactor solver templates to: \n- def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): \n  maintain incumbent and call operators without parentheses. \nS_SAFE_TYPES:Replace any List() with list(); keep from typing import List only for annotations. \nS_PERTURB_IMPL:Implement: def perturb_solution(sol,rng,k): for _ in range(k): apply a random 1-Flip\/Add\/Remove; ensure uniqueness and bounds; optionally repair afterwards. \nS_GREEDY_INIT:Start from empty set; add items with minimal value\/weight ratio until feasible; then perform greedy deletions of worst ratio items while preserving feasibility to reduce objective. \nS_INCREMENTAL_EVAL:Maintain (W,V) with delta updates: \n- Add j: W+=w[j]; V+=v[j] \n- Remove j: W-=w[j]; V-=v[j] \nReturn V if W>=67 else penalty. \nS_MOVE_BIAS:When infeasible (W<67), restrict neighbours to Add or Flip-in moves that increase weight\/value ratio; when feasible, prefer Remove or Swap that reduce V while keeping W>=67. \nS_TABU_DETAILS:Use short-term tabu tenure (e.g., 7\u201315) on moved indices; aspiration if move improves best_score; diversify by occasional random long-jump perturbation. \nS_SA_DETAILS:Metropolis acceptance p=exp(-(new-old)\/T) for worse moves; reheating if stagnation persists; ensure numerical stability by early rejecting new>=old when T is very low. \nS_ILS_KICK:After local optimum, apply k-perturbation (e.g., k=2..5 flips) then run hill-climb; retain best across restarts with acceptance criterion new_best < current_best or probabilistic acceptance. \nS_TEST_HARNESS:Add deterministic unit tests: \n- validate representation (range, uniqueness) \n- verify evaluate_solution(empty)==penalized \n- check incremental evaluator matches full evaluator over random moves. \nS_LOG_EXTRA_OUTPUTS:Per instruction 6, log NB_Type, Movement_Type, deltaW, deltaV, acceptance_reason at each step to aid diagnosis. \nS_RECONCILE_SCORING:Align objective_function and evaluate_solution validation rules; either both penalize duplicates\/invalids or both sanitize, but be consistent. \nS_RESOURCE_BOUNDS:Set evaluation budget and seed in other_params; avoid unbounded runs. \nASSERT_CORRECTNESS_CHECK:Using the provided evaluate_solution, automated validation shows the supplied KNOWN_SOLUTION\/EXPECTED_SCORE pair is inconsistent and the solution violates representation constraints; correct the test pair before using it for solver verification.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST: solution is a list of unique integers in [1,24], where each integer i indicates x_i=1. Example: [5,7,9,13]","Componentes":{"REPRESENTATION":"INDEX_LIST: solution is a list of unique integers in [1,24], where each integer i indicates x_i=1. Example: [5,7,9,13]","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 10**18\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    if not isinstance(solution, list):\n        return 10**12\n    if any((not isinstance(i, int)) for i in solution):\n        return 10**12\n    if len(solution) != len(set(solution)):\n        return 10**12\n    if any(i < 1 or i > 24 for i in solution):\n        return 10**12\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    obj = objective_function(solution)\n    if total_weight >= 67:\n        return obj\n    deficit = 67 - total_weight\n    return 10**12 + deficit\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    n_items = 24\n    sol_set = set()\n    current = []\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in sol_set:\n                sol_set.add(i)\n                current.append(i)\n    if not current:\n        move_type = \"Add\"\n    elif len(current) >= n_items:\n        move_type = \"Remove\"\n    else:\n        move_type = random.choice([\"Add\", \"Remove\", \"Swap\", \"1-Flip\"])  # richer neighborhood\n    new_sol = current.copy()\n    nb_type = move_type\n    movement = \"\"\n    if move_type == \"Add\":\n        candidates = [i for i in range(1, n_items + 1) if i not in sol_set]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n        movement = \"insert_one_index\"\n    elif move_type == \"Remove\":\n        if new_sol:\n            j = random.choice(new_sol)\n            new_sol.remove(j)\n        movement = \"delete_one_index\"\n    elif move_type == \"Swap\":\n        if new_sol and len(new_sol) < n_items:\n            out_idx = random.choice(new_sol)\n            excluded = [i for i in range(1, n_items + 1) if i not in sol_set]\n            if excluded:\n                in_idx = random.choice(excluded)\n                new_sol.remove(out_idx)\n                new_sol.append(in_idx)\n        movement = \"swap_out_in\"\n    else:  # 1-Flip toggle\n        j = random.randint(1, n_items)\n        if j in new_sol:\n            new_sol.remove(j)\n            movement = \"flip_off\"\n        else:\n            new_sol.append(j)\n            movement = \"flip_on\"\n    # ensure uniqueness and valid indices\n    filtered = []\n    seen = set()\n    for i in new_sol:\n        if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n            filtered.append(i)\n            seen.add(i)\n    return filtered, nb_type, movement\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n_items = 24\n    # sanitize input\n    base = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n                base.append(i)\n                seen.add(i)\n    new_sol = set(base)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.choice([\"flip\", \"add\", \"remove\"])\n        if move == \"flip\":\n            j = random.randint(1, n_items)\n            if j in new_sol:\n                new_sol.remove(j)\n            else:\n                new_sol.add(j)\n        elif move == \"add\":\n            excluded = [i for i in range(1, n_items + 1) if i not in new_sol]\n            if excluded:\n                new_sol.add(random.choice(excluded))\n        else:  # remove\n            included = list(new_sol)\n            if included:\n                new_sol.remove(random.choice(included))\n    return sorted(new_sol)\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIG:Heuristic signatures mismatch TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses from function parameters; pass function references, not calls. Example: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).\\nE_TYPING_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates runtime attempted to instantiate typing.List. Replace any default args or constructions using List() with list(), and avoid using typing generics as runtime values.\\nE_ILS_DEPENDENCY:perturb_solution is undefined ('$Perturb' placeholder). Provide a concrete implementation matching signature perturb_solution(solution, strength, rng) -> new_solution.\\nE_TS_SIG:Tabu signature deviates from TARGET; align to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure taboo_list and durations passed via other_params dict.\\nE_NEIGHBOUR_OUT:generate_neighbour returns (solution,nb_type,movement). If heuristics expect only a solution, this causes unpacking\/type errors. Standardize to return only solution from generate_neighbour, and log nb_type\/movement separately.\\nE_EVAL_COMPAT:KNOWN_SOLUTION check failed under evaluator (penalty returned). Cause: invalid index present (<1). Ensure all indices are within [1,24] and unique before using as a baseline.\\nE_OBJ_FEAS_INCONSIST:Objective minimizes sum(values) with feasibility sum(weights)>=67. Heuristics must treat lower scores as better; verify SA\/ILS\/TS accept-worse logic uses delta = new_old > 0 for worse moves.\\nE_FEAS_PENALTY:Current penalty 1e12 dwarfs objective scale; SA acceptance with temperature may never accept penalized moves. Add repair or feasibility-preserving moves to neighborhood, or use staged penalties that allow guided exploration near boundary.\\nE_INIT:No feasible construction provided. Add a greedy initializer to meet weight>=67 before starting local search to avoid all-penalty states.\\nE_DUPLICATES:Objective silently dedups; evaluator rejects duplicates. Enforce uniqueness in all operators and validate before evaluation.\\nE_COOLING:Undefined annealing schedule robustness. Use geometric cooling with reanneal safeguards; ensure TEMP does not drop below MIN_TEMP prematurely.\\nE_TABU_ATTR:Tabu tenure not tied to move attributes. Store move attributes (added\/removed index) to avoid cycling; include aspiration when new_score < best_score.\\nE_PIVOT_RULE:Neighbourhood sampling is single-move random. Add first-improvement or best-of-k sampling to improve exploitation without heavy cost.\\nE_DELTA_EVAL:Evaluation is O(n) per neighbor. Implement delta evaluation: maintain (current_weight,current_value). For add\/remove\/swap\/flip, update in O(1). Guard with feasibility check using updated weight.\\nE_NEIGH_EXPL:Operator set lacks bias toward satisfying constraint. Add 'Add-lightest' and 'Swap-increase-weight' moves when infeasible; add 'Remove-heaviest-value-per-weight' when over-weight not applicable but to reduce cost while keeping feasibility.\\nE_PERTURB_SPEC:Provide k-flip or k-swap perturbation with controlled strength and feasibility repair for ILS.\\nE_STOP_COND:No stopping criteria specified. Add max_evals\/time and no-improvement budget to stabilize runs and comparability.\\nE_RNG:Random calls not seeded; results non-reproducible. Inject rng instance and seed via other_params.\\nE_LOGGING:No structured extra outputs. Return diagnostics: best_score, best_solution, eval_count, feasible_rate, last_move, temperature trace or tabu metrics as required by local solver.\\nS_FIX_LOCAL_1:Replace all typing.List instantiations with built-in list; remove parentheses from function reference params; ensure signatures match TARGET.\\nS_FIX_LOCAL_2:Implement perturb_solution:\\n- k = other_params.get('perturb_k',3)\\n- repeat k times: randomly flip or swap ensuring indices in [1,24]; then repair to meet weight>=67 by greedily adding lowest-value-per-weight items.\\nS_FIX_LOCAL_3:Refactor generate_neighbour to return only new_solution; move nb_type\/movement to a side logger or return via separate debug hook.\\nS_FIX_LOCAL_4:Add feasible initializer: sort items by value\/weight ascending; add until weight>=67.\\nS_FIX_LOCAL_5:Implement delta-based evaluate_cached(current_weight,current_value,move) with immediate feasibility check and fallback to full evaluate for safety in debug mode.\\nS_SA_ACCEPT:Use accept if new<cur or rand()<exp(-(new-cur)\/T). Ensure lower-is-better. Reheat if stagnation.\\nS_TS_IMPL:Maintain tabu list of recent indices with tenure; apply aspiration if candidate improves best. Use best-of-k neighbors per iteration.\\nS_ILS_LOOP:Local search = steepest descent over neighbor samples; perturb when no improvement; accept if improved or with simulated annealing-style probabilistic acceptance using temperature tied to iteration.\\nS_VALIDATION:Unit tests: (1) all operators keep indices in [1,24] and unique, (2) feasibility check correct at boundary 67, (3) delta evaluation matches full evaluation for 1000 random moves.\\nE_KNOWN_CHECK_FAIL:Baseline verification against evaluator fails due to invalid index and penalty; do not trust provided baseline until corrected to representation constraints.\\nE_BOUNDARY_TESTS:Add tests for min feasible sets and near-boundary weights to validate acceptance logic and penalty handling.\\nE_PARAM_TUNING:Expose params: cooling_factor, MIN_TEMP, tabu_tenure, neighbor_k, perturb_k; provide defaults and ranges; grid search on seed set for stability.\\nE_OUTPUT_SCHEMA:Ensure final return matches local solver expectation: best_solution (INDEX_LIST), best_score (int), plus extra diagnostics as separate fields, not embedded in solution.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST: solution is a list of unique integers in [1,24], where each integer i indicates x_i=1. Example: [5,7,9,13]","Componentes":{"REPRESENTATION":"INDEX_LIST: solution is a list of unique integers in [1,24], where each integer i indicates x_i=1. Example: [5,7,9,13]","EVAL_CODE":"import random\nimport math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 10**18\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    if any((not isinstance(i, int)) for i in solution):\n        return 10**12\n    if len(solution) != len(set(solution)):\n        return 10**12\n    if any(i < 1 or i > 24 for i in solution):\n        return 10**12\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    # Objective value (minimize)\n    obj = objective_function(solution)\n    # Feasibility: sum weights >= 67\n    if total_weight >= 67:\n        return obj\n    # Infeasible penalty with deficit\n    deficit = 67 - total_weight\n    return 10**12 + deficit\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    n_items = 24\n    # sanitize and ensure uniqueness and domain\n    sol_set = set()\n    current = []\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in sol_set:\n                sol_set.add(i)\n                current.append(i)\n    # choose move type\n    if not current:\n        move_type = \"Add\"\n    elif len(current) >= n_items:\n        move_type = \"Remove\"\n    else:\n        move_type = random.choice([\"Add\", \"Remove\", \"Swap\", \"1-Flip\"])  # diversified neighborhood\n    new_sol = current.copy()\n    nb_type = move_type\n    movement = \"\"\n    if move_type == \"Add\":\n        candidates = [i for i in range(1, n_items + 1) if i not in sol_set]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n        movement = \"insert_one_index\"\n    elif move_type == \"Remove\":\n        if new_sol:\n            j = random.choice(new_sol)\n            new_sol.remove(j)\n        movement = \"delete_one_index\"\n    elif move_type == \"Swap\":\n        if new_sol and len(new_sol) < n_items:\n            out_idx = random.choice(new_sol)\n            excluded = [i for i in range(1, n_items + 1) if i not in sol_set]\n            if excluded:\n                in_idx = random.choice(excluded)\n                new_sol.remove(out_idx)\n                new_sol.append(in_idx)\n        movement = \"swap_out_in\"\n    else:  # 1-Flip toggle\n        j = random.randint(1, n_items)\n        if j in new_sol:\n            new_sol.remove(j)\n            movement = \"flip_off\"\n        else:\n            new_sol.append(j)\n            movement = \"flip_on\"\n    # ensure uniqueness and valid indices\n    filtered = []\n    seen = set()\n    for i in new_sol:\n        if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n            filtered.append(i)\n            seen.add(i)\n    return filtered, nb_type, movement\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n_items = 24\n    # sanitize base solution\n    base = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n                base.append(i)\n                seen.add(i)\n    new_set = set(base)\n\n    # random k-perturbation\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.choice([\"flip\", \"add\", \"remove\"])\n        if move == \"flip\":\n            j = random.randint(1, n_items)\n            if j in new_set:\n                new_set.remove(j)\n            else:\n                new_set.add(j)\n        elif move == \"add\":\n            excluded = [i for i in range(1, n_items + 1) if i not in new_set]\n            if excluded:\n                new_set.add(random.choice(excluded))\n        else:  # remove\n            included = list(new_set)\n            if included:\n                new_set.remove(random.choice(included))\n\n    # feasibility repair: ensure sum(weights) >= 67 by greedy additions with low value\/weight\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values =  [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8,18, 8, 9]\n\n    def total_weight(idx_set):\n        return sum(weights[i] for i in idx_set)\n\n    # add items with best value\/weight until feasible\n    if total_weight(new_set) < 67:\n        candidates = [(i, values[i]\/weights[i]) for i in range(1, n_items+1) if i not in new_set]\n        candidates.sort(key=lambda x: (x[1], values[x[0]]))  # prioritize low ratio, then low value\n        cw = total_weight(new_set)\n        for i, _ in candidates:\n            if cw >= 67:\n                break\n            new_set.add(i)\n            cw += weights[i]\n\n    # final sanitize and return as list (unsorted to allow diversity)\n    result = []\n    seen2 = set()\n    for i in new_set:\n        if isinstance(i, int) and 1 <= i <= n_items and i not in seen2:\n            result.append(i)\n            seen2.add(i)\n    return result\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_INIT:Missing perturbation implementation. '$Perturb' placeholder breaks ILS; provide a concrete 'perturb_solution' callable.\nE_SIG_WRONG_CALLABLES:Heuristic signatures incorrectly pass generate_neighbour() and evaluate_solution() with parentheses. Pass callables, not results. EX: def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).\nE_TYPING_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates usage of typing.List() or typing.Tuple(). Replace any 'List()','Tuple()' with 'list()','tuple()' and avoid constructing typing types at runtime.\nE_TARGET_SIGNATURE_MISMATCH:Framework expects def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Provide wrappers adapting SA\/ILS\/TS to this exact signature.\nE_PENALTY_INCONSISTENCY:OBJ_CODE uses 1e18 for type faults; EVAL_CODE uses 1e12 for invalidities. Normalize to a single penalty constant to avoid search bias. Suggest P=10**12 for all invalid cases.\nE_DOMAIN_VIOLATION_REF:Reference vector used for validation includes out-of-domain indices (0 not allowed). Evaluation correctly returns penalty. Ensure any seeded or test solutions strictly use indices in [1,24].\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood lacks feasibility awareness; random remove\/flip often violates weight constraint, wasting evaluations. Add feasibility-preserving moves: (a) Add-only until weight>=67; (b) 1-1 exchange keeping weight>=67; (c) Remove-then-Add only if feasibility restored.\nNB_REDUNDANT_FILTER:Post-move dedup\/filter rebuilds list every step. Maintain 'sol_set' throughout; update incrementally on add\/remove\/swap to O(1) instead of O(k).\nNB_MOVE_WEAK:Only single-element moves ('Add','Remove','Swap','1-Flip'). Add stronger neighborhoods: (d) 2-exchange (swap two-out two-in), (e) cost-improving drop of any item with zero marginal feasibility risk, (f) greedy repair operator when infeasible.\nINIT_CONSTRUCTION_WEAK:Random or empty-start slows convergence. Use constructive heuristic: sort indices by value\/weight ascending, add until weight>=67, then local improvement via drop or 1-1 exchanges.\nE_SA_ACCEPTANCE:Ensure SA uses minimization acceptance: accept worse with p=exp(-(delta)\/T) where delta=new_cost-old_cost>0. Reject when callable returns penalties > P-1000 to avoid learning from infeasible states.\nE_TS_MEMORY:Tabu list should store moves (e.g., swapped pairs or last added\/removed indices) not full solutions; set fixed tenure and aspiration when new_cost<best_cost.\nILS_PERTURB_SPEC:Define perturb as k random 1-1 exchanges biased toward high value\/low weight items to escape local minima; follow with best-improvement local search.\nE_EVAL_COST:Current evaluation recomputes total weight O(k) per call. Cache total_weight and total_value with incremental updates in the search loop to reduce complexity from O(k) to O(1) per neighbor.\nE_CONSISTENT_RANDOM:Seed control absent; add optional 'rng' parameter or seeded random.Random instance to ensure reproducibility in local solver.\nE_OUTPUT_TRACING:Local solver expects extra outputs; return (solution,cost,nb_type,movement,total_weight) per step for tracing. Ensure components propagate 'nb_type' and 'movement' from neighborhood function.\nE_CONSTRAINT_TIGHTEN:Add fast feasibility checks in neighborhood: precompute remaining slack s=total_weight-67; allow removals only if slack>=weights[item], otherwise pair with compensating add.\nR_REPR_VALIDATION:Add fast domain validator for INDEX_LIST once at loop start and assert uniqueness via set size; avoid repeated validation when using incremental updates.\nR_MOVE_SELECTION:Biased move selection: when feasible and improvable, prefer 'Remove' of worst ratio items; when infeasible, prefer 'Add' smallest ratio items. Use roulette or epsilon-greedy to balance exploration.\nE_PARAM_DEFAULTS:Set sane defaults: SA(TEMP=50,MIN_TEMP=1e-3,cooling=0.95,iters_per_T=100); TS(iterations=200,tabu_size=50,tenure=7); ILS(iterations=50,perturb_k=2,accept=better-or-equal). Expose via 'other_params'.\nE_STOPPING_CRITERIA:Add stagnation cutoff (no improvement for X iterations) and hard eval budget to prevent runaway runs.\nE_TEST_FIXTURE:Create unit checks: (1) evaluate_solution([]) returns penalty+67; (2) evaluate_solution([1]) returns penalty+56; (3) neighbour maintains uniqueness\/domain invariants. This prevents silent regressions.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Expect: solution is a list of distinct 1-based indices in 1..24\n    # Returns: objective value if feasible, else +inf. Objective is total value (minimize)\n    if not isinstance(solution, list):\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int):\n            return float('inf')\n    n = 24\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(x < 1 or x > n for x in solution):\n        return float('inf')\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n    if total_weight < 67:\n        return float('inf')\n    return total_value\n","NB_CODE":"import random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor move on INDEX_LIST representation.\n    # Ensures entries remain distinct and within 1..24.\n    if not isinstance(solution, list):\n        return (\"INDEX_LIST\", \"no-op\")\n    n = 24\n    current_set = set(x for x in solution if isinstance(x, int) and 1 <= x <= n)\n    # Sanitize to ensure internal consistency before move\n    if len(current_set) != len(solution):\n        solution[:] = sorted(current_set)\n    move_types = []\n    if len(solution) > 0:\n        move_types.append(\"remove\")\n    if len(solution) < n:\n        move_types.append(\"add\")\n    if 0 < len(solution) < n:\n        move_types.append(\"swap\")\n    if not move_types:\n        return (\"INDEX_LIST\", \"no-op\")\n    move = random.choice(move_types)\n    if move == \"remove\" and len(solution) > 0:\n        idx = random.randrange(len(solution))\n        del solution[idx]\n        return (\"INDEX_LIST\", \"remove\")\n    elif move == \"add\" and len(solution) < n:\n        available = [i for i in range(1, n + 1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            insert_pos = random.randrange(len(solution) + 1)\n            solution.insert(insert_pos, new_item)\n            return (\"INDEX_LIST\", \"add\")\n    elif move == \"swap\" and 0 < len(solution) < n:\n        # remove one existing and add a new absent one\n        rem_idx = random.randrange(len(solution))\n        removed = solution.pop(rem_idx)\n        available = [i for i in range(1, n + 1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            insert_pos = random.randrange(len(solution) + 1)\n            solution.insert(insert_pos, new_item)\n            return (\"INDEX_LIST\", \"swap\")\n        # fallback if no available (shouldn't happen)\n        solution.insert(rem_idx, removed)\n        return (\"INDEX_LIST\", \"no-op\")\n    return (\"INDEX_LIST\", \"no-op\")\n","PERTURB_CODE":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Strong perturbation: perform k random add\/remove\/swap moves.\n    # Keeps representation valid (distinct indices in 1..24).\n    if not isinstance(solution, list):\n        return\n    n = 24\n    # sanitize\n    solution[:] = sorted(set(x for x in solution if isinstance(x, int) and 1 <= x <= n))\n    k = max(3, len(solution) \/\/ 2)\n    for _ in range(k):\n        move = random.random()\n        if move < 0.34 and len(solution) > 0:\n            # remove\n            del solution[random.randrange(len(solution))]\n        elif move < 0.67 and len(solution) < n:\n            # add\n            available = [i for i in range(1, n + 1) if i not in solution]\n            if available:\n                solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n        else:\n            # swap when possible\n            if 0 < len(solution) < n:\n                rem_idx = random.randrange(len(solution))\n                removed = solution.pop(rem_idx)\n                available = [i for i in range(1, n + 1) if i not in solution]\n                if available:\n                    solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n                else:\n                    solution.insert(rem_idx, removed)\n    # final sanitize to ensure constraints\n    solution[:] = sorted(set(x for x in solution if 1 <= x <= n))\n","SAMPLE_SOL":[10,13,2,3,7,6,1,5,19,18,14,17,21,9,16]},"Version":0,"Feedback":"\"COMPONENT_VERSION\": \"v1.0\"\n\"FEEDBACK\": \"FIX_LOCAL_SOLVER_ERRORS_FIRST:Detected multiple local solver inconsistencies; address in the order listed below.\nE_SA_SCORE_MISMATCH:Simulated_Annealing reports score 148 for the provided solution but evaluate_solution returns a different value for the same indices; align objective direction and scoring so SA uses evaluate_solution consistently for acceptance and tracking.\nE_TS_API_UNPACK:Taboo_Search fails with 'too many values to unpack'; generate_neighbour currently returns (repr_type, move_type) instead of a neighbour solution; conform to a single-return neighbour object or update TS to handle the extra metadata explicitly.\nNB_API_CONTRACT:generate_neighbour mutates in place and returns a tuple of metadata; standardize to either (a) pure function returning a new solution with no side effects, or (b) in-place mutate and return the mutated solution only; remove extraneous return elements to meet heuristic interfaces.\nPERTURB_MISSING:Perturbation Function is undefined ('$Perturb'); implement a concrete perturbation operator (e.g., drop-k\/add-k with k>=2) to enable ILS and to escape local minima.\nILS_OUTPUT_INVALID:Iterated_Local_Search returns ('INDEX_LIST', inf, ...); output types\/positions are inconsistent; ensure it returns (best_solution, best_score, aux_outputs...) with best_solution as a valid INDEX_LIST and best_score computed via evaluate_solution.\nOBJ_DIR_CONFUSION:Heuristics must minimize; confirm delta = new_cost - old_cost and acceptance criteria reflect minimization; remove any residual maximization logic (no negation of scores).\nCONSTRAINT_HANDLING:Neighbour moves frequently produce infeasible solutions (weight<67) leading to inf scores and wasted evaluations; add repair (e.g., greedily add lowest-value or best value\/weight items until feasible) or use feasibility-preserving moves.\nEVAL_CALL_REQUIRED:All heuristic comparisons must use evaluate_solution; prohibit internal ad-hoc scoring to avoid drift from the ground truth objective.\nKNOWN_REF_INCONSISTENT:Provided reference solution format and score are incompatible with the stated representation and evaluator; fix to 1-based indices and recompute the expected score using evaluate_solution before using as a benchmark.\nINIT_CONSTRUCTIVE_WEAK:Sample solution is arbitrary; construct an initial feasible solution via greedy sorted by value\/weight (ascending due to minimization under >= constraint), then local-repair to reach feasibility with minimal cost increase.\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood limited to single add\/remove\/swap; augment with drop-1 add-1 (1-1 exchange), drop-2 add-1, and add-2 drop-1 to allow stronger local improvements; implement first-improvement and best-improvement scans.\nDELTA_EVAL_MISSING:Each move recomputes totals in O(k); maintain (total_weight,total_value) to update in O(1) per add\/remove\/swap; reject moves producing weight<67 early.\nNB_AVAIL_GEN_COST:Rebuilding 'available' via list comprehensions is O(n) per move; maintain a boolean in_set[1..n] or a bitset to sample adds in O(1) and update in O(1).\nR_REPR_LIMIT:INDEX_LIST causes O(n) membership checks; switch to dual representation (list + boolean membership) or a fixed-length bitset to reduce neighbour generation cost.\nSEED_REPRODUCIBILITY:random.seed() called without parameter; expose seed via other_params and set per run for reproducibility in experiments.\nTS_PARAMETERS:Specify taboo_list_size and taboo_duration explicitly; ensure the taboo list stores solution attributes consistent with the chosen representation (e.g., item indices or move signatures) and aspiration criteria for improving moves.\nSA_SCHEDULE_UNSPECIFIED:Define temperature schedule (T0, cooling rate alpha, stopping T_min); ensure acceptance p=exp(-delta\/T) with delta>=0 for worse moves under minimization; clamp T and probabilities for numeric stability.\nTERMINATION_CRITERIA:Missing iteration\/time\/plateau stopping conditions; add composite criteria (max_iters, max_no_improve, time budget).\nLOCAL_SEARCH_MOVE_EFF:Implement steepest-descent on a bounded candidate list (e.g., evaluate k random 1-1 exchanges per iteration) to control cost while improving solution quality.\nBIAS_EXPLOITATION_BALANCE:Random uniform neighbour choice hinders focus; bias choices toward low-value additions and high-value removals when overweight; inverse when underweight.\nREPAIR_STRATEGY_PRECISE:When infeasible underweight, greedily add by increasing value\/weight; when overweight (if that constraint existed), consider high-value removals; maintain feasibility boundary at 67 exactly or slightly above to minimize added cost.\nCODE_INTERFACE_STANDARD:Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE: Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params); ensure all components match types and return shapes required by the framework.\nVERIFICATION_PIPELINE:Add an exact DP checker (n=24 is trivial) to validate heuristic outputs post-run and to detect scoring\/feasibility bugs; do not expose the checker\u2019s solution during heuristic evaluation.\nOUTPUT_CONSISTENCY:Standardize solver return tuple to (best_solution, best_score, aux1=current_solution, aux2=current_score) and document; ensure all solvers adhere to it to avoid downstream parsing errors.\nACTION_ITEMS_ORDERED:1) Fix generate_neighbour return to a single neighbour solution and stop returning metadata; 2) Implement perturb_solution; 3) Route all scoring through evaluate_solution and correct minimization logic; 4) Add feasibility repair; 5) Add delta-evaluation with maintained totals; 6) Correct TS signature and taboo data structures; 7) Add reproducible seeding and schedules; 8) Validate against an exact checker; 9) Replace\/augment neighbourhood with 1-1 exchanges and bounded best-improvement.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Expect: solution is a list of distinct 1-based indices in 1..24\n    # Returns: objective value if feasible, else +inf. Objective is total value (minimize)\n    if not isinstance(solution, list):\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int):\n            return float('inf')\n    n = 24\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(x < 1 or x > n for x in solution):\n        return float('inf')\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n    if total_weight < 67:\n        return float('inf')\n    return total_value\n","NB_CODE":"import random\nimport math\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbour move; returns (representation_type, movement_type)\n    # Representation: INDEX_LIST (list of distinct 1-based indices)\n    if not isinstance(solution, list):\n        return (\"INDEX_LIST\", \"no-op\")\n\n    n = 24\n\n    def sanitize(sol):\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        # Ensure feasibility (weight >= 67) with minimal added cost, then trim redundant costly items\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        # Feasibility repair: add cheapest value\/weight absent items until weight >= 67\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n+1) if i not in sol]\n            # sort by ratio then by absolute value\n            absent.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                sol.append(absent[j])\n                tw += weights[absent[j]-1]\n                tv += values[absent[j]-1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        # Trimming: try removing items that keep feasibility, preferring removal of high value\/weight\n        if tw >= 67 and len(sol) > 0:\n            # sort indices in solution by decreasing value\/weight, then by value\n            cand = sorted(sol, key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n            changed = True\n            while changed:\n                changed = False\n                for i in list(cand):\n                    wi = weights[i-1]\n                    vi = values[i-1]\n                    if tw - wi >= 67:\n                        # remove i\n                        try:\n                            sol.remove(i)\n                        except ValueError:\n                            continue\n                        tw -= wi\n                        tv -= vi\n                        changed = True\n                        # update candidate list\n                        cand = sorted(sol, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)\n                        break\n        sanitize(sol)\n\n    # sanitize before move\n    sanitize(solution)\n\n    # choose a move\n    move_types = []\n    if len(solution) > 0:\n        move_types.append(\"remove\")\n    if len(solution) < n:\n        move_types.append(\"add\")\n    if 0 < len(solution) < n:\n        move_types.append(\"swap\")\n    if not move_types:\n        return (\"INDEX_LIST\", \"no-op\")\n\n    move = random.choice(move_types)\n\n    if move == \"remove\" and len(solution) > 0:\n        ridx = random.randrange(len(solution))\n        del solution[ridx]\n    elif move == \"add\" and len(solution) < n:\n        available = [i for i in range(1, n+1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution)+1)\n            solution.insert(pos, new_item)\n        else:\n            move = \"no-op\"\n    elif move == \"swap\" and 0 < len(solution) < n:\n        ridx = random.randrange(len(solution))\n        removed = solution.pop(ridx)\n        available = [i for i in range(1, n+1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution)+1)\n            solution.insert(pos, new_item)\n        else:\n            solution.insert(ridx, removed)\n            move = \"no-op\"\n    else:\n        move = \"no-op\"\n\n    # Repair and trim to improve feasibility and cost\n    repair_feasible_and_trim(solution)\n\n    return (\"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nimport math\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random edits followed by feasibility repair and trimming\n    if not isinstance(solution, list):\n        return\n\n    n = 24\n\n    def sanitize(sol):\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n+1) if i not in sol]\n            absent.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                sol.append(absent[j])\n                tw += weights[absent[j]-1]\n                tv += values[absent[j]-1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            cand = sorted(sol, key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n            changed = True\n            while changed:\n                changed = False\n                for i in list(cand):\n                    wi = weights[i-1]\n                    if tw - wi >= 67:\n                        try:\n                            sol.remove(i)\n                        except ValueError:\n                            continue\n                        tw -= wi\n                        changed = True\n                        cand = sorted(sol, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)\n                        break\n        sanitize(sol)\n\n    sanitize(solution)\n\n    # number of random edits\n    k = max(3, len(solution) \/\/ 2)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.34 and len(solution) > 0:\n            # remove\n            del solution[random.randrange(len(solution))]\n        elif r < 0.67 and len(solution) < n:\n            # add\n            available = [i for i in range(1, n+1) if i not in solution]\n            if available:\n                solution.insert(random.randrange(len(solution)+1), random.choice(available))\n        else:\n            # swap\n            if 0 < len(solution) < n:\n                ridx = random.randrange(len(solution))\n                removed = solution.pop(ridx)\n                available = [i for i in range(1, n+1) if i not in solution]\n                if available:\n                    solution.insert(random.randrange(len(solution)+1), random.choice(available))\n                else:\n                    solution.insert(ridx, removed)\n    repair_feasible_and_trim(solution)\n","SAMPLE_SOL":"[5,9,13,23]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_INPUT_TYPE:Local solver passes solution as string (e.g., '[5,9,13,23]') to evaluate_solution; function expects list -> returns +inf. Enforce list typing and avoid str() serialization in solver pipeline.\n\nE_KNOWN_REF_INVALID:Provided KNOWN_SOLUTION uses 0-based indices (contains 0) violating 1..24; evaluate_solution returns +inf. Correct to 1-based before asserting any score.\n\nE_EXPECTED_SCORE_INCONSISTENT:EXPECTED_SCORE_FROM_KNOWN_SOLUTION does not match evaluation under current evaluate_solution. Recompute expected score only after fixing indexing.\n\nE_TS_API_MISMATCH:generate_neighbour returns (repr, move_type) but Taboo_Search expects a single solution object -> 'too many values to unpack'. Standardize API to return only the new solution (and log move separately), or wrap to match TS signature.\n\nE_INPLACE_SIDE_EFFECTS:generate_neighbour mutates the input solution in place. Many metaheuristics assume functional neighbors. Return a deep-copied modified solution to avoid unintended state corruption and non-reproducible behavior.\n\nE_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Implement a concrete perturbation (e.g., randomized k-swap\/add\/drop) to enable ILS\/SA to escape local minima.\n\nE_SA_STALLED:Simulated_Annealing reports +inf due to type error above; no meaningful search progress. Fix input typing first; then ensure SA evaluates neighbors not representation strings.\n\nNB_API_CONTRACT:Current neighbor returns representation tag 'INDEX_LIST' redundantly. Remove from return to conform to Heuristic(currentSolution, ...) usage and prevent unpack errors.\n\nNB_MOVE_SET_LIMITED:Only add\/remove\/swap with light repair. Exploration weak in constrained space. Add compound moves: (drop-2 add-1), (swap-2), and ratio-guided multi-drop to traverse plateaus.\n\nNB_REPAIR_TIEBREAK_SUBOPTIMAL:Feasibility repair sorts absent by (value\/weight, value). Secondary key should prefer higher weight at same ratio to reach constraint faster with minimal cost. Use key=(v\/w, -w, v).\n\nNB_TRIM_COMPLEXITY:Trimming re-sorts candidate list after each removal -> O(k^2 log k). Improve to O(k log k): sort once by decreasing (v\/w, v), iterate once attempting removals, no resort unless a removal succeeds; maintain indices or use a heap.\n\nNB_COST_METRIC_ONLY:Repair\/trim optimize local proxy; no lookahead on combinatorial interactions. Add short greedy post-optimization: try replace-1-with-2 and replace-2-with-1 guided by ratio to reduce value while keeping weight \u2265 threshold.\n\nE_EVAL_DUPLICATION:OBJ_CODE and EVAL_CODE duplicate logic. Maintain a single source of truth to avoid drift; have objective_function call evaluate_solution or vice versa.\n\nE_CACHE_MISSING:Repeated evaluation of same solutions across SA\/ILS is likely. Add memoization of (frozenset(solution)) -> (value, weight) to reduce repeated O(n) scans.\n\nINIT_GEN_WEAK:No initialization policy specified beyond Sample Solution. Provide deterministic constructive heuristic (sort by v\/w ascending, then take until \u2265 threshold) to guarantee a strong feasible start.\n\nILS_ACCEPT_CRITERIA_OPAQUE:Ensure acceptance criterion considers feasibility and objective (reject +inf neighbors) and applies diversification if stuck (e.g., perturb until feasible then greedy trim).\n\nTS_TABU_SCOPE_UNDEFINED:Define move encoding for tabu (e.g., added\/removed item indices) and tenure consistent with move granularity; current mismatch will break cycling control.\n\nCONSTRAINT_ENFORCEMENT:Neighbor sanitize() sorts and uniques indices, ignoring multiplicity\u2014OK for set representation\u2014but it also silently drops invalid entries. Prefer explicit validation error to catch upstream bugs, not mask them.\n\nRANDOMNESS_CONTROL:random.seed() without explicit seed reduces reproducibility. Accept external seed via other_params and seed locally for deterministic runs when needed.\n\nPERF_EVAL:Current evaluation O(m) per call (m=|solution|). Maintain running totals in the heuristic loop to amortize to O(1) for add\/remove\/swap; recompute only on repair\/trim.\n\nTEST_SUITE_GAP:Add unit tests: (1) type handling (list vs string), (2) boundary indices, (3) feasibility repair reaching threshold, (4) trimming preserves feasibility, (5) neighbor API compliance with SA\/ILS\/TS signatures.\n\nCORRECTIVE_ACTIONS:\n- FIX_LOCAL_SOLVER_ERRORS_FIRST: Ensure solutions remain Python lists end-to-end; remove any str() conversions. Add type assertions before evaluate_solution calls.\n- STANDARDIZE_NEIGHBOR:def generate_neighbour(solution): return new_solution_only. Provide an adapter if a movement_type is needed by specific solvers.\n- IMPLEMENT_PERTURB:Define perturb_solution(solution,k=3): perform k random add\/remove\/swap operations followed by repair_trim; return new solution.\n- REPAIR_KEY:absent.sort(key=lambda i:(values[i-1]\/weights[i-1], -weights[i-1], values[i-1])).\n- TRIM_PASS:Precompute ordered list; single pass attempt removals without resort after each iteration; only recompute if a removal occurs.\n- STATE_CACHING:Introduce dict cache for (frozenset(solution))->(value,weight) in heuristics; update incrementally on elementary moves.\n- INDEXING_FIX:Convert any 0-based external inputs to 1-based before evaluation; validate no zeros present.\n- TS_INTEGRATION:Adjust TS to accept neighbor returning only solution; define tabu attributes as item additions\/removals; fix function signature per target template.\n- REPRODUCIBILITY:Thread seed via other_params; avoid global seeding in module scope.\n- METRIC_ASSERTION:After fixes, validate evaluation by comparing solver output score against an independently computed baseline on the same representation; do not rely on mismatched external references.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Expect: solution is a list of distinct 1-based indices in 1..24\n    # Returns: objective value if feasible, else +inf. Objective is total value (minimize)\n    if not isinstance(solution, list):\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int):\n            return float('inf')\n    n = 24\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(x < 1 or x > n for x in solution):\n        return float('inf')\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n    if total_weight < 67:\n        return float('inf')\n    return total_value","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor move; returns (representation_type, movement_type)\n    # Representation: INDEX_LIST (list of distinct 1-based indices)\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        # Ensure feasibility (weight >= 67) and attempt local trimming to reduce value\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n + 1) if i not in sol]\n            # Prefer lower value-per-weight, then higher weight, then lower value\n            absent.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                i = absent[j]\n                sol.append(i)\n                tw += weights[i - 1]\n                tv += values[i - 1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            # Single pass trimming: try removing items with worst value-per-weight first\n            order = sorted(sol, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n            for i in list(order):\n                wi = weights[i - 1]\n                vi = values[i - 1]\n                if tw - wi >= 67 and i in sol:\n                    sol.remove(i)\n                    tw -= wi\n                    tv -= vi\n        sanitize(sol)\n\n    if not isinstance(solution, list):\n        return (\"INDEX_LIST\", \"no-op\")\n\n    sanitize(solution)\n\n    # Choose a move type\n    candidates = []\n    if len(solution) > 0:\n        candidates.append(\"remove\")\n    if len(solution) < n:\n        candidates.append(\"add\")\n    if 0 < len(solution) < n:\n        candidates.append(\"swap\")\n    if not candidates:\n        return (\"INDEX_LIST\", \"no-op\")\n\n    move = random.choice(candidates)\n\n    if move == \"remove\" and len(solution) > 0:\n        ridx = random.randrange(len(solution))\n        del solution[ridx]\n    elif move == \"add\" and len(solution) < n:\n        available = [i for i in range(1, n + 1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution) + 1)\n            solution.insert(pos, new_item)\n        else:\n            move = \"no-op\"\n    elif move == \"swap\" and 0 < len(solution) < n:\n        ridx = random.randrange(len(solution))\n        removed = solution.pop(ridx)\n        available = [i for i in range(1, n + 1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution) + 1)\n            solution.insert(pos, new_item)\n        else:\n            solution.insert(ridx, removed)\n            move = \"no-op\"\n    else:\n        move = \"no-op\"\n\n    repair_feasible_and_trim(solution)\n\n    return (\"INDEX_LIST\", move)","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random edits followed by feasibility repair and trimming\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n + 1) if i not in sol]\n            absent.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                i = absent[j]\n                sol.append(i)\n                tw += weights[i - 1]\n                tv += values[i - 1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            order = sorted(sol, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n            for i in list(order):\n                wi = weights[i - 1]\n                vi = values[i - 1]\n                if tw - wi >= 67 and i in sol:\n                    sol.remove(i)\n                    tw -= wi\n                    tv -= vi\n        sanitize(sol)\n\n    if not isinstance(solution, list):\n        return\n\n    sanitize(solution)\n\n    k = max(3, max(1, len(solution)) \/\/ 2)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.34 and len(solution) > 0:\n            del solution[random.randrange(len(solution))]\n        elif r < 0.67 and len(solution) < n:\n            available = [i for i in range(1, n + 1) if i not in solution]\n            if available:\n                solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n        else:\n            if 0 < len(solution) < n:\n                ridx = random.randrange(len(solution))\n                removed = solution.pop(ridx)\n                available = [i for i in range(1, n + 1) if i not in solution]\n                if available:\n                    solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n                else:\n                    solution.insert(ridx, removed)\n\n    repair_feasible_and_trim(solution)","SAMPLE_SOL":"[5,9,13,21]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Type mismatch in solver pipeline. Solutions are passed as string representations (e.g., '[5,9,13,21]'), causing evaluate_solution to return +inf. Ensure all solvers pass a Python list[int] not str.\nEVAL_INTERFACE_STRICTNESS:evaluate_solution returns +inf on any type\/range\/duplication error. Add strict input validation in solvers before evaluation to prevent silent +inf propagation.\nPERTURB_MISSING:$Perturb placeholder makes code non-runnable. Implement perturb_solution(solution, other_params)->list[int] with bounded changes (e.g., k random add\/remove\/swap) and ensure feasibility via the same repair routine.\nTS_SIGNATURE_MISMATCH:Taboo_Search signature and return protocol do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and return (best_solution, best_score, meta). Remove custom param ordering and unpacking assumptions.\nRET_PROTOCOL_INCONSISTENCY:Simulated_Annealing and Iterated_Local_Search appear to return stringified solutions and +inf. Standardize returns to (best_solution:list[int], best_score:float, meta:dict) with machine-parseable types only.\nNB_INPLACE_SIDE_EFFECT:generate_neighbour mutates the input solution in-place and returns only metadata. Many metaheuristics expect a new candidate. Change to return (new_solution:list[int], movement_type:str) and avoid mutating the caller reference; or explicitly design solvers to clone before calling.\nNB_SANITIZE_COST:sanitize sorts and deduplicates entire solution each move O(n log n). Replace with O(1) membership via boolean mask length 24, and maintain sortedness only if required by downstream (representation is a set; sorting unnecessary).\nNB_REPAIR_GREEDY_SUBOPT:repair_feasible_and_trim uses single-pass greedy add\/trim by value\/weight. This can trap local minima. Improve with: (a) post-repair 1-0 and 2-1 drop heuristics maintaining feasibility; (b) bounded knapsack DP on the chosen subset to minimize value subject to weight\u226567; or (c) multi-start repair with different tie-breakers.\nNB_ADD_HEURISTIC_TIEBREAK:Current add heuristic prefers low v\/w then high weight then low value. Add a fallback that considers marginal value per missing weight to reach the threshold to reduce overshoot.\nINDEXING_INCONSISTENCY:KNOWN_SOLUTION provided is 0-based but representation and evaluator require 1-based indices. Convert by +1 before any assertion or evaluation to avoid +inf due to out-of-range items.\nEVAL_ASSERTION_PROTOCOL:Automate unit tests that evaluate the reference solution (after index correction) and a feasible sample. Fail the test if evaluate_solution returns +inf; log exact cause (type\/range\/dup\/weight).\nSA_ACCEPTANCE_GAP:Ensure annealing step uses the candidate score computed from evaluate_solution on a proper list; guard against +inf candidates by forcing repair or rejection to prevent best_score stagnating at +inf.\nILS_PERTURB_SCOPE:Define perturb strength relative to |solution| and threshold slack (total_weight-67). Too weak: no escape; too strong: disrupts good structure. Start with k in [1..3] random moves, followed by repair+trim.\nMETA_LOGGING_DEFICIENT:Do not emit human-readable tuples. Emit structured meta dict: {'iters':int,'accepts':int,'improvements':int,'last_move':str}. Avoid strings to ensure computational parsing.\nCONSTRAINT_HANDLING_ORDER:Apply repair-to-feasible before evaluation in every loop. Any evaluation of infeasible candidates should be skipped, not assigned +inf unless used strictly for rejection logic.\nDUP_CHECK_COST:len(solution)!=len(set(solution)) causes O(n) set creation each eval. Replace representation with fixed-size bitset or boolean array for O(1) uniqueness enforcement and faster neighbourhood ops.\nUNIT_TESTS_REQUIRED:Add tests: (a) evaluate_solution(list[int]) with feasible\/infeasible; (b) neighbour returns valid distinct 1..24 indices; (c) perturb preserves type and feasibility post-repair; (d) Tabu\/SA\/ILS contract compliance.\nCODE_SAFETY_RULE:Verify no component accesses filesystem\/network\/os. Keep random, math only; no IO side-effects per MAIN_CRITICAL_INSTRUCTION.\nCORRECTNESS_ASSERTION:Internal evaluation against the reference confirms evaluator logic is consistent once indices are corrected; embed this check in CI to prevent regressions.\nIMPLEMENTATION_SUGGESTIONS: \n- Replace generate_neighbour with:\n  - add: choose from available items minimizing delta value per delta weight needed;\n  - remove: try 1-0 with highest value\/weight first while maintaining feasibility;\n  - swap: combine remove+add with acceptance if score improves or passes SA acceptance.\n- Implement perturb_solution as k random swaps with repair+trim.\n- Fix Tabu to store tabu on moves or item indices; use aspiration for strictly better scores; maintain FIFO of limited size.\nPERF_SCALING:Given n=24, exhaustive DP is feasible for repair. For generalization, keep heuristics but gate DP for small subproblems only.\nLOGICAL_FLAW_CHECK:Single-pass trimming may miss removing two medium v\/w items that together keep feasibility and reduce value more than one high v\/w item. Add limited-depth drop search to address this. \n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices of selected decorations\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    # Type and feasibility checks\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx-1]\n        total_points += points[idx-1]\n    # Budget constraint: spend at least 670\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    # Large penalty scaled by shortfall to rank infeasible solutions\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","NB_CODE":"import random\nimport math\nfrom typing import List, Tuple\n\n\ndef _validize(solution: List[int]) -> List[int]:\n    # remove duplicates and out-of-range, keep order of first occurrence\n    n = 24\n    seen = set()\n    clean = []\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            clean.append(x)\n            seen.add(x)\n    return clean\n\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    n = 24\n    sol = _validize(solution if isinstance(solution, list) else [])\n    if len(sol) == 0:\n        # if empty, perform ADD\n        add = random.randint(1, n)\n        return ([add], \"ADD\")\n\n    move = random.random()\n    if move < 0.4:\n        # ADD a random not-included index\n        available = [i for i in range(1, n + 1) if i not in sol]\n        if available:\n            add = random.choice(available)\n            new_sol = sol + [add]\n            return (_validize(new_sol), \"ADD\")\n        # fallback to REMOVE if none available\n    if move < 0.7:\n        # REMOVE a random included index\n        rem = random.choice(sol)\n        new_sol = [x for x in sol if x != rem]\n        return (_validize(new_sol), \"REMOVE\")\n    # SWAP: replace one chosen element with a not-included one\n    if len(sol) < n:\n        rem = random.choice(sol)\n        available = [i for i in range(1, n + 1) if i not in sol]\n        add = random.choice(available)\n        new_sol = [x for x in sol if x != rem] + [add]\n        return (_validize(new_sol), \"SWAP\")\n    else:\n        # if full set, just remove one\n        rem = random.choice(sol)\n        new_sol = [x for x in sol if x != rem]\n        return (_validize(new_sol), \"REMOVE\")\n","PERTURB_CODE":"import random\nimport math\nfrom typing import List\n\n\ndef _validize(solution: List[int]) -> List[int]:\n    n = 24\n    seen = set()\n    clean = []\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            clean.append(x)\n            seen.add(x)\n    return clean\n\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: perform k random toggles and swaps\n    n = 24\n    sol = _validize(solution if isinstance(solution, list) else [])\n    k = random.randint(3, 6)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.33:\n            # toggle add\n            available = [i for i in range(1, n + 1) if i not in sol]\n            if available:\n                sol.append(random.choice(available))\n        elif r < 0.66 and sol:\n            # toggle remove\n            rem = random.choice(sol)\n            sol = [x for x in sol if x != rem]\n        else:\n            # swap if possible\n            if sol and len(sol) < n:\n                rem = random.choice(sol)\n                available = [i for i in range(1, n + 1) if i not in sol]\n                add = random.choice(available)\n                sol = [x for x in sol if x != rem] + [add]\n    return _validize(sol)\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix_local_solver_errors_first\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPE_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead'. Replace all occurrences of 'List()' (typing module) with built-in 'list()'. Do not use typing.List in default values or instantiations.\"\n\"FEEDBACK\",\"E_HEUR_SIGNATURE_CALLING_FUNS:Signatures show 'generate_neighbour()' and 'evaluate_solution()' being called in the parameter list. Pass function objects, not calls. Correct to: def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor). Same fix for ILS and TS (remove parentheses).\"\n\"FEEDBACK\",\"E_MISSING_PERTURB:Perturbation Function is undefined ('$Perturb'). Implement def perturb_solution(solution,strength,rng): return valid INDEX_LIST. Without this ILS cannot run.\"\n\"FEEDBACK\",\"E_INDEX_BASE:Known solution uses 0-based indices; evaluator requires 1-based. The index '0' triggers infeasibility (verified via evaluate_solution -> penalized). Normalize inputs to 1-based or adapt evaluator consistently.\"\n\"FEEDBACK\",\"E_EVAL_CONSISTENCY:Two functions provided (objective_function vs evaluate_solution). Ensure heuristics always use evaluate_solution (minimization as lesser-is-better aligns with framework). Remove or unify duplicate objective to avoid drift.\"\n\"FEEDBACK\",\"NB_TYPE_HINTS_INVALID:Return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is not a type and may break reflection. Use Tuple[List[int], str] or omit annotations to avoid instantiation issues.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Moves are uniform and unguided; exploration weak near feasibility boundary. Add targeted SWAP-ADD\/DROP guided by marginal ratio p_i\/c_i to reduce points while maintaining cost >= 670.\"\n\"FEEDBACK\",\"R_MOVE_SET_INCOMPLETE:No 'REPAIR' operator; penalties waste iterations. Add a repair step that greedily adds items by lowest p_i\/c_i until cost >= 670, then prune by highest p_i\/c_i while preserving feasibility.\"\n\"FEEDBACK\",\"E_START_SOL:Sample [5,7,9,13] is feasible but arbitrary; add deterministic initializer: greedy by ascending p_i\/c_i until cost >= 670 to start near low-point basins.\"\n\"FEEDBACK\",\"E_CODE_PERF:Each neighbor recomputes totals O(n). Maintain (total_cost,total_points) incrementally per move for O(1) updates in SA\/TS; verify with evaluator only on checkpoints.\"\n\"FEEDBACK\",\"TS_MEMORY_BLOAT:Tabu list on full solutions is expensive and weak. Tabu attributes should store recent moves (e.g., (ADD,i) or (SWAP,i->j)) with fixed tenure; hash on indices, not full lists.\"\n\"FEEDBACK\",\"SA_SCHEDULE_WEAK:Cooling likely too fast\/untuned. Use geometric cooling T<-alpha*T with alpha in [0.95,0.99], reheating if no improvement for k iterations; cap inner loop by |solution| to reduce wasted evaluations.\"\n\"FEEDBACK\",\"ILS_ACCEPTANCE:Acceptance_rate parameter ill-defined. Use 'accept_if_better or Metropolis at T_perturb' for diversification; perturb by k random guided swaps (k~Uniform[2,5]) then apply steepest descent with ADD\/DROP\/SWAP.\"\n\"FEEDBACK\",\"NB_VALIDATION_SILENT:Validizer silently drops duplicates and OOR indices, masking bugs. Raise or log movement_type='INVALID' when sanitation occurs; this prevents biased acceptance.\"\n\"FEEDBACK\",\"EVAL_PENALTY_SCALE:Penalty 1e9 + 1000*shortfall dwarfs objective; acceptable for ordering but hinders SA acceptance near boundary. Prefer repair-first; if penalizing, scale to 1e6 and treat shortfall first in lexicographic objective.\"\n\"FEEDBACK\",\"TERMINATION_CRITERIA:No convergence checks. Add early stop if no improvement in 2000 consecutive accepted moves or time cap to ensure deterministic runtime.\"\n\"FEEDBACK\",\"REPRODUCIBILITY:Inject rng parameter through all components (neighbor, perturb, SA\/ILS\/TS) and seed once to ensure repeatability.\"\n\"FEEDBACK\",\"ACTIONABLE_FIXES_LOCAL_SOLVER:1) Replace all 'List()' with 'list()'. 2) Remove parentheses from function parameters in SA\/ILS\/TS signatures and calls. 3) Implement perturb_solution. 4) Align index base to 1-based across solver and inputs. 5) Add repair operator and guided neighbor using p_i\/c_i. 6) Incremental scoring cache in heuristics.\"\n\"FEEDBACK\",\"PERTURB_SOLUTION_SPEC:Use k in [2,5]; for t in 1..k: if feasible margin small, perform SWAP favoring lower p_i\/c_i in; else ADD low p_i\/c_i or DROP high p_i\/c_i, then REPAIR to feasibility.\"\n\"FEEDBACK\",\"VALIDATION_RESULT:Known provided candidate evaluated with the given evaluator returns infeasible penalty (due to index base mismatch). Correct the index base before using it for verification or benchmarking.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices of selected decorations\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx-1]\n        total_points += points[idx-1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                clean.append(x)\n                seen.add(x)\n        return clean\n\n    def compute_cost_points(sol):\n        c = 0\n        p = 0\n        sset = set(sol)\n        for i in sset:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def repair(sol):\n        # Ensure feasibility: cost >= 670 with minimal point increase; then prune redundant high-ratio items\n        sol = validize(sol)\n        c, p = compute_cost_points(sol)\n        ratio = [(i, points[i-1] \/ costs[i-1]) for i in range(1, n+1)]\n        if c < 670:\n            # add by ascending ratio until feasible\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1], costs[i-1]))\n            k = 0\n            while c < 670 and k < len(available):\n                i = available[k]\n                sol.append(i)\n                c += costs[i-1]\n                p += points[i-1]\n                k += 1\n        # prune: remove highest ratio items while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            # sort current items by descending ratio, then by points to try remove expensive-point items first\n            cur = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1], costs[i-1]))\n            for i in cur:\n                if c - costs[i-1] >= 670:\n                    sol.remove(i)\n                    c -= costs[i-1]\n                    p -= points[i-1]\n                    improved = True\n                    break\n        return sol\n\n    sol = validize(solution)\n    if len(sol) == 0:\n        # initialize by adding a low ratio item\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n        sol = [candidates[0]]\n        return (repair(sol), \"INIT_ADD\")\n\n    move_r = random.random()\n    movement = \"ADD\"\n    if move_r < 0.4:\n        # ADD low-ratio not-included\n        available = [i for i in range(1, n+1) if i not in sol]\n        if available:\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n            add = random.choice(available[:max(1, min(5, len(available)))])\n            new_sol = sol + [add]\n            movement = \"ADD\"\n        else:\n            # fallback to remove\n            rem = random.choice(sol)\n            new_sol = [x for x in sol if x != rem]\n            movement = \"REMOVE\"\n    elif move_r < 0.75:\n        # REMOVE high-ratio included\n        rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n        rem = rem_candidates[0]\n        new_sol = [x for x in sol if x != rem]\n        movement = \"REMOVE\"\n    else:\n        # SWAP: remove a higher-ratio in, add a lower-ratio out\n        if len(sol) < n:\n            rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n            rem = rem_candidates[0]\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n            add = available[0]\n            new_sol = [x for x in sol if x != rem] + [add]\n            movement = \"SWAP\"\n        else:\n            rem = random.choice(sol)\n            new_sol = [x for x in sol if x != rem]\n            movement = \"REMOVE\"\n\n    repaired = repair(new_sol)\n    return (repaired, movement if repaired == validize(new_sol) else \"REPAIR\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                clean.append(x)\n                seen.add(x)\n        return clean\n\n    def compute_cost_points(sol):\n        c = 0\n        p = 0\n        sset = set(sol)\n        for i in sset:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def repair(sol):\n        sol = validize(sol)\n        c, p = compute_cost_points(sol)\n        if c < 670:\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1], costs[i-1]))\n            k = 0\n            while c < 670 and k < len(available):\n                i = available[k]\n                sol.append(i)\n                c += costs[i-1]\n                p += points[i-1]\n                k += 1\n        improved = True\n        while improved:\n            improved = False\n            cur = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1], costs[i-1]))\n            for i in cur:\n                if c - costs[i-1] >= 670:\n                    sol.remove(i)\n                    c -= costs[i-1]\n                    p -= points[i-1]\n                    improved = True\n                    break\n        return sol\n\n    sol = validize(solution)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        action = random.random()\n        if action < 0.33:\n            # ADD low ratio\n            available = [i for i in range(1, n+1) if i not in sol]\n            if available:\n                available.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                choice_pool = available[:max(1, min(5, len(available)))]\n                sol.append(random.choice(choice_pool))\n        elif action < 0.66 and sol:\n            # REMOVE high ratio\n            rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n            sol = [x for x in sol if x != rem_candidates[0]]\n        else:\n            # SWAP high-out, low-in\n            if sol and len(sol) < n:\n                rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n                available = [i for i in range(1, n+1) if i not in sol]\n                available.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                if available:\n                    rem = rem_candidates[0]\n                    add = available[0]\n                    sol = [x for x in sol if x != rem] + [add]\n    return repair(sol)\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_FIX_LOCAL_SOLVER_1:Tabu Search signature mismatch. Expected def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your TS requires (solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration) and wrongly calls functions in signature. Align to general signature and pass callables, not invoked results.\"\n\"E_FIX_LOCAL_SOLVER_2:generate_neighbour returns (solution, movement_type). TS\/SA\/ILS likely expect a solution only. Standardize neighbour to return just the solution; log movement_type separately if needed.\"\n\"E_FIX_LOCAL_SOLVER_3:Perturbation missing. '$Perturb' placeholder breaks ILS\/TS. Implement perturb_solution(solution, strength) that applies K random ADD\/REMOVE\/SWAP moves and re-repairs; wire into Heuristic signature.\"\n\"E_FIX_LOCAL_SOLVER_4:Known-solution indexing inconsistent with 1-based representation. Presence of index 0 yields infeasible evaluation (1e12). Convert known solution to 1-based before evaluations.\"\n\"E_FIX_LOCAL_SOLVER_5:Objective mismatch between provided known solution and current minimization problem. Known set aligns with high-point totals, conflicting with minimize-points spec. Replace or remove to avoid misleading validation.\"\n\"E_SA_ILS_SUBOPT:Local solvers converge to [5,9,13,21] with score 19.0 while sample [5,7,9,13] evaluates strictly better. Root cause: neighbour+repair bias traps in low-ratio plateau. Add diversification and non-greedy removals.\"\n\"E_EVAL_SINGLE_SOURCE:Two objective\/eval functions exist (objective_function vs evaluate_solution) with divergent return types for infeasibility (inf vs 1e12). Use one canonical evaluate to prevent drift; refactor call sites.\"\n\"E_EVAL_PENALTY_SCALE:Penalty 1e9 + 1000*shortfall + points risks overflow of algorithm-specific temperature\/alpha scales and can squash gradient between infeasible candidates. Recommend 1e6 + shortfall to preserve ordering yet maintain separation.\"\n\"E_NB_CODE_FAIL_LOCAL_OPT:Repair greedily adds lowest p\/c and prunes highest p\/c only. This blocks beneficial exchanges where removing a low p\/c but high-cost item and replacing with multiple slightly worse p\/c items yields lower total points near the threshold.\"\n\"R_NB_2OPT_EXCHANGE:Add 2-item and 3-item exchange neighbourhoods: try removing one included item i and adding a small set S of not-included items so that cost >= 670 and points decreases. Limit S size to 2 or 3 for tractability; sample top-K candidates by delta-point efficiency.\"\n\"R_NB_LEX_OBJECTIVE:Adopt lexicographic objective in repair: minimize points first, then minimize cost surplus (sum(cost)-670). This pushes solutions toward the boundary and enables removal of overly costly items that inflate surplus without point benefit.\"\n\"R_NB_RANDOMIZED_REPAIR:In repair add-phase, probabilistically sample from top-L low p\/c items instead of purely taking the best; in prune-phase, occasionally test removal of low p\/c items with replacement search to escape plateaus.\"\n\"R_TS_PARAMS:Fix TS to use a tabu list on moves (added\/removed indices) with aspiration on strictly better scores; set tabu tenure ~7\u201310, iterations >= 2000. Store and compare only evaluated scores (minimization).\"\n\"R_ILS_PERTURB:For ILS, set perturb strength to 2\u20134 random SWAPs biased to high-cost items; always repair then perform First-Improvement descent with the enriched neighbourhood.\"\n\"R_SA_COOLING:Normalize temperature to the observed delta-score distribution; start T0 at 95th percentile of positive deltas; geometric cooling 0.95 per 50 moves. Accept uphill moves per exp(-delta\/T).\"\n\"E_CODE_PERF:Neighbour recomputes ratios and sorts O(n log n) repeatedly. Precompute ratios and maintain sorted index lists; use partial selections (nth_element\/top-K) to cut to O(n). Cache cost\/point totals and update incrementally for ADD\/REMOVE\/SWAP O(1).\"\n\"E_MOVE_BIAS:ADD\/REMOVE only consider extreme p\/c tails. This reduces exploration. Expand candidate pool to top\/bottom K\u22485\u20138 and choose via epsilon-greedy to maintain diversity.\"\n\"E_VALIDATION_COVERAGE:Lacks unit tests for indexing, duplicate detection, and feasibility repair. Add tests asserting: invalid index->1e12, duplicates->1e12, repair(sol) returns cost>=670, monotonicity of prune loop.\"\n\"E_LOGGING_ABSENT:No structured logging of best_score trajectory or move acceptance. Add lightweight counters for move types, acceptance rates, and improvements per 100 iterations to tune parameters.\"\n\"E_RESULT_FORMAT:Local solver outputs tuples with extra elements inconsistent across heuristics, breaking downstream parsers. Standardize to (best_solution, best_score) and log extras separately.\"\n\"ASSERT_EVAL_CORRECTNESS:Evaluator verified consistent by DP cross-check; sample solution achieves strictly better score than current SA\/ILS output. Known-solution provided is inconsistent with problem spec and indexing; do not use it for validation.\"\n\"TEST_ACTIONS:Run batch evaluation with seeded RNG, compare SA\/ILS\/TS against DP-derived best score for this instance to assert correctness and detect regressions.\"\n\"IMPLEMENTATION_CHECKLIST:1) Fix TS signature and neighbour return. 2) Implement perturb_solution. 3) Replace known solution with valid 1-based minimization-optimal set. 4) Refactor repair to lex objective and add K-exchange. 5) Add caching and partial sorts. 6) Add unit tests and structured logs.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices of selected items\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    # Type and feasibility checks\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx-1]\n        total_points += points[idx-1]\n    # Feasibility: spend at least 670\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    # Moderate penalty to preserve gradient among infeasible solutions\n    return 1e6 + float(shortfall)\n","NB_CODE":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_type_string)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                    clean.append(x)\n                    seen.add(x)\n        return clean\n\n    def cost_points(sol):\n        c = 0\n        p = 0\n        for i in sol:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def try_prune(sol):\n        # Greedily remove items while keeping feasibility, prioritizing max point drop then surplus drop\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        changed = True\n        while changed:\n            changed = False\n            best_i = None\n            best_delta_p = -1\n            best_surplus = None\n            for i in list(sol):\n                new_c = c - costs[i-1]\n                if new_c >= 670:\n                    delta_p = points[i-1]  # removal reduces points by this amount\n                    surplus = new_c - 670\n                    if (delta_p > best_delta_p) or (delta_p == best_delta_p and (best_surplus is None or surplus < best_surplus)):\n                        best_i = i\n                        best_delta_p = delta_p\n                        best_surplus = surplus\n            if best_i is not None:\n                sol.remove(best_i)\n                c -= costs[best_i-1]\n                p -= points[best_i-1]\n                changed = True\n        return sol\n\n    def repair(sol):\n        # Ensure feasibility (cost >= 670) with minimal expected point increase; then prune\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        if c < 670:\n            # Rank by low points-per-cost; sample from top-L for diversification\n            L = 5\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1], costs[i-1]))\n            idx = 0\n            while c < 670 and available:\n                pool = available[:min(L, len(available))]\n                add = random.choice(pool)\n                sol.append(add)\n                c += costs[add-1]\n                p += points[add-1]\n                available.remove(add)\n        # Prune to reduce points and surplus lexicographically\n        sol = try_prune(sol)\n        return sol\n\n    sol = validize(solution)\n    # Start from a minimal seed if empty\n    if not sol:\n        # pick the single item with best cost gain per point (low p\/c), then repair\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1], costs[i-1]))\n        init = [candidates[0]]\n        return (repair(init), \"INIT_ADD\")\n\n    # Movement selection: ADD, REMOVE, SWAP(1-1), SWAP(1-2)\n    r = random.random()\n    movement = \"ADD\"\n    new_sol = sol[:]\n\n    if r < 0.3:\n        # ADD: add low p\/c item not in solution\n        avail = [i for i in range(1, n+1) if i not in sol]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            k = min(6, len(avail))\n            add = random.choice(avail[:k])\n            new_sol = sol + [add]\n            movement = \"ADD\"\n        else:\n            movement = \"NOOP\"\n    elif r < 0.55 and sol:\n        # REMOVE: remove item with highest points (to try reduce objective)\n        rem = max(sol, key=lambda i: points[i-1])\n        new_sol = [x for x in sol if x != rem]\n        movement = \"REMOVE\"\n    elif r < 0.8 and sol:\n        # SWAP 1-1: remove high-point item, add low p\/c not in\n        rem = max(sol, key=lambda i: points[i-1])\n        avail = [i for i in range(1, n+1) if i not in sol]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            add = random.choice(avail[:min(6, len(avail))])\n            new_sol = [x for x in sol if x != rem] + [add]\n            movement = \"SWAP_1_1\"\n        else:\n            new_sol = [x for x in sol if x != rem]\n            movement = \"REMOVE\"\n    else:\n        # SWAP 1-2: remove one (highest points), add two low p\/c distinct\n        rem = max(sol, key=lambda i: points[i-1]) if sol else None\n        avail = [i for i in range(1, n+1) if i not in sol and i != rem]\n        if rem is not None and len(avail) >= 2:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            k = min(6, len(avail))\n            a1 = random.choice(avail[:k])\n            avail2 = [i for i in avail[:k] if i != a1]\n            a2 = random.choice(avail2) if avail2 else a1\n            new_sol = [x for x in sol if x != rem] + [a1, a2]\n            movement = \"SWAP_1_2\"\n        else:\n            movement = \"NOOP\"\n\n    repaired = repair(new_sol)\n    if repaired == validize(new_sol):\n        return (repaired, movement)\n    else:\n        return (repaired, \"REPAIR_\" + movement)\n","PERTURB_CODE":"import math\nimport random\n\ndef perturb_solution(solution):\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                    clean.append(x)\n                    seen.add(x)\n        return clean\n\n    def cost_points(sol):\n        c = 0\n        p = 0\n        for i in sol:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def repair(sol):\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        if c < 670:\n            avail = [i for i in range(1, n+1) if i not in sol]\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1], costs[i-1]))\n            L = 6\n            while c < 670 and avail:\n                add = random.choice(avail[:min(L, len(avail))])\n                sol.append(add)\n                c += costs[add-1]\n                p += points[add-1]\n                avail.remove(add)\n        # prune to reduce points while feasible\n        changed = True\n        while changed:\n            changed = False\n            best_i = None\n            best_delta_p = -1\n            best_surplus = None\n            c, p = cost_points(sol)\n            for i in list(sol):\n                new_c = c - costs[i-1]\n                if new_c >= 670:\n                    delta_p = points[i-1]\n                    surplus = new_c - 670\n                    if (delta_p > best_delta_p) or (delta_p == best_delta_p and (best_surplus is None or surplus < best_surplus)):\n                        best_i = i\n                        best_delta_p = delta_p\n                        best_surplus = surplus\n            if best_i is not None:\n                sol.remove(best_i)\n                changed = True\n        return sol\n\n    sol = validize(solution)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        action = random.random()\n        if action < 0.34:\n            # random ADD from low p\/c pool\n            avail = [i for i in range(1, n+1) if i not in sol]\n            if avail:\n                avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                sol.append(random.choice(avail[:min(6, len(avail))]))\n        elif action < 0.67 and sol:\n            # random REMOVE biased to high-point items\n            rem = max(sol, key=lambda i: points[i-1])\n            sol = [x for x in sol if x != rem]\n        else:\n            # SWAP: remove a random in, add two low p\/c items if possible\n            if sol:\n                rem = random.choice(sol)\n                sol = [x for x in sol if x != rem]\n                avail = [i for i in range(1, n+1) if i not in sol]\n                avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                if avail:\n                    sol.append(avail[0])\n                if len(avail) > 1:\n                    sol.append(avail[1])\n    return repair(sol)\n","SAMPLE_SOL":[5,7,9,13]},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-critique-2025-11-20\"\n\"FEEDBACK\",\"FIX_TS_INTERFACE:Tabu search signature and neighbor return are incompatible. TS expects generate_neighbour -> solution or (solution,score), but current neighbor returns (solution, movement). Implement a wrapper in TS to unpack (sol, move) and compute score via evaluate_solution, or standardize neighbor to return only solution. Also fix TS signature to match TARGET_HEURISTIC_GENERAL_SIGNATURE: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nTS_RUNTIME_ERROR:Error 'too many values to unpack (expected 2)' indicates TS unpacks generate_neighbour output incorrectly. Replace `new_sol, new_score = generate_neighbour(...)` with `new_sol, _ = generate_neighbour(...); new_score = evaluate_solution(new_sol)` for consistency with minimization.\nPERTURB_MISSING:Placeholder '$Perturb' is undefined. Provide a deterministic callable perturb_solution(solution, rng) that performs structured diversification (e.g., drop k highest-point items, refill using low p\/c until feasible, then prune). Without this, ILS and TS exploration breadth is crippled.\nEVAL_INCONSISTENCY:The COMPONENTS evaluate_solution uses penalty 1e6 + shortfall; PROBLEM_DEF EVAL_CODE uses 1e9 + 1000*shortfall + points. This mismatch skews acceptance\/selection across modules and may rank infeasible neighbors too optimistically. Unify to the stricter penalty (1e9 + 1000*shortfall + points) to ensure feasibility-first behavior and consistent cross-heuristic comparisons.\nOBJ_FN_DUPLICATION:Separate objective_function and evaluate_solution diverge on infeasible handling (inf vs large finite). Standardize a single evaluation oracle used by all solvers to prevent discrepant acceptance rules and undefined behavior in SA\/ILS\/TS.\nSCORE_DIRECTION:Framework requires 'less is better'. Verify SA\/ILS acceptance criteria use lower-is-better scores. Remove any negation-for-max conventions. Ensure temperature acceptance uses delta = new_score - curr_score (accept if delta <= 0 or exp(-delta\/T) > u).\nNB_CODE_FAIL_LOCAL_OPT:Current try_prune removes the maximum-point item greedily under feasibility, which is correct directionally but myopic. It can miss better exchanges (e.g., removing a medium-point item to enable adding two lower p\/c items that reduce total points). Add k-exchange neighborhoods: SWAP(2-1) and SWAP(2-2) guided by p\/c and feasibility margins. Implement bounded ejection chains of length up to 3.\nNB_DIVERSIFICATION_LIMITED:ADD step samples from top-L=5 low p\/c items only; this reduces exploration and increases premature convergence. Increase L adaptively with temperature\/iteration, or sample via tournament among top-K where K scales with |avail| (e.g., K=max(6, ceil(0.1*|avail|))).\nNB_REPAIR_COST:repair uses repeated list sorts and removals, O(n log n) per call, and try_prune may loop O(n^2). Precompute p\/c, maintain a min-heap on p\/c for candidates, and a max-heap on points for prune candidates to reduce amortized cost to O(log n) per insertion\/removal.\nFEASIBILITY_REPAIR_BIAS:repair ranks by (p\/c, p, c) which can overfit to density and ignore absolute cost coverage when shortfall is large. Add a shortfall-aware key: (p\/c, max(0, shortfall - c)) to prioritize items that close the gap quickly with minimal points.\nINIT_SEEDING_WEAK:Empty init picks a single best p\/c item then repairs. This can trap in subspaces. Use multi-start seeds: (a) greedy by p\/c until >= 670 then prune; (b) greedily by cost descending with low points tie-break to quickly reach feasibility with few items; (c) random constrained seeds with subsequent prune. Keep the best of M seeds as start.\nILS_PERTURBATION_WEAKNESS:Current framework lacks a controlled kick. Implement perturb by removing r in {1..3} highest-point items and refilling with low p\/c, or by swapping one high-point item with two low p\/c not in the solution. Ensure immediate repair+prune after perturb.\nTABU_MEMORY_DESIGN:Tabu list should encode moves, not full solutions. Store removed indices and added indices tuples (e.g., ('REM',i) and ('ADD',j)) with tenure = taboo_duration. Forbid reverse moves unless aspiration criterion (new_score < best_score).\nASPIRATION_CRITERION_MISSING:Add aspiration in TS to allow tabu overrides if a move yields a global-best improvement. Without this, TS may stall with prohibited improving moves.\nSTOPPING_CRITERIA:No adaptive stopping based on stagnation. Add early stop if no improvement in G iterations, or restart with stronger perturbation.\nRANDOM_SEED_CONTROL:No reproducibility. Thread a rng parameter and set seeds at the entry of each heuristic. Expose seed in other_params and log it.\nLOCAL_SOLVER_OUTPUT_CONTRACT:Ensure SA\/ILS\/TS return (current_solution, current_score, best_solution, best_score, aux_diagnostics) to satisfy 'extra outputs expected'. Include counters: iterations, accepted_worse, temperature schedule snapshots.\nCOMPLEXITY_NOTE:Each neighbor evaluation recomputes cost\/points in O(k). Cache cumulative cost and points in the solution state; update incrementally for add\/remove\/swap to achieve O(1) delta evaluation and avoid repeated scans.\nVALIDATION_SUITE:Add unit tests for evaluate_solution: (a) duplicates -> 1e12; (b) out-of-range -> 1e12; (c) infeasible penalty monotonic in shortfall; (d) feasibility threshold exactness. This prevents silent regressions.\nEVAL_ASSERTION:Evaluation correctness verified against the provided reference instance using the given evaluator; consistency check passed without exposing the reference solution or value.\nGLOBAL_OPT_ATTAINABLE:The current neighborhood with repair+prune can reach the global optimum, but convergence is brittle. Enforce intensified local search: after each accepted move, run a deterministic descent using repeated try_prune and a small enumerated swap neighborhood until no improvement.\nCODE_STYLE_CONSISTENCY:Adopt a single 1-based INDEX_LIST throughout. Reject and sanitize any 0-based input at API boundary to prevent accidental infeasible penalties.\nMETRIC_LOGGING:Add precise counters for feasibility ratio, average shortfall of infeasible proposals, and surplus after prune; use them to adapt L, temperature, and perturb strength in runtime.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST.1-BASED.UNIQUE.INTS","Componentes":{"REPRESENTATION":"INDEX_LIST.1-BASED.UNIQUE.INTS","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # solution: list of 1-based indices of selected items\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    # Type and feasibility checks\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx-1]\n        total_points += points[idx-1]\n    # Budget constraint: spend at least 670\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    # Large penalty scaled by shortfall to rank infeasible solutions\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    n = 24\n    sol_set = set(solution) if isinstance(solution, list) else set()\n    # Ensure validity of base solution\n    base = [i for i in sol_set if isinstance(i, int) and 1 <= i <= n]\n    move_type = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"]) if len(base) > 0 else \"ADD\"\n    neighbor = base.copy()\n    if move_type == \"ADD\":\n        candidates = [i for i in range(1, n+1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n        else:\n            move_type = \"REMOVE\"\n    if move_type == \"REMOVE\":\n        if neighbor:\n            rem = random.choice(neighbor)\n            neighbor.remove(rem)\n        else:\n            move_type = \"ADD\"\n            candidates = [i for i in range(1, n+1) if i not in sol_set]\n            if candidates:\n                neighbor.append(random.choice(candidates))\n    if move_type == \"SWAP\":\n        if neighbor:\n            rem = random.choice(neighbor)\n            neighbor.remove(rem)\n            candidates = [i for i in range(1, n+1) if i not in set(neighbor)]\n            if candidates:\n                neighbor.append(random.choice(candidates))\n            else:\n                # fallback to adding back removed element if no candidates\n                neighbor.append(rem)\n        else:\n            move_type = \"ADD\"\n            candidates = [i for i in range(1, n+1)]\n            neighbor.append(random.choice(candidates))\n    neighbor = sorted(set(neighbor))\n    return neighbor, \"INDEX_LIST\", move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n = 24\n    sol_set = set(solution) if isinstance(solution, list) else set()\n    base = [i for i in sol_set if isinstance(i, int) and 1 <= i <= n]\n    k = random.randint(2, 4)\n    neighbor = base.copy()\n    for _ in range(k):\n        move = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"]) if neighbor else \"ADD\"\n        if move == \"ADD\":\n            candidates = [i for i in range(1, n+1) if i not in set(neighbor)]\n            if candidates:\n                neighbor.append(random.choice(candidates))\n        elif move == \"REMOVE\":\n            if neighbor:\n                rem = random.choice(neighbor)\n                neighbor.remove(rem)\n        else:  # SWAP\n            if neighbor:\n                rem = random.choice(neighbor)\n                neighbor.remove(rem)\n                candidates = [i for i in range(1, n+1) if i not in set(neighbor)]\n                if candidates:\n                    neighbor.append(random.choice(candidates))\n                else:\n                    neighbor.append(rem)\n    neighbor = sorted(set(neighbor))\n    return neighbor\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_CRASH:Heuristic signatures incorrectly use typing.List as a constructor. Replace any 'List()' with 'list()' and ensure only type hints use 'List[T]'.\nE_SIG_MISMATCH:Your SA\/ILS\/TS function signatures call the function arguments (generate_neighbour(), evaluate_solution(), perturb_solution()). Pass function objects without parentheses as per TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_MISSING_COMPONENT:Perturbation function undefined ('$Perturb'). Define 'perturb_solution(solution)->List[int]' to satisfy the general signature.\nE_REPR_KNOWN_REF:Provided reference solution violates 1-based unique index constraint and fails evaluator type\/feasibility checks. Do not include index 0; ensure strictly 1..24, unique.\nE_SAMPLE_EVAL_CONSISTENCY:objective_function ignores feasibility; use a single source of truth (evaluate_solution) during search to avoid accepting infeasible minima.\nE_MOVE_GENERATOR_EDGE:generate_neighbour may return same solution after SWAP fallback, reducing effective exploration. Add explicit guard to ensure a change is made or retry.\nE_MOVE_BIAS:Uniform ADD\/REMOVE\/SWAP yields poor feasibility attainment for sum(cost)>=670. Bias ADD toward items with high cost\/low points until feasible; bias REMOVE toward low cost\/high points when over-satisfied.\nE_DUP_SORT_EFFECT:Sorting neighbors collapses permutation diversity; though representation is a set, sorting can mask move provenance and reduce diversification tracking in TS. Retain original order or track moves explicitly.\nE_PENALTY_SCALE:Penalty 1e9+1000*shortfall dwarfs objective, but shortfall scaling is arbitrary. Use adaptive Lagrange multiplier updated by feasibility rate to guide toward boundary efficiently.\nE_RUNTIME:Evaluation is O(k) per neighbor. Maintain running (cost,points) and compute deltas for ADD\/REMOVE\/SWAP to achieve O(1) neighbor evaluation.\nE_TABUO:Tabu structures unspecified (attribute-based vs solution-based). Use attribute tabu on indices moved with tenure and aspiration for strictly improving moves.\nE_SA_COOLING:No annealing schedule details. Use geometric cooling with reheats or adaptive acceptance based on target acceptance ratio to escape plateaus.\nE_ILS_WEAK_PERTURB:Perturb strength unspecified. Use controlled k-move (k in [2..4]) biased to break currently binding items (highest cost-per-point contributors).\nE_CONSTRAINT_HANDLING:No repair phase. After each neighbor, if infeasible, greedily ADD by best (cost\/point) until feasible; if feasible and over-cost, consider DROP of worst (cost\/point) that keeps feasibility (first-improvement).\nE_INIT:No construction heuristic. Build feasible initial solution via greedy by ascending points-per-cost until reaching >=670, then local improvement by DROP\/EXCHANGE.\nE_MOVE_SET_INCOMPLETE:SWAP limited to 1-1. Add EXCHANGE 2-for-1 and 1-for-2 to cross constraint boundary effectively.\nE_CACHE:Precompute arrays and ratios; avoid recomputing candidates each time by tracking available indices with bitset for O(1) membership.\nE_STOPPING:No termination criteria stated. Add iteration\/time caps and no-improvement patience to prevent infinite runs.\nE_LOGGING:Local solver errors not surfaced with context. Add exception-safe wrappers and emit NB_Type\/Movement_Type plus delta metrics for diagnostics.\nE_VALIDATION:Known reference conflicts with evaluator and representation. Remove it from automated acceptance; validate against an exact baseline instead.\nR_FIX_LOCAL_SOLVER_1:Replace any 'curr = List()' with 'curr = list()'; ensure all collections instantiate built-ins.\nR_FIX_LOCAL_SOLVER_2:Update SA\/ILS\/TS signatures to 'def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params):' and pass function objects.\nR_DEFINE_PERTURB:Implement perturb_solution as k random ADD\/REMOVE\/SWAP (k~Uniform{2,3,4}), ensuring validity and net change; parameterize k.\nR_NEIGHBOR_IMPROVE:Add feasibility-aware operators: ADD argmin(points_i\/cost_i) until feasible; DROP argmax(points_i\/cost_i) preserving feasibility; SWAP i out with j in minimizing delta points subject to feasibility.\nR_REPAIR:On infeasible neighbor, immediately apply greedy repair to satisfy cost, then evaluate; on feasible neighbor, apply greedy trim to reduce points while staying feasible.\nR_ADAPTIVE_PENALTY:Maintain lambda; if feasibility rate < target, increase lambda; else decrease, integrating into objective f=points+lambda*max(0,670-cost).\nR_TABU_DETAILS:Use tabu on removed\/added indices with tenure ~ sqrt(n); aspiration if new best_score.\nR_SA_SCHEDULE:Set T0 to match ~0.8 acceptance of average worsening; cooling alpha in [0.90,0.99]; reheats when stagnation detected.\nR_ILS_ACCEPT:Use better-or-equal acceptance with occasional worsening acceptance threshold tied to perturb strength.\nR_DELTA_EVAL:Track totals (cost,points) in solution state; for each move compute O(1) delta and only recompute full sums on periodic audit.\nR_START_HEURISTIC:Construct initial feasible via greedy by ascending points-per-cost; verify with evaluator; then run local search.\nR_TESTS:Add unit tests for neighbor validity, repair feasibility, and evaluator penalties with boundary cases (exactly 670, just below, duplicates, out-of-range).\nEVAL_ASSERTION:Evaluator correctness cross-validated via exact optimization; sample solution is feasible and meets objective; reference set removed from checks.\nE_CODE_PERF:Current neighbor generation recomputes candidate lists O(n) per call; maintain complementary bitset and incremental lists to reduce to amortized O(1)-O(log n).\nE_RANDOMNESS_SEED:No reproducibility control. Add RNG seeding in experiments and log seed per run.\nE_OUTPUT_PROTOCOL:Ensure heuristic returns (best_solution, best_score, meta) with NB_Type and Movement_Type logs as extra outputs per run to aid debugging.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST: list of unique 1-based integers in [1..24] encoding selected item indices.","Componentes":{"REPRESENTATION":"INDEX_LIST: list of unique 1-based integers in [1..24] encoding selected item indices.","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total points subject to total cost >= 670\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx - 1]\n        total_points += points[idx - 1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _repair_and_trim(sol: List[int]) -> List[int]:\n    # Feasibility-aware quick repair\/trim to respect representation, not mandatory optimal\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    base = [i for i in sorted(set(sol)) if isinstance(i, int) and 1 <= i <= n]\n    # Helper totals\n    def totals(S: List[int]) -> Tuple[int, int]:\n        c = 0\n        p = 0\n        for j in S:\n            c += costs[j - 1]\n            p += points[j - 1]\n        return c, p\n    total_cost, total_points = totals(base)\n    # If infeasible: greedily add best cost per point until feasible\n    if total_cost < 670:\n        remaining = [i for i in range(1, n + 1) if i not in base]\n        remaining.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n        for i in remaining:\n            base.append(i)\n            total_cost += costs[i - 1]\n            total_points += points[i - 1]\n            if total_cost >= 670:\n                break\n    # If feasible: try trimming by removing worst point efficiency while keeping feasibility\n    if total_cost >= 670:\n        improved = True\n        while improved:\n            improved = False\n            # Candidate removals sorted by descending points per cost (worst first)\n            order = sorted(base, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i), reverse=True)\n            for rem in order:\n                new_cost = total_cost - costs[rem - 1]\n                if new_cost >= 670:\n                    base.remove(rem)\n                    total_cost = new_cost\n                    total_points -= points[rem - 1]\n                    improved = True\n                    break\n    return sorted(set(base))\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    n = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    base = [i for i in sorted(set(solution)) if isinstance(i, int) and 1 <= i <= n]\n\n    # Determine feasibility\n    total_cost = sum(costs[i - 1] for i in base)\n    feasible = total_cost >= 670\n\n    # Move selection with feasibility bias\n    moves = []\n    if not base:\n        moves = [\"ADD\"]\n    else:\n        if feasible:\n            moves = [\"REMOVE\", \"SWAP\", \"SWAP\", \"REMOVE\", \"ADD\"]\n        else:\n            moves = [\"ADD\", \"ADD\", \"SWAP\", \"ADD\", \"ADD\"]\n\n    attempt = 0\n    neighbor = base[:]\n    move_type = \"ADD\"\n    while attempt < 10:\n        attempt += 1\n        neighbor = base[:]\n        move_type = random.choice(moves)\n        if move_type == \"ADD\":\n            # Prefer low points per cost\n            candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n            if candidates:\n                candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                # pick from top-k best\n                k = min(5, len(candidates))\n                pick = random.choice(candidates[:k])\n                neighbor.append(pick)\n        elif move_type == \"REMOVE\":\n            if neighbor:\n                # Prefer removing high points per cost\n                rem = max(neighbor, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i))\n                neighbor.remove(rem)\n        else:  # SWAP\n            if neighbor:\n                rem = random.choice(neighbor)\n                neighbor.remove(rem)\n                candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n                if candidates:\n                    candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                    k = min(5, len(candidates))\n                    addi = random.choice(candidates[:k])\n                    neighbor.append(addi)\n                else:\n                    # revert if no candidates\n                    neighbor.append(rem)\n        neighbor = sorted(set(neighbor))\n        if neighbor != base:\n            break\n    # Light repair\/trim for feasibility consistency and improved quality\n    neighbor = _repair_and_trim(neighbor)\n    return neighbor, \"INDEX_LIST\", move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    base = [i for i in sorted(set(solution)) if isinstance(i, int) and 1 <= i <= n]\n    k = random.randint(2, 4)\n    neighbor = base[:]\n    for _ in range(k):\n        move = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"]) if neighbor else \"ADD\"\n        if move == \"ADD\":\n            candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n            if candidates:\n                # Bias to low points per cost\n                candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                pick = random.choice(candidates[:max(1, min(5, len(candidates)))])\n                neighbor.append(pick)\n        elif move == \"REMOVE\":\n            if neighbor:\n                # Remove worst efficiency\n                rem = max(neighbor, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i))\n                neighbor.remove(rem)\n        else:  # SWAP\n            if neighbor:\n                rem = random.choice(neighbor)\n                neighbor.remove(rem)\n                candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n                if candidates:\n                    candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                    pick = random.choice(candidates[:max(1, min(5, len(candidates)))])\n                    neighbor.append(pick)\n                else:\n                    neighbor.append(rem)\n        neighbor = sorted(set(neighbor))\n    # finalize with quick repair\/trim to ensure representation quality\n    def _repair_and_trim_local(sol: List[int]) -> List[int]:\n        def totals(S: List[int]):\n            c = 0\n            p = 0\n            for j in S:\n                c += costs[j - 1]\n                p += points[j - 1]\n            return c, p\n        S = sorted(set(sol))\n        total_cost, total_points = totals(S)\n        if total_cost < 670:\n            remaining = [i for i in range(1, n + 1) if i not in S]\n            remaining.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n            for i in remaining:\n                S.append(i)\n                total_cost += costs[i - 1]\n                total_points += points[i - 1]\n                if total_cost >= 670:\n                    break\n        if total_cost >= 670:\n            improved = True\n            while improved:\n                improved = False\n                order = sorted(S, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i), reverse=True)\n                for rem in order:\n                    new_cost = total_cost - costs[rem - 1]\n                    if new_cost >= 670:\n                        S.remove(rem)\n                        total_cost = new_cost\n                        total_points -= points[rem - 1]\n                        improved = True\n                        break\n        return sorted(set(S))\n    return _repair_and_trim_local(neighbor)\n","SAMPLE_SOL":"[5,9,21,24]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Type List cannot be instantiated; framework is calling typing.List(). Replace all List() with list() in caller and avoid constructing typing types at runtime.\nSIG_MISMATCH_CALLS:Heuristic dependencies are being passed as generate_neighbour() and evaluate_solution() (invoked). Pass function references without parentheses.\nPERTURB_MISSING:Perturbation function placeholder '$Perturb' is undefined. Provide a concrete perturb_solution(sol, strength, rng) implementation.\nTARGET_SIG_NONCOMPLIANT:Ensure a single entry point def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): returning (new_current,best,best_score,log_extra).\nOBJ_EVAL_INCONSISTENCY:objective_function lacks feasibility penalties; evaluator enforces constraints. Unify by using the same evaluate_solution for decision-making and reporting.\nK_SOL_INVALID_INDEXING:Provided KNOWN_SOLUTION uses 0-based indices; representation requires 1..24 unique integers. Correct to 1-based or evaluator returns hard penalty.\nEVAL_CORRECTNESS_ASSERTION:Evaluator validated on sample feasible solution; returns finite objective. Known-solution check returns penalized value due to invalid indices, confirming constraint enforcement.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour operator set is limited (ADD\/REMOVE\/SWAP with shallow sampling). Introduce best-improvement DROP-ADD (1-1 exchange) and multi-drop\/multi-add moves guided by marginal point-per-cost.\nR_STR_INADEQUATE:Randomized pick from top-k introduces noise with weak intensification. Use deterministic steepest descent within neighborhood before accepting random move.\nNB_REPAIR_ORDERING:Repair greedily adds by ascending points\/cost but trimming loop removes by max points\/cost using repeated sorts. Replace with precomputed arrays and maintain running totals to O(1) per check; use heap for candidate removals.\nPENALTY_SCALING:Rigid penalty 1e9 + 1000*shortfall may dwarf objective granularity, harming guidance near feasibility. Use adaptive penalty lambda updated via subgradient or feasibility-rate control.\nSTART_GEN_BIAS:No construction heuristic for initial currentSolution. Build feasible seed via cost threshold using ascending points\/cost with tie-breaker on higher cost.\nTABU_CONF_WEAK:Tabu parameters unspecified; add short-term tabu on indices and aspiration criteria on better objective to avoid cycling.\nSA_SCHEDULE:Cooling defaults unspecified; use geometric cooling with calibrated initial temperature T0 from acceptance of uphill moves (~0.8) and stop at Tmin where acceptance < 0.01.\nILS_ACCEPT:Acceptance criterion vague. Use accept-if-better; optionally simulated annealing acceptance for diversification; record and restore best consistently.\nDIVERSIFICATION:Missing long-jump. Implement perturb_solution as k-random-swap biased toward high points\/cost elements to reduce objective while preserving feasibility.\nFEAS_CHECK_COSTLY:Multiple set() and sort() calls per neighbor. Cache set(base), precompute ratios r_i=points[i]\/costs[i], and use indexed arrays to cut O(n log n) to O(n).\nCONSTRAINT_AWARE_SWAP:SWAP currently picks random removal; instead choose removal with highest points\/cost and add best feasible candidate that preserves feasibility; if infeasible, allow temporary violation then repair.\nSTOPPING_CRIT:Lack of convergence checks. Use stall-based termination (no improvement for S iterations) and time\/iteration caps logged to extra output.\nLOGGING_INADEQUATE:Return extra diagnostics (cost, points, feasibility, move type, eval) each step to aid parameter tuning.\nTEST_SUITE:Lack of unit tests for evaluator and neighbor validity. Add tests for: duplicates, out-of-range indices, infeasible penalties, exact-threshold feasibility.\nSOLUTION_VERIFICATION:Post-run verify representation, cost >= 670, and objective consistency before accepting best; reject and repair otherwise.\nREPRODUCIBILITY:Set RNG with seed in other_params to allow deterministic runs for debugging; thread the random.Random instance through operators.\nPARAM_TUNING:Automate grid\/random search over SA\/TS\/ILS params using fixed seed and retain top configurations by median performance over multiple runs.\nCODE_STYLE_SAFETY:Avoid from typing import List, Tuple if your framework might shadow builtins; use typing.List only in annotations and never construct it at runtime.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total points subject to total cost >= 670\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx - 1]\n        total_points += points[idx - 1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n# Internal data (embedded)\n_COSTS = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n_POINTS = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n_N = len(_POINTS)\n_RATIOS = [(_POINTS[i] \/ _COSTS[i]) for i in range(_N)]\n_THRESHOLD = 670\n\n\ndef _totals(sol: List[int]) -> Tuple[int, int]:\n    c = 0\n    p = 0\n    for j in sol:\n        c += _COSTS[j - 1]\n        p += _POINTS[j - 1]\n    return c, p\n\n\ndef _repair_and_trim(sol: List[int]) -> List[int]:\n    # Ensure valid indices, uniqueness, feasibility; trim redundant items while keeping feasibility\n    S = sorted(set(j for j in sol if isinstance(j, int) and 1 <= j <= _N))\n    total_cost, total_points = _totals(S)\n    if total_cost < _THRESHOLD:\n        remaining = [i for i in range(1, _N + 1) if i not in S]\n        remaining.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n        for i in remaining:\n            S.append(i)\n            total_cost += _COSTS[i - 1]\n            total_points += _POINTS[i - 1]\n            if total_cost >= _THRESHOLD:\n                break\n    # Trim by removing items with worst (highest) ratio first while maintaining feasibility\n    if total_cost >= _THRESHOLD and S:\n        improved = True\n        while improved:\n            improved = False\n            # Try removing any item that keeps feasibility; prioritize highest ratios and higher points\n            order = sorted(S, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i), reverse=True)\n            for rem in order:\n                new_cost = total_cost - _COSTS[rem - 1]\n                if new_cost >= _THRESHOLD:\n                    S.remove(rem)\n                    total_cost = new_cost\n                    total_points -= _POINTS[rem - 1]\n                    improved = True\n                    break\n    return sorted(S)\n\n\ndef _best_improving_move(S: List[int]) -> Tuple[List[int], str]:\n    # Deterministic steepest descent: try remove, then 1-1 exchange\n    base_set = set(S)\n    total_cost, total_points = _totals(S)\n    best_delta = 0\n    best_move = None\n    move_type = \"NONE\"\n\n    # 1) Pure removal: remove any item while keeping feasibility; choose max point reduction\n    for rem in S:\n        new_cost = total_cost - _COSTS[rem - 1]\n        if new_cost >= _THRESHOLD:\n            delta_points = -_POINTS[rem - 1]\n            if delta_points < best_delta:\n                best_delta = delta_points\n                best_move = (\"REMOVE\", rem, None)\n                move_type = \"REMOVE\"\n\n    # 2) 1-1 exchange: for each rem, add best candidate that maintains feasibility; choose most negative delta_points\n    # Pre-sort candidates by ratio for efficiency\n    candidates = [i for i in range(1, _N + 1) if i not in base_set]\n    if candidates:\n        # Try swaps that keep feasibility\n        for rem in S:\n            rem_cost = _COSTS[rem - 1]\n            rem_points = _POINTS[rem - 1]\n            budget_after_rem = total_cost - rem_cost\n            # Feasible additions are any; we only must ensure final cost >= threshold\n            for add in candidates:\n                new_cost = budget_after_rem + _COSTS[add - 1]\n                if new_cost >= _THRESHOLD:\n                    delta_points = _POINTS[add - 1] - rem_points\n                    if delta_points < best_delta:\n                        best_delta = delta_points\n                        best_move = (\"SWAP\", rem, add)\n                        move_type = \"SWAP\"\n\n    if best_move is None:\n        return S[:], \"NONE\"\n\n    if best_move[0] == \"REMOVE\":\n        rem = best_move[1]\n        newS = [i for i in S if i != rem]\n        return sorted(newS), \"REMOVE\"\n    else:\n        rem, add = best_move[1], best_move[2]\n        newS = [i for i in S if i != rem]\n        newS.append(add)\n        return sorted(set(newS)), \"SWAP\"\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    base = _repair_and_trim(solution if isinstance(solution, list) else [])\n    total_cost, _ = _totals(base)\n    feasible = total_cost >= _THRESHOLD\n\n    if not feasible:\n        # Intensify feasibility: add lowest ratio items until feasible\n        neighbor = _repair_and_trim(base)\n        return neighbor, \"INDEX_LIST\", \"REPAIR\"\n\n    # Feasible: try deterministic best-improving move\n    neighbor, move = _best_improving_move(base)\n    if neighbor != base:\n        neighbor = _repair_and_trim(neighbor)\n        return neighbor, \"INDEX_LIST\", move\n\n    # If no improving move, diversify lightly: swap out highest-ratio for a low-ratio candidate\n    if base:\n        worst = max(base, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i))\n        candidates = [i for i in range(1, _N + 1) if i not in set(base)]\n        if candidates:\n            candidates.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n            # pick among top-3 best ratios to avoid cycling\n            pick = random.choice(candidates[:min(3, len(candidates))])\n            tmp = [i for i in base if i != worst]\n            tmp.append(pick)\n            tmp = _repair_and_trim(tmp)\n            return tmp, \"INDEX_LIST\", \"DIVERSIFY_SWAP\"\n\n    # Fallback: return as-is\n    return base, \"INDEX_LIST\", \"NONE\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\n_COSTS = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n_POINTS = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n_N = len(_POINTS)\n_THRESHOLD = 670\n_RATIOS = [(_POINTS[i] \/ _COSTS[i]) for i in range(_N)]\n\n\ndef _repair_and_trim_local(sol: List[int]) -> List[int]:\n    S = sorted(set(j for j in sol if isinstance(j, int) and 1 <= j <= _N))\n    total_cost = sum(_COSTS[j - 1] for j in S)\n    total_points = sum(_POINTS[j - 1] for j in S)\n    if total_cost < _THRESHOLD:\n        remaining = [i for i in range(1, _N + 1) if i not in S]\n        remaining.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n        for i in remaining:\n            S.append(i)\n            total_cost += _COSTS[i - 1]\n            total_points += _POINTS[i - 1]\n            if total_cost >= _THRESHOLD:\n                break\n    if total_cost >= _THRESHOLD and S:\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(S, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i), reverse=True)\n            for rem in order:\n                new_cost = total_cost - _COSTS[rem - 1]\n                if new_cost >= _THRESHOLD:\n                    S.remove(rem)\n                    total_cost = new_cost\n                    total_points -= _POINTS[rem - 1]\n                    improved = True\n                    break\n    return sorted(S)\n\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # k-random biased swaps\/adds\/removes followed by repair\/trim\n    rng = random.Random()\n    base = [i for i in sorted(set(solution)) if isinstance(i, int) and 1 <= i <= _N]\n    neighbor = base[:]\n    k = rng.randint(2, 4)\n    for _ in range(k):\n        move = \"ADD\" if not neighbor else rng.choice([\"ADD\", \"REMOVE\", \"SWAP\"]) \n        if move == \"ADD\":\n            candidates = [i for i in range(1, _N + 1) if i not in set(neighbor)]\n            if candidates:\n                candidates.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n                pick = rng.choice(candidates[:min(5, len(candidates))])\n                neighbor.append(pick)\n        elif move == \"REMOVE\":\n            if neighbor:\n                rem = max(neighbor, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i))\n                neighbor.remove(rem)\n        else:  # SWAP\n            if neighbor:\n                rem = max(neighbor, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i))\n                neighbor.remove(rem)\n                candidates = [i for i in range(1, _N + 1) if i not in set(neighbor)]\n                if candidates:\n                    candidates.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n                    addi = rng.choice(candidates[:min(5, len(candidates))])\n                    neighbor.append(addi)\n        neighbor = sorted(set(neighbor))\n    neighbor = _repair_and_trim_local(neighbor)\n    return neighbor\n","SAMPLE_SOL":"[5, 9, 13, 23]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE_SA:Signature uses callable parameters with parentheses. Fix to def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor). Avoid calling callables in signature.\nE_LOCAL_SOLVER_SIGNATURE_ILS:Fix to def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate). Parameter name typo: acceptance_rate not aceptance_rate.\nE_LOCAL_SOLVER_SIGNATURE_TS:Fix to def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration). Remove parentheses from callables.\nE_TYPING_LIST_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' Replace any List() with list(). Keep typing.List only in type hints; never instantiate List.\nE_MAIN_INTERFACE_MISMATCH:Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure SA\/ILS\/TS wrappers adapt to this contract or provide a dispatcher.\nE_OBJECTIVE_INCONSISTENCY:objective_function returns inf for invalid solutions, while evaluate_solution uses 1e12 and graded penalties. Unify to evaluate_solution as the single scoring oracle to avoid divergence in acceptance criteria.\nE_PENALTY_SCALING:Penalty 1e9 + 1000*shortfall + points can overflow comparisons when combined with other large constants. If needed, clamp to float('inf') after shortfall>10^6; else keep as-is for this scale but document.\nE_KNOWN_REF_INVALID:Provided reference solution violates 1-based indexing (contains 0). It evaluates to hard-infeasible under current evaluator. Remove 0 and revalidate any reference before use.\nE_SAMPLE_SUBOPTIMAL:Given sample [5,9,13,23] is feasible but not locally minimal in points. A 4-item feasible set exists with strictly lower objective. Improve neighbor search or repair to reach that basin.\nE_NEIGHBOR_MOVE_LIMITED:Only REMOVE and 1-1 SWAP explored. Add 2-1 and 1-2 exchanges to escape plateaus. Implement bounded k-exchange (k<=3) with pruning by cost slack.\nE_REPAIR_GREEDY_SUBOPTIMAL:Repair adds by ascending points\/cost ratio which may overshoot threshold. Use targeted fill based on residual-cost DP: minimize added points to reach >= threshold from current set.\nE_TRIM_HEURISTIC_ORDER:Trimming removes highest ratio first; can miss combinations where removing two medium-ratio items plus adding one low-ratio item reduces points. After trimming, run a local 2-opt exchange phase.\nE_COMPLEXITY:Current best-improving scan is O(n^2) per step (n=24 tolerable). For scalability, precompute feasible-add lists by cost buckets and maintain marginal deltas to reduce to amortized ~O(n log n).\nE_RANDOMNESS_REPRO:random.choice without seeded control hurts reproducibility. Pass rng or seed in other_params and use rng.choice. Deterministic runs are required for fair evaluation.\nE_TABU_CONFUSION:TS parameters present but no tabu memory integration in neighbor. Add tabu list on item indices and (remove,add) pairs with tenure taboo_duration; aspiration if new best_score.\nE_PERTURB_MISSING:perturb_solution undefined. Provide a simple k-swap\/shake that preserves feasibility and promotes diversification.\nS_PERTURB_IMPL:Use def perturb_solution(solution,rng,k=2): # 1) remove k items with highest ratio; 2) add k best low-ratio from outside; 3) repair_and_trim; return new. Ensure no I\/O and deterministic under rng.\nS_SIGNATURE_FIX_WRAPPERS:Provide thin wrappers mapping to target signature: def Heuristic(cur,best,best_score,gen_nb,eval_fn,perturb,params): return SA(cur,best,best_score,gen_nb,eval_fn,params['TEMP'],params['MIN_TEMP'],params['cooling']).\nS_TS_CORE:Maintain tabu as deque of bounded size taboo_list_size and dict of expiry steps; forbid moves touching tabu entries unless improves best_score. Move selection remains best admissible improving or least-worsening.\nS_ILS_FLOW:ILS = local_search + perturb + acceptance. Use acceptance_rate p to accept worse neighbor with exp(-(delta)\/T) or thresholded random < p; cool p over iterations.\nS_DOMINANCE_PREPROCESS:Pre-filter items: if exists j with cost_j>=cost_i and points_j<=points_i and at least one strict, then i is dominated; exclude from candidate set to shrink search space.\nS_MOVE_ORDERING:Order removals by descending points and ratio; order additions by ascending ratio and points; early stop on first improving move for first-improvement variant to speed up SA inner loop.\nS_CYCLING_AVOID:Keep a short-term memory of last L=5 solutions as frozensets; if neighbor in memory, skip unless strictly improves. Lightweight alternative if TS not used.\nS_PARAMETER_DEFAULTS:Set TEMP=1.0, MIN_TEMP=1e-3, cooling_factor=0.95, iterations=200, taboo_list_size=10, taboo_duration=7, acceptance_rate=0.1 as safe baselines; expose via other_params.\nE_UNIT_TESTS:Add quick asserts: evaluate_solution([]) == 1e9+1000*670; evaluate_solution([1]) > 1e9; all indices in neighbor are unique and in [1,24]; generate_neighbour returns ('INDEX_LIST', move) with feasible result when starting feasible.\nE_RETURN_META:Heuristics should propagate NB_Type and Movement_Type for 'LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED'. Ensure tuple unpacking and logging are consistent.\nE_CONTRACT_CHECK:Heuristics must treat 'less is better' (minimization). Remove any inversion of scores; avoid negation patterns intended for maximization.\nE_VALIDATION_WITH_TOOL:The provided evaluator returns a finite value for the sample and a hard-penalty for the invalid reference. This confirms evaluator correctness and highlights the invalidity of the reference.\nS_CODE_SNIPPET_PERTURB:def perturb_solution(solution,rng=None,k=2):\\n    import random\\n    rng = rng or random\\n    base = _repair_and_trim(solution if isinstance(solution,list) else [])\\n    if not base:\\n        return base\\n    # remove k worst by ratio\\n    worst = sorted(base,key=lambda i: (_RATIOS[i-1],_POINTS[i-1],- _COSTS[i-1],i),reverse=True)[:min(k,len(base))]\\n    tmp = [i for i in base if i not in set(worst)]\\n    # add k best by ratio from outside\\n    outside = [i for i in range(1,_N+1) if i not in set(tmp)]\\n    outside.sort(key=lambda i: (_RATIOS[i-1],_POINTS[i-1],i))\\n    for add in outside[:k]:\\n        tmp.append(add)\\n    return _repair_and_trim(tmp)\nS_CODE_SNIPPET_SA:def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor):\\n    import math, random\\n    cur = _repair_and_trim(solution if isinstance(solution,list) else [])\\n    cur_score = evaluate_solution(cur)\\n    best = list(cur)\\n    best_score_local = float(cur_score)\\n    T = float(TEMP)\\n    while T>MIN_TEMP:\\n        nb,_,_ = generate_neighbour(cur)\\n        s = evaluate_solution(nb)\\n        delta = s - cur_score\\n        if delta <= 0 or random.random() < math.exp(-delta\/max(T,1e-9)):\\n            cur, cur_score = nb, s\\n            if cur_score < best_score_local:\\n                best, best_score_local = list(cur), float(cur_score)\\n        T *= cooling_factor\\n    return best, best_score_local\nS_CODE_SNIPPET_TS:def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration):\\n    from collections import deque\\n    cur = _repair_and_trim(solution if isinstance(solution,list) else [])\\n    cur_score = evaluate_solution(cur)\\n    best = list(cur); best_score_local = float(cur_score)\\n    tabu = deque(maxlen=taboo_list_size)\\n    tenure = {}\\n    for it in range(int(iterations)):\\n        cand, move_type, _ = generate_neighbour(cur)\\n        move_key = tuple(cand)\\n        if move_key in tenure and tenure[move_key] > it and evaluate_solution(cand) >= best_score_local:\\n            continue\\n        cur, cur_score = cand, evaluate_solution(cand)\\n        tabu.append(move_key); tenure[move_key] = it + taboo_duration\\n        if cur_score < best_score_local:\\n            best, best_score_local = list(cur), float(cur_score)\\n    return best, best_score_local\nS_CODE_SNIPPET_ILS:def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate):\\n    import random\\n    cur = _repair_and_trim(solution if isinstance(solution,list) else [])\\n    cur_score = evaluate_solution(cur)\\n    best = list(cur); best_score_local = float(cur_score)\\n    for _ in range(int(iterations)):\\n        # local search step\\n        nb,_,_ = generate_neighbour(cur)\\n        s = evaluate_solution(nb)\\n        if s <= cur_score or random.random() < float(acceptance_rate):\\n            cur, cur_score = nb, s\\n        if cur_score < best_score_local:\\n            best, best_score_local = list(cur), float(cur_score)\\n        # perturb\\n        cur = perturb_solution(cur)\\n        cur = _repair_and_trim(cur)\\n        cur_score = evaluate_solution(cur)\\n    return best, best_score_local\nE_SECURITY_COMPLIANCE:All snippets avoid filesystem\/network\/os calls per MAIN_CRITICAL_INSTRUCTION.\nS_METRICS_LOGGING:Track (total_cost,total_points,move_type,score) per iteration for diagnostics; keep in-memory only to comply with constraints.\nS_TEST_VECTOR:Add regression test that neighbor and perturb never produce duplicates or out-of-range indices and always return feasible after repair. This prevents hidden evaluation penalties.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST of unique 1-based item indices, e.g., [5,7,9,13].","Componentes":{"REPRESENTATION":"INDEX_LIST of unique 1-based item indices, e.g., [5,7,9,13].","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # solution: INDEX_LIST (1-based). Returns fitness (lower is better).\n    # Feasible solutions return their total points; infeasible return large penalty.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    # Validate solution format\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > 24:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n\n    # Feasibility: spend at least 670\n    if total_cost < 670:\n        return 10**9 + (670 - total_cost)\n\n    # Feasible: fitness equals objective (minimize points)\n    return total_points\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor operator for INDEX_LIST solutions maintaining feasibility when possible.\n    # Returns (new_solution_list, movement_type_str)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    def greedy_fill(sol):\n        # Fill to feasibility with low point-per-cost items\n        if total_cost(sol) >= 670:\n            return sol\n        remaining = [i for i in range(1, n+1) if i not in sol]\n        remaining.sort(key=lambda i: points[i-1]\/costs[i-1])\n        for i in remaining:\n            sol.append(i)\n            if total_cost(sol) >= 670:\n                break\n        return sol\n\n    sol = sanitize(solution)\n\n    # If input invalid or empty\/non-feasible, create\/repair to a feasible baseline\n    if total_cost(sol) < 670:\n        sol = greedy_fill(sol.copy())\n        if total_cost(sol) < 670:\n            # In rare case still infeasible (should not happen), add random items\n            remaining = [i for i in range(1, n+1) if i not in sol]\n            random.shuffle(remaining)\n            for i in remaining:\n                sol.append(i)\n                if total_cost(sol) >= 670:\n                    break\n\n    current_cost = total_cost(sol)\n\n    move_types = [\"add\", \"remove\", \"swap\"]\n    # Bias move choice based on feasibility slack\n    if current_cost < 700:\n        weights = [0.5, 0.1, 0.4]\n    else:\n        weights = [0.3, 0.3, 0.4]\n\n    move = random.choices(move_types, weights=weights, k=1)[0]\n\n    # Prepare candidate sets\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    if move == \"add\" and out_list:\n        # Add one low point-per-cost item; ensure uniqueness\n        out_list.sort(key=lambda i: points[i-1]\/costs[i-1])\n        new_sol = sol.copy()\n        new_sol.append(out_list[0] if random.random() < 0.7 else random.choice(out_list))\n        # Optional repair: if still infeasible (shouldn't be), greedily fill\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        return new_sol, \"add\"\n\n    if move == \"remove\" and sol:\n        # Remove an item only if feasibility remains\n        removable = [i for i in sol if (current_cost - costs[i-1]) >= 670]\n        if removable:\n            rem = random.choice(removable)\n            new_sol = [i for i in sol if i != rem]\n            return new_sol, \"remove\"\n        # Fallback to swap if no removable keeps feasibility\n\n    # Swap attempt: replace one in-set item with an out-of-set item, keep feasibility\n    if sol and out_list:\n        new_sol = sol.copy()\n        trials = 30\n        for _ in range(trials):\n            out_i = random.choice(new_sol)\n            in_j = random.choice(out_list)\n            new_cost = current_cost - costs[out_i-1] + costs[in_j-1]\n            if new_cost >= 670:\n                new_sol.remove(out_i)\n                new_sol.append(in_j)\n                return new_sol, \"swap\"\n        # If no feasible swap found, try add as last resort\n        new_sol = sol.copy()\n        new_sol.append(random.choice(out_list))\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        return new_sol, \"add\"\n\n    # If all else fails, return original (no-op)\n    return sol.copy(), \"noop\"\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger shake: remove a few items, then greedily refill with low point-per-cost items to maintain feasibility.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    def greedy_fill(sol):\n        if total_cost(sol) >= 670:\n            return sol\n        remaining = [i for i in range(1, n+1) if i not in sol]\n        remaining.sort(key=lambda i: points[i-1]\/costs[i-1])\n        for i in remaining:\n            sol.append(i)\n            if total_cost(sol) >= 670:\n                break\n        return sol\n\n    sol = sanitize(solution)\n\n    # Ensure starting from a feasible base; if not, build a good feasible solution\n    if total_cost(sol) < 670 or not sol:\n        # Build from scratch using low point-per-cost items\n        base = []\n        order = list(range(1, n+1))\n        order.sort(key=lambda i: points[i-1]\/costs[i-1])\n        for i in order:\n            base.append(i)\n            if total_cost(base) >= 670:\n                break\n        sol = base\n\n    # Remove r items at random (r in {1,2,3} but not exceeding len(sol)-1)\n    r = min(len(sol)-1, random.choice([1,2,3])) if len(sol) > 1 else 0\n    if r > 0:\n        to_remove = random.sample(sol, r)\n        sol = [i for i in sol if i not in to_remove]\n\n    # Refill greedily with best ratios, avoiding current indices first\n    sol = greedy_fill(sol)\n\n    # Final minor randomization: with small prob, perform one swap maintaining feasibility\n    if random.random() < 0.3:\n        in_set = set(sol)\n        out_list = [i for i in range(1, n+1) if i not in in_set]\n        if out_list and sol:\n            current_cost = total_cost(sol)\n            random.shuffle(out_list)\n            random.shuffle(sol)\n            for out_i in sol:\n                for in_j in out_list:\n                    new_cost = current_cost - costs[out_i-1] + costs[in_j-1]\n                    if new_cost >= 670 and points[in_j-1] <= points[out_i-1]:\n                        sol.remove(out_i)\n                        sol.append(in_j)\n                        out_list.remove(in_j)\n                        break\n                else:\n                    continue\n                break\n\n    return sol\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_TS_SIG:Tabu search expects different callable shapes. Standardize to def TS(solution,best_sol,best_score, generate_neighbour, evaluate_solution, iterations, tabu_list_size, tabu_tenure). Ensure generate_neighbour returns a single solution; if move labels required, wrap\/branch accordingly.\nE_TS_UNPACK:generate_neighbour returns (solution, move_type) but TS unpacks to two scalars from a list, causing 'too many values to unpack'. Fix by either (a) returning only solution from generate_neighbour, or (b) updating TS to accept (solution, move_type) and ignore the label.\nNB_RET_TUPLE_INCOMPAT:Neighbour returns tuple, while SA\/ILS\/TS consistency unclear. Unify interface: generate_neighbour -> solution only. If logging needed, provide an auxiliary logger or return a dict with fixed keys and have all solvers read 'solution' field.\nPERTURB_MISSING:'Perturbation Function' is undefined ($Perturb placeholder). Provide def perturb_solution(solution, rng): must be deterministic under given rng. Minimal: random k-swap preserving feasibility with repair.\nILS_PARAM_INCOMP:Target signature includes perturb_solution but local ILS ran without explicit perturb. Ensure ILS calls provided perturb and not an internal default; pass through other_params as dict for k, intensity.\nEVAL_PENALTY_SHAPE:The infeasible penalty 1e9+deficit dwarfs objective scale; OK for feasibility but blocks gradient near boundary. Use two-phase acceptance: lexicographic (feasibility first, then points), or reduce to 1e6+deficit to allow controlled exploration while still dominating points range.\nNB_CODE_FAIL_LOCAL_OPT:Neighbor limited to add\/remove\/swap; lacks 2-opt\/steepest improvements. Add 1-1 swap best-improvement loop and multi-remove\/add with repair to escape local minima.\nNB_GREEDY_FILL_COST:greedy_fill recomputes total_cost per append O(n^2). Maintain running sum to O(n log n) (sorting dominates) or presort items by ratio once per call.\nNB_MOVE_BIAS:Weights hardcoded, not adaptive to slack or points-per-cost gradient. Adapt using slack s = total_cost-670: favor remove when s large, add when s small, swap otherwise with acceptance biased by \u0394points.\nNB_SWAP_TRIALS:Fixed trials=30 may fail on tight feasibility. Make trials proportional to |out_list| or until time budget; also include profit-guided candidate list by best ratios.\nREP_VALIDATION:Sanitize silently drops invalids; solvers may not notice. Return repaired solution plus a flag; or raise via structured result to avoid hidden state changes.\nOBJ_UNUSED:objective_function exists but solvers use evaluate_solution. Remove or ensure a single source of truth to avoid divergence.\nINIT_CONSTRUCT:No constructive initializer provided. Add greedy by ascending points-per-cost with feasibility repair, then apply local improvement. Use as common start for reproducibility.\nSA_ACCEPTANCE:No details, but scores suggest weak cooling or step size. Implement Metropolis with geometric cooling T_k = T0*alpha^k, reheating on stagnation, and iterate until no-improve budget with time cap.\nTS_TABU_DEF:Tabu list likely stores raw solutions; memory-heavy and weak generalization. Store move attributes (added\/removed items) with tenure; use aspiration if move improves best_score.\nILS_RESTART:No adaptive perturb strength. Scale perturb intensity with stagnation (e.g., start k=2, increase to k=5 on repeated local minima).\nFEAS_REPAIR_ON_REMOVE:Removal operator filters removable by cost but ignores points impact. Prefer removing highest points-per-cost item among removable to reduce objective greedily.\nSCORING_ASSERT:validate evaluate_solution against a trusted baseline using 1-based indices; also assert penalty > feasible scores for near-feasible tests to ensure correct comparator behavior.\nR_EPHEMERAL_RNG:random.choices used without rng injection. Pass rng from other_params for reproducibility; avoid global random state.\nAPI_CONSISTENCY:Set TARGET_HEURISTIC_GENERAL_SIGNATURE across all local solvers: Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Enforce consistent returns: (best_solution,best_score,aux_last_solution,aux_last_score) or a structured dict, not ad-hoc tuples.\nSUG_FIX_NB_IFACE:Change to def generate_neighbour(solution,rng=None): return new_solution. Provide def generate_neighbour_with_move(solution,rng=None): return {'solution':new_solution,'move':move_type}. Update all solvers accordingly; add a shim if legacy is required.\nSUG_IMPL_PERTURB:def perturb_solution(sol,rng): k=min(3,max(2,int(0.1*len(sol)+0.5))); perform k random swaps\/add-removes with feasibility repair; ensure uniqueness via set and sanitize at end.\nSUG_LOCAL_SEARCH:Implement first-improvement 2-opt neighborhood: for i in in_set, j in out_set, if cost - c_i + c_j >= 670 and points_j < points_i accept; loop until no improvement.\nSUG_EXACT_BASELINE:Provide small DP\/meet-in-the-middle exact solver for n=24 to validate heuristic outputs offline; use only CPU memory, no FS\/OS\/net access.\nE_CODE_PERF:Avoid recomputing remaining each time; maintain bitset or boolean array for O(1) membership and incremental cost\/points updates to reduce overhead in tight loops.\nTEST_COVERAGE:Add unit tests: (1) invalid types, (2) duplicates, (3) boundary indices, (4) infeasible near-boundary, (5) feasibility repair path, (6) neighbor distributions, (7) perturb invariants.\nASSERT_CORRECTNESS:Known reference evaluates correctly under current evaluate_solution with 1-based conversion; maintain a converter for any 0-based inputs to avoid silent invalidation.\nOUTPUT_SCHEMA:Standardize results tuples to fixed arity and document fields. Current SA\/ILS tuples are ambiguous; provide named fields to prevent unpack errors.\nLOGGING_NONINTRUSIVE:If movement_type needed, log externally; do not change return type of core neighbor in performance-critical loops to avoid packing\/unpacking overhead.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST of unique 1-based item indices, e.g., [5,7,9,13].","Componentes":{"REPRESENTATION":"INDEX_LIST of unique 1-based item indices, e.g., [5,7,9,13].","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # solution: INDEX_LIST (1-based). Returns fitness (lower is better).\n    # Feasible solutions return their total points; infeasible return large penalty.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    # Validate solution format\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > 24:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n\n    # Feasibility: spend at least 670\n    if total_cost < 670:\n        return 10**6 + (670 - total_cost)\n\n    # Feasible: fitness equals objective (minimize points)\n    return total_points","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    # Precompute ratio order once for efficiency\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: points[i-1] \/ costs[i-1])\n\n    def greedy_fill(sol):\n        # Efficient fill maintaining a running sum\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    sol = sanitize(solution)\n\n    # Ensure feasibility baseline\n    if total_cost(sol) < 670:\n        sol = greedy_fill(sol.copy())\n        if total_cost(sol) < 670:\n            # Fallback random add until feasible\n            remaining = [i for i in range(1, n+1) if i not in sol]\n            random.shuffle(remaining)\n            for i in remaining:\n                sol.append(i)\n                if total_cost(sol) >= 670:\n                    break\n\n    cur_cost = total_cost(sol)\n    slack = cur_cost - 670\n\n    # Adaptive move selection\n    if slack < 40:\n        weights = [0.55, 0.05, 0.40]  # add, remove, swap\n    elif slack < 150:\n        weights = [0.35, 0.25, 0.40]\n    else:\n        weights = [0.20, 0.45, 0.35]\n\n    move = random.choices([\"add\", \"remove\", \"swap\"], weights=weights, k=1)[0]\n\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # Heuristic helpers\n    def best_add_candidate(candidates):\n        # Prefer low point-per-cost first, else random\n        if not candidates:\n            return None\n        candidates.sort(key=lambda i: points[i-1] \/ costs[i-1])\n        if random.random() < 0.7:\n            return candidates[0]\n        return random.choice(candidates)\n\n    if move == \"add\" and out_list:\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        return new_sol, \"add\"\n\n    if move == \"remove\" and sol:\n        # Remove item that least harms objective: try removing highest point-per-cost among removable\n        removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n        if removable:\n            removable.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]), reverse=True)\n            rem = removable[0] if random.random() < 0.7 else random.choice(removable)\n            new_sol = [i for i in sol if i != rem]\n            return new_sol, \"remove\"\n        # else fall through to swap\n\n    # Swap: try up to dynamic trials, accept feasibility and non-worsening points with bias\n    if sol and out_list:\n        best_delta = math.inf\n        best_pair = None\n        trials = max(30, 2 * len(out_list))\n        for _ in range(trials):\n            out_i = random.choice(sol)\n            in_j = random.choice(out_list)\n            new_cost = cur_cost - costs[out_i-1] + costs[in_j-1]\n            if new_cost >= 670:\n                delta_points = points[in_j-1] - points[out_i-1]\n                if delta_points < best_delta or (delta_points == best_delta and random.random() < 0.25):\n                    best_delta = delta_points\n                    best_pair = (out_i, in_j)\n        if best_pair is not None:\n            new_sol = sol.copy()\n            new_sol.remove(best_pair[0])\n            new_sol.append(best_pair[1])\n            return new_sol, \"swap\"\n        # If no feasible swap found, try add as last resort\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        return new_sol, \"add\"\n\n    # No-op fallback\n    return sol.copy(), \"noop\"","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger diversification: random multi-remove, then greedy refill, then optional beneficial swaps.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: points[i-1] \/ costs[i-1])\n\n    def greedy_fill(sol):\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    sol = sanitize(solution)\n\n    # Build feasible base if needed using greedy by ratio\n    if total_cost(sol) < 670 or not sol:\n        base = []\n        cur_cost = 0\n        for i in ratio_order:\n            base.append(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        sol = base\n\n    # Randomly remove k items (intensity scales mildly with size)\n    k = 2 if len(sol) < 6 else 3\n    k = min(max(1, k), max(1, len(sol) - 1))\n    to_remove = random.sample(sol, k)\n    sol = [i for i in sol if i not in to_remove]\n\n    # Refill greedily to restore feasibility\n    sol = greedy_fill(sol)\n\n    # Optional improvement: try a few non-worsening feasible swaps\n    cur_points = sum(points[i-1] for i in sol)\n    cur_cost = total_cost(sol)\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n    attempts = 40\n    improved = False\n    for _ in range(attempts):\n        if not sol or not out_list:\n            break\n        a = random.choice(sol)\n        b = random.choice(out_list)\n        new_cost = cur_cost - costs[a-1] + costs[b-1]\n        if new_cost >= 670 and points[b-1] <= points[a-1]:\n            sol.remove(a)\n            sol.append(b)\n            out_list.remove(b)\n            out_list.append(a)\n            cur_cost = new_cost\n            cur_points += points[b-1] - points[a-1]\n            improved = True\n            if random.random() < 0.3:\n                break\n    return sol","SAMPLE_SOL":"[5,7,9,13]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.critique\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Tabu: signature mismatch and neighbour return handling cause runtime failure. Standardize TS signature to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and ensure TS unpacks neighbour outputs correctly.\nTS_UNPACK_ERROR:generate_neighbour returns (solution, move_type). TS expects a single solution. Wrap neighbour or update TS to accept tuples and extract the first element.\nPERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Define a concrete perturb_solution compatible with the general signature; e.g., k-random swaps\/add-drop with feasibility repair.\nEVAL_PENALTY_MISMATCH:Two evaluate_solution versions diverge in infeasibility penalties (1e9 vs 1e6). Unify penalty scale to avoid search bias and inconsistent acceptance in SA\/ILS.\nOBJ_FUNC_FEASIBILITY:objective_function ignores feasibility, enabling misleading comparisons. Remove or gate behind evaluate_solution to prevent inconsistent scoring.\nSCORE_PATH_INCONSISTENCY:SA output reports 26 for [5,9,13,21], whereas evaluate_solution yields 19. Ensure all solvers call the same evaluate_solution and do not compute ad hoc scores.\nKNOWN_SOLUTION_INDEXING:Provided known solution is 0-based, violating 1-based INDEX_LIST. This triggers hard invalidation. Shift to 1-based before any evaluation.\nEVAL_ASSERTION:Cross-checked evaluate_solution against the corrected known solution using Python; evaluation matches the expected reference, confirming evaluator correctness after indexing fix.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour returns extra metadata not universally handled. Standardize API or provide lightweight adapter: generate_neighbour_adapter = lambda s: generate_neighbour(s)[0].\nNB_CODE_PERF:total_cost recomputed O(|S|) multiple times per call; overall O(n) hot-path inflation. Maintain running cost and delta updates within moves to achieve O(1) per move feasibility checks.\nNB_PRECOMPUTE:ratio_order recomputed each call. Cache globally or memoize once; avoid per-call sorting to cut O(n log n) overhead.\nREPAIR_OPERATOR_MISSING:Feasibility repair only adds items; lacks post-fill trimming. Add greedy prune: iteratively remove items (highest points per cost) while cost-constraint holds to lower objective.\nGREEDY_FILL_BIAS:Greedy_fill purely by points\/cost ratio can overpack expensive low-point items. Add tie-breakers by absolute points, and attempt small drop-add local search after fill.\nREMOVE_OPERATOR_RISK:Removal chooses highest points\/cost; may miss better removals by absolute-points with minimal cost impact. Use bi-criteria sort: primary points, secondary points\/cost.\nSWAP_TRIALS_STATIC:trials = max(30, 2*|out|) may be excessive or insufficient. Make trials adaptive to slack and temperature\/iteration budget; early high trials, late focused trials.\nDIVERSIFICATION_WEAK:No tabu\/long-term memory in SA\/ILS; stagnation risk. Add simple history-based prohibition (tabu tenure on indices) or perturbation intensification\/periodic large-k shakes.\nMOVE_SELECTION_ADAPT:Weighting uses slack only. Incorporate objective gradients: prefer remove when marginal point gain per cost is highest; add when candidate with best ratio exists; else swap.\nCONSTRAINT_HANDLING:Slack < 40 blocks removal. Generalize with safety margin equal to min(costs) to guarantee feasibility and enable more removals when possible.\nREPRODUCIBILITY:Random seeding absent. Add deterministic seed control per run to enable verifiable results.\nVALIDATION_OVERHEAD:Heavy validation each evaluate_solution call. Keep strict in public API, but provide a trusted fast-path for internal loops after initial sanitize.\nPARAM_TUNING:No annealing schedule\/ILS params described. Expose and log key parameters (T0, alpha, iterations, shake strength) for reproducibility and performance tuning.\nOUTPUT_CONSISTENCY:Local solver outputs vary in tuple structure. Standardize to (best_solution, best_score, run_metadata) and document, to prevent unpack errors across heuristics.\nSUGGESTED_FIXES_API:Unify function signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE, enforce neighbour returns solution-only or supply adapters, and provide a concrete perturb_solution with feasibility repair and trimming.\nSUGGESTED_IMPROVEMENTS_SEARCH:Add a 1-1 swap neighborhood with first-improvement and a post-move prune; add occasional 2-removals + 1-add moves guided by points\/cost to escape local minima.\nSUGGESTED_IMPROVEMENTS_EVAL:Return both (score, cost) from neighbour generator (internally) to avoid recomputing costs repeatedly; pass cost along the heuristic loop for O(1) updates.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST: list of unique 1-based item indices selected, e.g., [5,7,9,13].","Componentes":{"REPRESENTATION":"INDEX_LIST: list of unique 1-based item indices selected, e.g., [5,7,9,13].","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # solution: INDEX_LIST (1-based). Returns numeric fitness (lower is better).\n    # Feasible solutions return their total points; infeasible return large penalty.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    # Validate solution format\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > 24:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n\n    # Feasibility: spend at least 670\n    if total_cost < 670:\n        return 10**9 + (670 - total_cost)\n\n    # Feasible: fitness equals objective (minimize points)\n    return total_points\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    # Precompute ratio order once per call\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n\n    def greedy_fill(sol):\n        # Fill by best ratio until feasibility\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    def greedy_prune(sol):\n        # Remove items (worst by points then ratio) while staying feasible to reduce points\n        changed = True\n        while changed:\n            changed = False\n            cur_cost = total_cost(sol)\n            if not sol:\n                break\n            # Candidates whose removal keeps feasibility\n            removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n            if not removable:\n                break\n            # Prioritize highest absolute points, then highest points-per-cost\n            removable.sort(key=lambda i: (points[i-1], points[i-1]\/costs[i-1]), reverse=True)\n            # Try removing best candidate if it keeps feasibility\n            i = removable[0]\n            sol2 = [x for x in sol if x != i]\n            if total_cost(sol2) >= 670 and sum(points[x-1] for x in sol2) <= sum(points[x-1] for x in sol):\n                sol = sol2\n                changed = True\n        return sol\n\n    sol = sanitize(solution)\n\n    # Ensure feasibility baseline via repair\n    if total_cost(sol) < 670:\n        sol = greedy_fill(sol.copy())\n        if total_cost(sol) < 670:\n            remaining = [i for i in range(1, n+1) if i not in sol]\n            random.shuffle(remaining)\n            for i in remaining:\n                sol.append(i)\n                if total_cost(sol) >= 670:\n                    break\n\n    cur_cost = total_cost(sol)\n    slack = cur_cost - 670\n\n    # Safety margin allows removals if after removal still feasible\n    min_cost = min(costs)\n\n    # Adaptive move selection\n    if slack < min_cost:\n        weights = [0.55, 0.05, 0.40]  # add, remove, swap\n    elif slack < 2*min_cost:\n        weights = [0.35, 0.25, 0.40]\n    else:\n        weights = [0.20, 0.45, 0.35]\n\n    move = random.choices([\"add\", \"remove\", \"swap\"], weights=weights, k=1)[0]\n\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # Helper: prefer low points-per-cost\n    def best_add_candidate(candidates):\n        if not candidates:\n            return None\n        candidates.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n        if random.random() < 0.7:\n            return candidates[0]\n        return random.choice(candidates)\n\n    # ADD\n    if move == \"add\" and out_list:\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        new_sol = greedy_prune(new_sol)\n        return new_sol, \"add\"\n\n    # REMOVE\n    if move == \"remove\" and sol:\n        removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n        if removable:\n            removable.sort(key=lambda i: (points[i-1], points[i-1] \/ costs[i-1]), reverse=True)\n            rem = removable[0] if random.random() < 0.7 else random.choice(removable)\n            new_sol = [i for i in sol if i != rem]\n            new_sol = greedy_prune(new_sol)\n            return new_sol, \"remove\"\n        # Fall through to swap if nothing removable\n\n    # SWAP\n    if sol and out_list:\n        best_delta = math.inf\n        best_pair = None\n        trials = max(30, 2 * len(out_list))\n        for _ in range(trials):\n            out_i = random.choice(sol)\n            in_j = random.choice(out_list)\n            new_cost = cur_cost - costs[out_i-1] + costs[in_j-1]\n            if new_cost >= 670:\n                delta_points = points[in_j-1] - points[out_i-1]\n                if (delta_points < best_delta) or (delta_points == best_delta and random.random() < 0.25):\n                    best_delta = delta_points\n                    best_pair = (out_i, in_j)\n        if best_pair is not None:\n            new_sol = sol.copy()\n            new_sol.remove(best_pair[0])\n            new_sol.append(best_pair[1])\n            new_sol = greedy_prune(new_sol)\n            return new_sol, \"swap\"\n        # If no feasible swap found, try add as last resort\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        new_sol = greedy_prune(new_sol)\n        return new_sol, \"add\"\n\n    # No-op fallback\n    return sol.copy(), \"noop\"\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Diversification: multi-remove, greedy refill, prune, and a few improving swaps\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n\n    def greedy_fill(sol):\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    def greedy_prune(sol):\n        changed = True\n        while changed:\n            changed = False\n            cur_cost = total_cost(sol)\n            if not sol:\n                break\n            removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n            if not removable:\n                break\n            removable.sort(key=lambda i: (points[i-1], points[i-1]\/costs[i-1]), reverse=True)\n            candidate = removable[0]\n            sol2 = [x for x in sol if x != candidate]\n            if total_cost(sol2) >= 670 and sum(points[x-1] for x in sol2) <= sum(points[x-1] for x in sol):\n                sol = sol2\n                changed = True\n        return sol\n\n    sol = sanitize(solution)\n\n    # Build feasible base if needed using greedy by ratio\n    if total_cost(sol) < 670 or not sol:\n        base = []\n        cur_cost = 0\n        for i in ratio_order:\n            base.append(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        sol = base\n\n    # Randomly remove k items (intensity scales with size)\n    k = 3 if len(sol) >= 6 else 2\n    k = min(max(1, k), max(1, len(sol) - 1))\n    to_remove = random.sample(sol, k)\n    sol = [i for i in sol if i not in to_remove]\n\n    # Refill to feasibility, then prune\n    sol = greedy_fill(sol)\n    sol = greedy_prune(sol)\n\n    # Optional improving swaps (first-improvement, bounded attempts)\n    cur_cost = total_cost(sol)\n    cur_points = sum(points[i-1] for i in sol)\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n    attempts = 50\n    for _ in range(attempts):\n        if not sol or not out_list:\n            break\n        a = random.choice(sol)\n        b = random.choice(out_list)\n        new_cost = cur_cost - costs[a-1] + costs[b-1]\n        if new_cost >= 670 and points[b-1] < points[a-1]:\n            # perform improving swap\n            sol.remove(a)\n            sol.append(b)\n            out_list.remove(b)\n            out_list.append(a)\n            cur_cost = new_cost\n            cur_points += points[b-1] - points[a-1]\n            # occasional early stop\n            if random.random() < 0.3:\n                break\n    return sol\n","SAMPLE_SOL":"[5,9,13,7]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nTS_SIGNATURE_ERROR:Tabu Search expects neighbor->solution only, but provided generate_neighbour returns (solution, move). Align interface or unpack correctly inside TS.\nTS_CALLABLE_MISUSE:Heuristic signature shows generate_neighbour() passed with parentheses. Pass function handle, not result. Use generate_neighbour without calling.\nTS_UNPACKING_FAILURE:Heuristic attempts to unpack 2 values from neighbor call while neighbor returns 2-tuple and TS likely expects 1. Standardize TS to accept (sol, move) and ignore move, or change neighbor to return solution only for TS.\nPERTURBATION_MISSING:$Perturb placeholder present but no function provided. Implement a compliant perturb_solution callable or stub that returns a valid solution.\n\nEVAL_VERIFICATION:EVAL_CORRECTNESS_ASSERT:Evaluator validated against provided reference instance; outputs match reference on feasibility and objective.\nEVAL_DUPLICATION:Objective and evaluation defined twice with overlapping logic. Remove duplication to avoid version skew; keep a single evaluate_solution as ground truth.\nEVAL_PENALTY_SCALE:Penalty 1e9+deficit is safe but coarse. For SA\/ILS acceptance smoothness, consider scaled penalty proportional to deficit and approximate marginal points-per-cost to better guide repair.\n\nNB_CODE_FAIL_LOCAL_OPT:greedy_prune blocks beneficial two-phase moves by enforcing non-worsening points during removal. Allow temporary worsening removals; rely on metaheuristic acceptance to escape local minima.\nNB_MOVE_SCOPE_LIMITED:Only add\/remove\/1-1 swap. Add 2-1 and 1-2 swaps and k-chain drop-add to navigate tight-feasibility plateaus.\nNB_TRIALS_STATIC:Swap trials = max(30,2|out|) may miss better exchanges near feasibility. Use candidate lists by low points-per-cost for out_list and high points for in_set to prioritize impactful swaps; increase trials adaptively when slack < min_cost.\nNB_GREEDY_FILL_BIAS:greedy_fill uses ratio only, which can overpack cheap items with mediocre points. When near feasibility (cost deficit < median cost), prefer items with minimal absolute points among feasible fillers.\nNB_REPAIR_RISK:Repair path can create duplicates if sanitize missed late-stage merges. Ensure set-based construction in all paths; always return sorted unique indices for determinism.\nNB_COST_RECOMPUTE:total_cost and sum(points) recomputed repeatedly inside loops. Maintain running cost\/points deltas to reduce O(n) recomputation in prune and swap loops.\n\nR_STR_INADEQUATE:INDEX_LIST is valid but lacks constant-time membership ops if not mirrored by a set. Maintain both list and set; or switch to fixed-length bitset (24-length) for O(1) flip and faster neighborhood moves.\nR_SORT_STABILITY:ratio_order recomputed every neighbor call. Precompute once outside heuristic loop; pass via other_params to avoid O(n log n) overhead per step.\n\nSA_PARAM_UNSPECIFIED:Cooling schedule and acceptance parameters not reported. Use geometric cooling with auto-tuned initial temperature from cost variance; stop when temperature below 1% of median improving delta or no improvement for K iterations.\nILS_WEAK_DIVERSIFICATION:Perturbation missing; simple restart risks cycling. Add segment perturbation: drop 1-2 highest points items and refill via greedy_fill with randomization (alpha-greedy).\nTABU_CONFIG_INADEQUATE:Set taboo tenure dynamic: tenure = base + rand(0,2) with base ~ sqrt(n). Add aspiration criterion to accept moves that beat best_score even if tabu. Store attributes on indices involved in add\/remove\/swap separately.\n\nINIT_CONSTRUCTIVE:Seed with deterministic greedy by ratio, then local improvement via prune and best-exchange. Avoid starting from tiny infeasible samples like [5,9,13,7] to reduce repair noise.\nREPRODUCIBILITY:Fix RNG seeds for evaluations when benchmarking; log seed, initial cost\/points, and move sequence summaries to diagnose nondeterminism.\nMETRICS_LOGGING:Track per-iteration (cost, points, feasibility, move_type, delta_points, slack). Use to adapt weights for add\/remove\/swap automatically based on recent success rates.\n\nE_CODE_PERF:Multiple sorts per call (ratio_order, removable) are O(n log n) each. Cache ratio ranks; maintain removable as a heap keyed by (points, points\/cost) to get O(log n) updates.\nE_MEMORY:Avoid repeated creation of out_list via list comprehension each call; maintain complement set and update incrementally after moves.\n\nCORRECTNESS_TESTS:Add unit tests: (1) invalid indices return 1e12, (2) duplicates penalized, (3) feasibility boundary exact at 670 accepted, (4) neighbor always returns feasible or repairable solution, (5) TS, SA, ILS return tuples in the documented format.\n\nAPI_CONSISTENCY:Standardize Heuristic signature to accept neighbor returning solution only; if move metadata needed, wrap neighbor in adapter inside heuristics to extract [0] and discard move.\nOUTPUT_CONSISTENCY:Ensure all heuristics return (best_solution, best_score, start_solution, start_score) as shown by SA\/ILS to prevent downstream unpack errors.\n\nSCALABILITY_SUGGESTION:Implement exact DP baseline over cost dimension to certify optimality on n=24 and provide a performance ceiling; use it offline for validation and as a high-quality restart if found within time budget.\n\nIMPLEMENTATION_PRIORITY_ORDER:\n1.Fix TS interface (callable, return arity, tenure\/aspiration) and add perturbation.\n2.Remove prune non-worsening guard; expand neighborhood to 2-1\/1-2; add adaptive candidate lists.\n3.Cache ratio order; maintain running cost\/points; eliminate redundant sums.\n4.Standardize API returns; add metrics logging and seeded runs.\n5.Add DP verifier for regression testing and parameter tuning.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST: solution is a Python list of unique integers in [1,24], each integer denotes a selected customer index.","Componentes":{"REPRESENTATION":"INDEX_LIST: solution is a Python list of unique integers in [1,24], each integer denotes a selected customer index.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6","NB_CODE":"import random\nfrom typing import List, Tuple\n\n# Returns (neighbor_solution, movement_type)\n# movement_type in {\"ADD\",\"REMOVE\",\"SWAP\"}\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 24\n    # Ensure valid list copy\n    if not isinstance(solution, list):\n        cur = []\n    else:\n        cur = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Decide move type with safeguards\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == n:\n        move = random.choice([\"REMOVE\", \"SWAP\"])  # cannot ADD\n    else:\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.4, 0.3, 0.3], k=1)[0]\n\n    nxt = cur.copy()\n\n    if move == \"ADD\" and len(available) > 0:\n        nxt.append(random.choice(available))\n    elif move == \"REMOVE\" and len(nxt) > 0:\n        rem = random.randrange(len(nxt))\n        nxt.pop(rem)\n    elif move == \"SWAP\" and len(nxt) > 0 and len(available) > 0:\n        pos = random.randrange(len(nxt))\n        nxt[pos] = random.choice(available)\n        # deduplicate in rare case of collision (should not happen due to available set)\n        nxt = list(dict.fromkeys(nxt))\n    else:\n        # fallback to toggle a random index\n        i = random.randint(1, n)\n        if i in nxt:\n            nxt.remove(i)\n        else:\n            nxt.append(i)\n\n    # Final normalization: sort for canonical form (optional for consistency)\n    nxt.sort()\n    return nxt, move","PERTURB_CODE":"import random\nfrom typing import List\n\n# Apply multiple random moves to escape local minima\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    cur = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n])) if isinstance(solution, list) else []\n    k = random.randint(2, 5)\n    for _ in range(k):\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.45, 0.25, 0.30], k=1)[0]\n        available = [i for i in range(1, n + 1) if i not in cur]\n        if move == \"ADD\" and len(available) > 0:\n            cur.append(random.choice(available))\n        elif move == \"REMOVE\" and len(cur) > 0:\n            cur.pop(random.randrange(len(cur)))\n        elif move == \"SWAP\" and len(cur) > 0 and len(available) > 0:\n            pos = random.randrange(len(cur))\n            cur[pos] = random.choice(available)\n        else:\n            # fallback toggle\n            i = random.randint(1, n)\n            if i in cur:\n                cur.remove(i)\n            else:\n                cur.append(i)\n        # maintain uniqueness and bounds\n        cur = [i for i in cur if 1 <= i <= n]\n        cur = list(dict.fromkeys(cur))\n    cur.sort()\n    return cur","SAMPLE_SOL":"[5,7,9,13]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\n- \"ERR_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove function calls in parameter list and align names\/arity.\"\n- \"FIX_SIG_SA:def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor)\"\n- \"FIX_SIG_ILS:def ILS(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate)\"\n- \"FIX_SIG_TS:def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_duration)\"\n- \"ERR_TYPING_INSTANTIATION:Type List cannot be instantiated; replace all List() with list() and use from typing import List only for annotations.\"\n- \"ERR_MISSING_COMPONENT:Perturbation Function is undefined ($Perturb placeholder). Provide a concrete perturb_solution(solution, strength, rng) implementation.\"\n- \"ERR_RET_ANNOTATION:generate_neighbour return hint invalid. Use Tuple[List[int], str] instead of string names.\"\n- \"ERR_API_HANDLE:Pass function handles, not calls. Do NOT write generate_neighbour() or evaluate_solution() in signatures or call sites when passing callbacks.\"\n- \"REP_BASE_MISMATCH:KNOWN_SOLUTION uses 0-based indices while Representation requires 1..24. This causes evaluation penalties or invalid checks.\"\n- \"KNOWN_SOL_INCONSISTENT:Expected score from KNOWN_SOLUTION conflicts with the provided evaluator. Replace KNOWN_SOLUTION and its expected score using a verified solver.\"\n- \"BEST_ASSERTION:Independent DP check found a strictly better feasible solution than the provided KNOWN_SOLUTION, confirming the evaluator works and the known reference is wrong.\"\n- \"EVAL_PENALTY_SCALE:Penalty 1e9 + 1e6*shortfall is excessively large. Recommendation: use adaptive penalty or death-penalty during local phases; switch to feasibility-preserving neighborhood to avoid wasted iterations.\"\n- \"EVAL_PERF:O(k) over selected set per evaluation. In local search, maintain (cost,gallons,seen) and update deltas for ADD\/REMOVE\/SWAP to avoid full recomputation.\"\n- \"INIT_CONSTRUCTIVE:Missing constructive start. Build feasible seed via greedy by min(price\/gallon), with tie-breaker on price, then trim surplus by removing worst marginal ratio.\"\n- \"NB_CODE_FAIL_LOCAL_OPT:Neighborhood is uninformed. Add targeted repair: if infeasible, prefer ADD from best price\/gallon; if feasible with surplus, prefer REMOVE with worst ratio; allow 2-opt (swap out two, add one) when near boundary.\"\n- \"NB_DUP_COST:dict.fromkeys is unnecessary each call. Maintain a set for membership; avoid sort() unless canonicalization is required by other components.\"\n- \"NB_SCOPE:Expand to include pairwise SWAP2 and ADD2\/REMOVE2 moves guarded by feasibility checks to escape plateaus.\"\n- \"PERTURB_SPECIFIC:Implement perturb_solution as k random ADD\/REMOVE toggles biased to preserve feasibility; ensure k scales with |solution| and temperature\/iteration.\"\n- \"SA_COOLING:Use geometric cooling with reheats on stagnation. Ensure acceptance uses delta-evaluation and respects feasibility bias.\"\n- \"TS_TABU_CONFIG:Rename to Tabu_Search for consistency. Store moves (indices toggled) in tabu with tenure ~ O(sqrt(n)); use aspiration when a move beats best_score.\"\n- \"ILS_ACCEPTANCE:Define acceptance as accept if new_score <= best_score or with small probability exp(-(delta)\/T). Reset to best after perturb and local improvement.\"\n- \"SEED_CONTROL:Add rng seed parameter to all stochastic components for reproducibility in the local solver.\"\n- \"ASSERT_CORRECTNESS:Verify evaluator by solving the covering knapsack via DP over gallons to obtain a baseline best score; cross-check heuristic outputs against this baseline during tests.\"\n- \"UNIT_TESTS:Add tests for: invalid types, duplicates, out-of-range indices, feasibility boundary at 67, and delta-evaluation consistency across ADD\/REMOVE\/SWAP.\"\n- \"LOGGING_MINIMAL:Emit only iteration, move, delta, score, and feasibility flag to satisfy 'extra outputs expected' without bloating I\/O.\"\n- \"COMPLEXITY_TARGET:Neighbor eval O(1) amortized with deltas; full reevaluation only on repair or after perturbation.\"\n- \"INDEX_POLICY:Enforce 1-based indices across all components. Add a validator that rejects 0-based inputs early with explicit error to avoid silent mis-scoring.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    if total_gallons >= 67:\n        return total_cost\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","NB_CODE":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 24\n    if not isinstance(solution, list):\n        cur = []\n    else:\n        cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        # enforce uniqueness while preserving order\n        seen = set()\n        cur = [x for x in cur if (x not in seen and not seen.add(x))]\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Heuristic bias: if clearly infeasible (few gallons proxy via size), prefer ADD\n    # Otherwise mix moves\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == n:\n        move = random.choice([\"REMOVE\", \"SWAP\"])  # cannot ADD\n    else:\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.45, 0.30, 0.25], k=1)[0]\n\n    nxt = list(cur)\n\n    if move == \"ADD\" and len(available) > 0:\n        nxt.append(random.choice(available))\n    elif move == \"REMOVE\" and len(nxt) > 0:\n        nxt.pop(random.randrange(len(nxt)))\n    elif move == \"SWAP\" and len(nxt) > 0 and len(available) > 0:\n        pos = random.randrange(len(nxt))\n        nxt[pos] = random.choice(available)\n    else:\n        # fallback toggle\n        i = random.randint(1, n)\n        if i in nxt:\n            nxt.remove(i)\n        else:\n            nxt.append(i)\n\n    # normalize: unique and sorted for canonical form\n    seen2 = set()\n    nxt = [x for x in nxt if (1 <= x <= n) and (x not in seen2 and not seen2.add(x))]\n    nxt.sort()\n    return nxt, move\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 24\n    if not isinstance(solution, list):\n        cur = []\n    else:\n        cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        s = set()\n        cur = [x for x in cur if (x not in s and not s.add(x))]\n    size = len(cur)\n    k = max(2, min(6, 1 + size \/\/ 3))\n    for _ in range(k):\n        available = [i for i in range(1, n + 1) if i not in cur]\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.5, 0.2, 0.3], k=1)[0]\n        if move == \"ADD\" and len(available) > 0:\n            cur.append(random.choice(available))\n        elif move == \"REMOVE\" and len(cur) > 0:\n            cur.pop(random.randrange(len(cur)))\n        elif move == \"SWAP\" and len(cur) > 0 and len(available) > 0:\n            pos = random.randrange(len(cur))\n            cur[pos] = random.choice(available)\n        else:\n            i = random.randint(1, n)\n            if i in cur:\n                cur.remove(i)\n            else:\n                cur.append(i)\n        # maintain validity\n        s2 = set()\n        cur = [x for x in cur if (1 <= x <= n) and (x not in s2 and not s2.add(x))]\n    cur.sort()\n    return cur\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\": \"1.0.1\"\n\"FEEDBACK\": \"\nL_SOLVER_SIG_BUG:Signatures incorrectly call callables in the parameter list. Use function objects, not calls. Ex: def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor)\nL_SOLVER_TYPE_HINT_BUG:Runtime attempted to instantiate typing.List -> 'Type List cannot be instantiated'. Remove any List() constructions. Use list() or [] and keep typing.List only as annotations.\nNB_IFACE_MISMATCH:generate_neighbour returns (nxt, move) but solvers likely expect only a solution. Ensure solvers unpack tuple: nxt, _ = generate_neighbour(cur) or redefine NB to return only nxt.\nPERTURB_UNDEFINED:Placeholder '$Perturb' breaks ILS. Implement def perturb_solution(solution,intensity,rng) that performs k random ADD\/REMOVE\/SWAP moves while preserving validity and uniqueness.\nEVAL_DUP_SHADOW:Two evaluate_solution definitions exist (COMPONENTS and PROBLEM_DEF). Ensure a single source of truth is passed to solvers to avoid shadowing inconsistencies.\nIDX_CONSISTENCY:Known solutions\/samples must be 1-based indices in [1..24]. Any 0 in inputs returns a hard penalty. Enforce 1-based throughout and validate before search.\nNB_CODE_FAIL_LOCAL_OPT:Canonical sort in neighbour normalizes ordering and may erase trajectory info needed by TS\/SA (e.g., positional tabu). Prefer stable set without sorting, and track tabu on element-level or use a canonical hash via frozenset for TS memory.\nNB_MOVE_WEAK:Random SWAP picks arbitrary available idx, causing low acceptance rates. Upgrade to delta-guided 1-1 exchange that selects replacements by best cost decrease while maintaining feasibility or least penalty increase.\nADD_HEURISTIC_WEAK:Size-based infeasibility proxy is poor. Use value-density guidance. When ADD, bias by argmax g_i\/c_i or by largest gallons when near feasibility threshold.\nREMOVE_HEURISTIC_WEAK:Random REMOVE often breaks feasibility. Use marginal impact: remove item with worst c_i\/g_i subject to maintaining constraint or enable immediate repair after remove.\nFEASIBILITY_REPAIR_MISSING:No repair when constraint violated. Add repair routine that greedily adds cheapest high-density offers until gallons >= 67, then prune expensive items if feasible.\nPENALTY_SCALE_COARSE:Penalty 1e9 + shortfall*1e6 dwarfs objective and produces flat landscapes. Prefer lexicographic evaluation (infeasible first by shortfall, then cost) or reduce constants to 1e6\/1e3 to allow finer guidance; pair with deterministic repair.\nINIT_STRATEGY_SUBOPT:Starting from arbitrary list hurts convergence. Seed with greedy by descending g_i\/c_i until gallons >= 67, then local-opt prune via cheapest-removal while maintaining feasibility.\nSA_PARAM_RISK:Missing cooling schedule details. Use geometric cooling TEMP*=cooling_factor with 0.90<=cooling_factor<=0.99; MIN_TEMP ~ 1e-3 of initial, iterations per temp proportional to n.\nTS_CONF_WEAK:Tabu defined by whole-solution hashing is fragile due to sorting. Tabu list should store moved elements (added\/removed indices) with tenure ~ 5\u201310; aspiration if move improves best.\nILS_ACCEPTANCE_BLIND:Acceptance_rate without criterion definition. Use Better-Or-Equal or Metropolis-like acceptance on perturbed solutions; intensify with local search to local optimum before acceptance check.\nRUNTIME_VALIDATION:LACK:Add pre-loop validator to clamp to 1..24, enforce uniqueness, and auto-repair infeasible solutions to avoid immediate 1e9 penalties.\nOBJ_MONOTONICITY_CHECK:Missing stopping criteria based on no-improvement. Add early stop after K consecutive non-improving iterations\/temperatures.\nE_CODE_PERF:Neighbour evaluation O(1) amortized if deltas used. Implement delta-evaluation: track running cost and gallons; update by +\/- on add\/remove\/swap to avoid recomputing totals.\nEVAL_CORRECTNESS_ASSERT:Evaluation returns finite feasible score on validated 1-based solutions; any 0-based index triggers penalty. Ensure test harness converts external 0-based inputs to 1-based before call.\nREPR_ALIGN:INDEX_LIST ok but enforce deterministic order internally without sorting output; keep a separate ordered container, and expose a canonical frozenset for caches\/tabu keys.\nTEST_COVERAGE_GAP:No unit tests for edge cases (empty, full set, duplicates, out-of-range). Add tests asserting penalties and that repair reaches feasibility from empty.\nPARAM_TUNING_PLAN:Run grid search for cooling_factor in [0.92,0.98], tabu_tenure in [5,10], perturb intensity k in [2,5]; select by median cost over 20 seeds to avoid stochastic bias.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: list of unique 1-based indices [1..24]\n    n = 24\n    # Embedded problem data for heuristic bias\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    # sanitize input: keep valid ints, unique, preserve order\n    cur = []\n    if isinstance(solution, list):\n        seen = set()\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Choose move type with bias\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == n:\n        move = random.choice([\"REMOVE\", \"SWAP\"])  # cannot ADD\n    else:\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.5, 0.25, 0.25], k=1)[0]\n\n    nxt = list(cur)\n\n    if move == \"ADD\" and len(available) > 0:\n        # bias by high gallons\/price density\n        densities = [(i, offers_gallons[i - 1] \/ offers_price[i - 1]) for i in available]\n        # sample top-k to keep randomness\n        densities.sort(key=lambda t: -t[1])\n        k = min(5, len(densities))\n        cand = [i for i, _ in densities[:k]]\n        nxt.append(random.choice(cand))\n    elif move == \"REMOVE\" and len(nxt) > 0:\n        # remove worst density currently selected if possible\n        dens_map = {i: offers_gallons[i - 1] \/ offers_price[i - 1] for i in nxt}\n        worst = min(nxt, key=lambda i: dens_map[i])\n        # with small probability remove random to escape local traps\n        if random.random() < 0.2:\n            nxt.pop(random.randrange(len(nxt)))\n        else:\n            nxt.remove(worst)\n    elif move == \"SWAP\" and len(nxt) > 0 and len(available) > 0:\n        # swap out low-density for high-density candidate\n        out_i = min(nxt, key=lambda i: offers_gallons[i - 1] \/ offers_price[i - 1])\n        densities = [(i, offers_gallons[i - 1] \/ offers_price[i - 1]) for i in available]\n        densities.sort(key=lambda t: -t[1])\n        k = min(5, len(densities))\n        in_i = random.choice([i for i, _ in densities[:k]])\n        # replace first occurrence of out_i\n        for pos, val in enumerate(nxt):\n            if val == out_i:\n                nxt[pos] = in_i\n                break\n    else:\n        # fallback toggle\n        i = random.randint(1, n)\n        if i in nxt:\n            nxt.remove(i)\n        else:\n            nxt.append(i)\n\n    # enforce uniqueness and bounds, preserve first occurrence order\n    seen2 = set()\n    cleaned = []\n    for x in nxt:\n        if 1 <= x <= n and x not in seen2:\n            seen2.add(x)\n            cleaned.append(x)\n\n    return cleaned, move\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply k random ADD\/REMOVE\/SWAP moves; maintain validity and uniqueness.\n    n = 24\n    cur = []\n    if isinstance(solution, list):\n        seen = set()\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    k = max(2, min(6, 1 + len(cur) \/\/ 3))\n    for _ in range(k):\n        available = [i for i in range(1, n + 1) if i not in cur]\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.45, 0.25, 0.30], k=1)[0]\n        if move == \"ADD\" and len(available) > 0:\n            cur.append(random.choice(available))\n        elif move == \"REMOVE\" and len(cur) > 0:\n            cur.pop(random.randrange(len(cur)))\n        elif move == \"SWAP\" and len(cur) > 0 and len(available) > 0:\n            pos = random.randrange(len(cur))\n            cur[pos] = random.choice(available)\n        else:\n            # toggle fallback\n            i = random.randint(1, n)\n            if i in cur:\n                cur.remove(i)\n            else:\n                cur.append(i)\n        # enforce uniqueness and bounds after each move\n        seen2 = set()\n        tmp = []\n        for x in cur:\n            if 1 <= x <= n and x not in seen2:\n                seen2.add(x)\n                tmp.append(x)\n        cur = tmp\n    return cur\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_SIG_SA:Invalid function signature. Remove callable invocations in parameters. Use def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor).\"\n\"E_SIG_ILS:Invalid function signature and misspelling. Use def ILS(solution, best_sol, best_score, generate_neighbour, perturb_solution, evaluate_solution, iterations, acceptance_rate).\"\n\"E_SIG_TS:Invalid function signature and naming. Use def TS(solution, best_sol, best_score, generate_neighbour, evaluate_solution, iterations, tabu_list_size, tabu_tenure).\"\n\"E_SIG_TARGET_MISMATCH:Align all heuristic signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE. Ensure argument positions and names match exactly for automated wiring.\"\n\"E_TYPE_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead' indicates runtime attempted to call typing.List or similar. Remove any instantiation of typing.List; use built-in list instead and avoid default params referencing typing objects.\"\n\"E_PERT_MISSING:Perturbation function undefined ('$Perturb'). Provide def perturb_solution(solution, intensity, rng) returning a valid neighbour after k random add\/remove\/swap operations.\"\n\"E_RET_NB:Neighbour function returns (solution, move) but most solvers expect only solution. Standardize to return solution; if move metadata is needed, expose a separate wrapper or update callers to unpack.\"\n\"E_REPR_INDEXING:KNOWN_SOLUTION provided uses 0-based indices; evaluation expects 1-based [1..24]. This causes infeasible-penalty returns. Normalize inputs to 1-based before evaluation or pre-validate and auto-correct.\"\n\"E_EVAL_KNOWN_CHECK:Evaluator correctness assertion against provided reference fails under 0-based input; passes after 1-based normalization. Add a pre-check test to reject or correct 0 values.\"\n\"E_CONSTRAINT_ENFORCEMENT:Feasibility penalty 1e9 + shortfall*1e6 is excessively large, causing acceptance to be dominated by infeasibility even for small shortfalls. Replace with adaptive penalty or feasibility-first acceptance in SA\/ILS\/TS.\"\n\"E_VALIDATION_COST:Per-evaluation structural validation is O(k) and repeated each iteration. For local moves, maintain incremental totals (cost, gallons) to achieve O(1) delta evaluation and validate only when structure changes (e.g., duplicates).\"\n\"E_CODE_PERF:Neighbour generation recomputes densities each call in O(n). Cache static densities (g_i\/c_i) and update only for availability changes; pre-sort indices once to O(n log n), then sample top-k via prefix of cached order.\"\n\"E_MOVE_SET_LIMITED:Single ADD\/REMOVE\/SWAP is weak for set-cover structure. Add k-exchange moves: 1-1, 2-1, and 2-2 exchanges guided by marginal density to escape plateaus.\"\n\"E_HEURISTIC_BIAS:Pure density bias can stall when nearing constraint threshold. Add marginal-gain heuristic: choose item i that minimizes delta_cost subject to reaching the next unmet gallon slack.\"\n\"E_ACCEPTANCE_SA:Cooling parameters unspecified. Use geometric cooling T_{t+1}=alpha*T_t with alpha in [0.90,0.99], stopping at MIN_TEMP; acceptance p=exp(-(delta)\/T). Clamp temperature to avoid underflow.\"\n\"E_ACCEPTANCE_ILS:Define acceptance on non-improving steps (e.g., accept if delta <= epsilon or random() < acceptance_rate) and include perturb intensity schedule (increase after stagnation).\"\n\"E_TABU_MEMORY:Define explicit tabu attributes (moves or items) and tenure. Store last-used items or swaps; aspiration allow override when candidate beats best_score. Avoid storing full solutions to reduce memory.\"\n\"E_STOPPING_CRITERIA:Missing. Add max_iterations, max_no_improve, and time_budget guards to prevent infinite runs in local solver.\"\n\"E_SAMPLING_STABILITY:Set RNG seed inside solvers via local Random instance to ensure reproducibility in tests without global side effects.\"\n\"E_FEASIBILITY_REPAIR:When infeasible, apply greedy repair: iteratively add item with best g_i\/c_i until constraint met. When feasible with slack, try removing the worst contributor if feasibility preserved.\"\n\"E_START_SOLUTION:Initialize via greedy cover (sort by g_i\/c_i and add until >= threshold) to guarantee feasibility and provide strong baseline; then apply local improvement with removals and exchanges.\"\n\"E_BOUNDING:Add Lagrangian-relaxation bound (lambda on gallons) to rank candidates during search and to guide add\/remove decisions; update lambda via subgradient on slack.\"\n\"E_UNIT_TESTS:Add tests: (1) index validation rejects 0 and >24; (2) duplicate indices rejected; (3) feasibility at threshold accepted; (4) incremental evaluation matches full evaluation after each move.\"\n\"E_BASELINE_VERIFICATION:Compute exact DP baseline (min-cost cover on gallons dimension) to validate heuristic outcomes during development. Compare heuristic cost against DP cost to assert correctness without exposing values at runtime.\"\n\"E_API_CONTRACT:Ensure all components avoid filesystem\/network\/OS calls per MAIN_CRITICAL_INSTRUCTION. All functions must be pure w.r.t. problem data and RNG provided.\"\n\"E_LOGGING:Local solver allows extra outputs; restrict to structured metrics per iteration: iter, score, gallons, move, temp\/tenure, no_improve. Avoid verbose prints to maintain performance.\"\n\"E_DOC_SIGNATURES:Document exact callable types in code: generate_neighbour: Callable[[List[int]], List[int]]; evaluate_solution: Callable[[List[int]], int]; perturb_solution: Callable[[List[int], int, random.Random], List[int]].\"\n\"E_DUP_REMOVAL:Neighbour cleanup currently preserves first occurrence but silently drops later duplicates. Prefer to prevent duplicates at move-time; if encountered, treat as invalid move and resample to avoid biased shortening.\"\n\"E_EDGE_CASES:Handle empty solution in REMOVE\/SWAP by resampling; handle full solution in ADD by forcing REMOVE\/SWAP. Ensure availability lists are updated after each modification.\"\n\"E_PARAMETER_TUNING:Expose TEMP, MIN_TEMP, cooling_factor; iterations, acceptance_rate; tabu_list_size, tabu_tenure via other_params dict per TARGET signature to allow uniform solver driver configuration.\"\n\"E_METRICS:Track and report feasibility ratio, average delta per move type, and exchange acceptance to identify stagnation; adjust perturbation intensity dynamically when no_improve exceeds threshold.\"\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n                return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","NB_CODE":"import random\nimport copy\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood over INDEX_LIST: random add, drop, or swap of indices in 1..24 without duplicates\n    n = 24\n    if not isinstance(solution, list):\n        solution = []\n    current = list(solution)\n    pool = set(range(1, n + 1))\n    in_set = set(current)\n\n    def do_add(sol: List[int]) -> List[int]:\n        choices = list(pool - set(sol))\n        if not choices:\n            return sol\n        idx = random.choice(choices)\n        ns = sol + [idx]\n        return ns\n\n    def do_drop(sol: List[int]) -> List[int]:\n        if not sol:\n            return sol\n        i = random.randrange(len(sol))\n        ns = sol[:i] + sol[i+1:]\n        return ns\n\n    def do_swap(sol: List[int]) -> List[int]:\n        if not sol:\n            return do_add(sol)\n        if len(sol) == n:\n            return do_drop(sol)\n        out_i = random.randrange(len(sol))\n        out_val = sol[out_i]\n        choices = list(pool - set(sol))\n        if not choices:\n            return sol\n        in_val = random.choice(choices)\n        ns = sol.copy()\n        ns[out_i] = in_val\n        return ns\n\n    move_types = [\"add\", \"drop\", \"swap\"]\n    # Bias to ensure valid action given boundary cases\n    if len(current) == 0:\n        move = \"add\"\n    elif len(current) >= n:\n        move = \"drop\"\n    else:\n        move = random.choices(move_types, weights=[0.4, 0.3, 0.3], k=1)[0]\n\n    if move == \"add\":\n        neighbor = do_add(current)\n    elif move == \"drop\":\n        neighbor = do_drop(current)\n    else:\n        neighbor = do_swap(current)\n\n    # Guarantee a change; fallback attempts\n    attempts = 0\n    while neighbor == current and attempts < 5:\n        move = random.choice(move_types)\n        if move == \"add\":\n            neighbor = do_add(current)\n        elif move == \"drop\":\n            neighbor = do_drop(current)\n        else:\n            neighbor = do_swap(current)\n        attempts += 1\n\n    return neighbor, \"INDEX_LIST\", move\n","PERTURB_CODE":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: perform k random add\/drop\/swap operations\n    n = 24\n    if not isinstance(solution, list):\n        solution = []\n    sol = list(solution)\n\n    def add_once(sol: List[int]) -> List[int]:\n        pool = set(range(1, n + 1))\n        choices = list(pool - set(sol))\n        if not choices:\n            return sol\n        sol = sol + [random.choice(choices)]\n        return sol\n\n    def drop_once(sol: List[int]) -> List[int]:\n        if not sol:\n            return sol\n        i = random.randrange(len(sol))\n        return sol[:i] + sol[i+1:]\n\n    def swap_once(sol: List[int]) -> List[int]:\n        pool = set(range(1, n + 1))\n        if not sol:\n            return add_once(sol)\n        if len(sol) == n:\n            return drop_once(sol)\n        out_i = random.randrange(len(sol))\n        out_val = sol[out_i]\n        choices = list(pool - set(sol))\n        if not choices:\n            return sol\n        in_val = random.choice(choices)\n        new_sol = sol.copy()\n        new_sol[out_i] = in_val\n        return new_sol\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"])\n        if move == \"add\":\n            sol = add_once(sol)\n        elif move == \"drop\":\n            sol = drop_once(sol)\n        else:\n            sol = swap_once(sol)\n\n    # Deduplicate and keep as list preserving order of first occurrence\n    seen = set()\n    cleaned = []\n    for x in sol:\n        if x not in seen and 1 <= x <= n:\n            cleaned.append(x)\n            seen.add(x)\n    return cleaned\n","SAMPLE_SOL":"[5,9,13,21]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_TYPE_HINT_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates misuse of typing generics. Replace all uses of 'List()', 'Dict()', 'Set()' with built-in 'list()', 'dict()', 'set()'. Do not instantiate from 'typing'.\nE_HEUR_SIG_MISMATCH_SA:Signatures shown include parentheses on function parameters (e.g., 'generate_neighbour()'). Parameters must be function objects, not calls. Correct to: def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor).\nE_HEUR_SIG_MISMATCH_ILS:Current signature lists 'perturb_solution()' and parentheses on others. Correct to: def ILS(solution, best_sol, best_score, generate_neighbour, perturb_solution, evaluate_solution, iterations, acceptance_rate).\nE_HEUR_SIG_MISMATCH_TS:Remove parentheses in parameter list. Correct to: def TS(solution, best_sol, best_score, generate_neighbour, evaluate_solution, iterations, taboo_list_size, taboo_duration).\nE_PERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb'). Provide a concrete implementation. Ex: swap-k with re-add\/remove: choose k in [2,4], perform 1\u20132 drops and 1\u20132 adds from remaining pool; ensure deduplication; return valid INDEX_LIST.\nE_IFACE_NEIGHBOR_RETURN:generate_neighbour returns (neighbor, 'INDEX_LIST', move). Ensure all heuristics unpack accordingly. If heuristics expect only the neighbor, wrap adapter or change return to (neighbor, move) consistently and pass representation via other_params.\nE_REP_INDEX_BASE:Representation is 1..24 (inclusive), but provided 'KNOWN_SOLUTION' appears 0-based. Standardize all IO to 1-based to match evaluator and sample solution, or convert at boundary.\nE_EVAL_CORRECTNESS_ASSERTION:Evaluator validated feasible vs infeasible and returns cost; cross-checked via independent exact DP shows current 'reference solution\/value' pair is inconsistent with the evaluator. Recompute the reference with the evaluator and update the test oracle; do not rely on stale values.\nE_OBJ_EVAL_ALIGNMENT:objective_function and evaluate_solution both sum identical costs but only the latter checks feasibility. Ensure all heuristics use evaluate_solution, not objective_function, to avoid accepting infeasible selections.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood includes only add\/drop\/swap at random; lacks intensity control and often stalls. Add steepest\/first-improvement local search using multi-add\/drop trials or pair-swap (2-swap) to escape shallow basins.\nR_STR_INADEQUATE:INDEX_LIST with pure random moves causes poor exploration on cover constraints. Add ratio-guided biased selection: prioritize additions by increasing price-per-gallon (c_i\/g_i) and removals by decreasing marginal utility.\nE_CODE_PERF:Each evaluation re-aggregates O(k) per neighbor. Implement delta evaluation: maintain (total_cost,total_gallons) and update in O(1) for add\/drop\/swap to reduce runtime by ~10\u2013100x under SA\/TS.\nE_SA_SCHEME:Cooling lacks specification. Use geometric schedule with reheats: TEMP0 set via acceptance of cost delta target p0 (e.g., TEMP0 = -\u0394\/ln(p0)), MIN_TEMP such that acceptance of worst \u0394_min ~ 0.01, cooling_factor in [0.90,0.99], iterations per temperature proportional to |solution|.\nE_TS_TABU_DEF:Tabu tenure undefined. Use recency-based tabu on indices for add\/drop (tenure ~ [7, 15]) and aspiration if a move yields a global best. Maintain tabu list as fixed-size queue keyed by moved indices.\nE_ILS_ACCEPT:Acceptance misspelled ('aceptance_rate') and unspecified. Define acceptance_rate in [0.05,0.20] for worse solutions; use kick perturbation every L local optima stalls, with L ~ 50\u2013200 iterations based on n.\nE_FEAS_REPAIR:No feasibility repair. Add greedy repair when total_gallons < 67: iteratively add items with best c_i\/g_i until feasible; for reduction when heavily overfilled, drop worst g_i\/c_i while keeping feasibility.\nE_STOPPING:No termination criteria provided. Add time\/iteration budget and stall counters per heuristic; e.g., SA stops after no improvement in T temperatures; TS stops after I iterations without improvement.\nE_TEST_COVERAGE:Unit tests missing for: (a) duplicate index rejection, (b) out-of-range indices, (c) 0-based input conversion, (d) neighbor validity invariants. Add tests to assert evaluator returns penalties for each invalid case.\nE_BASELINE_OPT:Provide exact solver baseline for regression. Implement DP for minimum-cost cover to at least 67 gallons; verify heuristic outputs within small optimality gap; use it to validate changes.\nS_CONCRETE_IMPROVEMENTS_1:Implement dp_min_cost_cover(offers_price, offers_gallons, target=67) to compute optimal value and a certificate set; use to auto-validate local solver and update 'EXPECTED_SCORE'.\nS_CONCRETE_IMPROVEMENTS_2:Add deterministic greedy init: sort by c_i\/g_i ascending and add until feasible; then local prune (try dropping any single index that preserves feasibility). Use as SA\/TS\/ILS starting point.\nS_CONCRETE_IMPROVEMENTS_3:Augment neighborhood with 2-opt style pair move: try removing one index and adding one non-selected index; accept improving or probabilistic via SA; this meaningfully changes gallons while controlling cost.\nS_CONCRETE_IMPROVEMENTS_4:Cache price and gallons in arrays; avoid recomputing sets inside neighbor generator; precompute pool once; prefer random.randrange and preallocated lists to lower overhead.\nS_CONCRETE_IMPROVEMENTS_5:Normalize interfaces to TARGET_HEURISTIC_GENERAL_SIGNATURE. Pass functions as objects; include other_params dict with all hyperparameters to avoid signature drift across heuristics.\nE_LOGGING:Local solver expects extra outputs. Standardize return: (best_solution, best_score, meta) where meta includes trace of moves, temperatures, and feasibility flags; ensure types are JSON-serializable.\nE_SEED_REPRO:No RNG control. Add 'seed' in other_params, set random.seed(seed) at run start to reproduce results across runs.\nE_DOC_GAP:Document 1-based indexing, feasibility threshold (67), penalty scheme, and neighbor return format in module-level constants to prevent future mismatches.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood over INDEX_LIST: random biased add\/drop\/swap, 1-based indices in [1..24]\n    n = 24\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = list(solution)\n    pool = set(range(1, n + 1))\n\n    # Heuristic bias by price-per-gallon for adds (cheaper better) and for drops (worse removed first)\n    prices = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n\n    def ratio(i):\n        return prices[i - 1] \/ float(gallons[i - 1])\n\n    def do_add(sol):\n        choices = list(pool - set(sol))\n        if not choices:\n            return sol\n        # bias towards lower price-per-gallon\n        choices.sort(key=ratio)\n        k = min(5, len(choices))\n        pick = random.choice(choices[:k])\n        return sol + [pick]\n\n    def do_drop(sol):\n        if not sol:\n            return sol\n        # drop item with highest price-per-gallon with some randomness among top-k\n        ranked = sorted(sol, key=ratio, reverse=True)\n        k = min(3, len(ranked))\n        out = random.choice(ranked[:k])\n        idx = sol.index(out)\n        return sol[:idx] + sol[idx + 1:]\n\n    def do_swap(sol):\n        if not sol:\n            return do_add(sol)\n        if len(sol) == n:\n            return do_drop(sol)\n        out_candidates = sorted(sol, key=ratio, reverse=True)\n        out = random.choice(out_candidates[:min(3, len(out_candidates))])\n        remaining = list(pool - set(sol))\n        if not remaining:\n            return sol\n        remaining.sort(key=ratio)\n        inn = random.choice(remaining[:min(5, len(remaining))])\n        new_sol = sol.copy()\n        pos = new_sol.index(out)\n        new_sol[pos] = inn\n        return new_sol\n\n    move_types = [\"add\", \"drop\", \"swap\"]\n    if len(current) == 0:\n        move = \"add\"\n    elif len(current) >= n:\n        move = \"drop\"\n    else:\n        move = random.choices(move_types, weights=[0.5, 0.2, 0.3], k=1)[0]\n\n    if move == \"add\":\n        neighbor = do_add(current)\n    elif move == \"drop\":\n        neighbor = do_drop(current)\n    else:\n        neighbor = do_swap(current)\n\n    # ensure change\n    attempts = 0\n    while neighbor == current and attempts < 5:\n        move = random.choice(move_types)\n        if move == \"add\":\n            neighbor = do_add(current)\n        elif move == \"drop\":\n            neighbor = do_drop(current)\n        else:\n            neighbor = do_swap(current)\n        attempts += 1\n\n    # deduplicate while preserving order and validity\n    seen = set()\n    cleaned = []\n    for x in neighbor:\n        if x not in seen and 1 <= x <= n:\n            cleaned.append(x)\n            seen.add(x)\n\n    return (cleaned, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger shake: perform k random add\/drop\/swap operations with bias\n    n = 24\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = list(solution)\n\n    prices = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n\n    def ratio(i):\n        return prices[i - 1] \/ float(gallons[i - 1])\n\n    def add_once(sol):\n        choices = list(set(range(1, n + 1)) - set(sol))\n        if not choices:\n            return sol\n        choices.sort(key=ratio)\n        pick = random.choice(choices[:min(6, len(choices))])\n        return sol + [pick]\n\n    def drop_once(sol):\n        if not sol:\n            return sol\n        ranked = sorted(sol, key=ratio, reverse=True)\n        out = random.choice(ranked[:min(4, len(ranked))])\n        i = sol.index(out)\n        return sol[:i] + sol[i + 1:]\n\n    def swap_once(sol):\n        if not sol:\n            return add_once(sol)\n        if len(sol) == n:\n            return drop_once(sol)\n        out_candidates = sorted(sol, key=ratio, reverse=True)\n        out = random.choice(out_candidates[:min(4, len(out_candidates))])\n        remaining = list(set(range(1, n + 1)) - set(sol))\n        if not remaining:\n            return sol\n        remaining.sort(key=ratio)\n        inn = random.choice(remaining[:min(6, len(remaining))])\n        new_sol = sol.copy()\n        pos = new_sol.index(out)\n        new_sol[pos] = inn\n        return new_sol\n\n    k = random.randint(3, 7)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"])\n        if move == \"add\":\n            sol = add_once(sol)\n        elif move == \"drop\":\n            sol = drop_once(sol)\n        else:\n            sol = swap_once(sol)\n\n    # Clean and validate\n    seen = set()\n    cleaned = []\n    for x in sol:\n        if x not in seen and 1 <= x <= n:\n            cleaned.append(x)\n            seen.add(x)\n    return cleaned\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0.3\"\n\"FEEDBACK\":\n\"E_FIX_SIG_NEIGH:generate_neighbour must return exactly 2 values (neighbor, move). Remove the third 'INDEX_LIST' tag. Current 3-tuple causes 'too many values to unpack' in SA\/ILS.\"\n\"E_FIX_SIG_PASSING:Do not call functions in heuristic signatures. Pass function objects, not generate_neighbour(). SA\/ILS\/TS should receive generate_neighbour, evaluate_solution, perturb_solution as callables.\"\n\"E_FIX_TS_ARITY:Ensure all code paths in generate_neighbour return (neighbor, move). A single-value return triggers 'expected 2, got 1' in TS.\"\n\"E_FIX_PERTURB_MISSING:Perturbation Function is undefined. Add perturb_solution(solution, intensity) that performs multi-swap\/multi-add\/drop to escape local minima.\"\n\"E_IDX_BASE_MISMATCH:All indices must be 1..24. Any reference solutions using 0-based indices violate validation. Standardize to 1-based across components.\"\n\"E_EVAL_OBJ_INCONSISTENCY:objective_function ignores feasibility while evaluate_solution penalizes it. Use evaluate_solution consistently for search and acceptance to prevent infeasible-biased selection.\"\n\"E_LOCAL_ASSERT:Evaluation validated locally against the reference after correcting index base; assertion passes. Maintain 1-based indexing to avoid false penalties.\"\n\"E_NB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to single add\/drop\/swap. Add pair-exchange (drop two, add one and vice versa) and cost-effective swaps to improve local optimality depth.\"\n\"E_REPAIR_MISSING:No feasibility repair. Add greedy repair that adds cheapest price-per-gallon items until gallons >= 67; add clean-up that drops redundant items while maintaining feasibility.\"\n\"E_COST_HEURISTIC_DRIFT:Ratio bias alone can trap in local minima. Introduce occasional anti-greedy moves (epsilon exploration) and adaptive bias based on marginal cost contribution.\"\n\"E_CODE_PERF:Sorting candidate lists every call is O(n log n). Precompute ratios once and maintain two ordered pools; use reservoir\/partial selection to achieve amortized O(1)-O(log n) sampling.\"\n\"E_DUP_CHECK:Current dedup is post-hoc. Prevent duplicates at operator level; operate on sets plus preserved order list to avoid repeated cleanup.\"\n\"E_INIT_FEASIBILITY:Sample solution is feasible, but pipeline should enforce feasibility at start. If initial solution infeasible, run repair immediately.\"\n\"E_SA_PARAMS:Cooling not specified; use geometric cooling with calibrated alpha (e.g., 0.95) and reheating on stagnation. Scale temperature to median improving move cost to balance acceptance.\"\n\"E_ILS_ACCEPT:Define acceptance for worse solutions (e.g., accept if within tau% of best or probabilistic) to avoid premature convergence.\"\n\"E_TS_MEMORY:Clarify tabu attributes (indices added\/removed, tenure). Track both added and dropped items; aspiration if move improves best_score.\"\n\"E_TESTS_IO:Add unit tests for return arity and types for all components. Validate that evaluate_solution(solution) returns finite cost for feasible and penalty for infeasible.\"\n\"E_CONSTRAINT_SCALING:Penalty 1e9 + 1e6*shortfall may dwarf objective gradients. Keep but enable dynamic penalty to balance feasibility drive early vs. fine-tuning later.\"\n\"R_PERTURB_SPEC:Implement perturb_solution as k-perturb (k sampled from {2,3,4}): drop top-k ratio items, then greedily add best ratio items; finalize with repair and local improvement.\"\n\"R_NEIGH_SPEC:Revise generate_neighbour to return (neighbor, move). Add operators: (swap2) swap two out two in; (drop_add) drop worst then add best non-selected; include epsilon=0.1 random pick among full pool.\"\n\"R_REPAIR_SPEC:repair(solution): while gallons<67 add best ratio from remaining; then while feasible try dropping worst ratio items that keep gallons>=67.\"\n\"R_OBJ_USE:evaluate_solution must be the sole fitness used by SA\/ILS\/TS. Remove direct calls to objective_function in search loops.\"\n\"R_CACHE_RATIO:Precompute ratio = price\/gallons once; store arrays for fast lookup; avoid per-call sorting by using heap of remaining candidates.\"\n\"R_TS_TABU:Use tabu list on indices moved with tenure ~7; aspiration override if move improves best_score. Maintain recency and frequency to diversify.\"\n\"R_SA_INIT_TEMP:Set initial temperature to accept ~80% of +delta median costs; estimate delta via sampling 100 random neighbors.\"\n\"R_ILS_PERTURB_INTENSITY:Adapt k based on stagnation length; increase k when no improvement in L iterations.\"\n\"R_VALIDATION:Property tests: (1) no duplicates, (2) indices in [1,24], (3) neighbor differs from current, (4) repair returns feasible, (5) move application preserves type.\"\n\"R_LOGGING_MIN:Log tuple (iter, best_score, curr_score, move, feas_flag) only; avoid verbose prints to keep performance deterministic.\"\n\"R_EDGE_CASES:Handle empty and full solutions explicitly in operators; ensure swap path always alters solution.\"\n\"R_EXACT_CHECK:Add a deterministic DP\/meet-in-the-middle checker to verify best_score after run for correctness on this small instance.\"\n\"R_CODE_SNIPPETS_COMPLIANT:All provided code must avoid filesystem\/network\/OS calls per MAIN_CRITICAL_INSTRUCTION.\"\n\"R_REFERENCE_IMPL\":\n\"def generate_neighbour(solution):\\n    import random\\n    n=24\\n    prices=[19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\\n    gallons=[11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\\n    ratio=[p\/g for p,g in zip(prices,gallons)]\\n    cur=list(solution) if isinstance(solution,list) else []\\n    pool=set(range(1,n+1))\\n    def add(sol):\\n        rem=sorted(list(pool-set(sol)), key=lambda i: ratio[i-1])\\n        if not rem: return sol\\n        k=min(5,len(rem))\\n        pick=random.choice(rem[:k])\\n        return sol+[pick]\\n    def drop(sol):\\n        if not sol: return sol\\n        ranked=sorted(sol, key=lambda i: ratio[i-1], reverse=True)\\n        k=min(3,len(ranked))\\n        out=random.choice(ranked[:k])\\n        sol2=sol.copy(); sol2.remove(out); return sol2\\n    def swap(sol):\\n        if not sol: return add(sol)\\n        rem=list(pool-set(sol))\\n        if not rem: return drop(sol)\\n        out=max(sol, key=lambda i: ratio[i-1])\\n        inn=min(rem, key=lambda i: ratio[i-1])\\n        sol2=sol.copy(); sol2[sol2.index(out)]=inn; return sol2\\n    move = 'add' if len(cur)==0 else random.choices(['add','drop','swap'],[0.5,0.2,0.3])[0]\\n    nb = add(cur) if move=='add' else drop(cur) if move=='drop' else swap(cur)\\n    # ensure change and validity, dedup\\n    nb=list(dict.fromkeys([x for x in nb if 1<=x<=n]))\\n    if nb==cur:\\n        nb=add(cur) if move!='add' else swap(cur)\\n        nb=list(dict.fromkeys([x for x in nb if 1<=x<=n]))\\n    return nb, move\"\n\"def perturb_solution(solution, intensity=3):\\n    import random\\n    n=24\\n    prices=[19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\\n    gallons=[11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\\n    ratio=[p\/g for p,g in zip(prices,gallons)]\\n    cur=list(solution)\\n    k=max(2,int(intensity))\\n    if cur:\\n        cur=sorted(cur, key=lambda i: ratio[i-1], reverse=True)[k:] or cur[:max(0,len(cur)-k)]\\n    pool=set(range(1,n+1))\\n    rem=sorted(list(pool-set(cur)), key=lambda i: ratio[i-1])\\n    for i in rem[:k]:\\n        cur.append(i)\\n    # dedup and clamp\\n    cur=list(dict.fromkeys([x for x in cur if 1<=x<=n]))\\n    return cur\"\n\"def evaluate_solution(solution):\\n    prices=[19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\\n    gallons=[11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\\n    if not isinstance(solution,list): return 10**12\\n    seen=set(); cost=0; gal=0; n=len(prices)\\n    for idx in solution:\\n        if not isinstance(idx,int) or idx<1 or idx>n or idx in seen: return 10**12\\n        seen.add(idx); cost+=prices[idx-1]; gal+=gallons[idx-1]\\n    return cost if gal>=67 else cost+10**9+(67-gal)*10**6\"\n\"R_VALIDATION_ASSERTS:Add quick asserts: shape(generate_neighbour)==2, type(neighbor)==list, all 1<=idx<=24, unique, evaluate_solution(neighbor) finite.\"\n\"R_POSTRUN_CHECK:After run, cross-verify best with exact solver (DP) for this small instance to ensure implementation correctness without revealing the reference value.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    n = len(prices)\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    cost = 0\n    gal = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 10**12\n        seen.add(idx)\n        cost += prices[idx - 1]\n        gal += gallons[idx - 1]\n    if gal >= 67:\n        return cost\n    shortfall = 67 - gal\n    return cost + 10**9 + shortfall * 10**6\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_list, move_type)\n    n = 24\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    ratio = [p \/ g for p, g in zip(prices, gallons)]\n\n    cur = list(solution) if isinstance(solution, list) else []\n    pool = set(range(1, n + 1))\n\n    def add_once(sol):\n        rem = list(pool - set(sol))\n        if not rem:\n            return sol\n        rem.sort(key=lambda i: ratio[i - 1])\n        k = min(5, len(rem))\n        pick = random.choice(rem[:k])\n        return sol + [pick]\n\n    def drop_once(sol):\n        if not sol:\n            return sol\n        ranked = sorted(sol, key=lambda i: ratio[i - 1], reverse=True)\n        k = min(3, len(ranked))\n        out = random.choice(ranked[:k])\n        sol2 = sol.copy()\n        sol2.remove(out)\n        return sol2\n\n    def swap_once(sol):\n        if not sol:\n            return add_once(sol)\n        rem = list(pool - set(sol))\n        if not rem:\n            return drop_once(sol)\n        out = max(sol, key=lambda i: ratio[i - 1])\n        inn = min(rem, key=lambda i: ratio[i - 1])\n        sol2 = sol.copy()\n        pos = sol2.index(out)\n        sol2[pos] = inn\n        return sol2\n\n    # Additional mixed operator: drop worst then add best\n    def drop_add(sol):\n        return add_once(drop_once(sol))\n\n    if len(cur) == 0:\n        move = 'add'\n    elif len(cur) >= n:\n        move = 'drop'\n    else:\n        move = random.choices(['add', 'drop', 'swap', 'drop_add'], [0.45, 0.2, 0.25, 0.10])[0]\n\n    if move == 'add':\n        nb = add_once(cur)\n    elif move == 'drop':\n        nb = drop_once(cur)\n    elif move == 'swap':\n        nb = swap_once(cur)\n    else:\n        nb = drop_add(cur)\n\n    # ensure change and validity\n    attempts = 0\n    while nb == cur and attempts < 5:\n        move = random.choice(['add', 'drop', 'swap'])\n        if move == 'add':\n            nb = add_once(cur)\n        elif move == 'drop':\n            nb = drop_once(cur)\n        else:\n            nb = swap_once(cur)\n        attempts += 1\n\n    # deduplicate and clamp\n    seen = set()\n    cleaned = []\n    for x in nb:\n        if 1 <= x <= n and x not in seen:\n            cleaned.append(x)\n            seen.add(x)\n\n    return cleaned, move\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    ratio = [p \/ g for p, g in zip(prices, gallons)]\n\n    sol = list(solution) if isinstance(solution, list) else []\n\n    k = random.randint(3, 6)\n    # Drop top-k worst ratio items (if exist)\n    if sol:\n        ranked = sorted(sol, key=lambda i: ratio[i - 1], reverse=True)\n        drop_k = min(k, len(ranked))\n        to_keep = set(ranked[drop_k:])\n        sol = [i for i in sol if i in to_keep]\n\n    # Add k best from remaining\n    remaining = sorted(list(set(range(1, n + 1)) - set(sol)), key=lambda i: ratio[i - 1])\n    for i in remaining[:k]:\n        sol.append(i)\n\n    # Final cleanup: dedup and clamp\n    seen = set()\n    cleaned = []\n    for x in sol:\n        if 1 <= x <= n and x not in seen:\n            cleaned.append(x)\n            seen.add(x)\n    return cleaned\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_PERTURB_UNDEFINED: 'Perturbation Function' is '$Perturb' (undefined). Define a deterministic, parameterized perturbation that preserves feasibility or includes a repair step.\"\n\"FEEDBACK\",\"E_TS_SIG_MISMATCH: Taboo_Search signature expects generate_neighbour() returning 1 value, but current neighbor returns (neighbor, move). Standardize: either (a) change TS to unpack 2-tuple, or (b) change generate_neighbour to return only neighbor.\"\n\"FEEDBACK\",\"E_TS_RUNTIME: 'not enough values to unpack (expected 2, got 1)' indicates immediate failure; fix interface and add unit tests: assert isinstance(nb, list) and len(nb)>=0.\"\n\"FEEDBACK\",\"E_INIT_MISSING: No constructive initializer provided. SA\/ILS start from weak seeds; add greedy-by-price-per-gallon initializer to satisfy >=67 gallons with minimal incremental cost.\"\n\"FEEDBACK\",\"E_FEAS_REPAIR_ABSENT: Moves can create infeasible solutions; lack of repair leads to penalty-dominated search. Add repair: if gallons<67 then iteratively add lowest price-per-gallon items until feasible; if feasible, try dropping redundant items with lowest marginal benefit-cost ratio.\"\n\"FEEDBACK\",\"E_PENALTY_SCALE: Fixed penalty 1e9 + 1e6*shortfall overwhelms objective and destabilizes SA acceptance. Replace with adaptive penalty \u03bb updated by feasibility rate (e.g., \u03bb <- \u03bb*1.05 when feasible rate>target else \u03bb\/1.05) and use cost + \u03bb*max(0,67-gal).\"\n\"FEEDBACK\",\"E_NEIGH_GREEDY_BIAS: swap_once deterministically removes worst ratio and inserts best remainder, collapsing diversity. Introduce stochastic ranking or sample-k candidates and pick with softmax on ratio to balance exploration.\"\n\"FEEDBACK\",\"E_NEIGH_SCOPE_LIMITED: Single add\/drop\/swap too myopic. Add compound operators: add2, drop2, swap2, and 'drop_repair' (drop worst until just-feasible) to escape plateaus.\"\n\"FEEDBACK\",\"E_SA_CONFIG: SA output shows feasible cost far from achievable; likely temperature\/cooling too aggressive or step count too low. Use geometric cooling T<-\u03b1T with \u03b1\u2208[0.95,0.99], length L\u221dn per temperature, and reheating on stagnation.\"\n\"FEEDBACK\",\"E_ILS_WEAK_PERTURB: ILS returns high-penalty incumbents; perturbation likely breaks feasibility without repair. Use bounded-k random swaps plus immediate repair, then run strong local search to feasibility-optimality.\"\n\"FEEDBACK\",\"E_OUTPUT_PROTO: Heuristic returns heterogeneous tuples across methods. Standardize: return (best_feasible_solution, best_feasible_score, best_overall_solution, best_overall_score, meta) where meta may include trace; document and enforce in tests.\"\n\"FEEDBACK\",\"E_REF_INCONSISTENT: Reference benchmark solution is non-tight under the provided evaluator; cheaper feasible subsets exist. Do not use it to guide acceptance\/termination; rely on evaluator + lower-bound checks.\"\n\"FEEDBACK\",\"E_INDEX_BASE: Known reference uses 0-based indices; evaluator uses 1-based. Normalize consistently at boundaries and assert: min(sol)>=1 and max(sol)<=n.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Operators lack targeted 'redundant-drop' local search. Add post-processing: while feasible, try dropping one element that keeps feasibility and reduces cost; iterate greedily by smallest coverage loss per cost.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Index list is fine, but lack of fast membership ops slows neighborhood. Maintain both list (order) and bitset\/bool array for O(1) membership and delta updates.\"\n\"FEEDBACK\",\"E_CODE_PERF: evaluate_solution is O(k) per call. Implement delta evaluation caching cost and gallons; update in O(1) per add\/drop\/swap; recompute only on repair.\"\n\"FEEDBACK\",\"E_TESTS_MISSING: No unit tests for feasibility, penalties, index normalization, or neighbor validity. Add tests: empty set infeasible; single invalid index -> penalty; duplicate indices -> penalty; repair achieves feasibility.\"\n\"FEEDBACK\",\"S_FIX_TS: Update TS to accept (nb, move). Tabu on attributes: store last-m moves (e.g., dropped indices) with tenure; aspiration if candidate improves best. Include intensification: periodic redundant-drop descent.\"\n\"FEEDBACK\",\"S_INIT_GREEDY: Build initial solution by sorting by price\/gallon ascending and adding until gallons\u226567; then perform redundant-drop prune pass.\"\n\"FEEDBACK\",\"S_REPAIR_FUNC: Implement repair(solution): while gallons<67 add argmin_i price\/gallon among not-selected; then prune redundant elements greedily to reduce cost.\"\n\"FEEDBACK\",\"S_NEIGH_ADV: Add 2-opt-like pair-swap: replace two selected with two unselected minimizing delta cost subject to feasibility via repair; sample limited subsets for efficiency.\"\n\"FEEDBACK\",\"S_SA_ACCEPT: Use Metropolis on penalized cost with adaptive \u03bb; maintain best_feasible separately; accept uphill moves with p=exp(-(\u0394f)\/T).\"\n\"FEEDBACK\",\"S_ILS: Local search = first-improvement hill-climb with moves {drop, swap, add+repair}. Perturbation = random drop r\u2208[1,3] followed by repair; iterate with acceptance if best_feasible improves.\"\n\"FEEDBACK\",\"S_TRACE: Log per-iter (cost, gallons, feasible_flag) to detect penalty dominance; terminate on max no-improve iters or time.\"\n\"FEEDBACK\",\"VERIFICATION_STATUS: Evaluator validated against a separate reference; outputs consistent. However, current solver results are dominated by much cheaper feasible solutions, confirming algorithmic deficiencies.\"\n\"FEEDBACK\",\"COMPATIBILITY_GUARD: Ensure no functions access filesystem\/network\/OS; keep determinism via seeded RNG in tests (random.seed).\"\n\"FEEDBACK\",\"ACTION_ITEMS: (1) Define perturb_solution with repair; (2) Fix TS neighbor interface; (3) Add greedy initializer + redundant-drop; (4) Implement adaptive penalty; (5) Add delta evaluation; (6) Standardize outputs and tests.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","Componentes":{"REPRESENTATION":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","EVAL_CODE":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness = total revenue if gallons >= 67 and indices valid & unique; else revenue plus penalties.\n    Lower is better. SOL_TYPE=INDEX_LIST (1-based).\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    # Type check\n    if not isinstance(solution, (list, tuple)):\n        return float('inf')\n\n    # Count duplicates and invalids\n    seen = set()\n    dup_count = 0\n    invalid_count = 0\n    cleaned = []\n    for idx in solution:\n        if not isinstance(idx, int):\n            invalid_count += 1\n            continue\n        if not (1 <= idx <= n):\n            invalid_count += 1\n            continue\n        if idx in seen:\n            dup_count += 1\n            continue\n        seen.add(idx)\n        cleaned.append(idx)\n\n    # Objective components\n    revenue = 0\n    total_gallons = 0\n    for idx in cleaned:\n        revenue += prices[idx - 1]\n        total_gallons += gallons[idx - 1]\n\n    # Constraint and validity penalties\n    required = 67\n    shortage = max(0, required - total_gallons)\n\n    # Penalty scheme (dominates any feasible revenue):\n    PENALTY_BASE = 10**9\n    penalty = 0\n    if invalid_count > 0 or dup_count > 0 or shortage > 0:\n        penalty += PENALTY_BASE\n        # Add proportional components for diagnostics and to strictly order infeasible solutions\n        penalty += 10**6 * invalid_count\n        penalty += 10**3 * dup_count\n        penalty += 10**5 * shortage\n\n    return float(revenue + penalty)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    \"\"\"\n    Generate a valid neighboring solution for INDEX_LIST (1-based unique indices for 1..24).\n    Returns: (neighbor_solution, \"INDEX_LIST\", movement_type)\n    movement_type in {\"add\",\"remove\",\"swap\"}.\n    \"\"\"\n    n = 24\n    # Sanitize input to a unique valid list within 1..n\n    base: List[int] = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                base.append(v)\n    # Decide movement\n    if len(base) == 0:\n        # must add\n        available = [i for i in range(1, n + 1)]\n        choice = random.choice(available)\n        neighbor = [choice]\n        move = \"add\"\n    elif len(base) == n:\n        # must remove\n        idx = random.randrange(len(base))\n        neighbor = base.copy()\n        neighbor.pop(idx)\n        move = \"remove\"\n    else:\n        move = random.choice([\"add\", \"remove\", \"swap\"])  # balanced moves\n        neighbor = base.copy()\n        if move == \"add\":\n            missing = list(sorted(set(range(1, n + 1)) - set(base)))\n            if missing:\n                neighbor.append(random.choice(missing))\n        elif move == \"remove\":\n            if neighbor:\n                idx = random.randrange(len(neighbor))\n                neighbor.pop(idx)\n        else:  # swap\n            missing = list(sorted(set(range(1, n + 1)) - set(base)))\n            if neighbor and missing:\n                out_idx = random.randrange(len(neighbor))\n                in_val = random.choice(missing)\n                neighbor[out_idx] = in_val\n    # Ensure uniqueness and validity\n    uniq = []\n    seen = set()\n    for v in neighbor:\n        if 1 <= int(v) <= n and v not in seen:\n            seen.add(v)\n            uniq.append(int(v))\n    return (uniq, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: apply 2-5 random neighborhood moves while keeping indices in 1..24 and unique.\n    Returns a new valid INDEX_LIST solution (1-based, unique order preserved as modified).\n    \"\"\"\n    n = 24\n    # sanitize\n    cur: List[int] = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                cur.append(v)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        if len(cur) == 0:\n            # add\n            missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n            if missing:\n                cur.append(random.choice(missing))\n            continue\n        if len(cur) == n:\n            # remove\n            cur.pop(random.randrange(len(cur)))\n            continue\n        move = random.choice([\"add\", \"remove\", \"swap\"]) \n        if move == \"add\":\n            missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n            if missing:\n                cur.append(random.choice(missing))\n        elif move == \"remove\":\n            if cur:\n                cur.pop(random.randrange(len(cur)))\n        else:  # swap\n            missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n            if cur and missing:\n                out_idx = random.randrange(len(cur))\n                cur[out_idx] = random.choice(missing)\n    # final cleanup uniqueness\n    seen = set()\n    uniq = []\n    for v in cur:\n        if 1 <= int(v) <= n and v not in seen:\n            seen.add(v)\n            uniq.append(int(v))\n    return uniq\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-local-solver-fix-priority\"\n\"FEEDBACK\":\"ERR_LOCAL_SOLVER_TYPE_INSTANTIATION:Using typing.List() at runtime causes 'Type List cannot be instantiated'. Replace all List() usages with list() and keep typing imports for annotations only. ERR_SIGNATURE_CALLABLES:Heuristics pass generate_neighbour(), evaluate_solution(), perturb_solution() with parentheses; pass function objects (generate_neighbour, evaluate_solution, perturb_solution) per TARGET_HEURISTIC_GENERAL_SIGNATURE. ERR_SIGNATURE_MISMATCH_SA_ILS_TS:Align all heuristic signatures to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params); remove hard-coded SA\/ILS\/TS bespoke signatures or provide thin adapters. ERR_NEIGHBOUR_API:generate_neighbour returns (neighbor,'INDEX_LIST',move); if heuristics expect just a solution, this tuple breaks evaluation. Standardize to return only neighbor or update heuristics to unpack. ERR_KNOWN_SOLUTION_INDEXING:Provided known solution violates 1-based INDEX_LIST and includes invalid indices; under EVAL_CODE it is infeasible and gets penalized, so the provided expected score is inconsistent with current specs. Correct the known solution to 1-based valid unique indices or update specs\/penalties. ERR_OBJECTIVE_INCONSISTENCY:objective_function silently drops invalids and ignores the gallon constraint; using it anywhere in acceptance or reporting desynchronizes from EVAL_CODE. Use evaluate_solution exclusively, or mirror its feasibility logic in objective_function. ERR_CONSTRAINT_SCORING:Single huge PENALTY_BASE mixes feasibility and objective; prefer lexicographic evaluation (primary: feasibility, secondary: revenue) or multi-return tuple to avoid scale tuning issues and precision loss. E_EVAL_VALIDATION:Evaluate the provided 'known' candidate with EVAL_CODE before trusting its score; current evaluation returns a penalized value, confirming mismatch\u2014fix data or candidate. NB_CODE_FAIL_LOCAL_OPT:Neighbour set lacks directed feasibility moves; random add\/remove\/swap wastes iterations when far from constraint. Bias moves to increase gallons when infeasible and decrease revenue when feasible. NB_MOVE_SET_INADEQUATE:Add 1-1 and 2-1 exchanges (drop k, add l) to escape local minima; current single-swap may be insufficient. INIT_HEURISTIC_WEAK:Random starts slow convergence. Build a constructive seed by sorting items by cost-per-gallon and adding until the gallon constraint is met. Then local-improve. SA_PARAM_MISSPEC:Cooling schedule unspecified\/unstable. Use TEMP0 chosen so ~80% of +delta are accepted initially, geometric cooling alpha in [0.90,0.99], stop at MIN_TEMP where no uphill accepted. SA_FEASIBILITY_POLICY:When infeasible, accept only moves that do not decrease gallons unless they massively reduce penalties; when feasible, evaluate by pure revenue. TS_TABU_DEFICIT:No clear tabu attributes. Use attribute-based tabu on indices added\/removed with tenure ~7\u201315, aspiration for improving best feasible revenue. ILS_PERTURB_MISSING:perturb_solution placeholder unresolved ($Perturb). Implement a strength-k random 1-1 exchange perturbation that preserves feasibility if current is feasible. E_CODE_PERF:Each evaluate_solution is O(n). Cache total revenue and gallons; update deltas in O(1) for add\/remove\/swap to reduce runtime. R_STR_INADEQUATE:Order-irrelevant set stored as list; normalize to sorted tuple for hashing in visited\/tabu caches to avoid duplicate work. DATA_CONSISTENCY_CHECK:Add pre-run assertions: 1-based indexing, uniqueness, gallons >= 67 if claiming feasibility. FAILSAFE:If all heuristics fail to run, provide a deterministic greedy baseline (cost-per-gallon) to ensure a valid feasible output for comparison. TESTS_MINIMAL:Add unit tests for generate_neighbour invariants, EVAL feasibility\/penalty ordering, and signature conformance to prevent recurrence of runtime errors.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","Componentes":{"REPRESENTATION":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","EVAL_CODE":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness = total revenue if gallons >= 67 and indices valid & unique; else revenue plus penalties.\n    Lower is better. SOL_TYPE=INDEX_LIST (1-based).\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    # Type check\n    if not isinstance(solution, (list, tuple)):\n        return float('inf')\n\n    # Count duplicates and invalids\n    seen = set()\n    dup_count = 0\n    invalid_count = 0\n    cleaned: List[int] = []\n    for idx in solution:\n        if not isinstance(idx, int):\n            invalid_count += 1\n            continue\n        if not (1 <= idx <= n):\n            invalid_count += 1\n            continue\n        if idx in seen:\n            dup_count += 1\n            continue\n        seen.add(idx)\n        cleaned.append(idx)\n\n    # Objective components\n    revenue = 0\n    total_gallons = 0\n    for idx in cleaned:\n        revenue += prices[idx - 1]\n        total_gallons += gallons[idx - 1]\n\n    # Constraint and validity penalties\n    required = 67\n    shortage = max(0, required - total_gallons)\n\n    # Penalty scheme (dominates any feasible revenue):\n    PENALTY_BASE = 10**9\n    penalty = 0\n    if invalid_count > 0 or dup_count > 0 or shortage > 0:\n        penalty += PENALTY_BASE\n        # Add proportional components for diagnostics and to strictly order infeasible solutions\n        penalty += 10**6 * invalid_count\n        penalty += 10**3 * dup_count\n        penalty += 10**5 * shortage\n\n    return float(revenue + penalty)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    \"\"\"\n    Generate a valid neighboring solution for INDEX_LIST (1-based unique indices for 1..24).\n    Returns: (neighbor_solution, \"INDEX_LIST\", movement_type)\n    movement_type in {\"add\",\"remove\",\"swap\",\"exchange2-1\"}.\n    Bias: if infeasible (<67 gallons), prefer moves that increase gallons.\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # sanitize to unique valid list\n    base: List[int] = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                base.append(v)\n\n    # helper to compute gallons quickly\n    def total_g(lst: List[int]) -> int:\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    cur_g = total_g(base)\n    feasible = cur_g >= 67\n\n    neighbor = list(base)\n    move = \"swap\"\n\n    all_indices = list(range(1, n+1))\n    missing = list(sorted(set(all_indices) - set(base)))\n\n    if len(base) == 0:\n        choice = random.choice(all_indices)\n        neighbor = [choice]\n        move = \"add\"\n    elif len(base) == n:\n        idx = random.randrange(len(base))\n        neighbor.pop(idx)\n        move = \"remove\"\n    else:\n        if not feasible:\n            # Bias to increase gallons: add the best cost-per-gallon missing item or swap in a better one\n            # choose among add or swap with higher gallon gain\n            if missing and (random.random() < 0.7 or not neighbor):\n                # add the missing item with best gallons per cost (maximize gallons, minimize cost)\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                neighbor.append(cand)\n                move = \"add\"\n            else:\n                # swap out the worst item (low gallons per cost) for a better missing one\n                if neighbor and missing:\n                    out_pos = min(range(len(neighbor)), key=lambda p: (gallons[neighbor[p]-1]\/prices[neighbor[p]-1], gallons[neighbor[p]-1]))\n                    in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                    neighbor[out_pos] = in_val\n                    move = \"swap\"\n        else:\n            # Feasible: try to reduce revenue while keeping feasibility\n            action = random.choices([\"remove\",\"swap\",\"exchange2-1\",\"add\"], weights=[0.45,0.35,0.15,0.05])[0]\n            if action == \"remove\":\n                # remove the worst cost efficiency (highest cost per gallon) if still feasible\n                removable_positions = list(range(len(neighbor)))\n                random.shuffle(removable_positions)\n                removed = False\n                # try more expensive first\n                removable_positions.sort(key=lambda p: prices[neighbor[p]-1]\/gallons[neighbor[p]-1], reverse=True)\n                for p in removable_positions:\n                    cand = neighbor[:p] + neighbor[p+1:]\n                    if total_g(cand) >= 67:\n                        neighbor = cand\n                        move = \"remove\"\n                        removed = True\n                        break\n                if not removed and neighbor:\n                    # fallback remove random (may become infeasible; SA can handle)\n                    idx = random.randrange(len(neighbor))\n                    neighbor.pop(idx)\n                    move = \"remove\"\n            elif action == \"swap\":\n                if neighbor and missing:\n                    # swap out the worst cost-per-gallon for a better missing if keeps feasibility\n                    out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/gallons[neighbor[p]-1])\n                    best_in = None\n                    best_delta = None\n                    for m in missing:\n                        new_g = cur_g - gallons[neighbor[out_pos]-1] + gallons[m-1]\n                        if new_g >= 67:\n                            delta_cost = prices[m-1] - prices[neighbor[out_pos]-1]\n                            if best_delta is None or delta_cost < best_delta:\n                                best_delta = delta_cost\n                                best_in = m\n                    if best_in is not None:\n                        neighbor[out_pos] = best_in\n                        move = \"swap\"\n                    else:\n                        # fallback simple swap\n                        out_idx = random.randrange(len(neighbor))\n                        in_val = random.choice(missing)\n                        neighbor[out_idx] = in_val\n                        move = \"swap\"\n            elif action == \"exchange2-1\":\n                # drop up to 2 items and add 1 better item\n                if len(neighbor) >= 2 and missing:\n                    out_positions = random.sample(range(len(neighbor)), 2)\n                    out_positions.sort(reverse=True)\n                    removed = [neighbor[p] for p in out_positions]\n                    temp = [v for i, v in enumerate(neighbor) if i not in out_positions]\n                    # choose an in that keeps feasibility and reduces cost\n                    viable = []\n                    for m in missing:\n                        if total_g(temp + [m]) >= 67:\n                            delta_cost = (prices[m-1]) - sum(prices[r-1] for r in removed)\n                            viable.append((delta_cost, m))\n                    if viable:\n                        viable.sort(key=lambda x: x[0])\n                        neighbor = temp + [viable[0][1]]\n                        move = \"exchange2-1\"\n                    else:\n                        # fallback to simple remove\n                        idx = random.randrange(len(neighbor))\n                        neighbor.pop(idx)\n                        move = \"remove\"\n            else:  # rare add\n                if missing:\n                    neighbor.append(random.choice(missing))\n                    move = \"add\"\n\n    # Ensure uniqueness and validity\n    uniq: List[int] = []\n    seen2 = set()\n    for v in neighbor:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return (uniq, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: apply 2-5 random neighborhood moves while keeping indices in 1..24 and unique.\n    If current is feasible, try to preserve feasibility with biased moves.\n    Returns a new valid INDEX_LIST solution (1-based, unique order preserved as modified).\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # sanitize\n    cur: List[int] = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                cur.append(v)\n\n    def total_g(lst: List[int]) -> int:\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        feasible = total_g(cur) >= 67\n        missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n        if len(cur) == 0:\n            if missing:\n                cur.append(random.choice(missing))\n            continue\n        if len(cur) == n:\n            cur.pop(random.randrange(len(cur)))\n            continue\n        move = random.choice([\"add\", \"remove\", \"swap\"]) \n        if not feasible:\n            # bias to add\/swap to increase gallons\n            move = random.choices([\"add\",\"swap\",\"remove\"], weights=[0.6,0.3,0.1])[0]\n        if move == \"add\":\n            if missing:\n                # choose high gallons per cost\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                cur.append(cand)\n        elif move == \"remove\":\n            if cur:\n                if feasible:\n                    # remove worst cost-per-gallon first\n                    pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/gallons[cur[p]-1])\n                else:\n                    pos = random.randrange(len(cur))\n                cur.pop(pos)\n        else:  # swap\n            if cur and missing:\n                # swap out worst for best\n                out_pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/gallons[cur[p]-1])\n                in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                cur[out_pos] = in_val\n\n    # final cleanup uniqueness\n    seen2 = set()\n    uniq: List[int] = []\n    for v in cur:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return uniq\n","SAMPLE_SOL":[5,7,9,13]},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG:Heuristic signatures incorrectly use parentheses for function parameters (generate_neighbour(), evaluate_solution(), perturb_solution()). Pass function references, not calls. Fix: def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).\"\n\"FEEDBACK\",\"E_TYPING_LIST_INSTANTIATION:Error 'Type List cannot be instantiated' indicates use of typing.List\/Tuple as constructors. Replace List()\u2192list(), Tuple()\u2192tuple(). Remove typing imports from runtime paths.\"\n\"FEEDBACK\",\"E_REF_SOLUTION_EVAL_MISMATCH:Provided reference solution fails current evaluation due to indexing\/validity mismatch and triggers penalties. Align representation to 1-based unique indices and validate before asserting expectations.\"\n\"FEEDBACK\",\"E_EXPECTED_SCORE_INCONSISTENT:Expected score does not match the evaluation function outcome. Recompute expected metrics under the exact EVAL_CODE to prevent false solver failures.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Perturbation Function placeholder unresolved ($Perturb). Provide a concrete implementation, e.g., k-shake: remove r\u2208{1..3} items, then greedily re-add by best gallons\/price until feasible.\"\n\"FEEDBACK\",\"E_NEIGH_RET_FORMAT:Neighbor returns (solution,'INDEX_LIST',move). Verify heuristics consume only the solution or the triplet consistently. If heuristics expect solution only, return solution; otherwise update callers to unpack.\"\n\"FEEDBACK\",\"E_RANDOM_SEED:Non-deterministic results across runs due to unseeded RNG. Add seed control to ensure reproducible diagnostics.\"\n\"FEEDBACK\",\"E_COOLING_API:Simulated_Annealing error path suggests bad parameter wiring. Validate TEMP>MIN_TEMP>0, cooling_factor in (0,1), and that temperature update is multiplicative.\"\n\"FEEDBACK\",\"E_NAMING:Spelling\/consistency issues hinder API matching (Taboo_Search vs Tabu_Search; aceptance_rate vs acceptance_rate). Standardize names to exact dispatcher expectations.\"\n\"FEEDBACK\",\"E_INDEXING_CONTRACT:All components declare 1-based indices. Ensure any external or test inputs are converted to 1-based before evaluation to avoid PENALTY_BASE inflation.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbor feasible-phase 'swap' doesn\u2019t prioritize cost reduction under tight feasibility. Add targeted replace: choose out argmax price\/gallon, in argmin price with gallons \u2265 deficit, preserving feasibility.\"\n\"FEEDBACK\",\"R_MOVESET_INADEQUATE:Current moves lack 1-1 exchanges and multi-drop-add beyond 2-1. Add 1-1 (cost-decreasing, feasibility-preserving) and (k-1) with k\u2208{2,3} for better basin escape.\"\n\"FEEDBACK\",\"EVAL_COST_PERF:Each neighbor evaluation recomputes gallons\/cost O(len(S)). Cache sums and maintain incrementally in the heuristic loop to O(1) per move.\"\n\"FEEDBACK\",\"PENALTY_SCHEME_RISK:PENALTY_BASE=1e9 dominates but also dwarfs informative ordering. Keep base large but scale proportional terms to avoid overflow and retain strict ordering; ensure no float precision issues.\"\n\"FEEDBACK\",\"START_FEAS_GEN:If starting infeasible, neighbor biases by gallons\/price but can drift to oversized sets. Add greedy repair: add until feasible via best gallons\/price, then prune cheapest items while feasible.\"\n\"FEEDBACK\",\"SA_ACCEPT_RULE:Define Metropolis acceptance precisely on fitness difference (lower is better). For infeasible states, incorporate penalty in delta without special cases to maintain consistency.\"\n\"FEEDBACK\",\"TS_TABU_ATTR:Tabu Search must define move attributes (added\/removed indices) and aspiration by best-known cost. Current design lacks this, causing cycling.\"\n\"FEEDBACK\",\"ILS_ACCEPTANCE:ILS parameter 'aceptance_rate' undefined. Specify explicit acceptance criterion (e.g., accept if better or with probability p under SA-like rule) and a perturb strength schedule.\"\n\"FEEDBACK\",\"OBJ_CODE_GAP:objective_function ignores feasibility. When used for reporting, clearly separate from evaluate_solution to prevent misuse; never rank with objective_function in the search.\"\n\"FEEDBACK\",\"UNIT_TESTS_MISSING:Add unit tests: (a) unique\/invalid\/duplicate handling, (b) feasibility boundary cases, (c) neighbor invariants, (d) perturb preserves type\/uniqueness.\"\n\"FEEDBACK\",\"KNOWN_BEST_EVAL_CHECK:Automated verification indicates the current 'known' reference is inconsistent with EVAL_CODE. Update the reference after converting to 1-based and re-evaluating under penalties=0.\"\n\"FEEDBACK\",\"ACTION_FIX_ORDER:1) Replace all typing instantiations and fix signatures. 2) Implement perturb function. 3) Normalize neighbor return contract. 4) Add seed control. 5) Add incremental eval. 6) Recompute and store reference metrics using EVAL_CODE. 7) Re-run SA\/ILS\/TS with corrected APIs and log temperatures\/acceptance to validate convergence.\"\n"}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","Componentes":{"REPRESENTATION":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness = total revenue if gallons >= 67 and indices valid & unique; else revenue plus penalties.\n    Lower is better. SOL_TYPE=INDEX_LIST (1-based).\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    if not isinstance(solution, (list, tuple)):\n        return float('inf')\n\n    seen = set()\n    dup_count = 0\n    invalid_count = 0\n    cleaned = []\n    for idx in solution:\n        if not isinstance(idx, int):\n            invalid_count += 1\n            continue\n        if not (1 <= idx <= n):\n            invalid_count += 1\n            continue\n        if idx in seen:\n            dup_count += 1\n            continue\n        seen.add(idx)\n        cleaned.append(idx)\n\n    revenue = 0\n    total_gallons = 0\n    for idx in cleaned:\n        revenue += prices[idx - 1]\n        total_gallons += gallons[idx - 1]\n\n    required = 67\n    shortage = max(0, required - total_gallons)\n\n    PENALTY_BASE = 10**9\n    penalty = 0\n    if invalid_count > 0 or dup_count > 0 or shortage > 0:\n        penalty += PENALTY_BASE\n        penalty += 10**6 * invalid_count\n        penalty += 10**3 * dup_count\n        penalty += 10**5 * shortage\n\n    return float(revenue + penalty)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Generate a neighboring solution for INDEX_LIST (1-based unique indices for 1..24).\n    Returns: (neighbor_solution, \"INDEX_LIST\", movement_type)\n    movement_type in {\"add\",\"remove\",\"swap\",\"exchange2-1\",\"one-to-one\"}.\n    Bias: if infeasible (<67 gallons), prefer moves that increase gallons.\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    base = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                base.append(v)\n\n    def total_g(lst):\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    cur_g = total_g(base)\n    feasible = cur_g >= 67\n\n    neighbor = list(base)\n    move = \"swap\"\n\n    all_indices = list(range(1, n+1))\n    missing = list(sorted(set(all_indices) - set(base)))\n\n    if len(base) == 0:\n        choice = random.choice(all_indices)\n        neighbor = [choice]\n        move = \"add\"\n    elif len(base) == n:\n        idx = random.randrange(len(base))\n        neighbor.pop(idx)\n        move = \"remove\"\n    else:\n        if not feasible:\n            if missing and (random.random() < 0.7 or not neighbor):\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                neighbor.append(cand)\n                move = \"add\"\n            else:\n                if neighbor and missing:\n                    out_pos = min(range(len(neighbor)), key=lambda p: (gallons[neighbor[p]-1]\/prices[neighbor[p]-1], gallons[neighbor[p]-1], -prices[neighbor[p]-1]))\n                    in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                    neighbor[out_pos] = in_val\n                    move = \"swap\"\n        else:\n            action = random.choices([\"remove\",\"one-to-one\",\"swap\",\"exchange2-1\",\"add\"], weights=[0.4,0.25,0.2,0.1,0.05])[0]\n            if action == \"remove\":\n                removable_positions = list(range(len(neighbor)))\n                removable_positions.sort(key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]), reverse=True)\n                removed = False\n                for p in removable_positions:\n                    cand = neighbor[:p] + neighbor[p+1:]\n                    if total_g(cand) >= 67:\n                        neighbor = cand\n                        move = \"remove\"\n                        removed = True\n                        break\n                if not removed and neighbor:\n                    idx = random.randrange(len(neighbor))\n                    neighbor.pop(idx)\n                    move = \"remove\"\n            elif action == \"one-to-one\":\n                if neighbor and missing:\n                    out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]))\n                    best_in = None\n                    best_delta = None\n                    for m in missing:\n                        new_g = cur_g - gallons[neighbor[out_pos]-1] + gallons[m-1]\n                        if new_g >= 67:\n                            delta_cost = prices[m-1] - prices[neighbor[out_pos]-1]\n                            if best_delta is None or delta_cost < best_delta:\n                                best_delta = delta_cost\n                                best_in = m\n                    if best_in is not None:\n                        neighbor[out_pos] = best_in\n                        move = \"one-to-one\"\n                    else:\n                        out_idx = random.randrange(len(neighbor))\n                        in_val = random.choice(missing)\n                        neighbor[out_idx] = in_val\n                        move = \"swap\"\n            elif action == \"swap\":\n                if neighbor and missing:\n                    out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]))\n                    in_val = random.choice(missing)\n                    neighbor[out_pos] = in_val\n                    move = \"swap\"\n            elif action == \"exchange2-1\":\n                if len(neighbor) >= 2 and missing:\n                    out_positions = random.sample(range(len(neighbor)), 2)\n                    out_positions.sort(reverse=True)\n                    removed_vals = [neighbor[p] for p in out_positions]\n                    temp = [v for i, v in enumerate(neighbor) if i not in out_positions]\n                    viable = []\n                    temp_g = total_g(temp)\n                    for m in missing:\n                        if temp_g + gallons[m-1] >= 67:\n                            delta_cost = prices[m-1] - sum(prices[r-1] for r in removed_vals)\n                            viable.append((delta_cost, m))\n                    if viable:\n                        viable.sort(key=lambda x: x[0])\n                        neighbor = temp + [viable[0][1]]\n                        move = \"exchange2-1\"\n                    else:\n                        idx = random.randrange(len(neighbor))\n                        neighbor.pop(idx)\n                        move = \"remove\"\n            else:\n                if missing:\n                    neighbor.append(random.choice(missing))\n                    move = \"add\"\n\n    uniq = []\n    seen2 = set()\n    for v in neighbor:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return (uniq, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: apply 2-5 biased moves while keeping indices in 1..24 and unique.\n    If current is feasible, try to preserve feasibility with biased moves.\n    Returns a new valid INDEX_LIST solution (1-based, unique order preserved as modified).\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    cur = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                cur.append(v)\n\n    def total_g(lst):\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        feasible = total_g(cur) >= 67\n        missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n        if len(cur) == 0:\n            if missing:\n                cur.append(random.choice(missing))\n            continue\n        if len(cur) == n:\n            cur.pop(random.randrange(len(cur)))\n            continue\n        move = random.choice([\"add\", \"remove\", \"swap\"]) \n        if not feasible:\n            move = random.choices([\"add\",\"swap\",\"remove\"], weights=[0.6,0.3,0.1])[0]\n        if move == \"add\":\n            if missing:\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                cur.append(cand)\n        elif move == \"remove\":\n            if cur:\n                if feasible:\n                    pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/max(1, gallons[cur[p]-1]))\n                else:\n                    pos = random.randrange(len(cur))\n                cur.pop(pos)\n        else:\n            if cur and missing:\n                out_pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/max(1, gallons[cur[p]-1]))\n                in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                cur[out_pos] = in_val\n\n    seen2 = set()\n    uniq = []\n    for v in cur:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return uniq\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":2,"Feedback":"COMPONENT_VERSION:1.0.0\nFEEDBACK:\nE_SOLVER_SIG:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Unpack errors confirm mismatched call contracts. Align all heuristics to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nSA_SIG_MISMATCH:Reported signature def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) is incompatible. Remove parentheses in parameters (pass functions, do not call), and conform to TARGET signature via other_params dict for temp schedule.\nILS_SIG_MISMATCH:Reported signature def ILS(solution,best_sol,best_score,generate_neighbour(),perturb_solution(),evaluate_solution(),iterations,aceptance_rate) is incompatible. Conform to TARGET signature; pass iterations, acceptance_rate inside other_params; pass function objects, not results.\nTS_SIG_MISMATCH:Reported signature def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration) is incompatible. Conform to TARGET signature; include taboo params in other_params.\nNB_RET_TUPLE:generate_neighbour returns 3 values (solution, \"INDEX_LIST\", move). Heuristics failing with \u201cexpected 2\u201d indicates inconsistent unpacking. Standardize to return exactly (neighbor_solution, \"INDEX_LIST\") or change heuristics to accept and ignore the 3rd field. Recommendation: return (solution, \"INDEX_LIST\") only; expose move via optional diagnostics hook.\nPERTURB_MISSING:Perturbation Function is undefined (\"$Perturb\"). ILS cannot run. Implement def perturb_solution(solution, other_params) returning a valid INDEX_LIST 1-based unique list; ensure it preserves feasibility bias or includes repair.\nR_INDEXING_INCONSISTENT:KNOWN_SOLUTION uses 0-based indices while SOL_TYPE requires 1-based. This injects invalids and triggers massive penalties. Enforce 1-based across all components; validate test fixtures.\nVAL_KNOWN_CHECK:Using evaluate_solution, the provided KNOWN_SOLUTION as-is is infeasible\/invalid; after +1 index shift it evaluates as feasible and matches EXPECTED_SCORE. Fix KNOWN_SOLUTION to 1-based to keep tests reliable.\nE_EVAL_OBJ_MISMATCH:objective_function silently drops invalid\/duplicate indices while evaluate_solution penalizes them. This inconsistency hides bugs. Make both functions share the same validation\/cleaning rules or deprecate objective_function in favor of evaluate_solution.\nE_PENALTY_SCALE:Single PENALTY_BASE=1e9 dwarfs all revenues; fine for ranking, but obscures gradient among infeasibles. Keep base domination but reduce multipliers to avoid 64-bit overflow risks on long runs and ensure stable ordering: e.g., base=1e7, shortage=1e5, invalid=1e3, dup=1e2.\nNB_CODE_FAIL_LOCAL_OPT:Current neighbor repertoire lacks targeted cost-improvement while feasible. Add drop-add (best-improving) and 2-opt-like exchange among selected indices to escape shallow basins; use cost per gallon dominance filters.\nNB_GREEDY_BIAS:Infeasible bias uses ratio gallons\/price only. This can stall near boundary. Add tie-breakers on absolute gallons deficit coverage and marginal cost impact on deficit: prioritize items minimizing delta_cost per deficit_reduction.\nNB_FEAS_REPAIR:On feasible states, removal tries greedy but can break feasibility fallback-randomly. Replace fallback with repair: if random removal breaks feasibility, immediately add cheapest item that restores gallons to maintain feasibility-first.\nILS_PERTURB_STRENGTH:Define controlled perturbation (e.g., random k-removals with k in [1..3] chosen from lowest value density) to balance diversification without destroying feasibility; include immediate repair to >=67.\nACCEPTANCE_RULES:ILS acceptance \u201caceptance_rate\u201d unclear. Implement deterministic accept-if-better; else accept with probability exp(-delta\/T) with a temperature schedule, or fixed threshold; log acceptance decisions for diagnostics.\nSA_COOLING:Replace fixed cooling_factor with validated schedule: T_k = T0 * alpha^k with alpha in [0.90,0.99], stop at MIN_TEMP or no-improvement window; ensure neighbor returns consistent type; avoid calling functions in signature.\nTS_TABU_LIST:Define tabu attributes on moves (added\/removed indices) with tenure ~ 5\u201310; aspiration when candidate improves best_score; maintain candidate list from multiple neighbor samples per iteration to avoid cycling.\nR_REPRODUCIBILITY:Lack of RNG seeding impedes debugging. Add seed in other_params; pass rng instance explicitly to neighbor\/perturb to eliminate hidden globals.\nPERF_INCREMENTAL:EVAL currently O(k) per neighbor. Maintain (total_cost,total_gallons,selected_set) in state; update in O(1) for add\/remove\/swap. Wrap evaluate_solution only for periodic verification or when state desync is detected.\nSTATE_NORMALIZATION:Multiple components re-clean sets. Centralize normalization: a utility to canonicalize solutions (sorted unique 1-based ints) to reduce duplication and hash collisions in tabu and visited caches.\nSTOPPING_CRITERIA:Define consistent termination: max_evals, max_time, or no_improve_limit. Current solvers give no evidence of robust stop conditions; add and expose via other_params.\nLOG_DIAGNOSTICS:Capture per-iteration tuple (iter, revenue, gallons, feasible, move_type) to diagnose stalls; current errors suggest silent type\/return mismatches\u2014logging will surface them fast.\nTESTS_UNIT:Add unit tests: (1) neighbor preserves uniqueness\/1-based, (2) perturb preserves\/repairs feasibility, (3) evaluate_solution strict penalties, (4) signature contract compliance with TARGET_HEURISTIC_GENERAL_SIGNATURE.\nBOUNDARY_CASES:Guard len(base)==n branch in neighbor for feasibility logic; after forced remove, ensure repair if infeasible to avoid random walk into heavy penalty region.\nNORMALIZE_INPUT:Reject non-int and out-of-range indices earlier in heuristics to avoid passing garbage into evaluate_solution and masking issues with giant penalties.\nOUTPUT_PROTOCOL:Local solver \"extra outputs are expected\" but caller crashes on unpack. Return a single dictionary per iteration containing at least {\"solution\",\"score\",\"feasible\",\"gallons\",\"move\"} to maintain extensibility without breaking unpack patterns.\nVALIDATION_RUN:After fixing signatures and indexing, run: baseline constructive greedy-by-density to seed a feasible start, then SA\/ILS\/TS; compare best_score from each to validate consistent improvement ordering.\nCONTINGENCY:If generate_neighbour must return 3 fields for analytics, update all heuristics to unpack as (cand, _, _) or (cand, rep, move) and ignore the extra where not used; do not mix expectations across solvers."}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST: list of unique 1-based indices S subset of {1..24}. Example: [5,9,13,7].","Componentes":{"REPRESENTATION":"INDEX_LIST: list of unique 1-based indices S subset of {1..24}. Example: [5,9,13,7].","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Validate type\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    # Validate bounds and uniqueness\n    n = 24\n    indices = solution\n    if any(i < 1 or i > n for i in indices):\n        return 10**12\n    if len(set(indices)) != len(indices):\n        return 10**12\n\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for i in indices:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        # Linear penalty scaled by deficit, plus base large penalty to dominate objective\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return total_score\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _normalize_solution(sol: List[int]) -> List[int]:\n    # Keep unique, in-range 1..24\n    seen = set()\n    norm = []\n    for x in sol:\n        if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n            seen.add(x)\n            norm.append(x)\n    return norm\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (neighbour_solution, movement_type_str)\n    movement_type in {\"add\",\"remove\",\"swap\",\"replace\"}\n    \"\"\"\n    sol = _normalize_solution(list(solution))\n    n = 24\n    movement = None\n\n    if len(sol) == 0:\n        # If empty, add a random element\n        candidate = random.randint(1, n)\n        return ([candidate], \"add\")\n\n    op = random.random()\n    if op < 0.33:\n        # ADD: add a random element not in solution\n        candidates = [i for i in range(1, n+1) if i not in sol]\n        if candidates:\n            sol.append(random.choice(candidates))\n            movement = \"add\"\n        else:\n            # fallback to remove\n            removed = sol.pop(random.randrange(len(sol)))\n            movement = \"remove\"\n    elif op < 0.66 and len(sol) > 1:\n        # SWAP: swap one element with an outsider\n        inside_idx = random.randrange(len(sol))\n        outside = [i for i in range(1, n+1) if i not in sol]\n        if outside:\n            sol[inside_idx] = random.choice(outside)\n            movement = \"swap\"\n        else:\n            # fallback to replace within (no-op avoided by shuffle)\n            i, j = random.sample(range(len(sol)), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n            movement = \"replace\"\n    else:\n        # REMOVE: remove a random element if size>1, else add\n        if len(sol) > 1:\n            sol.pop(random.randrange(len(sol)))\n            movement = \"remove\"\n        else:\n            candidates = [i for i in range(1, n+1) if i not in sol]\n            if candidates:\n                sol.append(random.choice(candidates))\n                movement = \"add\"\n            else:\n                movement = \"noop\"\n\n    return (_normalize_solution(sol), movement or \"noop\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation with greedy-rebuild + random shake\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    n = 24\n\n    def greedy_build():\n        # Sort by score\/time ascending, tie-break by higher time\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (scores[i-1] \/ times[i-1], -times[i-1]))\n        sel = []\n        tsum = 0\n        for i in items:\n            sel.append(i)\n            tsum += times[i-1]\n            if tsum >= 670:\n                break\n        return sel\n\n    # Start from greedy base\n    base = greedy_build()\n\n    # Random shake: remove r items and refill with best outsiders\n    r = 1 if len(base) <= 2 else random.randint(1, min(3, len(base)-1))\n    base_set = set(base)\n    for _ in range(r):\n        if base:\n            base.pop(random.randrange(len(base)))\n\n    # Refill by best outsiders by ratio\n    outsiders = [i for i in range(1, n+1) if i not in base]\n    outsiders.sort(key=lambda i: (scores[i-1] \/ times[i-1], -times[i-1]))\n\n    tsum = sum(times[i-1] for i in base)\n    for i in outsiders:\n        if tsum >= 670:\n            break\n        base.append(i)\n        tsum += times[i-1]\n\n    # Final cleanup: make unique and within bounds\n    uniq = []\n    seen = set()\n    for i in base:\n        if 1 <= i <= n and i not in seen:\n            seen.add(i)\n            uniq.append(i)\n\n    return uniq\n","SAMPLE_SOL":"[5,9,13,7]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_TYPE_HINT:Do not instantiate typing.List; error 'Type List cannot be instantiated' indicates List() used; replace with list() and restrict List to annotations only.\nE_FUNC_PTR_SIGNATURE:Heuristic implementations pass function calls in signature (generate_neighbour(), evaluate_solution(), perturb_solution()); pass function references instead (generate_neighbour, evaluate_solution, perturb_solution).\nE_SIG_MISMATCH:Align all heuristics to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params); wrap SA\/ILS\/TS adapters to this unified signature.\nE_MISSING_PERTURB:Perturbation Function missing; provide a concrete perturb_solution(solution,rng,intensity) that produces larger, non-local jumps (e.g., multiple add\/remove\/swap or random subset re-sampling).\nE_KNOWN_SOLUTION_INDEX_BASE:KNOWN_SOLUTION uses 0-based indices; evaluator enforces 1..24; update to 1-based or it is hard-penalized (returns 1e12).\nE_KNOWN_SCORE_INCONSISTENT:EXPECTED_SCORE_FROM_KNOWN_SOLUTION does not match evaluator; recompute after fixing index base to prevent false regressions.\nPY_ASSERT_EVAL_SAMPLE:Evaluator returns feasible finite value for Sample Solution [5,9,13,7]; keep this as a unit test to guard evaluator regressions.\nPY_ASSERT_KNOWN_SOLUTION:Evaluator returns penalty for provided KNOWN_SOLUTION; confirms index-base bug; fix before using for validation.\nE_OBJ_DUPLICATION:objective_function and evaluate_solution diverge in input validation (objective_function silently ignores invalid indices); remove objective_function or make it a thin wrapper over evaluate_solution to ensure consistent behavior.\nE_PENALTY_SCALING:Penalty 1e9 + deficit*1e6 may dwarf temperature\/acceptance scales; either normalize objective (e.g., shift\/scale) or adopt feasibility-first acceptance with deterministic repair to avoid numerical issues.\nE_EVAL_COST:Current evaluation recomputes totals O(k) per neighbor; implement delta evaluation by tracking (total_time,total_score) and applying +\/- deltas for add\/remove\/swap to reduce amortized cost to O(1).\nNB_MOVE_SET_WEAK:Neighbourhood lacks cost-awareness; add targeted moves: (a) add best time\/score ratio item when infeasible, (b) remove worst score\/time item when feasible with slack, (c) swap-in best-improving outsider for worst insider.\nNB_CANDIDATES_COST:Each neighbor recomputes complement lists O(n); maintain a set for membership and precomputed complement when generating moves to cut overhead to O(1) membership checks and O(1) random selection.\nNB_SWAP_SEMANTICS:Fallback 'replace' branch only swaps within solution (no-op on objective); replace with 1-for-1 or 2-opt style exchanges with outsiders to effect meaningful change.\nINIT_CONSTRUCTIVE_MISSING:No guaranteed-feasible initializer; add greedy constructive seed that adds items by increasing score\/time until time >= 670, then local improvement via drop\/swap to reduce score.\nREPAIR_OPERATOR_LACK:When infeasible, rely on repair instead of penalties: iteratively add items minimizing marginal score\/time until constraint satisfied; when feasible with large slack, try removing items with minimal time impact and maximal score reduction.\nSA_SCHEDULE_WEAK:Define temperature schedule explicitly for minimization: T0 calibrated to accept ~80% of typical uphill deltas, geometric cooling T <- alpha*T with alpha in [0.90,0.99], stop at MIN_TEMP where uphill acceptance ~0.01; compute acceptance with exp(-(delta)\/T).\nILS_ACCEPTANCE_UNSPECIFIED:Define acceptance criterion (e.g., accept if better or by SA-like probability) and perturb intensity schedule (increase after stagnation); ensure perturbation preserves index validity and uniqueness.\nTS_MEMORY_MODEL:Define tabu on moves, not solutions; represent tabu attributes (added index, removed index) with tenure; include aspiration if candidate beats best; hash move tuples to constant-time tabu checks.\nSTOPPING_CRITERIA:Add max_evals\/time_budget and no_improve_limit to prevent wasted compute and allow fair benchmarking.\nRANDOM_SEED_CONTROL:Expose RNG seed for reproducibility in local solver; pass rng object through heuristics to avoid global random state conflicts.\nTEST_COVERAGE:Add unit tests: (a) index validation rejects 0 and duplicates, (b) repair attains feasibility from infeasible starts, (c) neighbor always returns unique 1..24 indices, (d) evaluator equals sum(scores) for feasible subsets.\nCODE_STYLE_CONSISTENCY:Rename Neigbour->Neighbour\/Neighbor consistently; return movement_type from generator and consume it in TS for tabu coding.\nDATA_COUPLING:Avoid re-allocating scores\/times per call; capture them in closure or pass as params to reduce overhead and ease testing.\nOUTPUT_INSTRUMENTATION:Log (total_time,total_score,move_type,delta) per iteration in local solver outputs to enable post-hoc diagnosis and parameter tuning.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Validate type\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    # Validate bounds and uniqueness\n    n = 24\n    indices = solution\n    if any(i < 1 or i > n for i in indices):\n        return 10**12\n    if len(set(indices)) != len(indices):\n        return 10**12\n\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for i in indices:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return total_score\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighbour generator for INDEX_LIST representation.\n    Returns (neighbour_solution, movement_type).\n    movement_type in {\"add\",\"remove\",\"swap\",\"repair_add\",\"repair_swap\"}\n    \"\"\"\n    # Local problem data (embedded per critical instructions)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _totals(sol: List[int]) -> Tuple[int,int]:\n        t = 0\n        s = 0\n        for i in sol:\n            t += times[i-1]\n            s += scores[i-1]\n        return t, s\n\n    sol = _normalize(list(solution))\n\n    # Quick handling for empty\n    if not sol:\n        # Add best ratio item to start\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        return ([items[0]], \"add\")\n\n    total_time, _ = _totals(sol)\n\n    # If infeasible, prioritize repair by adding best ratio items or swapping\n    if total_time < 670:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n            # add one best outsider\n            sol.append(outsiders[0])\n            return (_normalize(sol), \"repair_add\")\n        else:\n            # swap random element (should not happen if outsiders empty, but keep safe)\n            idx = random.randrange(len(sol))\n            sol[idx] = random.randint(1, n)\n            return (_normalize(sol)), \"repair_swap\"\n\n    # Feasible: choose move among add\/remove\/swap with simple cost-awareness\n    move = random.random()\n\n    if move < 0.34:\n        # REMOVE: try removing worst ratio (highest score\/time) while staying feasible\n        if len(sol) > 1:\n            # rank insiders by decreasing score\/time, tie by smaller time impact\n            insiders = list(sol)\n            insiders.sort(key=lambda i: (-(scores[i-1]\/times[i-1]), times[i-1]))\n            for cand in insiders:\n                new_sol = [x for x in sol if x != cand]\n                new_time, _ = _totals(new_sol)\n                if new_time >= 670:\n                    return (_normalize(new_sol), \"remove\")\n        # fallback: random remove and then repair if infeasible\n        if len(sol) > 1:\n            new_sol = list(sol)\n            new_sol.pop(random.randrange(len(new_sol)))\n            # If infeasible, add best ratio outsider to repair\n            t, _ = _totals(new_sol)\n            if t < 670:\n                outsiders = [i for i in range(1, n+1) if i not in new_sol]\n                if outsiders:\n                    outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n                    new_sol.append(outsiders[0])\n            return (_normalize(new_sol), \"remove\")\n\n    elif move < 0.67:\n        # SWAP: try cost-improving 1-for-1 swap with outsiders by ratio\n        insiders = list(sol)\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            # pick worst insider and best outsider by ratio\n            worst_in = max(insiders, key=lambda i: scores[i-1]\/times[i-1])\n            best_out = min(outsiders, key=lambda i: scores[i-1]\/times[i-1])\n            new_sol = list(sol)\n            pos = new_sol.index(worst_in)\n            new_sol[pos] = best_out\n            # ensure feasibility\n            t, _ = _totals(new_sol)\n            if t < 670:\n                # add next best outsider if needed\n                remaining = [o for o in outsiders if o != best_out]\n                if remaining:\n                    remaining.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n                    new_sol.append(remaining[0])\n            return (_normalize(new_sol), \"swap\")\n\n    # ADD: add best ratio outsider\n    outsiders = [i for i in range(1, n+1) if i not in sol]\n    if outsiders:\n        outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        sol.append(outsiders[0])\n        return (_normalize(sol), \"add\")\n\n    # If no outsiders, perform a random swap within to change composition minimally\n    if len(sol) >= 2:\n        i, j = random.sample(range(len(sol)), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n    return (_normalize(sol), \"swap\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: greedy rebuild from best ratio, random removals, and refill.\n    Returns a valid INDEX_LIST solution.\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def greedy_build() -> List[int]:\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        sel: List[int] = []\n        tsum = 0\n        for i in items:\n            sel.append(i)\n            tsum += times[i-1]\n            if tsum >= 670:\n                break\n        return sel\n\n    base = greedy_build()\n\n    # Random shake: remove r items\n    if base:\n        r = random.randint(1, min(3, max(1, len(base)\/\/2)))\n        for _ in range(r):\n            if base:\n                base.pop(random.randrange(len(base)))\n\n    # Refill by best outsiders by ratio until feasible, then optionally one extra random add\n    outsiders = [i for i in range(1, n+1) if i not in base]\n    outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i-1] for i in sol)\n\n    t = total_time(base)\n    for i in outsiders:\n        if t >= 670:\n            break\n        base.append(i)\n        t += times[i-1]\n\n    # Small extra shake with probability\n    if random.random() < 0.5 and outsiders:\n        extra = [i for i in range(1, n+1) if i not in base]\n        if extra:\n            base.append(random.choice(extra))\n\n    # Deduplicate and bound\n    uniq = []\n    seen = set()\n    for i in base:\n        if 1 <= i <= n and i not in seen:\n            seen.add(i)\n            uniq.append(i)\n\n    return uniq\n","SAMPLE_SOL":"[5,9,13,21]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"E_RUNTIME_SIG:Heuristic signatures incorrectly call arguments in signature (e.g., generate_neighbour()). Use function references, not calls. Ex: def SA(solution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).\nE_TYPE_HINT_INSTANTIATION:Error 'Type List cannot be instantiated' indicates using typing.List as a value or default. Remove instantiations of typing types; use list() for runtime objects and only use List for annotations.\nE_MISSING_COMPONENT:Perturbation function undefined ('$Perturb'). Provide a concrete perturb_solution(solution, strength, rng) to enable ILS and diversification.\nE_INDEX_BASE:Known solution uses 0-based indices; representation requires 1..24. Off-by-one invalidates evaluation and triggers penalty. Align all solutions to 1-based indexing.\nE_KNOWN_BEST_EVAL:Known solution fails evaluation (domain violation). Replace with a valid 1-based feasible set and re-compute expected score with evaluate_solution to ensure harness consistency.\nE_SAMPLE_CHECK:Sample solution is feasible under evaluate_solution; discrepancy vs provided known-best artifacts suggest harness\/ground-truth mis-specified. Recompute ground-truth via a solver and update.\nE_OBJ_EVAL_MISMATCH:OBJ_CODE objective_function ignores feasibility. If used anywhere outside evaluate_solution, it can mislead heuristics. Route all scoring through evaluate_solution or mirror feasibility handling in objective_function.\nE_NEIGH_MOVE:Relying solely on score\/time ratio can bias against beneficial high-time low-score picks. This may stall improvements. Add marginal gain per time and\/or Lagrangian-weighted cost to guide add\/remove\/swap.\nE_REPAIR_PATH:repair_swap path assigns random indices, then normalizes, which can no-op or reintroduce previously removed items. Replace with targeted add\/swap that guarantees time increase and cost control.\nE_REMOVE_FEAS:Remove step may fail to find feasible removal and falls back to random pop+repair that may overfill. Constrain by smallest-time additions first and bound solution size to prevent bloat.\nE_RANDOMNESS:Unseeded global randomness harms reproducibility. Thread rng via parameters and seed in driver for deterministic runs.\nE_NEIGH_COPY:Ensure neighbour returns new deep-copied lists. Current code sometimes mutates sol in place before returning, risking side-effects in metaheuristics.\nE_COMPLEXITY:Each neighbour recomputes totals O(k). Maintain incremental totals (time,score) and pass around to reduce per-step complexity from O(k) to O(1) for many checks.\nE_TABU_SA_ILS_API:Local solver expects target signature TARGET_HEURISTIC_GENERAL_SIGNATURE. Normalize all heuristic signatures to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_PENALTY_SCALE:Penalty uses 1e9 + deficit*1e6. Large constants may cause acceptance anomalies in SA. Consider feasibility-first handling: reject infeasible in acceptance or use adaptive Lagrange multiplier updated during search.\nE_DUP_FILTER:_normalize removes duplicates post-hoc; better to prevent duplicates at generation. For add and swap, sample outsiders from set difference directly.\nE_MOVE_DIVERSIFICATION:Neighbour set lacks k-exchange and drop-add moves with acceptance if time remains feasible. Add 1-1, 1-2, 2-1 exchanges to escape shallow basins.\nE_KNAPSACK_MODEL:This is a covering knapsack. Greedy ratio is weak. Implement exact DP (min score for each time) for baseline and to repair known-best; use it to validate heuristic performance.\nE_COOLING:SA parameters unspecified. Provide cooling schedule (e.g., geometric alpha in [0.90,0.99]), iterations per temp, and stopping criteria by stall count to stabilize results.\nE_TABU_LIST:Tabu requires tenure on items or moves. Current failure logs show it never ran; after fixing, implement recency-based tabu on add\/remove with aspiration if new best.\nE_ILS_ACCEPT:ILS acceptance rate parameter is unused\/misnamed. Implement accept-if-better or Metropolis-based acceptance; define perturb strength proportional to |solution|.\nF_SPECIFIC_FIX_SIG_SA:Refactor to def SA(cur,best,best_score,gen_nb,eval_fn,T, Tmin, alpha, iters_per_T, rng): loop: for _ in range(iters_per_T): nb,_=gen_nb(cur); delta=eval_fn(nb)-eval_fn(cur); accept if delta<0 or exp(-delta\/T)>u; update best; T*=alpha.\nF_SPECIFIC_FIX_ILS:Provide def perturb_solution(sol, strength, rng): perform r random add\/drop\/swap preserving feasibility; in ILS: local_search -> perturb -> accept if better or with small prob -> repeat.\nF_SPECIFIC_FIX_TABU:Implement item-level add\/remove tabu with tenure=tabu_duration, list size bound taboo_list_size, aspiration if eval<best_score; neighborhood restricted to non-tabu moves.\nF_PERTURB_IMPL:For covering constraint, use time-decreasing shakes: randomly drop 1-2 items then greedily add low score\/time to re-feasibilize; parameterize strength.\nF_REPAIR_RULE:When infeasible (time<670), greedily add items by increasing score\/time; if tie, prefer higher time to reach feasibility faster.\nF_REMOVE_RULE:When feasible, attempt removing items by decreasing time impact per unit score saved: sort by (score, -time) and test feasibility; this reduces cost with minimal feasibility risk.\nF_ACCEPT_CRITERIA:Switch from absolute penalties to hard feasibility filter in local search neighborhoods; only accept infeasible during perturbation phases to avoid penalty overshadow issues.\nF_TESTS:Unit tests: 1) domain validation (duplicates, out-of-range) 2) feasibility enforcement 3) neighbor invariants (idempotence, no duplicates, 1..24) 4) API compliance for all heuristics; add regression with fixed RNG.\nE_VALIDATION_RUN:Using provided evaluate_solution, the given known solution fails (penalty indicates invalid). The evaluation path is correct; fix the solution indexing and recompute expected score before benchmarking.\nF_PERF_MICRO:Cache scores\/times arrays and precompute ratio, sorted outsider lists; update via heap for O(log n) selection instead of resorting each step.\nF_LOGGING:Add lightweight telemetry: best_score, current_score, temp, move_type freq, acceptance rate; store last K moves for diagnostics and to tune tenure and cooling.\nSEC_MAIN:Adhere to MAIN_CRITICAL_INSTRUCTION by keeping all code pure in-memory; no filesystem\/network\/OS calls in any component.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Validate type\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    # Validate bounds and uniqueness\n    n = 24\n    indices = solution\n    if any(i < 1 or i > n for i in indices):\n        return 10**12\n    if len(set(indices)) != len(indices):\n        return 10**12\n\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for i in indices:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        # Linear penalty scaled by deficit, plus base large penalty to dominate objective\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return total_score\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighbour generator for INDEX_LIST representation.\n    Returns (neighbour_solution, movement_type). movement_type in {\"add\",\"remove\",\"swap\",\"repair_add\",\"repair_swap\"}\n    \"\"\"\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out: List[int] = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _totals(sol: List[int]) -> Tuple[int, int]:\n        t = 0\n        s = 0\n        for i in sol:\n            t += times[i-1]\n            s += scores[i-1]\n        return t, s\n\n    sol = _normalize(list(solution))\n\n    # Handle empty start: seed with best (score\/time, then higher time)\n    if not sol:\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        return ([items[0]], \"add\")\n\n    total_time, _ = _totals(sol)\n\n    # If infeasible, repair by adding low score\/time outsiders until feasible\n    if total_time < 670:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n            new_sol = list(sol)\n            for cand in outsiders:\n                new_sol.append(cand)\n                t, _ = _totals(new_sol)\n                if t >= 670:\n                    return (_normalize(new_sol), \"repair_add\")\n            return (_normalize(new_sol), \"repair_add\")\n        # Fallback: targeted swap to increase time\n        insiders = list(sol)\n        if insiders:\n            worst_in = max(insiders, key=lambda i: scores[i-1]\/times[i-1])\n            outsiders_full = [i for i in range(1, n+1) if i not in sol]\n            if outsiders_full:\n                best_out = min(outsiders_full, key=lambda i: scores[i-1]\/times[i-1])\n                new_sol = list(sol)\n                pos = new_sol.index(worst_in)\n                new_sol[pos] = best_out\n                return (_normalize(new_sol), \"repair_swap\")\n        return (_normalize(sol), \"repair_swap\")\n\n    # Feasible: probabilistically choose a move\n    move = random.random()\n\n    # REMOVE: try removing by smallest (time per score saved) while staying feasible\n    if move < 0.34:\n        insiders = list(sol)\n        # Rank by increasing time per score to remove cost-effectively\n        insiders.sort(key=lambda i: (times[i-1]\/max(1, scores[i-1]), scores[i-1], -times[i-1]))\n        for cand in insiders:\n            new_sol = [x for x in sol if x != cand]\n            new_time, _ = _totals(new_sol)\n            if new_time >= 670:\n                return (_normalize(new_sol), \"remove\")\n        # Fallback: no safe removal; try a mild improving swap\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            worst_in = max(sol, key=lambda i: scores[i-1]\/times[i-1])\n            best_out = min(outsiders, key=lambda i: scores[i-1]\/times[i-1])\n            new_sol = list(sol)\n            new_sol[new_sol.index(worst_in)] = best_out\n            return (_normalize(new_sol), \"swap\")\n        return (_normalize(sol), \"swap\")\n\n    # SWAP: 1-for-1 guided by ratio; ensure feasibility; if infeasible, add best outsider\n    elif move < 0.67:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            worst_in = max(sol, key=lambda i: scores[i-1]\/times[i-1])\n            best_out = min(outsiders, key=lambda i: scores[i-1]\/times[i-1])\n            new_sol = list(sol)\n            pos = new_sol.index(worst_in)\n            new_sol[pos] = best_out\n            t, _ = _totals(new_sol)\n            if t < 670:\n                # Add next best outsider by ratio prioritizing time\n                remaining = [o for o in outsiders if o != best_out]\n                if remaining:\n                    remaining.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n                    new_sol.append(remaining[0])\n            return (_normalize(new_sol), \"swap\")\n        return (_normalize(sol), \"swap\")\n\n    # ADD: add best outsider by ratio\n    outsiders = [i for i in range(1, n+1) if i not in sol]\n    if outsiders:\n        outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        new_sol = list(sol)\n        new_sol.append(outsiders[0])\n        return (_normalize(new_sol), \"add\")\n\n    # If no outsiders, perform a within-swap to diversify\n    if len(sol) >= 2:\n        i, j = random.sample(range(len(sol)), 2)\n        new_sol = list(sol)\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (_normalize(new_sol), \"swap\")\n\n    return (_normalize(sol), \"swap\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation for INDEX_LIST: randomly drop 1-2 items (if possible), then greedily refill\n    with items of lowest score\/time ratio until feasibility is restored. May add one extra random item\n    with small probability to promote diversification.\n    Returns a valid INDEX_LIST solution (deduplicated, 1-based indices within 1..24).\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    # Normalize input\n    def norm(sol: List[int]) -> List[int]:\n        seen = set()\n        out: List[int] = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    base = norm(list(solution))\n\n    # Randomly drop r items\n    if base:\n        r = 1 if len(base) == 1 else random.randint(1, min(2, len(base)))\n        for _ in range(r):\n            if base:\n                base.pop(random.randrange(len(base)))\n\n    # Greedy refill by increasing score\/time and prioritizing higher time on tie\n    outsiders = [i for i in range(1, n+1) if i not in base]\n    outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n\n    def total_time(sol: List[int]) -> int:\n        t = 0\n        for i in sol:\n            t += times[i-1]\n        return t\n\n    t = total_time(base)\n    for i in outsiders:\n        if t >= 670:\n            break\n        base.append(i)\n        t += times[i-1]\n\n    # Small extra random add with probability 0.3 if any outsiders remain\n    if random.random() < 0.3:\n        extra = [i for i in range(1, n+1) if i not in base]\n        if extra:\n            base.append(random.choice(extra))\n\n    # Deduplicate and bound\n    return norm(base)\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"LOCAL_SOLVER_ERROR_1:Type List cannot be instantiated; replace any List() with list().\"\n\"FEEDBACK\",\"LOCAL_SOLVER_ERROR_2:Heuristic signatures show callable parameters invoked with parentheses. Pass function references, not calls. EX: SA(..., generate_neighbour, evaluate_solution, ...).\"\n\"FEEDBACK\",\"LOCAL_SOLVER_ERROR_3:Missing perturbation implementation ($Perturb placeholder). Provide def perturb_solution(solution): ... and pass the callable.\"\n\"FEEDBACK\",\"LOCAL_SOLVER_ERROR_4:Parameter name typo 'aceptance_rate' in ILS. Standardize to 'acceptance_rate' to avoid mismatches.\"\n\"FEEDBACK\",\"LOCAL_SOLVER_ERROR_5:British spelling generate_neighbour may mismatch frameworks expecting generate_neighbor. Ensure consistent naming across solver and components or pass the correct reference explicitly.\"\n\"FEEDBACK\",\"LOCAL_SOLVER_ERROR_6:Movement type extra return ('add','remove','swap',...) must be handled by the heuristics; update SA\/ILS\/TS to accept (neighbour, move_type) or ignore the second value explicitly to prevent tuple-unpacking errors.\"\n\"FEEDBACK\",\"KNOWN_REF_INVALID:Provided 'KNOWN_SOLUTION' contains out-of-bounds indices causing infeasibility under evaluate_solution; 'EXPECTED_SCORE_FROM_KNOWN_SOLUTION' is inconsistent with the evaluator. Remove or correct the reference pair.\"\n\"FEEDBACK\",\"EVAL_CORRECTNESS_ASSERTION:Evaluator validated via exact dynamic programming; objective\/constraint behavior is consistent. The discrepancy lies in the provided known reference, not in the evaluator.\"\n\"FEEDBACK\",\"E_CODE_PERF:Each neighbour evaluation recomputes totals O(k) per check. Precompute numpy-free arrays and cache partial totals; or return (new_sol, delta_score, delta_time) to enable O(1) updates within heuristics.\"\n\"FEEDBACK\",\"E_PENALTY_SCALE:Penalty 1e9 + deficit*1e6 dwarfs objective; safe but harms annealing\/ILS temperature scaling. Normalize by objective magnitude or use additive infeasibility layer with lexicographic compare (feasible-first, then score).\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Within-solution 'swap' is a no-op for set-based INDEX_LIST; it yields identical solutions and wastes iterations. Remove or replace with drop-add (1-1 exchange) guided by marginal ratios.\"\n\"FEEDBACK\",\"NB_MOVE_WEAK:ADD selects best by score\/time may overshoot constraint and bloat sets. Replace greedy with constrained add: choose outsider minimizing marginal score subject to achieving >=670 with minimal added time.\"\n\"FEEDBACK\",\"NB_REPAIR_SUBOPTIMAL:Repair phase greedily adds by ratio; replace with bounded knapsack repair targeting the remaining time deficit to minimize added score (meet-in-the-middle for speed on small N).\"\n\"FEEDBACK\",\"NB_DIVERSIFICATION_INADEQUATE:Random branch probabilities fixed (0.34\/0.67). Introduce adaptive move selection using stagnation counters and success rates to bias toward productive operators.\"\n\"FEEDBACK\",\"NB_DOMINANCE:Pre-filter items by Pareto dominance (score, -time). Remove items strictly worse than others to reduce search space and simplify neighbour choices.\"\n\"FEEDBACK\",\"INIT_WEAK:Seeding with a single best-ratio item is slow to reach feasibility. Initialize with greedy cover to the boundary using minimal marginal score to satisfy >=670 quickly.\"\n\"FEEDBACK\",\"SA_CONFIG_BAD:Temperature parameters unspecified; add auto-scaling TEMP0 = c * std(cost over 100 neighbours) and geometric cooling with reheats on stagnation.\"\n\"FEEDBACK\",\"ILS_PERTURB_WEAK:Define perturb_solution as multi-move (e.g., drop 1\u20132 worst ratio insiders, add 1\u20132 best outsiders subject to feasibility) with strength adaptive to stagnation.\"\n\"FEEDBACK\",\"TS_MEMORY:Tabu list needs attribute-based memory (e.g., tabu indices) with aspiration when a move produces a strictly better feasible cost; ensure tabu tenure > neighbourhood diameter fraction.\"\n\"FEEDBACK\",\"CONSTRAINT_HANDLING:During REMOVE, ensure feasibility by checking time after removal; add second-chance add of best outsider if remove breaks feasibility to keep neighbourhood connected.\"\n\"FEEDBACK\",\"SCORING_GUIDE:Use lexicographic comparison (feasible flag, score, set size) in heuristics instead of mixing penalties to stabilize acceptance\/aspiration decisions.\"\n\"FEEDBACK\",\"REPRODUCIBILITY:Inject random.seed(other_params.get('seed', 0)) entry point in heuristics to enable consistent evaluations.\"\n\"FEEDBACK\",\"CODE_SAFETY:Avoid hidden state in neighbour; do not mutate input solution in-place. Always operate on copies and normalize once at entry.\"\n\"FEEDBACK\",\"SUGGESTED_FIX_SIGNATURE:Target signature should be def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params): and call function refs without parentheses.\"\n\"FEEDBACK\",\"SUGGESTED_PERTURB:Implement def perturb_solution(sol): perform k iterations of drop-add guided by worst_in = argmax(score\/time), best_out = argmin(score\/time) while keeping or restoring feasibility.\"\n\"FEEDBACK\",\"SUGGESTED_NEIGHBOURS:Augment with 1-1 swap (drop i add j) chosen by best improvement in score subject to time >= 670, and 0-1 add of minimal marginal score to reach boundary; remove within-swap.\"\n\"FEEDBACK\",\"VALIDATION_TESTS:Add unit tests: (i) invalid types -> 1e12; (ii) duplicate indices -> 1e12; (iii) out-of-range -> 1e12; (iv) feasibility boundary cases around 670; (v) neighbour returns valid unique 1..24 indices.\"\n\"FEEDBACK\",\"INSTRUMENTATION:Log (cost, time, move_type) per iteration to detect no-op moves and stagnation rapidly; assert cost strictly decreases on accepted improving moves.\"\n\"FEEDBACK\",\"TERMINATION:Stop criteria should include no-improvement budget and wall-iteration cap; include early-stop when lower bound from repair DP matches current best.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST: solution is a list of unique 1-based indices (subset of {1..24}). Fitness = total score; constraint enforced via penalty if total time < 670. Lower fitness is better.","Componentes":{"REPRESENTATION":"INDEX_LIST: solution is a list of unique 1-based indices (subset of {1..24}). Fitness = total score; constraint enforced via penalty if total time < 670. Lower fitness is better.","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Validate type\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    # Validate bounds and uniqueness\n    n = 24\n    indices = solution\n    if any(i < 1 or i > n for i in indices):\n        return 10**12\n    if len(set(indices)) != len(indices):\n        return 10**12\n\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for i in indices:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return float(total_score)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Representation: INDEX_LIST of unique 1-based indices in [1..24]\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel: List[int]) -> int:\n        return sum(times[i-1] for i in sel)\n\n    def make_feasible(sel: List[int]) -> List[int]:\n        # Greedily add lowest score\/time ratio items until time >= 670\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        ratio = sorted(avail, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1]))\n        for i in ratio:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    current = list(solution)\n    current = [i for i in current if isinstance(i, int) and 1 <= i <= n]\n    current = list(dict.fromkeys(current))  # ensure uniqueness and order\n\n    move_type = None\n\n    if not current:\n        # start by adding one\n        add_candidates = list(range(1, n+1))\n        add = random.choice(add_candidates)\n        neighbor = [add]\n        neighbor = make_feasible(neighbor)\n        move_type = \"add_init\"\n        return neighbor, \"INDEX_LIST\", move_type\n\n    move_choice = random.random()\n\n    if move_choice < 0.34:\n        # Swap: replace one selected index with a non-selected index\n        in_set = list(current)\n        out_set = [i for i in range(1, n+1) if i not in current]\n        if in_set and out_set:\n            a = random.choice(in_set)\n            b = random.choice(out_set)\n            neighbor = [i for i in current if i != a] + [b]\n            neighbor = list(dict.fromkeys(neighbor))\n            neighbor = make_feasible(neighbor)\n            move_type = \"swap\"\n        else:\n            neighbor = make_feasible(list(current))\n            move_type = \"noop\"\n    elif move_choice < 0.68:\n        # Add: add one new index\n        candidates = [i for i in range(1, n+1) if i not in current]\n        if candidates:\n            add = random.choice(candidates)\n            neighbor = current + [add]\n            neighbor = make_feasible(neighbor)\n            move_type = \"add\"\n        else:\n            neighbor = make_feasible(list(current))\n            move_type = \"noop\"\n    else:\n        # Remove: remove one index if feasible afterward; otherwise perform a swap\n        if len(current) > 1:\n            rem = random.choice(current)\n            tentative = [i for i in current if i != rem]\n            if total_time(tentative) >= 670:\n                neighbor = tentative\n                move_type = \"remove\"\n            else:\n                # fallback to swap to keep diversity and push toward feasibility\n                in_set = list(current)\n                out_set = [i for i in range(1, n+1) if i not in current]\n                if in_set and out_set:\n                    a = random.choice(in_set)\n                    b = random.choice(out_set)\n                    neighbor = [i for i in current if i != a] + [b]\n                    neighbor = list(dict.fromkeys(neighbor))\n                    neighbor = make_feasible(neighbor)\n                    move_type = \"swap_fallback\"\n                else:\n                    neighbor = make_feasible(list(current))\n                    move_type = \"noop\"\n        else:\n            neighbor = make_feasible(list(current))\n            move_type = \"noop\"\n\n    # Final sanitation: uniqueness, bounds\n    neighbor = [i for i in neighbor if 1 <= i <= n]\n    neighbor = list(dict.fromkeys(neighbor))\n    return neighbor, \"INDEX_LIST\", move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Strong shake: perform a random number of edits with feasibility repair\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel: List[int]) -> int:\n        return sum(times[i-1] for i in sel)\n\n    def make_feasible(sel: List[int]) -> List[int]:\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        ratio = sorted(avail, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1]))\n        for i in ratio:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    current = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n    k = random.randint(2, 6)\n    sel = set(current)\n\n    for _ in range(k):\n        r = random.random()\n        if r < 0.4 and sel:\n            # remove\n            rem = random.choice(list(sel))\n            sel.remove(rem)\n        elif r < 0.8:\n            # add\n            candidates = [i for i in range(1, n+1) if i not in sel]\n            if candidates:\n                sel.add(random.choice(candidates))\n        else:\n            # swap\n            if sel:\n                in_choice = random.choice(list(sel))\n                out_candidates = [i for i in range(1, n+1) if i not in sel]\n                if out_candidates:\n                    sel.remove(in_choice)\n                    sel.add(random.choice(out_candidates))\n\n    neighbor = list(sel)\n    neighbor.sort()\n\n    # Ensure feasibility by repair; also try to prune if overly large while staying feasible\n    neighbor = make_feasible(neighbor)\n\n    # Attempt light pruning: drop items with worst score\/time if feasibility remains\n    changed = True\n    while changed:\n        changed = False\n        if not neighbor:\n            break\n        # sort by descending score\/time then score\n        order = sorted(neighbor, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n        for i in order:\n            trial = [j for j in neighbor if j != i]\n            if total_time(trial) >= 670:\n                neighbor = trial\n                changed = True\n                break\n\n    return neighbor\n","SAMPLE_SOL":[5,7,9,13]},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"2025-11-20\"\n\"FEEDBACK\":\"\\\nFIX_LOCAL_SOLVER_ERROR_1:Heuristic signatures mismatch. Use def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) with callables passed WITHOUT parentheses; remove SA\/ILS\/TS bespoke signatures or wrap them to this general interface.\\\nFIX_LOCAL_SOLVER_ERROR_2:Typing misuse. Do not instantiate typing.List; replace any List() with list(), and remove any type objects used as constructors.\\\nFIX_LOCAL_SOLVER_ERROR_3:Constructor calls in signatures. In SA\/ILS\/TS definitions and invocations, remove generate_neighbour(), evaluate_solution(), perturb_solution() parentheses; pass function references, not return values.\\\nFIX_LOCAL_SOLVER_ERROR_4:Perturbation function missing. Implement a perturb_solution(solution, intensity, rng) that performs multi-move (e.g., 1\u20132 swaps\/removes\/adds) while maintaining representation constraints; wire it into the unified Heuristic signature.\\\nE_INTERFACE_INCOMPATIBLE:Provided heuristic function signatures do not conform to TARGET_HEURISTIC_GENERAL_SIGNATURE, preventing orchestration. Unify to a single entry point and adapt parameter order accordingly.\\\nNB_CODE_FAIL_LOCAL_OPT:Neighbour generator over-relies on greedy make_feasible, biasing toward bloated sets and limiting escape from local minima. Add balanced infeasible exploration with controlled penalties or delayed repair; include 1-1 and 2-1 swap moves optimizing delta score per delta time.\\\nNB_MOVE_SET_INSUFFICIENT:Only add\/remove\/swap singletons. Add compound moves: (i) drop-k until time just above threshold by largest score\/time, (ii) 2-opt exchanges minimizing score increase while keeping time \u2265 670, (iii) time-tightening operator removing redundant items with minimal time loss.\\\nE_CODE_PERF:Neighbour evaluation is O(n) per step due to repeated total_time computation and set membership scans. Maintain cached (total_time,total_score) and a boolean in_set[1..24] for O(1) membership; update deltas per move.\\\nREPAIR_HEURISTIC_WEAK:make_feasible uses score\/time ratio only. Improve with lexicographic key (score\/time, score, -time) and consider knapsack-like bounded lookahead (try top-2 candidates) to avoid myopic additions.\\\nCONSTRAINT_HANDLING_IMBALANCE:Penalty uses 1e9 + deficit*1e6; this dwarfs objective and can stall annealing near boundary. Use adaptive penalty or allow a small band of infeasibility with scaled deficit to preserve gradient; alternatively repair after a few steps rather than every step.\\\nOBJ_FN_DUPLICATION:objective_function differs from evaluate_solution and ignores penalties. Remove or unify to a single evaluation to prevent inconsistent fitness usage.\\\nREPRESENTATION_VALIDATION:Known solution vector contains 0 (0-based), violating 1-based bounds and uniqueness rules; current evaluator returns a large penalty. Normalize inputs to 1-based or reject early with explicit error codes.\\\nKNOWN_SOLUTION_INCONSISTENT:Provided expected score does not match evaluate_solution under current constraints; recompute scores from indices using the evaluator to avoid silent drift.\\\nSAMPLE_SOLUTION_CHECK:Sample [5,7,9,13] is feasible and consistent with the evaluator; keep as a test case for regression. Do not assume optimality without verification in code.\\\nTEST_HARNESS_GAPS:Add automated unit tests: (i) invalid types, (ii) out-of-bounds, (iii) duplicates, (iv) feasibility threshold edge cases (e.g., exactly 670, 669, 671), (v) neighbour move invariants.\\\nDELTA_EVAL_RECOMMEND:Implement evaluate_delta(solution, move) to compute new (time,score) in O(1) for SA\/TS acceptance; this reduces runtime and stabilizes cooling schedules.\\\nTABU_CONFIG_WEAK:No actual taboo attributes defined. Use attribute-based tabu on indices involved in swaps (tenure ~7\u201315) and aspiration if new best. Avoid storing full solutions.\\\nANNEALING_PARAMS:Cooling_factor unspecified; use geometric cooling with reheats, e.g., T0 from stddev of initial deltas, Tmin ~ 1e-3*T0, reheats on stagnation.\\\nILS_ACCEPTANCE:Acceptance criterion unclear; implement late acceptance or Metropolis-based acceptance for perturbed local minima to prevent cycling.\\\nOUTPUT_DIAGNOSTICS:Local solver expects extra outputs; include move_type, current_time, current_score, is_feasible flags each iteration for traceability.\\\nVERIFICATION_STATUS:Evaluator cross-checked against exhaustive dynamic programming to validate constraint handling and to detect mismatches between provided \u201cknown\u201d data and actual evaluation behavior; current \u201cknown\u201d entry fails verification.\\\nCONCRETE_FIX_SIG:Replace SA signature with def Heuristic(cur,best,best_score,gen,evalf,perturb,params): for it in range(params['iters']): cand,_rtype,_move=gen(cur); f=evalf(cand); accept=...; update tabu\/annealing as needed; return best,best_score. Ensure no filesystem\/network usage.\\\nCONCRETE_FIX_PERTURB:def perturb_solution(sol,intensity,rng): apply m=random.randint(1,intensity) random composite moves: random 1-1 swap, add, remove-if-feasible, or targeted drop by highest score\/time; sanitize to 1-based unique indices; optionally repair if time<670 via improved ratio heuristic.\\\nACTION_ITEMS:1) Fix signatures and typing; 2) Implement perturb; 3) Add delta-eval and richer moves; 4) Rebalance penalty\/repair; 5) Build unit tests including the sample; 6) Add diagnostics for local solver expectations; 7) Re-run and benchmark convergence.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST; list of unique 1-based indices in [1..24].","Componentes":{"REPRESENTATION":"INDEX_LIST; list of unique 1-based indices in [1..24].","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Type validation\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return float(10**12)\n\n    n = 24\n    # Bounds and uniqueness\n    if any(i < 1 or i > n for i in solution):\n        return float(10**12)\n    if len(set(solution)) != len(solution):\n        return float(10**12)\n\n    total_time = 0\n    total_score = 0\n    for i in solution:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    if total_time < 670:\n        deficit = 670 - total_time\n        return float(total_score + 10**9 + deficit * 10**6)\n\n    return float(total_score)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Representation: INDEX_LIST\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel: List[int]) -> int:\n        return sum(times[i-1] for i in sel)\n\n    def sanitize(sel: List[int]) -> List[int]:\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        # maintain order but unique\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def greedy_repair(sel: List[int]) -> List[int]:\n        # Only repair with some probability to allow controlled infeasibility exploration\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        # Lexicographic key: score\/time, score, -time\n        avail.sort(key=lambda i: (scores[i-1] \/ times[i-1], scores[i-1], -times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n    if not cur:\n        # Initialize by adding one random item then repair\n        add = random.randint(1, n)\n        nb = greedy_repair([add])\n        return sanitize(nb), \"INDEX_LIST\", \"init_add_repair\"\n\n    move_r = random.random()\n    move_type = \"noop\"\n\n    # Candidate pools\n    in_set = list(cur)\n    out_set = [i for i in range(1, n+1) if i not in cur]\n\n    if move_r < 0.20 and len(in_set) >= 2 and len(out_set) >= 1:\n        # 2->1 exchange: drop two, add one\n        a, b = random.sample(in_set, 2)\n        c = random.choice(out_set)\n        nb = [i for i in cur if i not in (a, b)] + [c]\n        move_type = \"exchange_2_1\"\n    elif move_r < 0.40 and len(in_set) >= 1 and len(out_set) >= 2:\n        # 1->2 exchange: drop one, add two\n        a = random.choice(in_set)\n        b, c = random.sample(out_set, 2)\n        nb = [i for i in cur if i != a] + [b, c]\n        move_type = \"exchange_1_2\"\n    elif move_r < 0.60 and in_set and out_set:\n        # 1-1 swap\n        a = random.choice(in_set)\n        b = random.choice(out_set)\n        nb = [i for i in cur if i != a] + [b]\n        move_type = \"swap_1_1\"\n    elif move_r < 0.80 and out_set:\n        # Add\n        b = random.choice(out_set)\n        nb = cur + [b]\n        move_type = \"add\"\n    else:\n        # Targeted remove or time-tightening: remove worst score\/time if feasible after removal; else fallback swap\n        if in_set:\n            # sort by descending score\/time then score to drop high-cost per time\n            order = sorted(in_set, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for rem in order:\n                trial = [j for j in cur if j != rem]\n                if total_time(trial) >= 670:\n                    nb = trial\n                    move_type = \"remove_tighten\"\n                    break\n            else:\n                # fallback: swap\n                if out_set:\n                    a = random.choice(in_set)\n                    b = random.choice(out_set)\n                    nb = [i for i in cur if i != a] + [b]\n                    move_type = \"swap_fallback\"\n                else:\n                    nb = list(cur)\n                    move_type = \"noop\"\n        else:\n            nb = list(cur)\n            move_type = \"noop\"\n\n    # With small probability, repair to feasibility to avoid drifting too far\n    if random.random() < 0.5:\n        nb = greedy_repair(nb)\n\n    nb = sanitize(nb)\n    return nb, \"INDEX_LIST\", move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel: List[int]) -> int:\n        return sum(times[i-1] for i in sel)\n\n    def sanitize(sel: List[int]) -> List[int]:\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def repair(sel: List[int]) -> List[int]:\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        avail.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n\n    # Intensity: random number of composite edits\n    m = random.randint(3, 7)\n    sel = set(cur)\n\n    for _ in range(m):\n        r = random.random()\n        if r < 0.33 and sel:\n            # remove random\n            rem = random.choice(list(sel))\n            sel.remove(rem)\n        elif r < 0.66:\n            # add random\n            candidates = [i for i in range(1, n+1) if i not in sel]\n            if candidates:\n                sel.add(random.choice(candidates))\n        else:\n            # targeted swap: replace worst score\/time with a random outsider\n            if sel:\n                worst = max(sel, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                outsiders = [i for i in range(1, n+1) if i not in sel]\n                if outsiders:\n                    sel.remove(worst)\n                    sel.add(random.choice(outsiders))\n\n    nb = sorted(list(sel))\n    nb = repair(nb)\n\n    # Light pruning: drop items (highest score\/time first) while keeping feasibility\n    changed = True\n    while changed and nb:\n        changed = False\n        order = sorted(nb, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n        for i in order:\n            trial = [j for j in nb if j != i]\n            if total_time(trial) >= 670:\n                nb = trial\n                changed = True\n                break\n\n    return nb\n","SAMPLE_SOL":"[5,7,9,13]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Heuristic signature mismatch. Use def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) exactly. Remove parentheses from parameter names in SA\/ILS\/TS to avoid runtime binding errors.\"\n\n\"E_LOCAL_SOLVER_TYPE_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead' indicates runtime instantiation of typing.List. Do not create List() or Tuple() anywhere. Use built-ins list() and tuple() only; keep typing imports strictly for annotations.\"\n\n\"E_LOCAL_SOLVER_PERTURB_MISSING:Perturbation function undefined ('$Perturb'). Provide a concrete def perturb_solution(solution, rng) that preserves representation and returns a valid neighbor to enable ILS and restarts.\"\n\n\"E_EVAL_REPR_INCONSISTENCY:Known solution contains index 0 while evaluation enforces 1..24. Resolve index base mismatch: either shift data to 0-based everywhere or keep 1-based and correct all test vectors accordingly.\"\n\n\"E_KNOWN_EXPECTED_MISMATCH:Expected score attached to known solution is inconsistent under the current evaluator. Recompute or realign expected with the enforced representation to avoid false negatives in tests.\"\n\n\"E_INIT_POLICY:generate_neighbour initializes from a single random add + repair only when cur is empty. Provide a deterministic feasible constructor for starting solutions to stabilize SA\/ILS\/TS (e.g., greedy ratio-based fill).\"\n\n\"E_PENALTY_SCALING:Penalty 1e9 + deficit*1e6 dwarfs objective; SA temperature and acceptance become ineffective for infeasible exploration. Either enforce feasibility in neighborhoods or adopt an adaptive penalty with bounded range relative to objective (e.g., lambda updated by subgradient on time deficit).\"\n\n\"E_MOVE_SET_BIAS:Neighbour adds 50% greedy_repair post-move, which frequently forces large overshoots and reduces diversity. Make repair probability state-dependent (increase when highly infeasible; 0 when already feasible) and cap additions to the minimum required to cross 670 using a priority queue.\"\n\n\"E_DROP_CRITERION:remove_tighten ranks by -score\/time then -score, which is reasonable, but it never considers pairwise removals that maintain feasibility with lower objective. Add 2-drop feasibility-preserving removal and 2-for-2 exchanges guided by marginal ratios.\"\n\n\"E_TIME_AWARE_SWAP:1-1 swaps ignore time slack; can create deep infeasibility then get over-repaired. Add slack-aware swap: prefer adding items with low score\/time when time < 670; when time >= 670 prefer removing items with high score\/time; evaluate only moves that keep or minimally repair feasibility.\"\n\n\"E_DETERMINISM_FOR_TESTS:RNG not seeded; regression tests will be flaky. Accept rng instance in Heuristic and generate_neighbour, or set local rng = random.Random(seed) passed via other_params for reproducibility.\"\n\n\"E_OUTPUT_PROTOCOL:Local solver expects extra outputs; ensure Heuristic returns (newSolution,newBest,newBestScore,meta) and log move_type from generate_neighbour for traceability as required by 'LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED'.\"\n\n\"R_REP_VALIDATION:Strict uniqueness and bounds are good; add sorted canonicalization or stable order policy to avoid accidental duplicates from chained moves and to keep hashing consistent for tabu.\"\n\n\"R_MOVE_INTENSIFICATION:Add ejection-chain (k-sequence add->remove guided by lambda) to escape 1-step local minima. Also add greedy fill and greedy prune phases alternating until no improvement.\"\n\n\"R_SCORING_HEURISTIC:Switch greedy_repair sort key to (score\/time, score, time) strictly ascending to prefer shorter time when ratios tie; current -time favors longer time and can cause unnecessary overshoot.\"\n\n\"R_TABU_CONF:Tabu Search must track attributes (added, removed indices) not whole solutions; configure tabu tenure relative to n (e.g., 7\u201312) and aspiration by objective.\"\n\n\"R_SA_SCHEDULE:Set initial TEMP to match objective scale (median delta over 200 random feasible moves); multiplicative cooling 0.95\u20130.99; stop when no improvement for K iterations or TEMP < 1e-3. Current penalty scale mandates recalibration.\"\n\n\"R_ILS_PERTURB:Design perturb to flip 1\u20133 high score\/time items and greedily repair; acceptance criterion accept if better or with probability exp(-(delta)\/T0) where T0 tuned to feasible deltas only.\"\n\n\"NB_CODE_FAIL_LOCAL_OPT:Neighbourhood lacks targeted add of best ratio items conditioned on remaining deficit. Implement a loop that adds the single lowest ratio item that crosses the deficit instead of batch append.\"\n\n\"E_TEST_FIXTURE:Sample solution [5,7,9,13] evaluates feasible under current evaluator; use it as a smoke test to assert pipeline integrity before running metaheuristics.\"\n\n\"VALIDATION_ASSERT:Run evaluator on the provided test solutions to confirm mismatch detection. Actions: 1) assert invalid for any index outside 1..24; 2) assert feasibility threshold at 670; 3) assert that greedy ratio-based fill yields a feasible objective consistent across runs.\"\n\n\"ACTIONABLE_PATCH_ORDER:1) Fix signatures and remove typing instantiation. 2) Implement perturb_solution. 3) Add deterministic feasible constructor. 4) Adjust repair and move-set per slack. 5) Seed RNG via other_params. 6) Recalibrate SA\/TS parameters to feasible deltas. 7) Update tests to use consistent 1-based indices.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Type validation\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return float(10**12)\n\n    n = 24\n    # Bounds and uniqueness\n    if any(i < 1 or i > n for i in solution):\n        return float(10**12)\n    if len(set(solution)) != len(solution):\n        return float(10**12)\n\n    total_time = 0\n    total_score = 0\n    for i in solution:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    if total_time < 670:\n        deficit = 670 - total_time\n        return float(total_score + 10**9 + deficit * 10**6)\n\n    return float(total_score)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Representation: INDEX_LIST (list of unique 1-based indices in [1..24])\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel):\n        return sum(times[i-1] for i in sel)\n\n    def total_score(sel):\n        return sum(scores[i-1] for i in sel)\n\n    def sanitize(sel):\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def greedy_construct():\n        # Deterministic feasible constructor: add items by ascending (score\/time, score, time)\n        order = list(range(1, n+1))\n        order.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        sel = []\n        cur_t = 0\n        for i in order:\n            sel.append(i)\n            cur_t += times[i-1]\n            if cur_t >= 670:\n                break\n        # Light pruning: remove items with worst score\/time while keeping feasibility\n        changed = True\n        while changed and sel:\n            changed = False\n            order_drop = sorted(sel, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for j in order_drop:\n                trial = [k for k in sel if k != j]\n                if total_time(trial) >= 670:\n                    sel = trial\n                    changed = True\n                    break\n        return sel\n\n    def greedy_repair(sel):\n        cur_t = total_time(sel)\n        if cur_t >= 670:\n            return sel\n        deficit = 670 - cur_t\n        avail = [i for i in range(1, n+1) if i not in sel]\n        # Prefer low score\/time, then low score, then low time\n        avail.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n    if not cur:\n        nb = greedy_construct()\n        return nb, \"INDEX_LIST\", \"init_greedy_construct\"\n\n    in_set = list(cur)\n    out_set = [i for i in range(1, n+1) if i not in cur]\n\n    move_r = random.random()\n    move_type = \"noop\"\n\n    # Slack-aware moves\n    cur_time = total_time(cur)\n\n    if move_r < 0.18 and len(in_set) >= 2 and len(out_set) >= 1:\n        # 2->1 exchange\n        a, b = random.sample(in_set, 2)\n        c = random.choice(out_set)\n        nb = [i for i in cur if i not in (a, b)] + [c]\n        move_type = \"exchange_2_1\"\n    elif move_r < 0.36 and len(in_set) >= 1 and len(out_set) >= 2:\n        # 1->2 exchange\n        a = random.choice(in_set)\n        b, c = random.sample(out_set, 2)\n        nb = [i for i in cur if i != a] + [b, c]\n        move_type = \"exchange_1_2\"\n    elif move_r < 0.54 and in_set and out_set:\n        # 1-1 swap\n        a = random.choice(in_set)\n        b = random.choice(out_set)\n        nb = [i for i in cur if i != a] + [b]\n        move_type = \"swap_1_1\"\n    elif move_r < 0.72 and out_set:\n        # Add\n        b = random.choice(out_set)\n        nb = cur + [b]\n        move_type = \"add\"\n    else:\n        # Feasibility-preserving removal: drop high score\/time if feasible after removal\n        nb = list(cur)\n        if in_set:\n            order = sorted(in_set, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for rem in order:\n                trial = [j for j in cur if j != rem]\n                if total_time(trial) >= 670:\n                    nb = trial\n                    move_type = \"remove_tighten\"\n                    break\n            else:\n                # fallback targeted swap based on slack\n                if out_set:\n                    if cur_time < 670:\n                        # prefer adding low ratio\n                        add = min(out_set, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n                        rem = max(in_set, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                    else:\n                        add = min(out_set, key=lambda i: (scores[i-1], scores[i-1]\/times[i-1], times[i-1]))\n                        rem = max(in_set, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                    nb = [i for i in cur if i != rem] + [add]\n                    move_type = \"swap_targeted\"\n                else:\n                    move_type = \"noop\"\n\n    # State-dependent repair probability\n    nb_time = total_time(nb)\n    if nb_time < 670:\n        deficit = 670 - nb_time\n        # Probability increases with deficit; ensure within [0.0, 1.0]\n        p_repair = max(0.2, min(1.0, deficit \/ 200.0))\n        if random.random() < p_repair:\n            nb = greedy_repair(nb)\n    else:\n        # Optional light prune to reduce cost while keeping feasibility (small chance)\n        if random.random() < 0.25 and nb:\n            # Try remove a single worst ratio item if feasible\n            order = sorted(nb, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for rem in order:\n                trial = [j for j in nb if j != rem]\n                if total_time(trial) >= 670:\n                    nb = trial\n                    move_type = move_type + \"+prune1\"\n                    break\n\n    nb = sanitize(nb)\n    return nb, \"INDEX_LIST\", move_type\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel):\n        return sum(times[i-1] for i in sel)\n\n    def sanitize(sel):\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def repair(sel):\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        avail.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n\n    # If empty or grossly infeasible, construct a deterministic feasible base\n    if not cur or total_time(cur) < 200:\n        # Greedy construct\n        order = list(range(1, n+1))\n        order.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        sel = []\n        t = 0\n        for i in order:\n            sel.append(i)\n            t += times[i-1]\n            if t >= 670:\n                break\n        cur = sel\n\n    sel = set(cur)\n    # Intensity: 3 to 7 composite edits\n    m = random.randint(3, 7)\n\n    for _ in range(m):\n        r = random.random()\n        if r < 0.33 and sel:\n            # remove random\n            rem = random.choice(list(sel))\n            sel.remove(rem)\n        elif r < 0.66:\n            # add random outsider\n            candidates = [i for i in range(1, n+1) if i not in sel]\n            if candidates:\n                sel.add(random.choice(candidates))\n        else:\n            # targeted swap: replace worst score\/time with a random outsider\n            if sel:\n                worst = max(sel, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                outsiders = [i for i in range(1, n+1) if i not in sel]\n                if outsiders:\n                    sel.remove(worst)\n                    sel.add(random.choice(outsiders))\n\n    nb = sorted(list(sel))\n    nb = repair(nb)\n\n    # Light multi-step pruning: repeatedly drop highest ratio items while feasible\n    changed = True\n    while changed and nb:\n        changed = False\n        order = sorted(nb, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n        for i in order:\n            trial = [j for j in nb if j != i]\n            if total_time(trial) >= 670:\n                nb = trial\n                changed = True\n                break\n\n    return nb\n","SAMPLE_SOL":"[5,9,13,24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nE_SIG_MISMATCH_SA:Signature does not match required general signature. Replace with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_SIG_MISMATCH_ILS:Signature does not match required general signature. Replace with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_SIG_MISMATCH_TS:Signature does not match required general signature. Replace with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nNB_RETVAL_ARITY:generate_neighbour returns 3 values (solution,repr,move_type) but local solvers expect 2. Remove move_type from return or adapt solvers to unpack 3 consistently. Minimal fix: return (neighbour, 'INDEX_LIST') only.\nPERTURB_MISSING:Perturbation function not provided. Implement perturb_solution(solution) with safe, representation-preserving moves.\nKNOWN_SOL_FORMAT:Provided known solution uses 0-based indices violating bounds [1..24]. Correct to 1-based unique indices to avoid hard penalty.\nEVAL_CORRECTNESS_CHECK:Evaluation of provided known solution triggers infeasibility penalty due to index bounds. Fix KNOWN_SOLUTION format to validate scoring pipeline.\nE_CODE_FLOAT_REDUNDANCY:Unnecessary float(...) casts in evaluate_solution. Remove to reduce overhead and keep pure numeric types.\nE_CODE_PENALTY_SCALE:Penalty 1e9 + deficit*1e6 is acceptable but large. Verify no overflow in aggregations; keep int to avoid float precision noise.\nE_CODE_PERF:O(n) recomputation of totals for every neighbor. Use incremental deltas for swap\/add\/remove to cut to O(1) per move.\nR_STATE_INVARIANT:Representation lacks ordering invariant. Sort solution list after moves to stabilize hashing\/caching and taboo checks.\nINIT_BIAS:greedy_construct deterministic and narrow. Add GRASP-style randomized construction (alpha in [0.1,0.4]) to diversify starts.\nREPAIR_OVERSHOOT:greedy_repair may add multiple high-time items without minimal marginal cost control. Use a loop selecting argmin(score\/time) with early stop and consider 1-for-k exchanges when close to feasibility.\nPRUNE_WEAKNESS:Pruning removes worst ratio greedily; may miss multi-drop improvements. Add 2-drop and 3-drop prune attempts bounded by time budget.\nMOVE_SET_GAPS:No targeted 2-for-2 exchange when time slack small. Add balanced 2-2 swap exploring pairs via sampled subset.\nTABUO_LIST_DEFINITION:Tabu structures unspecified. Define tabu tenure on indices and attribute-based aspiration to prevent cycling.\nTEMP_SCHEDULE:SA lacks parameterization. Use geometric cooling T*=T*cf with cf in [0.90,0.99], stop at MIN_TEMP or stall iterations.\nACCEPT_CRITERIA_ILS:Acceptance not defined. Use accept if score improves or with small prob exp(-(delta)\/T_ils).\nRANDOM_SEEDING:No seed control. Expose seed param for reproducibility during evaluation.\nLOGGING_NONINTRUSIVE:Do not return move_type from neighbour. If needed, log via external callback to avoid retval arity drift.\nBOUND_CHECK:Ensure every operator preserves 1..24 bounds and uniqueness; sanitize once per move only to avoid O(n^2) overhead.\nSUGGESTED_PATCH_NB:def generate_neighbour(solution): implement and return only (neighbour,'INDEX_LIST'). Keep all internal helpers; drop move_type from output. Maintain sanitize and optional light prune. Ensure O(1) delta updates if integrated with solver.\nSUGGESTED_PATCH_PERTURB:def perturb_solution(sol): perform k-shuffle on 10\u201320% of positions; optionally drop a high ratio item if still feasible and then greedy-repair to restore feasibility.\nSUGGESTED_PATCH_HEUR:def Heuristic(cur,best,best_score,gen_nb,eval_sol,perturb,params): unified signature across SA\/ILS\/TS; unpack neighbour=gen_nb(cur)[0]; never assume third return.\nASSERTION_TESTS:Add unit tests: (1) bounds\/uniqueness validation, (2) feasibility repair reaches >=670, (3) neighbour arity equals 2, (4) perturb preserves representation, (5) heuristic stops with finite evaluations.\nCODE_SNIPPET_NEIGHBOUR:\ndef generate_neighbour(solution):\n    import random\n    scores=[19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times=[110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n=24\n    def total_time(sel): return sum(times[i-1] for i in sel)\n    def sanitize(sel):\n        out=[]; seen=set()\n        for i in sel:\n            if isinstance(i,int) and 1<=i<=n and i not in seen:\n                out.append(i); seen.add(i)\n        return out\n    def greedy_repair(sel):\n        if total_time(sel)>=670: return sel\n        avail=[i for i in range(1,n+1) if i not in sel]\n        avail.sort(key=lambda i:(scores[i-1]\/times[i-1],scores[i-1],times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel)>=670: break\n        return sel\n    cur=sanitize(list(solution))\n    if not cur:\n        order=list(range(1,n+1))\n        order.sort(key=lambda i:(scores[i-1]\/times[i-1],scores[i-1],times[i-1]))\n        sel=[]\n        t=0\n        for i in order:\n            sel.append(i); t+=times[i-1]\n            if t>=670: break\n        return sanitize(sel),'INDEX_LIST'\n    in_set=list(cur); out_set=[i for i in range(1,n+1) if i not in cur]\n    r=random.random()\n    if r<0.3 and in_set and out_set:\n        a=random.choice(in_set); b=random.choice(out_set)\n        nb=[i for i in cur if i!=a]+[b]\n    elif r<0.6 and out_set:\n        nb=cur+[random.choice(out_set)]\n    else:\n        # prune if feasible\n        nb=list(cur)\n        if in_set:\n            idx=max(in_set,key=lambda i:(scores[i-1]\/times[i-1],scores[i-1],-times[i-1]))\n            trial=[j for j in cur if j!=idx]\n            if total_time(trial)>=670: nb=trial\n    if sum(times[i-1] for i in nb)<670: nb=greedy_repair(nb)\n    nb=sanitize(nb)\n    nb.sort()\n    return nb,'INDEX_LIST'\nCODE_SNIPPET_PERTURB:\ndef perturb_solution(solution):\n    import random\n    n=24\n    sol=list(solution)\n    k=max(1,len(sol)\/\/5)\n    # Drop k worst ratio items if feasible after each drop; else skip drop\n    scores=[19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times=[110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    def t(sel): return sum(times[i-1] for i in sel)\n    if sol:\n        drop=sorted(sol,key=lambda i:(scores[i-1]\/times[i-1],scores[i-1]))[:k]\n        for d in drop:\n            trial=[x for x in sol if x!=d]\n            if t(trial)>=670: sol=trial\n    # Random add up to k items\n    avail=[i for i in range(1,n+1) if i not in sol]\n    random.shuffle(avail)\n    for i in avail[:k]:\n        sol.append(i)\n    # Final repair\n    if t(sol)<670:\n        avail=[i for i in range(1,n+1) if i not in sol]\n        avail.sort(key=lambda i:(scores[i-1]\/times[i-1],scores[i-1],times[i-1]))\n        for i in avail:\n            sol.append(i)\n            if t(sol)>=670: break\n    sol=sorted(set(sol))\n    return sol\nCODE_SNIPPET_SA:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params):\n    import math,random\n    T=params.get('TEMP',100.0); Tmin=params.get('MIN_TEMP',1e-3); cf=params.get('cooling_factor',0.95)\n    cur=list(currentSolution); cur_score=evaluate_solution(cur)\n    if best is None or cur_score<best_score: best=list(cur); best_score=cur_score\n    while T>Tmin:\n        nb,repr_tag=generate_neighbour(cur)\n        nb_score=evaluate_solution(nb)\n        delta=nb_score-cur_score\n        if delta<=0 or random.random()<math.exp(-delta\/max(T,1e-12)):\n            cur,cur_score=nb,nb_score\n            if cur_score<best_score: best,best_score=list(cur),cur_score\n        # occasional perturb\n        if random.random()<0.05:\n            p=perturb_solution(cur); ps=evaluate_solution(p)\n            if ps<cur_score: cur,cur_score=p,ps\n        T*=cf\n    return best,best_score\nMETRICS_AND_TESTS:\n- TEST_RETVALS:Assert generate_neighbour returns 2-tuple and perturb_solution returns list of ints in [1..24] unique.\n- TEST_EVAL:Check feasibility penalty triggers on time<670 and equals base+deficit*1e6+objective.\n- TEST_REPR:Ensure sort-invariant solutions to stabilize tabu hashing and caching.\n- TEST_SA:Run 5 restarts with different seeds; assert non-increasing best_score across iterations.\nPARAM_RANGES:\n- SA:TEMP in [10, 1000], MIN_TEMP in [1e-6, 1e-2], cooling_factor in [0.90,0.99].\n- TS:taboo_list_size in [7, 50], taboo_duration in [5, 20].\n- ILS:iterations in [50, 1000], acceptance_rate in [0.0, 0.2].\nACTION_ITEMS:\n- Normalize function signatures to the general signature immediately.\n- Change neighbour return to (solution,'INDEX_LIST') and remove move_type from outputs.\n- Implement perturb_solution as above.\n- Fix KNOWN_SOLUTION to valid 1-based indices.\n- Add unit tests described to prevent regression in arity\/feasibility.\n- Optimize evaluation with incremental deltas if solver tracks move details.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_ASC_CSV","Componentes":{"REPRESENTATION":"INDEX_LIST_ASC_CSV","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation: comma-separated ascending list of unique indices in [1,24]\n    # Accepts empty string for empty set\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130,50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Parse solution string to list of ints\n    if solution is None:\n        return float('inf')\n    if not isinstance(solution, str):\n        return float('inf')\n    sol_str = solution.strip()\n    if sol_str == \"\":\n        idx_list: List[int] = []\n    else:\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != \"\"]\n        # Validate integer tokens\n        try:\n            idx_list = [int(p) for p in parts]\n        except Exception:\n            return float('inf')\n\n    # Basic validations\n    if any(i < 1 or i > n for i in idx_list):\n        return float('inf')\n    if len(idx_list) != len(set(idx_list)):\n        return float('inf')\n\n    # Compute score and time\n    total_score = 0\n    total_time = 0\n    for i in idx_list:\n        j = i - 1\n        total_score += scores[j]\n        total_time += times[j]\n\n    # Feasibility and fitness\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n    return float(total_score) + (float(total_time) * 1e-6)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _parse_sol(sol_str: str) -> List[int]:\n    if sol_str is None:\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out = []\n    for p in parts:\n        try:\n            out.append(int(p))\n        except Exception:\n            return []\n    # Deduplicate and keep only valid range 1..24\n    out = [i for i in out if 1 <= i <= 24]\n    out = sorted(set(out))\n    return out\n\ndef _encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_neighbour_solution, movement_type)\n    n = 24\n    indices = set(range(1, n+1))\n    curr = _parse_sol(solution if isinstance(solution, str) else \"\")\n    curr_set = set(curr)\n\n    move = random.random()\n    # Prefer feasible search diversification: random move among add\/remove\/swap\n    if move < 0.34:\n        # ADD one random missing index\n        missing = list(indices - curr_set)\n        if missing:\n            add_i = random.choice(missing)\n            curr.append(add_i)\n            nb_type = \"add\"\n        else:\n            nb_type = \"noop\"\n    elif move < 0.68:\n        # REMOVE one random present index\n        if curr:\n            rem_i = random.choice(curr)\n            curr.remove(rem_i)\n            nb_type = \"remove\"\n        else:\n            nb_type = \"noop\"\n    else:\n        # SWAP: remove one present, add one missing\n        if curr:\n            present = list(curr)\n            missing = list(indices - set(curr))\n            if missing:\n                rem_i = random.choice(present)\n                add_i = random.choice(missing)\n                curr.remove(rem_i)\n                curr.append(add_i)\n                nb_type = \"swap\"\n            else:\n                nb_type = \"noop\"\n        else:\n            # If empty, degrade to add\n            missing = list(indices)\n            add_i = random.choice(missing)\n            curr.append(add_i)\n            nb_type = \"add\"\n\n    encoded = _encode_sol(curr)\n    return encoded, nb_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _parse_sol(sol_str: str) -> List[int]:\n    if sol_str is None:\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out = []\n    for p in parts:\n        try:\n            out.append(int(p))\n        except Exception:\n            return []\n    out = [i for i in out if 1 <= i <= 24]\n    return sorted(set(out))\n\ndef _encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\ndef perturb_solution(solution):\n    # Stronger random shake: apply k random add\/remove\/swap moves\n    n = 24\n    k = random.randint(3, 6)\n    curr = _parse_sol(solution if isinstance(solution, str) else \"\")\n    indices_all = set(range(1, n+1))\n\n    for _ in range(k):\n        curr_set = set(curr)\n        r = random.random()\n        if r < 0.33:\n            # add\n            missing = list(indices_all - curr_set)\n            if missing:\n                curr.append(random.choice(missing))\n        elif r < 0.66:\n            # remove\n            if curr:\n                rem = random.choice(curr)\n                curr.remove(rem)\n        else:\n            # swap\n            present = list(curr)\n            missing = list(indices_all - curr_set)\n            if present and missing:\n                rem = random.choice(present)\n                add = random.choice(missing)\n                curr.remove(rem)\n                curr.append(add)\n    return _encode_sol(curr)\n","SAMPLE_SOL":"5,7,9,13"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.0\"\n\n\"FEEDBACK\",\"E_SIG_SA:Invalid signature and call syntax. Remove function calls from parameters and align to TARGET_HEURISTIC_GENERAL_SIGNATURE. Use def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) not def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor).\"\n\n\"E_SIG_ILS:Invalid signature and call syntax; misspelled parameter. Use def ILS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove parentheses after function parameters and fix 'acceptance_rate' spelling.\"\n\n\"E_SIG_TS:Invalid signature and call syntax. Use def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do not pass taboo parameters as separate scalars; pack into other_params or a small dict.\"\n\n\"E_TYPE_LIST:Runtime error 'Type List cannot be instantiated; use list() instead.' Replace any List() constructions with list(). Keep typing only in annotations: from typing import List; def f(x: List[int]) -> List[int]: ...; never call List().\"\n\n\"E_PERTURB_MISSING:Perturbation function placeholder '$Perturb' is undefined. Provide a concrete perturb_solution(currentSolution,rng,scale) that performs multi-swap or add-remove-k moves to escape local minima.\"\n\n\"E_REPR_MISMATCH:Evaluation expects INDEX_LIST_ASC_CSV (string) while OBJ_CODE expects list[int]. Unify to a single representation. Recommendation: internal search uses sorted list[int]; convert to CSV string only at I\/O. Update evaluate_solution to accept list[int] to avoid parse overhead, or wrap a thin adapter.\"\n\n\"E_KNOWN_SOLUTION_INVALID:Provided KNOWN_SOLUTION uses 0-based indices and wrong SOL_TYPE (list vs CSV string). Convert to 1..24 and to CSV string to be valid. Also re-check feasibility and objective under the given time constraint.\"\n\n\"E_FEASIBILITY_REPAIR_MISSING:Neighbour generation allows infeasible states without repair, causing heavy 1e6 penalties that swamp annealing\/acceptance scales. Add deterministic repair: after any move, while total_time < 670 add items maximizing time\/score until feasible; while feasible, try removing items with worst score\/time to reduce score.\"\n\n\"NB_CODE_FAIL_LOCAL_OPT:Current moves (add\/remove\/swap) are too weak. Add 1-1, 1-2, and 2-1 exchanges guided by delta-score and delta-time feasibility checks to accelerate descent and escape plateaus.\"\n\n\"E_INIT_CONSTRUCTIVE:No constructive initializer. Build a feasible start by greedy maximizing time\/score (t_i\/s_i) until \u2265670, then prune with best-improvement removals.\"\n\n\"E_ANNEALING_SCALE:Penalty magnitude (1e6) plus tiny 1e-6 tie-breakers makes temperature tuning brittle. Use repair-first strategy; if penalties retained, normalize penalty magnitude relative to typical score range to allow probabilistic acceptance to function.\"\n\n\"E_RNG_CONTROL:Lack of RNG injection harms reproducibility. Pass a random.Random instance (rng) through generate_neighbour and perturb_solution; avoid module-level random.\"\n\n\"E_NEIGH_ENCODE:generate_neighbour returns (encoded, nb_type) but type annotation claims (\\\"NB_Type\\\", \\\"Movement_Type\\\"). Fix annotations to Tuple[str,str] or remove them; ensure ascending unique indices via encode (already sorted) and keep invariant.\"\n\n\"E_EVAL_COST:Parsing CSV on every evaluation is avoidable overhead. Maintain list[int] during search; only encode to CSV at logging\/output. If keeping string input, cache parsed lists or switch evaluate_solution to list-based with a thin adapter for compatibility.\"\n\n\"E_LOCAL_VALIDATION:Current validation returns inf for type issues, which can silently hide bugs. Add explicit diagnostic flags in solver loop to count invalid generations and backtrack immediately rather than scoring them.\"\n\n\"E_TS_TABU_STRUCT:Define tabu as a set of recent moves (e.g., tuples of indices swapped\/added\/removed) with tenure; avoid storing full solutions. Ensure tabu tenure decays per-iteration; prohibit aspiration only when candidate not strictly improving best_score.\"\n\n\"E_MOVE_TIEBREAKER:Fitness uses time as micro tie-breaker. Ensure exchange evaluation uses lexicographic comparison (score first, then time) to be consistent with evaluate_solution.\"\n\n\"E_STOP_CRITERIA:Missing convergence checks. Add stall-based stopping (no best improvement in K iterations) and temperature floor for SA, plus iteration cap.\"\n\n\"E_API_CONTRACT:Heuristic functions must return (newSolution,new_best,new_best_score,aux_info). Ensure outputs include extra diagnostics (accepted_moves, improved_moves, feasibility_repairs) per FEEDBACK_INSTRUCTIONS 6.\"\n\n\"ACTION_SA_FIX:Implement SA with proper signature and no typing misuse. Example core: maintain current as list[int], propose neighbour via generate_neighbour; if infeasible, repair; compute delta on score then time tie-breaker; accept if delta<0 or exp(-delta\/T)>rng.random(); cool T*=alpha.\"\n\n\"ACTION_ILS_FIX:Define perturb_solution as k random exchanges preserving feasibility via repair; accept new local optimum via better score or with acceptance_rate probability when close; restart from best on rejection.\"\n\n\"ACTION_TS_FIX:Use short-term tabu list (size ~ n) keyed on moved indices; aspiration allows tabu override if new score < best_score.\"\n\n\"ASSERT_CORRECTNESS_EVAL:Verified via python that the provided evaluation function correctly enforces feasibility (\u2265670) and score minimization with time tie-breaker. The current KNOWN_SOLUTION and EXPECTED_SCORE are inconsistent with this evaluation; update or remove them to prevent false validation passes.\"\n\n\"R_STR_INADEQUATE:Pure string representation harms exploration and speed. Recommend using permutation-like list[int] with a maintained sorted invariant; only encode to CSV at output boundary to satisfy SOL_TYPE.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_ASC_CSV","Componentes":{"REPRESENTATION":"INDEX_LIST_ASC_CSV","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation: comma-separated ascending list of unique indices in [1,24]\n    # Accepts empty string for empty set\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Parse solution string to list of ints\n    if solution is None:\n        return float('inf')\n    if not isinstance(solution, str):\n        return float('inf')\n    sol_str = solution.strip()\n    if sol_str == \"\":\n        idx_list: List[int] = []\n    else:\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != \"\"]\n        try:\n            idx_list = [int(p) for p in parts]\n        except Exception:\n            return float('inf')\n\n    # Basic validations\n    if any(i < 1 or i > n for i in idx_list):\n        return float('inf')\n    if len(idx_list) != len(set(idx_list)):\n        return float('inf')\n\n    # Compute score and time\n    total_score = 0\n    total_time = 0\n    for i in idx_list:\n        j = i - 1\n        total_score += scores[j]\n        total_time += times[j]\n\n    # Feasibility and fitness\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n    return float(total_score) + (float(total_time) * 1e-6)\n","NB_CODE":"import random\nfrom typing import List\n\n\ndef _nb_parse_sol(sol_str: str) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= 24:\n                out.append(v)\n        except Exception:\n            return []\n    return sorted(set(out))\n\n\ndef _nb_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_neighbour_solution, movement_type)\n    n = 24\n    all_indices = set(range(1, n + 1))\n    curr = _nb_parse_sol(solution)\n    curr_set = set(curr)\n\n    move_r = random.random()\n    move_type = \"noop\"\n\n    if move_r < 0.34:\n        # ADD\n        missing = list(all_indices - curr_set)\n        if missing:\n            add_i = random.choice(missing)\n            curr.append(add_i)\n            move_type = \"add\"\n    elif move_r < 0.68:\n        # REMOVE\n        if curr:\n            rem_i = random.choice(curr)\n            curr.remove(rem_i)\n            move_type = \"remove\"\n    else:\n        # SWAP\n        present = list(curr)\n        missing = list(all_indices - curr_set)\n        if present and missing:\n            rem_i = random.choice(present)\n            add_i = random.choice(missing)\n            curr.remove(rem_i)\n            curr.append(add_i)\n            move_type = \"swap\"\n        elif not present:\n            # degrade to add\n            add_i = random.randint(1, n)\n            curr.append(add_i)\n            move_type = \"add\"\n\n    encoded = _nb_encode_sol(curr)\n    return encoded, move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\n\ndef _pert_parse_sol(sol_str: str) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= 24:\n                out.append(v)\n        except Exception:\n            return []\n    return sorted(set(out))\n\n\ndef _pert_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef perturb_solution(solution):\n    # Stronger random shake: apply k random add\/remove\/swap moves\n    n = 24\n    k = random.randint(3, 6)\n    curr = _pert_parse_sol(solution)\n    all_idx = set(range(1, n + 1))\n\n    for _ in range(k):\n        curr_set = set(curr)\n        r = random.random()\n        if r < 0.33:\n            # add\n            missing = list(all_idx - curr_set)\n            if missing:\n                curr.append(random.choice(missing))\n        elif r < 0.66:\n            # remove\n            if curr:\n                rem = random.choice(curr)\n                curr.remove(rem)\n        else:\n            # swap\n            present = list(curr)\n            missing = list(all_idx - curr_set)\n            if present and missing:\n                rem = random.choice(present)\n                add = random.choice(missing)\n                curr.remove(rem)\n                curr.append(add)\n    return _pert_encode_sol(curr)\n","SAMPLE_SOL":"5,7,9,13"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0-fix1\"\n\"FEEDBACK\",\"E_LOCAL_SIG:Heuristic signatures incorrectly call dependencies in the signature (e.g., generate_neighbour()). Pass callables, do not invoke them. Match TARGET_HEURISTIC_GENERAL_SIGNATURE strictly.\nE_TYPEHINT_LIST_CALL:Type List is being instantiated (List()). Replace with built-in list() and remove any attempts to call typing hints. Also avoid Dict(), Set()\u2014use dict(), set().\nE_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide a concrete perturbation callable for ILS and reuse in SA\/TS for diversification.\nR_REP_MISMATCH:Representation conflict. Local evaluator accepts CSV string; OBJ\/EVAL_CODE accept Python index lists. Standardize to a single representation or implement a thin adapter at heuristic boundaries.\nE_TARGET_SIG_SA:SA\/ILS\/TS declared with called parameters in signature and\/or wrong order. Use: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood is purely random add\/remove\/swap without feasibility guidance. Add state-aware moves: if infeasible (<670) force ADD of low score-per-time items; if feasible, prioritize REMOVE of high score-per-time items; include 1-1 and 2-1 exchanges.\nR_STR_ORDERING:Ensure emitted solutions are strictly ascending CSV. Enforce sort and de-dup in encoder on every return path.\nINIT_HEURISTIC_WEAK:Starting from arbitrary sample degrades convergence. Build a greedy initialization by ascending (score\/time) until time \u2265 670, then perform improvement by DROP and SWAP.\nEVAL_INCONSISTENT:Tie-breakers and penalties differ between components. Mirror a single policy: fitness = score + time*1e-6 for feasible, else 1e6 + deficit + score*1e-6 for infeasible.\nEVAL_PERF:Full recomputation per neighbour is O(k). Maintain running (score,time) and update incrementally per add\/remove\/swap to O(1).\nILS_ACCEPTANCE_UNSPEC:No clear acceptance criterion. Use accept-if-better; else accept with probability exp(-(\u0394)\/T) or threshold-based acceptance ratio parameter.\nSA_PARAMS_BAD:Temperature schedule not grounded. Set TEMP0 to median absolute fitness delta from warm-up neighbours; MIN_TEMP such that acceptance of worst observed \u0394 is \u2264 1%; cooling geometric 0.90\u20130.98.\nTS_CONFIG_WEAK:Tabu not defined. Maintain tabu on indices moved (add\/remove) with tenure ~7\u201315; aspiration if move improves best. Use short-term memory only to start.\nMOVE_SET_INCOMPLETE:Add compound moves: (i) DROP k (k=1,2) with repair if violated; (ii) SWAP(1,1) and SWAP(2,1); (iii) SHAKe for perturbation: random DROP of 1\u20133 lowest time contributions then greedy refill.\nFEASIBILITY_REPAIR:When infeasible after a DROP, repair greedily by adding items with minimal (score\/time) until feasible rather than returning penalized states to the metaheuristic.\nRANDOM_SEED_DIAG:Expose seed control for reproducibility during debugging; keep randomized behavior for exploration in final runs.\nTEST_HARNESS_MISSING:Add unit tests: (a) parser round-trip; (b) neighbourhood preserves domain; (c) feasibility\/penalty boundary at 670; (d) incremental updates equal full recomputation.\nVALIDATION_WITH_BASELINE:Cross-check evaluate_solution against a verified baseline set to assert correctness of scoring and feasibility; include assert tests in CI without disclosing the baseline content.\nERROR_HANDLING:Parser currently tolerates silent failures. Fail fast on invalid tokens and return +\u221e fitness; log movement_type for diagnosis as extra output only.\nSTOPPING_CRITERIA:Define robust termination: max iters without improvement, wall-clock cap, and convergence (\u0394 best < \u03b5 for N iters).\nOUTPUT_CONTRACT:Guarantee final emitted solution uses the CSV format with no spaces, ascending, unique indices.\nPARAM_TUNING:Annealing cooling 0.95, iterations per T ~ 50\u2013200 neighbours; TS tenure 10\u00b13 based on problem size; ILS perturbation strength 2\u20133 moves; accept improved-or-equal only for intensification runs.\nSCALABILITY_NOTE:Abstract n=24 constants; derive n from data; generalize move generation and bounds.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_ASC_CSV","Componentes":{"REPRESENTATION":"INDEX_LIST_ASC_CSV","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation: comma-separated ascending list of unique indices in [1,24]\n    # Accepts empty string for empty set\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Parse solution string to list of ints\n    if solution is None:\n        return float('inf')\n    if not isinstance(solution, str):\n        return float('inf')\n    sol_str = solution.strip()\n    if sol_str == \"\":\n        idx_list: List[int] = []\n    else:\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != \"\"]\n        try:\n            idx_list = [int(p) for p in parts]\n        except Exception:\n            return float('inf')\n\n    # Basic validations\n    if any(i < 1 or i > n for i in idx_list):\n        return float('inf')\n    if len(idx_list) != len(set(idx_list)):\n        return float('inf')\n\n    # Compute score and time\n    total_score = 0\n    total_time = 0\n    for i in idx_list:\n        j = i - 1\n        total_score += scores[j]\n        total_time += times[j]\n\n    # Feasibility and fitness (consistent policy)\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n    return float(total_score) + (float(total_time) * 1e-6)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n# Helpers kept internal to this module\n\ndef _nb_parse_sol(sol_str: str, n: int) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out: List[int] = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= n:\n                out.append(v)\n            else:\n                return []\n        except Exception:\n            return []\n    # ensure ascending unique\n    return sorted(set(out))\n\n\ndef _nb_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef _compute_totals(idx_list: List[int], scores: List[int], times: List[int]) -> Tuple[int, int]:\n    total_s = 0\n    total_t = 0\n    for i in idx_list:\n        j = i - 1\n        total_s += scores[j]\n        total_t += times[j]\n    return total_s, total_t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # State-aware stochastic neighbourhood for INDEX_LIST_ASC_CSV\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    curr = _nb_parse_sol(solution, n)\n    all_idx = list(range(1, n + 1))\n    present = set(curr)\n    missing = [i for i in all_idx if i not in present]\n\n    total_s, total_t = _compute_totals(curr, scores, times)\n\n    # Precompute ratios for guidance\n    ratio = {i: (scores[i-1] \/ max(1, times[i-1])) for i in all_idx}\n\n    move_type = \"noop\"\n    new_list = list(curr)\n\n    if total_t < TIME_REQ:\n        # Infeasible: bias towards ADD of lowest score\/time\n        if missing:\n            missing_sorted = sorted(missing, key=lambda i: (ratio[i], scores[i-1], -times[i-1]))\n            # With 70% choose best, else random among top 5\n            pick_pool = missing_sorted[:min(5, len(missing_sorted))]\n            add_i = random.choice(pick_pool) if random.random() < 0.3 else pick_pool[0]\n            new_list.append(add_i)\n            move_type = \"add-guided\"\n        else:\n            move_type = \"noop\"\n    else:\n        # Feasible: try DROP that keeps feasibility and reduces score\n        droppable = []\n        for i in curr:\n            t_after = total_t - times[i-1]\n            if t_after >= TIME_REQ:\n                droppable.append(i)\n        if droppable and random.random() < 0.6:\n            # Drop the worst by score\/time (i.e., highest score per time) or highest score\n            drop_sorted = sorted(droppable, key=lambda i: (-ratio[i], -scores[i-1], times[i-1]))\n            pick_pool = drop_sorted[:min(5, len(drop_sorted))]\n            rem_i = random.choice(pick_pool) if random.random() < 0.3 else pick_pool[0]\n            new_list.remove(rem_i)\n            move_type = \"remove-guided\"\n        else:\n            # Try 1-1 swap to reduce score while maintaining feasibility\n            improved = False\n            if curr and missing:\n                cand_present = sorted(curr, key=lambda i: (ratio[i], scores[i-1]))\n                cand_missing = sorted(missing, key=lambda i: (ratio[i], scores[i-1]))\n                # Try a few random pairs favoring lower ratio additions\n                trials = 10\n                for _ in range(trials):\n                    i_rem = random.choice(cand_present[:min(6, len(cand_present))])\n                    i_add = random.choice(cand_missing[:min(6, len(cand_missing))])\n                    t_after = total_t - times[i_rem-1] + times[i_add-1]\n                    s_after = total_s - scores[i_rem-1] + scores[i_add-1]\n                    if t_after >= TIME_REQ and s_after <= total_s:\n                        new_list.remove(i_rem)\n                        new_list.append(i_add)\n                        move_type = \"swap1-1\"\n                        improved = True\n                        break\n            if not improved:\n                # Fallback random small move\n                r = random.random()\n                if r < 0.5 and missing:\n                    new_list.append(random.choice(missing))\n                    move_type = \"add\"\n                elif new_list:\n                    rem = random.choice(new_list)\n                    new_list.remove(rem)\n                    move_type = \"remove\"\n\n    encoded = _nb_encode_sol(new_list)\n    return encoded, move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\n# Helpers duplicated locally to keep function self-contained\n\ndef _pert_parse_sol(sol_str: str, n: int) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out: List[int] = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= n:\n                out.append(v)\n            else:\n                return []\n        except Exception:\n            return []\n    return sorted(set(out))\n\n\ndef _pert_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef perturb_solution(solution):\n    # Stronger shake with greedy repair to maintain\/restore feasibility\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    curr = _pert_parse_sol(solution, n)\n    present = set(curr)\n    all_idx = set(range(1, n + 1))\n\n    # Randomly drop 1\u20133 items with lowest time contributions (to shake but not destroy feasibility too much)\n    k = random.randint(1, 3)\n    by_time = sorted(curr, key=lambda i: times[i-1])\n    drops = by_time[:min(k, len(by_time))]\n    for d in drops:\n        if d in curr:\n            curr.remove(d)\n    present = set(curr)\n\n    # Greedy refill by ascending score\/time until feasible\n    total_time = sum(times[i-1] for i in curr)\n    if total_time < TIME_REQ:\n        missing = list(all_idx - present)\n        ratio_sorted = sorted(missing, key=lambda i: (scores[i-1] \/ max(1, times[i-1]), scores[i-1], -times[i-1]))\n        for i in ratio_sorted:\n            curr.append(i)\n            total_time += times[i-1]\n            if total_time >= TIME_REQ:\n                break\n\n    return _pert_encode_sol(curr)\n","SAMPLE_SOL":"5,7,9,13"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0.1\"\n\"FEEDBACK\",\"E_LOCAL_SIG:Heuristic signatures misuse typing.List as a constructor. Replace all List() with list(). Ensure parameters are functions, not calls. EX: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).\nE_LOCAL_CALLS:Provided SA\/ILS\/TS signatures show generate_neighbour() and evaluate_solution() called in signature string. Remove parentheses; pass callables, not results.\nE_LOCAL_MISSING_PERTURB:$Perturb is undefined. Provide a concrete perturb_solution callable matching TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_REP_INCONSISTENCY:OBJ_CODE\/EVAL_CODE (top) expect a Python list of 1-based ints; Components Evaluation expects an ascending CSV string. Unify to INDEX_LIST_ASC_CSV string throughout (objective\/eval\/neighbour\/heuristics).\nE_KNOWN_SOLUTION_FORMAT:KNOWN_SOLUTION is zero-based Python list; violates SOL_TYPE and indexing [1..24]. Convert to 1-based CSV string to be compatible with parser.\nE_EVAL_PARITY:Two evaluate_solution implementations exist with different interfaces. Keep a single source of truth: the Components Evaluation Function (CSV input) and delete or wrap OBJ_CODE\/EVAL_CODE to delegate to it.\nE_PARSE_LOSSY:_nb_parse_sol returns [] on any parse issue, masking errors. Instead, return the original solution or raise\/propagate an invalid flag to avoid collapsing state to empty set.\nE_NB_COST:generate_neighbour sorts full missing\/droppable sets every call (O(n log n)). Cache ratios and pre-sorted lists; maintain incremental totals to reduce complexity to O(1)\u2013O(log n) per move.\nE_NB_ADD_POLICY:In infeasible states, the add key uses (ratio, score, -time). This can still pick low-time items near the threshold. Strengthen with a feasibility-aware heuristic: prioritize max time per unit score (minimize score\/time, tie-break by highest time), and dynamically widen pick_pool as deficit shrinks.\nE_NB_DROP_POLICY:Dropping by highest score\/time may remove long-time low-score items that help feasibility. Constrain drop set with t_after \u2265 TIME_REQ + safety_margin to avoid oscillation near feasibility boundary.\nE_SWAP_LIMITED:1-1 swap uses 10 random trials; may stagnate. Add deterministic best-improving pass over top-k candidates or allow 1-2 \/ 2-1 exchanges when no 1-1 improvement exists.\nE_INIT_WEAK:No constructive initializer is provided. Build a greedy start: add items by ascending score\/time until TIME_REQ met, then prune redundant items by descending score\/time while feasible.\nE_PENALTY_SCHEME:Penalty uses 1e6 + deficit + tiny score. This causes steep cliffs and poor guidance. Use Lagrangian relaxation: fitness = score + \u03bb\u00b7max(0,670-total_time), adapt \u03bb based on feasibility rate to balance exploration.\nE_SA_CONFIG:Missing annealing schedule spec. Use exponential cooling TEMP*=cooling_factor, with calibrated initial TEMP from cost std over a sample of moves; stop at MIN_TEMP or stall iterations. Accept worse moves by \u0394\/Temp Boltzmann criterion.\nE_ILS_ACCEPT:ILS signature misspells acceptance_rate and lacks proper acceptance criterion. Define accept(new_cost, best_cost) based on cost delta or simulated restarts; include a bounded perturbation strength proportional to |S|.\nE_TABU_NAMING:Taboo_Search misnamed; use Tabu. Implement tabu tenure on moves (added\/removed indices) not full solutions; include aspiration if new_cost < best_cost.\nE_MOVE_TRACKING:Neighbour returns (solution, move_type) but heuristics may not unpack second value. Standardize to always accept a tuple and heuristics must read the first element; otherwise wrap generator to drop auxiliary info.\nE_VALIDATION:Heuristics must re-encode outputs through _nb_encode_sol to enforce ascending unique indices before evaluation; reject or repair invalid states.\nE_REPRODUCIBILITY:Seed randomization externally via other_params['seed'] and thread-local RNG to ensure repeatability in tests.\nE_BOUND_CHECK:Ensure all components uniformly enforce 1-based indices \u2208 [1,24]; add assertions in dev mode to fail fast.\nR_PERTURB_SPEC:Provide perturb_solution that flips k indices with bias: if feasible, attempt removing low time-utility items and adding high time-per-score items; if infeasible, add high time-per-score items. Set k ~ max(1, |S|\/\/5).\nR_CACHE_STATS:Maintain and pass (total_score,total_time,present,missing) in other_params to avoid recomputation in neighbour\/evaluation.\nR_GREEDY_PRUNE:Post-construction, run drop phase: iteratively remove any index whose removal keeps time \u2265 670 and reduces score; this rapidly reaches near-optimal fronts.\nR_SMALL_LOCAL_MOVES:Add deterministic local search: for each present i and missing j, if replacing i with j keeps feasibility and reduces score (or leaves score equal but reduces time), perform best-improving swap.\nR_UNIT_TESTS:Add tests for: empty, out-of-range, duplicates, malformed CSV, exactly-on-threshold, near-threshold add\/drop, and stability of encoding.\nR_PERF_METRIC:Track evaluations\/sec and acceptance rates; adapt neighbourhood biases based on observed improvement frequency.\nEVAL_ASSERTION:Using the Components Evaluation Function with the provided data, the sample solution '5,7,9,13' is feasible and consistent. The provided KNOWN_SOLUTION object does not comply with SOL_TYPE nor indexing; it should not be used as-is for correctness checks.\nE_CODE_PERF:Evaluation O(k) in |S|; neighbour naive O(n log n). After caching, expected O(1) amortized for add\/remove and O(log n) for swap candidate selection.\nR_OUTPUT_POLICY:Always output ascending, comma-separated indices with no spaces. Return empty string only for the empty set case.\nFIX_ORDER:1) Unify representation and evaluation interface. 2) Fix heuristic signatures and remove List() usage. 3) Implement perturb_solution. 4) Add greedy initializer and prune. 5) Optimize neighbour with caching. 6) Add deterministic local search. 7) Calibrate SA\/ILS\/Tabu parameters and acceptance. 8) Add unit tests and reproducible seeding.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices in [1..24]; empty string allowed for empty set. Example: \"8,4,18\".","Componentes":{"REPRESENTATION":"Comma-separated unique item indices in [1..24]; empty string allowed for empty set. Example: \"8,4,18\".","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Minimization-compatible cost (use negative value for maximization). Lower is better.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    BIG_PENALTY = 10**9\n    if solution is None:\n        return BIG_PENALTY\n    s = str(solution).strip()\n    if s == \"\":\n        return 0.0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not p.isdigit():\n            return BIG_PENALTY\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return BIG_PENALTY\n        idxs.append(idx)\n    if len(set(idxs)) != len(idxs):\n        return BIG_PENALTY\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return BIG_PENALTY\n        total_v += values[idx]\n    return float(-total_v)","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_type)\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    def parse(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        items = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24:\n                items.add(idx)\n        return items\n    def to_str(items):\n        return \",\".join(str(i) for i in sorted(items))\n    def total_weight(items):\n        return sum(weights[i] for i in items)\n\n    items = parse(solution)\n    curr_w = total_weight(items)\n\n    moves = [\"ADD\", \"REMOVE\", \"SWAP\"]\n    # Filter feasible move types based on current state\n    feasible_moves = []\n    # ADD feasible if exists item not in set that fits\n    add_candidates = [i for i in range(1,25) if i not in items and weights[i] + curr_w <= CAP]\n    if add_candidates:\n        feasible_moves.append(\"ADD\")\n    # REMOVE feasible if non-empty\n    if items:\n        feasible_moves.append(\"REMOVE\")\n    # SWAP feasible if there exists out not in items and in in items such that weight decreases or fits\n    swap_pairs_exist = False\n    if items:\n        for i_out in items:\n            for i_in in range(1,25):\n                if i_in in items:\n                    continue\n                if curr_w - weights[i_out] + weights[i_in] <= CAP:\n                    swap_pairs_exist = True\n                    break\n            if swap_pairs_exist:\n                break\n    if swap_pairs_exist:\n        feasible_moves.append(\"SWAP\")\n\n    if not feasible_moves:\n        # If nothing feasible (should be rare), return empty solution\n        return (\"\", \"RESET\")\n\n    move = random.choice(feasible_moves)\n    new_items = set(items)\n\n    if move == \"ADD\":\n        i = random.choice(add_candidates)\n        new_items.add(i)\n    elif move == \"REMOVE\":\n        i = random.choice(list(new_items))\n        new_items.remove(i)\n    else:  # SWAP\n        # Try a bounded number of attempts to find a feasible swap\n        for _ in range(100):\n            i_out = random.choice(list(items))\n            i_in = random.randrange(1,25)\n            if i_in in items:\n                continue\n            if curr_w - weights[i_out] + weights[i_in] <= CAP:\n                new_items.remove(i_out)\n                new_items.add(i_in)\n                break\n        else:\n            # fallback to REMOVE if swap failed\n            i = random.choice(list(new_items))\n            new_items.remove(i)\n            move = \"REMOVE\"\n\n    return (to_str(new_items), move)","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Apply multiple random feasible moves to escape local minima\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    def parse(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        items = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24:\n                items.add(idx)\n        return items\n    def to_str(items):\n        return \",\".join(str(i) for i in sorted(items))\n    def total_weight(items):\n        return sum(weights[i] for i in items)\n\n    items = parse(solution)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        curr_w = total_weight(items)\n        # Build candidate moves\n        add_candidates = [i for i in range(1,25) if i not in items and weights[i] + curr_w <= CAP]\n        remove_candidates = list(items)\n        # Choose a move with slight bias to ADD then SWAP then REMOVE\n        r = random.random()\n        if add_candidates and r < 0.45:\n            items.add(random.choice(add_candidates))\n            continue\n        if remove_candidates and r > 0.85:\n            items.remove(random.choice(remove_candidates))\n            continue\n        # Try a swap\n        if items:\n            found = False\n            for _ in range(50):\n                i_out = random.choice(list(items))\n                i_in = random.randrange(1,25)\n                if i_in in items:\n                    continue\n                if curr_w - weights[i_out] + weights[i_in] <= CAP:\n                    items.remove(i_out)\n                    items.add(i_in)\n                    found = True\n                    break\n            if not found:\n                # fallback small random toggle if possible\n                if add_candidates:\n                    items.add(random.choice(add_candidates))\n                elif remove_candidates:\n                    items.remove(random.choice(remove_candidates))\n    return to_str(items)","SAMPLE_SOL":"8,4,18"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_TABU_SIGNATURE_MISMATCH: Tabu implementation expects a different neighbour return arity\/signature. generate_neighbour returns (solution, move) but TS unpacks 2 from a single value or vice versa. Align TS to accept neighbour_fn returning a 2-tuple and only use the first element as the candidate; update TS signature to match TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\"\n\"FEEDBACK\",\"E_TABU_PARAM_INCONSISTENCY: Provided TS signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration) incorrectly calls functions at definition and diverges from required general signature. Remove parentheses, pass function references, and rename taboo_* consistently to tabu_*.\"\n\"FEEDBACK\",\"E_OBJ_EVAL_MISMATCH: objective_function ignores capacity, duplicates, and returns positive maximization value; evaluate_solution enforces capacity, uniqueness, and returns negative cost for minimization. Unify logic: either remove objective_function or make it a thin wrapper over evaluate_solution with sign flip for reporting.\"\n\"FEEDBACK\",\"E_KNOWN_SOL_INFEASIBLE_WITH_EVAL: The provided known solution violates CAP under the given evaluate_solution (Python check returns BIG_PENALTY). Recompute the reference using the same weights, values, and CAP; do not validate against an infeasible baseline.\"\n\"FEEDBACK\",\"E_RESULT_TUPLE_CONFUSION: Simulated_Annealing\/ILS outputs mix current and best with inconsistent scores relative to the values table (e.g., single-index solution\u2019s score not matching values vector). Standardize result schema: (best_sol, best_cost, last_sol, last_cost) where costs are evaluate_solution outputs.\"\n\"FEEDBACK\",\"P_PARSE_COST: String parsing on every evaluation causes O(n) overhead and repeated conversions. Cache a parsed immutable representation (sorted tuple or bitset) with incremental deltas to cut eval per neighbour to O(1).\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Neighbour generator is purely random within feasibility, leading to weak local improvement pressure. Add deterministic best-improvement 1-1 swap, add, and drop moves; include 1-2 and 2-1 exchanges to escape local optima.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Raw comma-separated strings force repeated parse\/sort and set construction. Maintain an internal Set[int] plus cached total_w,total_v; only serialize to string at boundaries.\"\n\"FEEDBACK\",\"E_FEASIBILITY_BIAS: ADD candidates filter by capacity only; no consideration of marginal value. Introduce bias proportional to value\/weight ratio and remaining capacity slack to prioritize high-gain adds.\"\n\"FEEDBACK\",\"E_SWAP_SEARCH_LIMIT: SWAP attempts capped at 100 random trials can miss obvious improving swaps and degrade to REMOVE. Replace with enumerating feasible swaps with early-exit on first-improvement; keep a bounded candidate list for efficiency.\"\n\"FEEDBACK\",\"E_DUPLICATE_POLICY: objective_function allows duplicates; evaluate_solution penalizes them. Ensure neighbour generator never creates duplicates (it currently uses a set, OK) and align objective_function to reject duplicates.\"\n\"FEEDBACK\",\"E_SCORING_SIGN: Heuristics must treat lower cost as better. Confirm all acceptance\/elite updates use evaluate_solution\u2019s negative cost; remove any place that compares positive objective values against negative costs.\"\n\"FEEDBACK\",\"E_SA_SCHEDULE: Missing\/weak temperature schedule likely causes premature convergence. Use T0 scaled to stddev of initial neighbourhood costs, geometric cooling (alpha in [0.90,0.99]), and reheating on stagnation.\"\n\"FEEDBACK\",\"E_ILS_PERTURB_WEAK: Perturbation unspecified ($Perturb). Current setup risks cycling. Implement capacity-preserving k-exchange perturbation (e.g., drop 1\u20132 low-ratio items, add 1\u20132 high-ratio items) with strength adapted to stagnation length.\"\n\"FEEDBACK\",\"E_TABU_MEMORY: Tabu list likely storing raw strings; move-attribute memory is preferred. Store attributes (added, removed indices) with tenure; include aspiration criterion when a move improves best_cost.\"\n\"FEEDBACK\",\"E_RANDOM_SEED: Non-deterministic runs hinder regression. Inject a fixed seed parameter and log it to reproduce results.\"\n\"FEEDBACK\",\"E_BOUNDARY_CASES: Empty solution handling returns 0 cost, but some operators cannot move from empty if no ADD fits; ensure ADD is always feasible from empty by checking all items and not prematurely returning RESET.\"\n\"FEEDBACK\",\"IMP_INIT_GREEDY: Start from a greedy feasible solution sorted by value\/weight and value; optionally run a quick first-improvement hill climb before metaheuristics to boost starting quality.\"\n\"FEEDBACK\",\"IMP_DELTA_EVAL: Maintain (curr_w, curr_v). For each move: ADD i => w+=w[i], v+=v[i]; DROP i => w-=w[i], v-=v[i]; SWAP o->i => w+=w[i]-w[o], v+=v[i]-v[o]. Validate capacity in O(1); compute new cost as -v.\"\n\"FEEDBACK\",\"IMP_NEIGHBOUR_POOL: Precompute candidate lists: light items, high-ratio items, borderline-weight items; sample from these lists instead of uniform [1..24] to increase productive moves.\"\n\"FEEDBACK\",\"IMP_TERMINATION: Add no-improvement budget and time cap; return both best and trace to diagnose stagnation.\"\n\"FEEDBACK\",\"IMP_VALIDATION: Add unit tests to assert evaluate_solution rejects duplicates, out-of-range indices, and overweight sets; confirm equality between wrapper objective and -evaluate.\"\n\"FEEDBACK\",\"PY_ASSERT_CORRECTNESS: Python evaluation of the provided \u201cknown solution\u201d under evaluate_solution returns BIG_PENALTY, confirming inconsistency. Fix the reference before using it for validation.\"\n\"FEEDBACK\",\"PERF_COMPLEXITY: Current neighbour feasibility checks compute total_weight via sum() each time O(n). Replace with cached curr_w to reduce to O(1) feasibility checks.\"\n\"FEEDBACK\",\"LOGGING_SCHEMA: Record (iter, move_type, delta_cost, curr_cost, best_cost, curr_w) to enable targeted debugging of acceptance rules and capacity handling.\"\n\"FEEDBACK\",\"RETURN_CONSISTENCY: Ensure all heuristics return (best_solution_str, best_cost) with best_cost = evaluate_solution(best_solution_str). Mixed tuple sizes\/types break downstream parsers.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices in [1..24]; empty string \"\" denotes empty set. Example: \"8,4,18\".","Componentes":{"REPRESENTATION":"Comma-separated unique item indices in [1..24]; empty string \"\" denotes empty set. Example: \"8,4,18\".","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Minimization-compatible cost (negative total value); lower is better.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    BIG = 10**9\n    if solution is None:\n        return float(BIG)\n    s = str(solution).strip()\n    if s == \"\":\n        return 0.0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.isdigit() and p[0] != '-'):\n            return float(BIG)\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return float(BIG)\n        idxs.append(idx)\n    if len(set(idxs)) != len(idxs):\n        return float(BIG)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return float(BIG)\n        total_v += values[idx]\n    return float(-total_v)\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic first-improvement with feasibility; falls back to heuristic random move.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_to_set(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        items = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.isdigit() and p[0] != '-'):\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24:\n                items.add(idx)\n        return items\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def weight_of(items_set):\n        return sum(weights[i] for i in items_set)\n\n    items = parse_to_set(solution)\n    curr_w = weight_of(items)\n    curr_v = sum(values[i] for i in items)\n\n    all_idxs = range(1, 25)\n    not_in = [i for i in all_idxs if i not in items]\n\n    # 1) Try best improving ADD (by value density then value)\n    add_cands = [i for i in not_in if curr_w + weights[i] <= CAP]\n    if add_cands:\n        add_cands.sort(key=lambda i: (values[i]\/weights[i], values[i]), reverse=True)\n        best_add = add_cands[0]\n        # Any ADD increases value => improves cost\n        new_items = set(items)\n        new_items.add(best_add)\n        return (to_str(new_items), \"ADD\")\n\n    # 2) Try best improving SWAP (first-improvement by highest delta value)\n    if items:\n        best_pair = None\n        best_delta_v = 0  # require positive improvement\n        for o in items:\n            for i in not_in:\n                new_w = curr_w - weights[o] + weights[i]\n                if new_w <= CAP:\n                    delta_v = values[i] - values[o]\n                    if delta_v > best_delta_v:\n                        best_delta_v = delta_v\n                        best_pair = (o, i)\n        if best_pair is not None:\n            o, i = best_pair\n            new_items = set(items)\n            new_items.remove(o)\n            new_items.add(i)\n            return (to_str(new_items), \"SWAP\")\n\n    # 3) If no improving move, do a diversification: remove lowest-density item if any\n    if items:\n        worst = min(items, key=lambda i: (values[i]\/weights[i], values[i]))\n        new_items = set(items)\n        new_items.remove(worst)\n        return (to_str(new_items), \"REMOVE\")\n\n    # 4) From empty: add best ratio item that fits\n    best_fit = None\n    best_key = None\n    for i in all_idxs:\n        if weights[i] <= CAP:\n            key = (values[i]\/weights[i], values[i])\n            if best_key is None or key > best_key:\n                best_key = key\n                best_fit = i\n    if best_fit is not None:\n        return (str(best_fit), \"ADD\")\n\n    # Fallback: no feasible items\n    return (\"\", \"RESET\")\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Capacity-preserving multi-step perturbation: drop low-ratio items, then add high-ratio items.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_to_set(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        items = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.isdigit() and p[0] != '-'):\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24:\n                items.add(idx)\n        return items\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def total_weight(items_set):\n        return sum(weights[i] for i in items_set)\n\n    items = parse_to_set(solution)\n\n    if not items:\n        # Seed with a decent greedy start\n        candidates = [i for i in range(1,25) if weights[i] <= CAP]\n        candidates.sort(key=lambda i: (values[i]\/weights[i], values[i]), reverse=True)\n        curr = []\n        curr_w = 0\n        for i in candidates:\n            if curr_w + weights[i] <= CAP:\n                curr.append(i)\n                curr_w += weights[i]\n        return to_str(set(curr))\n\n    # Drop k in {1,2} lowest-density items (if available)\n    k = 1 if len(items) == 1 else random.choice([1,2])\n    if items:\n        sorted_items = sorted(list(items), key=lambda i: (values[i]\/weights[i], values[i]))\n        to_drop = sorted_items[:min(k, len(sorted_items))]\n        for d in to_drop:\n            items.remove(d)\n\n    # Greedy refill with high-ratio items\n    curr_w = total_weight(items)\n    add_pool = [i for i in range(1,25) if i not in items]\n    add_pool.sort(key=lambda i: (values[i]\/weights[i], values[i]), reverse=True)\n    for i in add_pool:\n        if curr_w + weights[i] <= CAP:\n            items.add(i)\n            curr_w += weights[i]\n        if curr_w == CAP:\n            break\n\n    return to_str(items)\n","SAMPLE_SOL":"8,4,18"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Tabu search crashes. Signature mismatch and neighbour return unpacking error.\nTS_SIG_MISMATCH:def TS(...) != TARGET_HEURISTIC_GENERAL_SIGNATURE. Align to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nTS_NB_UNPACK_ERROR:generate_neighbour returns (solution,movement_type) but TS expects a single object. Accept and propagate both or ignore movement_type explicitly.\nPERTURB_MISSING:Placeholder $Perturb is undefined. Provide a concrete perturbation callable; otherwise ILS\/SA diversification is ill-posed.\nSA_ILS_SCORE_INCONSISTENCY:Reported scores disagree with provided evaluate_solution. Example: '2,8,14,18' evaluated as -49 but logged as -44. Unify a single scoring function (use evaluate_solution) across all components and outputs.\nOBJ_EVAL_MIXUP:objective_function (max form) and evaluate_solution (min form) both exist. Heuristics must exclusively use evaluate_solution; eliminate or gate objective_function to prevent accidental use.\nDUP_HANDLING_RISK:Neighbour parser silently drops invalid tokens; risk of phantom feasibility. Enforce strict parsing (reject non-digit and out-of-range) to keep generator consistent with evaluator.\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood limited to greedy add, best 1-1 swap, and forced remove; misses profitable 2-move exchanges at tight capacity. Add 1-2 and 2-1 exchanges; optionally 2-2.\nNB_TIE_BIAS:Deterministic ratio sort induces search bias and premature convergence. Randomized tie-breaking or candidate list strategies recommended (GRASP-style RCL).\nNB_FEASIBILITY_ONLY:No exploration of infeasible boundary with penalties; diversification collapses to remove-lowest-density. Add temporary overweight acceptance with controlled penalty or LNS destroy-repair.\nR_STR_INADEQUATE:String parsing adds overhead and ambiguity. Use sorted tuple of ints or a 24-bit bitset to guarantee uniqueness and O(1) membership.\nE_CODE_PERF:O(n) parse + O(n) weight\/value per evaluation. Cache cumulative weight\/value and apply delta updates in neighbour moves for O(1) per step.\nSA_BAD_ACCEPT:Using BIG=1e9 for infeasible costs risks underflow in exp(-(\u0394)\/T). Use math.inf internally and short-circuit reject, or bounded penalty: cost = -(value) + \u03bb\u00b7excess_weight with \u03bb>>max value density.\nILS_WEAK_PERTURB:No defined shaking strength; current REMOVE-only move is too weak. Implement k-random destroy (k in {1,2,3}) followed by greedy repair.\nTS_TABU_DEFICIENT:No aspiration criteria or tenure management shown. Add aspiration (override tabu if strictly better), dynamic tenure, and hashable move encoding (add, remove, swap).\nSCORING_REPORTING_PROTO:Standardize solver returns to (best_sol, best_score, start_sol, start_score) and verify scores via evaluate_solution before logging to prevent drift.\nBASELINE_CHECK:Implement exact DP (capacity 9) as a validator to cross-check heuristic output and catch regressions fast.\nEVAL_ASSERT:Internal verification against reference baseline PASSED; do not change evaluate_solution semantics.\nSPECIFIC_IMPROVEMENTS_1:Add 1-2 and 2-1 exchanges; explore all improving candidates up to a bounded list size L to maintain O(nL).\nSPECIFIC_IMPROVEMENTS_2:Introduce GRASP construction: randomized ratio-based RCL with \u03b1 in [0.1,0.3], then local search with multi-exchange.\nSPECIFIC_IMPROVEMENTS_3:Adopt bitset representation; implement delta evaluation for add\/remove\/swap to reduce constant factors.\nSPECIFIC_IMPROVEMENTS_4:For SA, calibrate T0 from median |\u0394| of random feasible moves; geometric cooling with factor in [0.90,0.98]; prohibit infeasible states or use bounded penalty.\nSPECIFIC_IMPROVEMENTS_5:For ILS, use variable-strength perturbation (k sampled) and accept if best_score improves or with \u03b5-greedy to escape plateaus.\nSPECIFIC_IMPROVEMENTS_6:For TS, normalize neighbour return handling; store tabu on moved indices (e.g., added item and removed item), include aspiration, and cap candidate list by ratio.\nUNIT_TESTS:Add tests: parsing strictness, duplicate rejection, capacity check, neighbour feasibility, score invariants, and solver return schema.\nINSTR_COMPAT:Ensure no code accesses filesystem\/network\/OS. Keep all components pure functions as required.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices in [1..24]; empty string \"\" denotes empty set. Example: \"8,4,18\".","Componentes":{"REPRESENTATION":"Comma-separated unique item indices in [1..24]; empty string \"\" denotes empty set. Example: \"8,4,18\".","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Minimization-compatible: return negative total value for feasible solutions; lower is better.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    BIG = 10**9\n    if solution is None:\n        return float(BIG)\n    s = str(solution).strip()\n    if s == \"\":\n        return 0.0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.isdigit() and p[0] != '-'):\n            return float(BIG)\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return float(BIG)\n        idxs.append(idx)\n    # 0\/1 constraint: no duplicates\n    if len(set(idxs)) != len(idxs):\n        return float(BIG)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return float(BIG)\n        total_v += values[idx]\n    return float(-total_v)\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Multi-exchange neighbourhood with strict parsing; always returns a feasible neighbour when possible.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_strict(sol):\n        if sol is None:\n            return None\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        items = []\n        for p in parts:\n            if not (p.isdigit() and p[0] != '-'):\n                return None\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return None\n            items.append(idx)\n        if len(set(items)) != len(items):\n            return None\n        return set(items)\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def w(items_set):\n        return sum(weights[i] for i in items_set)\n\n    def v(items_set):\n        return sum(values[i] for i in items_set)\n\n    items = parse_strict(solution)\n    if items is None:\n        # Invalid input -> reset to empty\n        items = set()\n    curr_w = w(items)\n    curr_v = v(items)\n\n    all_idxs = list(range(1,25))\n    not_in = [i for i in all_idxs if i not in items]\n\n    # Helper: randomized tie-breaking key for ratio-based sorts\n    def ratio_key(i):\n        return (values[i]\/weights[i], values[i], random.random())\n\n    # 1) Try best ADD by ratio that fits\n    add_cands = [i for i in not_in if curr_w + weights[i] <= CAP]\n    if add_cands:\n        add_cands.sort(key=ratio_key, reverse=True)\n        i = add_cands[0]\n        new = set(items)\n        new.add(i)\n        return (to_str(new), \"ADD\")\n\n    # 2) Try improving 1-1 SWAP (feasible and increases value)\n    best_pair = None\n    best_delta = 0\n    for o in items:\n        for i in not_in:\n            if curr_w - weights[o] + weights[i] <= CAP:\n                dv = values[i] - values[o]\n                if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                    best_delta = dv\n                    best_pair = (o, i)\n    if best_pair is not None and best_delta > 0:\n        o, i = best_pair\n        new = set(items)\n        new.remove(o)\n        new.add(i)\n        return (to_str(new), \"SWAP_1_1\")\n\n    # 3) Try 1-2 SWAP: remove one, add two\n    best_trip = None\n    best_delta = 0\n    if len(not_in) >= 2 and len(items) >= 1:\n        # Limit candidate list for efficiency using top-L by ratio\n        L = min(10, len(not_in))\n        cand_add = sorted(not_in, key=ratio_key, reverse=True)[:L]\n        for o in items:\n            for i1 in range(len(cand_add)):\n                a = cand_add[i1]\n                for i2 in range(i1+1, len(cand_add)):\n                    b = cand_add[i2]\n                    new_w = curr_w - weights[o] + weights[a] + weights[b]\n                    if new_w <= CAP:\n                        dv = values[a] + values[b] - values[o]\n                        if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                            best_delta = dv\n                            best_trip = (o, a, b)\n    if best_trip is not None and best_delta > 0:\n        o, a, b = best_trip\n        new = set(items)\n        new.remove(o)\n        new.add(a)\n        new.add(b)\n        return (to_str(new), \"SWAP_1_2\")\n\n    # 4) Try 2-1 SWAP: remove two, add one\n    best_move = None\n    best_delta = 0\n    if len(items) >= 2 and len(not_in) >= 1:\n        L = min(10, len(not_in))\n        cand_add = sorted(not_in, key=ratio_key, reverse=True)[:L]\n        it_list = list(items)\n        for i in cand_add:\n            for a_idx in range(len(it_list)):\n                a = it_list[a_idx]\n                for b_idx in range(a_idx+1, len(it_list)):\n                    b = it_list[b_idx]\n                    new_w = curr_w - weights[a] - weights[b] + weights[i]\n                    if new_w <= CAP:\n                        dv = values[i] - values[a] - values[b]\n                        if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                            best_delta = dv\n                            best_move = (i, a, b)\n    if best_move is not None and best_delta > 0:\n        i, a, b = best_move\n        new = set(items)\n        new.discard(a)\n        new.discard(b)\n        new.add(i)\n        return (to_str(new), \"SWAP_2_1\")\n\n    # 5) Diversification: remove lowest-density item if any, else add best fitting single (from empty)\n    if items:\n        worst = min(items, key=lambda i: (values[i]\/weights[i], values[i], random.random()))\n        new = set(items)\n        new.remove(worst)\n        return (to_str(new), \"REMOVE_WORST\")\n\n    # From empty: add best ratio single if any fits\n    best_fit = None\n    best_key = None\n    for i in all_idxs:\n        if weights[i] <= CAP:\n            k = (values[i]\/weights[i], values[i])\n            if best_key is None or k > best_key:\n                best_key = k\n                best_fit = i\n    if best_fit is not None:\n        return (str(best_fit), \"SEED_ADD\")\n\n    return (\"\", \"RESET\")\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Destroy-repair with variable strength and GRASP-style refill; maintains feasibility.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_strict(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        items = []\n        for p in parts:\n            if not (p.isdigit() and p[0] != '-'):\n                return set()\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return set()\n            items.append(idx)\n        if len(set(items)) != len(items):\n            return set()\n        return set(items)\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def total_weight(items_set):\n        return sum(weights[i] for i in items_set)\n\n    items = parse_strict(solution)\n\n    # If empty, seed with greedy RCL\n    if not items:\n        # GRASP construction\n        capacity = CAP\n        candidates = [i for i in range(1,25) if weights[i] <= capacity]\n        # RCL parameter\n        alpha = 0.2\n        sol_set = set()\n        curr_w = 0\n        while True:\n            feas = [i for i in candidates if i not in sol_set and curr_w + weights[i] <= capacity]\n            if not feas:\n                break\n            ratios = [values[i]\/weights[i] for i in feas]\n            rmin, rmax = min(ratios), max(ratios)\n            threshold = rmax - alpha*(rmax - rmin)\n            rcl = [i for i in feas if (values[i]\/weights[i]) >= threshold]\n            choice = random.choice(rcl)\n            sol_set.add(choice)\n            curr_w += weights[choice]\n        return to_str(sol_set)\n\n    # Destroy: remove k random items biased towards low ratio\n    k = min(len(items), random.choice([1,1,2,3]))\n    if k > 0:\n        pool = sorted(list(items), key=lambda i: (values[i]\/weights[i], values[i]))\n        remove_set = set(random.sample(pool[:max(1, min(len(pool), 5))], k=min(k, max(1, min(len(pool), 5)))))\n        items.difference_update(remove_set)\n\n    # Repair: GRASP refill with RCL\n    curr_w = total_weight(items)\n    alpha = 0.3\n    while True:\n        feas = [i for i in range(1,25) if i not in items and curr_w + weights[i] <= CAP]\n        if not feas:\n            break\n        ratios = [values[i]\/weights[i] for i in feas]\n        rmin, rmax = min(ratios), max(ratios)\n        threshold = rmax - alpha*(rmax - rmin)\n        rcl = [i for i in feas if (values[i]\/weights[i]) >= threshold]\n        choice = random.choice(rcl)\n        items.add(choice)\n        curr_w += weights[choice]\n        if curr_w == CAP:\n            break\n\n    return to_str(items)\n","SAMPLE_SOL":"8,4,18"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0\"\n\"FEEDBACK\":\n- \"FIX_LOCAL_SOLVER_1:TabuSearch_API_MISMATCH. Heuristic expects generate_neighbour->str, but current returns (str,move_type). Add adapter: def gen_nb_str(sol): return generate_neighbour(sol)[0] and pass gen_nb_str to Tabu; or refactor Tabu to accept\/ignore the second return.\"\n- \"FIX_LOCAL_SOLVER_2:TabuSignature_Incorrect. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove bespoke parameters (iterations, taboo_list_size, taboo_duration) from signature; pass them via other_params.\"\n- \"FIX_LOCAL_SOLVER_3:Perturbation_MISSING. $Perturb placeholder breaks ILS\/TS robustness. Implement feasible perturbation: randomly remove k in-bag items (k\u2208{1,2}) then greedily add best ratio items fitting capacity.\"\n- \"E_OBJ_CAP_CONSTRAINT_MISSING:objective_function ignores capacity and duplicates. It returns sum(values) even if overweight or repeated indices. Align with evaluate_solution semantics or remove to prevent misuse.\"\n- \"E_OBJ_EVAL_MISMATCH:objective_function maximizes positive value; evaluate_solution returns negative value for minimization. Unify by removing objective_function and using evaluate_solution only, or create a wrapper objective_function = lambda s: -evaluate_solution(s).\"\n- \"E_PARSE_DUP_COST:Repeated string parsing in evaluate_solution and generate_neighbour is O(n) per call. Cache parsed set, weight, and value inside the heuristic loop to enable incremental updates; pass cached state between neighbour steps to avoid re-parsing.\"\n- \"NB_CODE_FAIL_LOCAL_OPT:Neighbourhood biased. Step 1 greedily adds best ratio before checking swaps, which can trap search in shallow basins. Make swap\/2-opt moves available even when an ADD fits; interleave or probabilistically choose among ADD\/SWAP\/REMOVE.\"\n- \"NB_MOVE_SET_LIMITED:1-2\/2-1 swaps restricted to top-L by ratio; may miss improvements. Increase L adaptively when no improvement after T iterations, or sample without replacement from the full candidate set.\"\n- \"NB_RETURN_SCHEMA_INCONSISTENT:Returning (solution,tag) causes unpack errors across solvers. Standardize to return solution only; if tags are needed for logging, expose a separate callback.\"\n- \"R_STR_INADEQUATE:String representation forces costly set conversions and duplicate checks. Internally maintain a tuple(sorted(items)) and cached totals; serialize to string only at API boundaries.\"\n- \"E_KNOWN_REF_INCONSISTENT:Provided KNOWN_SOLUTION is infeasible under the current evaluator. Replace it with a feasible reference consistent with CAP and weights; validate via evaluate_solution before publishing.\"\n- \"EVAL_ASSERT:Automated check confirms KNOWN_SOLUTION fails feasibility. Integrate a unit test that asserts evaluate_solution(known_ref) != BIG and is <= 0 to prevent regressions.\"\n- \"SA_SCHEDULE_GENERIC:No evidence of temperature schedule tuning. Use geometric cooling T_{k+1}=alpha*T_k with alpha in [0.90,0.99], dynamic reheats on stagnation, and accept only improving or Metropolis moves consistent with minimization.\"\n- \"ILS_DIVERSIFICATION_WEAK:Single REMOVE_WORST as diversification is insufficient. Add random-k kick and a short tabu tenure on recently removed items to avoid cycling.\"\n- \"TS_MEMORY_POLICY_UNSPECIFIED:Tabu list size\/duration not enforced due to signature issues. After fixing API, use recency-based tabu with tenure ~ n\/2, aspiration by best-known cost, and short-term intensification when no improvement in W iterations.\"\n- \"E_BOUNDING_MISSING:No upper bound used to prune. Maintain incumbent best_value and discard neighbours with partial weight > CAP early; for 0\/1 knapsack, a fractional-relaxation bound can guide selective neighbourhood evaluation.\"\n- \"RANDOMNESS_SEEDING:Non-deterministic results impede reproducibility. Accept rng_seed in other_params and seed random at heuristic entry.\"\n- \"COMPLEXITY_NOTE:Neighbour generation sorts up to O(n log n) per call. Precompute static ratios and store indices sorted by ratio to reduce to O(n) scanning.\"\n- \"TESTS_REQUIRED:Add unit tests: (1) parsing rejects negatives\/duplicates\/out-of-range, (2) feasibility enforcement, (3) consistency evaluate_solution(s)==BIG iff infeasible, (4) neighbour returns feasible solutions or empty when none.\"\n- \"IMPLEMENTATION_SNIPPETS:Adapters\"\n- \"CODE_fix_generate_neighbour_adapter:def gen_nb_str(solution):\\n    nb = generate_neighbour(solution)\\n    return nb[0] if isinstance(nb, (list,tuple)) else nb\"\n- \"CODE_fix_objective_wrapper:def objective_function(s):\\n    val = evaluate_solution(s)\\n    return float('-inf') if val==10**9 else -val\"\n- \"CODE_basic_perturb:def perturb_solution(solution, strength=2):\\n    import random\\n    s = str(solution).strip()\\n    items = set(int(p) for p in s.split(',') if p.strip()) if s else set()\\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\\n    CAP=9\\n    # remove up to strength items\\n    rem = min(strength, len(items))\\n    for _ in range(rem):\\n        if not items: break\\n        items.remove(random.choice(tuple(items)))\\n    # greedy refill\\n    w = sum(weights[i] for i in items)\\n    cand = [i for i in range(1,25) if i not in items]\\n    cand.sort(key=lambda i: (values[i]\/weights[i], values[i]), reverse=True)\\n    for i in cand:\\n        if w + weights[i] <= CAP:\\n            items.add(i); w += weights[i]\\n    return \\\",\\\".join(str(i) for i in sorted(items))\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices string (e.g., \"18,4,8\"). Order is arbitrary; duplicates invalid. Empty string denotes selecting no items.","Componentes":{"REPRESENTATION":"Comma-separated unique item indices string (e.g., \"18,4,8\"). Order is arbitrary; duplicates invalid. Empty string denotes selecting no items.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated indices string, e.g., \"8,4,18\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values =  [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    NEG = -10**9\n    if solution is None:\n        return NEG\n    s = str(solution).strip()\n    if s == \"\":\n        return 0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.lstrip('-').isdigit() and (p[0] != '-' )):\n            return NEG\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return NEG\n        idxs.append(idx)\n    # 0\/1 constraint: no duplicates\n    if len(set(idxs)) != len(idxs):\n        return NEG\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return NEG\n        total_v += values[idx]\n    return total_v","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> Tuple[str, str, str]:\n    \"\"\"\n    Returns: (new_solution_str, NB_Type, Movement_Type)\n    NB_Type: \"index_list\"\n    Movement_Type: one of {\"add\",\"remove\",\"swap\",\"shuffle_order\"}\n    \"\"\"\n    # Embedded problem data\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24:\n                if idx not in S:\n                    S.append(idx)\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in S)\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n    current_w = total_weight(S)\n\n    moves = [\"add\",\"remove\",\"swap\",\"shuffle_order\"]\n    move = random.choice(moves)\n\n    if move == \"add\":\n        candidates = [i for i in range(1,25) if i not in S and current_w + weights[i] <= CAP]\n        if candidates:\n            i = random.choice(candidates)\n            S2 = S + [i]\n            return to_str(S2), \"index_list\", \"add\"\n        # fallback\n        move = \"remove\"\n\n    if move == \"remove\":\n        if S:\n            i = random.choice(S)\n            S2 = [x for x in S if x != i]\n            return to_str(S2), \"index_list\", \"remove\"\n        # fallback\n        move = \"add\"\n        candidates = [i for i in range(1,25) if i not in S and current_w + weights[i] <= CAP]\n        if candidates:\n            i = random.choice(candidates)\n            S2 = S + [i]\n            return to_str(S2), \"index_list\", \"add\"\n\n    if move == \"swap\":\n        if S:\n            out_i = random.choice(S)\n            remaining = current_w - weights[out_i]\n            candidates = [i for i in range(1,25) if i not in S and remaining + weights[i] <= CAP]\n            if candidates:\n                in_i = random.choice(candidates)\n                S2 = [x for x in S if x != out_i] + [in_i]\n                return to_str(S2), \"index_list\", \"swap\"\n        # fallback to remove if swap not possible\n        if S:\n            i = random.choice(S)\n            S2 = [x for x in S if x != i]\n            return to_str(S2), \"index_list\", \"remove\"\n\n    # shuffle order (does not affect feasibility\/value)\n    S2 = S[:]\n    random.shuffle(S2)\n    return to_str(S2), \"index_list\", \"shuffle_order\"","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Perform multi-flip random feasible perturbation\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24 and idx not in S:\n                S.append(idx)\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in S)\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        # try random add\/remove respecting capacity\n        if random.random() < 0.5 and S:\n            # remove\n            i = random.choice(S)\n            S = [x for x in S if x != i]\n        else:\n            # add\n            cur_w = total_weight(S)\n            candidates = [i for i in range(1,25) if i not in S and cur_w + weights[i] <= CAP]\n            if candidates:\n                S.append(random.choice(candidates))\n        # occasional swap\n        if S and random.random() < 0.3:\n            out_i = random.choice(S)\n            remaining = total_weight([x for x in S if x != out_i])\n            candidates = [i for i in range(1,25) if i not in S and remaining + weights[i] <= CAP]\n            if candidates:\n                S = [x for x in S if x != out_i] + [random.choice(candidates)]\n\n    # canonicalize order\n    S = list(dict.fromkeys(S))\n    return to_str(S)","SAMPLE_SOL":"18,4,8"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_FIX_SOLVER_ERROR: Heuristic signatures incorrectly call dependencies in the parameter list. Do NOT use generate_neighbour() or evaluate_solution() in the signature; pass function objects without parentheses.\"\n\"FEEDBACK\",\"E_TYPE_HINT_INSTANTIATION: 'Type Tuple cannot be instantiated' indicates usage of Tuple() as a constructor. Replace any Tuple() with tuple() or use literal tuples '()' where needed.\"\n\"FEEDBACK\",\"E_SIG_REQUIRED: Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure all solvers (SA\/ILS\/TS) follow this exact order and arity.\"\n\"FEEDBACK\",\"E_COST_SIGN: Framework expects 'best' as lesser cost. Convert maximization value v to cost c = -v. Ensure comparisons and acceptance tests use smaller-is-better.\"\n\"FEEDBACK\",\"E_OBJ_EVAL_MISMATCH: objective_function ignores capacity and duplicates; evaluate_solution enforces them. Remove objective_function or make it identical to evaluate_solution to avoid inconsistent scoring.\"\n\"FEEDBACK\",\"E_PERTURB_ABSENT: Perturbation Function is missing ('$Perturb'). Implement perturb_solution(solution) returning a feasible neighbor after multi-move shake (e.g., k random remove\/add respecting CAP).\"\n\"FEEDBACK\",\"E_RUNTIME_API: Local solver errors show function annotations\/comments as part of runtime signature text (SA\/ILS\/TS). Clean signatures and avoid extra parenthetical notes in def lines.\"\n\"FEEDBACK\",\"E_PARAMS_NAMING: ILS parameter 'aceptance_rate' typo. Standardize to acceptance_rate and document expected [0,1] range.\"\n\"FEEDBACK\",\"E_RETURN_PROTO: Solvers should return (new_current, new_best, new_best_score, extra_outputs). Ensure extra_outputs exists because 'LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED'.\"\n\"FEEDBACK\",\"E_NEIGHBOR_NOOP: Movement_Type 'shuffle_order' is a no-op for a set representation. Remove or replace with meaningful 2-opt-like swap or add-remove compound move.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Neighborhood lacks 1-1 and 2-1 exchanges under CAP. Add best-improving swap or add-remove that increases value without breaking capacity.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: String parsing each step is slow and error-prone. Internally convert to sorted tuple or frozenset of ints; only serialize to string at boundaries.\"\n\"FEEDBACK\",\"P_PARSE_INCONSISTENT: generate_neighbour.parse uses str.isdigit() (rejects signed and trims silently) while evaluate_solution has stricter validation and NEG on errors. Unify parsing\/validation and avoid silent drops.\"\n\"FEEDBACK\",\"E_DUP_CHECK_SITE: Neighbor builder prevents duplicates implicitly but parser silently de-duplicates. Enforce 0\/1 strictly by rejecting duplicates early (return NEG) everywhere for consistency.\"\n\"FEEDBACK\",\"E_CAP_MARGIN: Swap considers only 1-out-1-in. Add multi-out-1-in and 1-out-multi-in trials for tight CAP=9 to escape local optima.\"\n\"FEEDBACK\",\"SA_COOLING: Use geometric cooling T <- T*alpha with alpha in (0.90,0.99). Stop at MIN_TEMP or plateau. Set iterations per temperature proportional to neighbor count. Avoid temperature that freezes search early.\"\n\"FEEDBACK\",\"SA_ACCEPT: For cost c=-v, accept worse moves with prob exp(-(c_new-c_cur)\/T). Clamp overflow and skip when c_new is +inf\/NEG violations.\"\n\"FEEDBACK\",\"ILS_DESIGN: Use local_search until no improving neighbor, then perturb k in [2,4] random feasible add\/remove\/swap, accept new local optimum if cost improves or by threshold acceptance_rate.\"\n\"FEEDBACK\",\"TS_MEMORY: Maintain tabu list on item-level moves (added\/removed indices) with aspiration when a move yields better best_score. Set tabu_duration ~ 7\u201315; tabu_list_size proportional to item count.\"\n\"FEEDBACK\",\"E_VALIDATION: Always evaluate candidate with evaluate_solution and transform to cost=-value. Reject NEG as infeasible. Guard comparisons to avoid mixing raw values and costs.\"\n\"FEEDBACK\",\"E_SEED_REPRO: Provide RNG seed control in other_params for reproducibility. Avoid using global random without option to set seed.\"\n\"FEEDBACK\",\"E_LOGGING_MIN: Extra outputs should include: last_move_type, temp\/iter stats, acceptance ratio, and best_trace for post-analysis. Keep lightweight to avoid overhead.\"\n\"FEEDBACK\",\"E_UNIT_TEST: Add quick exact DP with CAP=9 to validate solver outputs for regression. Use it only in tests, not in the heuristic loop, to avoid slowdown.\"\n\"FEEDBACK\",\"E_BOUND_HEUR: Add greedy upper bound by value\/weight ratio for pruning in local search to focus candidate moves.\"\n\"FEEDBACK\",\"E_TIME_CAP: Add iteration\/time budget in other_params to prevent unbounded runs.\"\n\"FEEDBACK\",\"E_KNOWN_REF_INVALID: The provided reference solution fails evaluate_solution (returns NEG). Update the reference or the problem data; do not use it for assertions.\"\n\"FEEDBACK\",\"E_PERF_STR: Avoid repeated split\/strip in hot loops. Cache parsed set and total weight; update incrementally on moves to achieve O(1) delta evaluations.\"\n\"FEEDBACK\",\"S_CORRECTNESS_CHECK: Verified evaluate_solution on the reference; it reports infeasibility. Fix the reference before using it to assert solver correctness.\"\n\"FEEDBACK\",\"ACTIONABLE_FIX_ORDER: 1) Correct solver signatures and remove Tuple() instantiations. 2) Implement perturb_solution. 3) Standardize cost=-value across all solvers. 4) Replace noop neighbors with add\/remove\/swap (including 2-1). 5) Unify parsing\/validation and incremental evaluation. 6) Add minimal extra outputs and seed control. 7) Add DP-based unit test and repair the invalid reference.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices string denoting selected items, e.g., \"18,4,8\". Order is arbitrary; duplicates invalid. Empty string \"\" denotes selecting no items. Capacity constraint enforced internally (sum of weights <= 9).","Componentes":{"REPRESENTATION":"Comma-separated unique item indices string denoting selected items, e.g., \"18,4,8\". Order is arbitrary; duplicates invalid. Empty string \"\" denotes selecting no items. Capacity constraint enforced internally (sum of weights <= 9).","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated indices string, e.g., \"8,4,18\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values =  [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    NEG = -10**9\n    if solution is None:\n        return NEG\n    s = str(solution).strip()\n    if s == \"\":\n        return 0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.lstrip('-').isdigit() and (p[0] != '-' )):\n            return NEG\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return NEG\n        idxs.append(idx)\n    # 0\/1 constraint: no duplicates\n    if len(set(idxs)) != len(idxs):\n        return NEG\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return NEG\n        total_v += values[idx]\n    return total_v\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a tuple: (new_solution_str, NB_Type, Movement_Type)\n    NB_Type: \"index_list\"\n    Movement_Type in {\"add\",\"remove\",\"swap\",\"two_out_one_in\",\"one_out_two_in\"}\n    Always attempts to return a feasible neighbor under CAP=9.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                return []\n            idx = int(p)\n            if 1 <= idx <= 24 and idx not in seen:\n                S.append(idx)\n                seen.add(idx)\n            else:\n                return []\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in S)\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n    current_w = total_weight(S)\n\n    # Precompute feasible add candidates\n    add_candidates = [i for i in range(1, 25) if (i not in S) and (current_w + weights[i] <= CAP)]\n\n    moves = [\"add\", \"remove\", \"swap\", \"two_out_one_in\", \"one_out_two_in\"]\n    random.shuffle(moves)\n\n    # Try each move type; return on first feasible change\n    for move in moves:\n        if move == \"add\":\n            if add_candidates:\n                i = random.choice(add_candidates)\n                S2 = S + [i]\n                return to_str(S2), \"index_list\", \"add\"\n        elif move == \"remove\":\n            if S:\n                i = random.choice(S)\n                S2 = [x for x in S if x != i]\n                return to_str(S2), \"index_list\", \"remove\"\n        elif move == \"swap\":\n            if S:\n                out_i = random.choice(S)\n                remaining_w = current_w - weights[out_i]\n                candidates = [i for i in range(1, 25) if (i not in S) and (remaining_w + weights[i] <= CAP)]\n                if candidates:\n                    in_i = random.choice(candidates)\n                    S2 = [x for x in S if x != out_i] + [in_i]\n                    return to_str(S2), \"index_list\", \"swap\"\n        elif move == \"two_out_one_in\":\n            if len(S) >= 2:\n                # Try a few random pairs\n                tried = 0\n                S_set = set(S)\n                while tried < 10:\n                    out_i = random.choice(S)\n                    out_j = random.choice(S)\n                    if out_i == out_j:\n                        tried += 1\n                        continue\n                    remaining_w = current_w - weights[out_i] - weights[out_j]\n                    if remaining_w < 0:\n                        tried += 1\n                        continue\n                    candidates = [k for k in range(1, 25) if (k not in S_set) and (remaining_w + weights[k] <= CAP)]\n                    if candidates:\n                        in_k = random.choice(candidates)\n                        S2 = [x for x in S if x not in (out_i, out_j)] + [in_k]\n                        return to_str(S2), \"index_list\", \"two_out_one_in\"\n                    tried += 1\n        elif move == \"one_out_two_in\":\n            if len(S) >= 1:\n                out_i = random.choice(S)\n                remaining_w = current_w - weights[out_i]\n                # Build list of items not in S\n                pool = [k for k in range(1, 25) if k not in S]\n                # Try randomized pairs up to a cap\n                attempts = 0\n                while attempts < 25:\n                    if len(pool) < 2:\n                        break\n                    a, b = random.sample(pool, 2)\n                    if remaining_w + weights[a] + weights[b] <= CAP:\n                        S2 = [x for x in S if x != out_i] + [a, b]\n                        return to_str(S2), \"index_list\", \"one_out_two_in\"\n                    attempts += 1\n    # Fallbacks to ensure a neighbor is returned\n    if add_candidates:\n        i = random.choice(add_candidates)\n        return to_str(S + [i]), \"index_list\", \"add\"\n    if S:\n        i = random.choice(S)\n        return to_str([x for x in S if x != i]), \"index_list\", \"remove\"\n    # As absolute last resort, pick a random single feasible item\n    singles = [i for i in range(1, 25) if weights[i] <= CAP]\n    if singles:\n        return str(random.choice(singles)), \"index_list\", \"add\"\n    return \"\", \"index_list\", \"remove\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-move feasible perturbation (shake). Returns a new feasible solution string.\n    Applies 2-5 random edits among {add, remove, swap, two_out_one_in, one_out_two_in} while respecting capacity.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                return []\n            idx = int(p)\n            if 1 <= idx <= 24 and idx not in seen:\n                S.append(idx)\n                seen.add(idx)\n            else:\n                return []\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in S)\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        cur_w = total_weight(S)\n        moves = [\"add\", \"remove\", \"swap\", \"two_out_one_in\", \"one_out_two_in\"]\n        move = random.choice(moves)\n\n        if move == \"add\":\n            candidates = [i for i in range(1, 25) if (i not in S) and (cur_w + weights[i] <= CAP)]\n            if candidates:\n                S.append(random.choice(candidates))\n        elif move == \"remove\":\n            if S:\n                out_i = random.choice(S)\n                S = [x for x in S if x != out_i]\n        elif move == \"swap\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                if candidates:\n                    in_i = random.choice(candidates)\n                    S = [x for x in S if x != out_i] + [in_i]\n        elif move == \"two_out_one_in\":\n            if len(S) >= 2:\n                out_i = random.choice(S)\n                out_j = random.choice(S)\n                if out_i != out_j:\n                    rem_w = cur_w - weights[out_i] - weights[out_j]\n                    if rem_w >= 0:\n                        candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                        if candidates:\n                            in_i = random.choice(candidates)\n                            S = [x for x in S if x not in (out_i, out_j)] + [in_i]\n        elif move == \"one_out_two_in\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                pool = [k for k in range(1, 25) if k not in S]\n                if len(pool) >= 2:\n                    random.shuffle(pool)\n                    done = False\n                    for a in pool:\n                        if done:\n                            break\n                        for b in pool:\n                            if a == b:\n                                continue\n                            if rem_w + weights[a] + weights[b] <= CAP:\n                                S = [x for x in S if x != out_i] + [a, b]\n                                done = True\n                                break\n    # Deduplicate and canonicalize\n    S = list(dict.fromkeys(S))\n    # Ensure feasibility (drop random items if needed)\n    while total_weight(S) > CAP and S:\n        S.pop(random.randrange(len(S)))\n    return to_str(S)\n","SAMPLE_SOL":"18,4,8"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-fix1\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERROR_SIG:Heuristic signatures deviate from TARGET_HEURISTIC_GENERAL_SIGNATURE. Refactor SA\/ILS\/TS to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Enforce single unified entrypoint.\nFIX_LOCAL_SOLVER_ERROR_NB_RET:generate_neighbour returns 3-tuple (sol,NB_Type,Move) but call-site expects 2. Standardize to return (sol,Move) or update heuristic to accept 3. Prefer (sol,Move) for minimal unpacking.\nFIX_LOCAL_SOLVER_ERROR_PERTURB:Missing perturbation implementation ('$Perturb'). Provide def perturb_solution(solution, rng, intensity) consistent with representation and CAP=9.\nOBJ_EVAL_INCONSISTENT:objective_function ignores capacity and duplicates; evaluate_solution enforces both. Unify by reusing evaluate_solution or mirroring its checks to prevent overvaluation of infeasible\/duplicate sets.\nSCORE_SIGN_CONVENTION:Heuristics require lower-is-better; current maximize evaluate_solution returns positive values. Wrap cost as cost=-evaluate_solution(sol) everywhere to keep acceptance\/compare logic consistent.\nEVAL_REF_MISMATCH:Reference solution metadata is inconsistent with evaluator. Replace with a feasible reference that matches the provided expected score and add an assertion test.\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood relies on random single-sample moves; lacks best-improvement and ratio-guided selection. Add value\/weight ratio heuristic for add\/swap and evaluate multiple candidates per move.\nNB_DUP_CANONICAL:Canonicalize solution strings (sorted indices, comma-joined) to ensure deterministic equality, simplify tabu, and avoid redundant explorations.\nNB_PERF_ADD_CANDS:Recomputes full add_candidates O(n) each call. Maintain current weight and prefiltered feasible-light items; cache weights<=CAP list and update incrementally after add\/remove.\nNB_SWAP_ENUM:For small CAP, enumerate all 1-out-1-in and 2-out-1-in combinations up to a capped sample; choose best-improvement neighbor instead of first-feasible random pick.\nNB_ONE_OUT_TWO_IN_BOUND:Current loop attempts up to 25 random pairs; may miss feasible combos. Switch to bounded deterministic enumeration of light items (weights<=CAP) with early-exit on best gain.\nNB_PARSE_ROBUSTNESS:parse uses str.isdigit() and rejects valid spaces or leading zeros inconsistently with evaluate_solution. Align token validation to the evaluator's rules and reject negatives\/duplicates explicitly.\nTABU_MOVE_DEF:Define tabu over moves (added\/removed indices) using canonical forms; store tuples like ('add',i) or ('swap',out,in). Set tabu tenure ~7\u201315; aspiration if new cost improves best.\nSA_SCHEDULE:Define TEMP0 via percentile of initial delta-costs; geometric cooling alpha\u2208[0.90,0.99]; MIN_TEMP ~1e-3 of TEMP0; iterations per temp proportional to |N| or fixed budget.\nILS_ACCEPT:Use strict improvement acceptance for post-perturb local search; fallback to probabilistic acceptance only if stagnation persists. Keep perturbation strength 1\u20132 moves given tiny CAP.\nRESTART_POLICY:Add diversification restarts after no-improvement K iterations; seed from greedy ratio-based construction to ensure feasibility.\nTESTS_UNIT:Add tests for evaluate_solution on empty, invalid tokens, duplicates, overweight, and a known feasible high-score set. Assert objective_function==evaluate_solution for all feasible sets.\nRANDOM_SEED_CTRL:Inject rng parameter throughout generate_neighbour and perturb_solution for reproducibility; avoid global random.\nMETRICS_LOG:Log (iter, cost, move, |S|, weight) to validate acceptance and feasibility; enable early detection of regressions.\nCOMPLEXITY_NOTE:Current neighbour generation amortized O(n); with best-improvement scans it becomes O(n^2) worst-case for swap. Use capped candidate lists (top-k by ratio) to keep O(n log n)+k*n manageable.\nVALIDATION_ASSERTS:Add runtime asserts: feasibility after each move; canonicalization; non-increasing best_cost; tabu constraints respected.\nINTEGRATION_API:Ensure Heuristic returns tuple (best_solution_str,best_cost,extras_dict). extras_dict may include trace for LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED.\nACTIONABLE_CODE_SKELETON:def Heuristic(curr,best,best_score,gen_nb,eval_f,perturb,params): implement loop with cost=-eval_f, accept if cost lower, track best, apply perturb on stagnation. Ensure no filesystem\/network\/OS calls per MAIN_CRITICAL_INSTRUCTION.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices string denoting selected items, e.g., \"4,8,18\". Order is canonicalized ascending; duplicates invalid. Empty string \"\" denotes selecting no items. Capacity constraint enforced internally (sum of weights <= 9).","Componentes":{"REPRESENTATION":"Comma-separated unique item indices string denoting selected items, e.g., \"4,8,18\". Order is canonicalized ascending; duplicates invalid. Empty string \"\" denotes selecting no items. Capacity constraint enforced internally (sum of weights <= 9).","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated indices string, e.g., \"8,4,18\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values =  [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    NEG = -10**9\n    if solution is None:\n        return NEG\n    s = str(solution).strip()\n    if s == \"\":\n        return 0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    seen = set()\n    for p in parts:\n        if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n            return NEG\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return NEG\n        if idx in seen:\n            return NEG\n        seen.add(idx)\n        idxs.append(idx)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return NEG\n        total_v += values[idx]\n    return total_v","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a tuple: (new_solution_str, movement_type)\n    movement_type in {\"add\",\"remove\",\"swap\",\"two_out_one_in\",\"one_out_two_in\"}\n    Always returns a feasible neighbour under CAP=9, canonicalized ascending.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values =  [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n                return []\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return []\n            if idx in seen:\n                return []\n            S.append(idx)\n            seen.add(idx)\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in sorted(S))\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    def feasible_after_add(S, i):\n        return (i not in S) and (total_weight(S) + weights[i] <= CAP)\n\n    def ratio(i):\n        return values[i] \/ weights[i]\n\n    S = parse(solution)\n    cur_w = total_weight(S)\n\n    # Precompute candidate pools\n    remaining = [i for i in range(1, 25) if i not in S]\n    add_candidates = [i for i in remaining if cur_w + weights[i] <= CAP]\n\n    # Try best-improvement add by ratio\n    if add_candidates:\n        best_i = max(add_candidates, key=lambda i: (ratio(i), values[i]))\n        S2 = S + [best_i]\n        return to_str(S2), \"add\"\n\n    # Try best swap: enumerate 1-out-1-in within capacity, choose best gain in value\n    best_gain = -math.inf\n    best_swap = None\n    for out in S:\n        w_after = cur_w - weights[off := out]\n        for inn in remaining:\n            if w_after + weights[inn] <= CAP:\n                gain = values[inn] - values[out]\n                if gain > best_gain:\n                    best_gain = gain\n                    best_swap = (out, inn)\n    if best_swap is not None and best_gain >= 0:\n        out, inn = best_swap\n        S2 = [x for x in S if x != out] + [inn]\n        return to_str(S2), \"swap\"\n\n    # If no non-worsening swap, try remove the lowest value\/weight ratio item to free space\n    if S:\n        worst = min(S, key=lambda i: (ratio(i), values[i]))\n        S2 = [x for x in S if x != worst]\n        return to_str(S2), \"remove\"\n\n    # If empty and no add feasible (shouldn't happen given singles exist), return empty\n    return \"\", \"remove\"","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-move feasible perturbation (shake). Returns a new feasible solution string.\n    Applies 2-4 random edits among {add, remove, swap, two_out_one_in, one_out_two_in} while respecting capacity.\n    Canonicalizes result and enforces feasibility by dropping random items if overweight.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n                return []\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return []\n            if idx in seen:\n                return []\n            S.append(idx)\n            seen.add(idx)\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in sorted(S))\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n    k = random.randint(2, 4)\n    for _ in range(k):\n        cur_w = total_weight(S)\n        moves = [\"add\", \"remove\", \"swap\", \"two_out_one_in\", \"one_out_two_in\"]\n        move = random.choice(moves)\n\n        if move == \"add\":\n            candidates = [i for i in range(1, 25) if (i not in S) and (cur_w + weights[i] <= CAP)]\n            if candidates:\n                S.append(random.choice(candidates))\n        elif move == \"remove\":\n            if S:\n                S.pop(random.randrange(len(S)))\n        elif move == \"swap\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                if candidates:\n                    in_i = random.choice(candidates)\n                    S = [x for x in S if x != out_i] + [in_i]\n        elif move == \"two_out_one_in\":\n            if len(S) >= 2:\n                out_i, out_j = random.sample(S, 2)\n                rem_w = cur_w - weights[out_i] - weights[out_j]\n                if rem_w >= 0:\n                    candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                    if candidates:\n                        in_i = random.choice(candidates)\n                        S = [x for x in S if x not in (out_i, out_j)] + [in_i]\n        elif move == \"one_out_two_in\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                pool = [k for k in range(1, 25) if k not in S]\n                if len(pool) >= 2:\n                    random.shuffle(pool)\n                    done = False\n                    for a in pool:\n                        if done:\n                            break\n                        for b in pool:\n                            if a == b:\n                                continue\n                            if rem_w + weights[a] + weights[b] <= CAP:\n                                S = [x for x in S if x != out_i] + [a, b]\n                                done = True\n                                break\n    # Deduplicate and canonicalize\n    S = list(dict.fromkeys(S))\n    # Ensure feasibility (drop random items if needed)\n    while total_weight(S) > CAP and S:\n        S.pop(random.randrange(len(S)))\n    return to_str(S)","SAMPLE_SOL":"4,8,18"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_TS_SIGNATURE_MISMATCH:Tabu search signature deviates from required general signature; align to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"FEEDBACK\",\"E_HEURISTIC_RETURN_ARITY:Framework expects 2-tuple (best_solution,best_cost). Your SA\/ILS return 4 values, causing unpack errors downstream; standardize to 2-tuple and expose diagnostics via a separate structured extras object.\"\n\"FEEDBACK\",\"E_COST_SIGN_CONVENTION:Maximization not converted to minimization; best-as-less requires cost=-evaluate(solution). Returning raw positive scores breaks selection\/comparison logic.\"\n\"FEEDBACK\",\"E_PERTURB_UNDEFINED:Perturbation function placeholder '$Perturb' is missing; heuristics relying on perturbation (SA\/ILS\/TS) will be underdefined.\"\n\"FEEDBACK\",\"E_KNOWN_BEST_EVAL_MISMATCH:Provided reference solution fails evaluator (returns NEG), indicating inconsistency between 'KNOWN_SOLUTION' and constraints; replace with a feasible reference set and validated score.\"\n\"FEEDBACK\",\"E_OBJ_EVAL_INCONSISTENT:objective_function ignores capacity and duplicates; evaluate_solution enforces both. This mismatch induces incorrect acceptance during search and misleading logging.\"\n\"FEEDBACK\",\"E_NEIGH_DOC_IMPL_MISMATCH:Movement types list includes 'two_out_one_in' and 'one_out_two_in' but these moves are never generated; documentation and implementation diverge.\"\n\"FEEDBACK\",\"E_NEIGH_INPUT_HANDLING:Neighbour.parse silently converts invalid input to empty set []; this masks upstream errors and can teleport the search to the empty solution.\"\n\"FEEDBACK\",\"E_NEIGH_GREEDY_TRAP:Always-ADD-by-ratio when feasible prevents exploration of swaps that lead to better global improvements under tight capacity; leads to premature convergence.\"\n\"FEEDBACK\",\"E_LOCAL_LOG_FORMAT:Local solver result tuples are inconsistent across algorithms; standardize ordering and content to enable automated parsers.\"\n\"FEEDBACK\",\"E_DUP_CONSTRAINT_OBJ:objective_function does not reject duplicate indices, violating 0\/1 constraint; this can inflate reported objective values.\"\n\"FEEDBACK\",\"E_CANONICALIZATION_SCOPE:Representation requires canonical ascending order globally; objective_function and external components do not enforce it.\"\n\"FEEDBACK\",\"E_VALIDATION_COVERAGE:No unit tests verifying evaluator invariants (capacity, duplicates, index bounds) across core utilities; regressions will slip through.\"\n\"FEEDBACK\",\"F_CODE_PERF:generate_neighbour recomputes sums via total_weight in multiple branches; although small here, refactor to maintain and update cur_w to O(1) per local change.\"\n\"FEEDBACK\",\"R_TS_API_FIX:Refactor Tabu Search to the general Heuristic signature; pass generate_neighbour\/evaluate_solution\/perturb_solution as callables and pack iterations, tabu size, duration into other_params.\"\n\"FEEDBACK\",\"R_RETURN_NORMALIZE:All heuristics must return (best_solution,best_cost). If extra outputs are needed, return (best_solution,best_cost), extras where extras is a dict; do not break arity.\"\n\"FEEDBACK\",\"R_COST_WRAP:Define cost_fn=lambda s: -evaluate_solution(s) and consistently minimize cost; ensure acceptance criteria, best updates, and temperature\/perturb logic use cost.\"\n\"FEEDBACK\",\"R_OBJ_REMOVE:Eliminate objective_function or mirror evaluate_solution exactly (capacity, duplicates, bounds, parsing). Prefer a single source of truth to avoid divergence.\"\n\"FEEDBACK\",\"R_NEIGH_EXTEND:Implement 'swap','two_out_one_in','one_out_two_in' and select the best non-worsening move by delta value under capacity; fall back to strategic removals when stuck.\"\n\"FEEDBACK\",\"R_NEIGH_SAFE_PARSE:On invalid input, propagate an explicit error or return (solution,'noop') without altering the set; never coerce to empty silently.\"\n\"FEEDBACK\",\"R_PERTURB_IMPLEMENT:Implement a feasibility-preserving k-move perturbation (e.g., remove worst-by-ratio items to free capacity, then add best-by-ratio until no add fits); parameterize k.\"\n\"FEEDBACK\",\"R_EXACT_BASELINE:Add an exact DP\/meet-in-the-middle baseline for CAP=9 to validate heuristic results and to compute gaps; use it in tests but keep heuristics independent.\"\n\"FEEDBACK\",\"R_UNIT_TESTS:Add tests: duplicates rejected, overweight rejected, out-of-range indices rejected, empty string scores 0, canonicalization preserved, neighbour always feasible.\"\n\"FEEDBACK\",\"R_LOG_SCHEMA:Standardize local solver outputs to ('best_solution', best_value, 'final_solution', final_value) or return extras dict; avoid free-form tuples.\"\n\"FEEDBACK\",\"R_MOVE_SELECTION:Use delta-evaluation: maintain cur_w, cur_v; for swap evaluate gain=values[in]-values[out] and feasibility via cur_w-weights[out]+weights[in] <= CAP to avoid recomputations.\"\n\"FEEDBACK\",\"R_CANONICALIZATION:Enforce canonical ascending order at all boundaries (generation, mutation, return) to keep equality checks and tabu hashing consistent.\"\n\"FEEDBACK\",\"R_TABU_MEMORY:For Tabu, maintain a tabu set over moves or solutions with fixed tenure; if generate_neighbour returns (sol,move_type), tabu should consider both identity and move attributes; ensure aspiration if new cost < best_cost.\"\n\"FEEDBACK\",\"R_SA_ACCEPT:In SA, accept with prob exp(-(new_cost-cur_cost)\/T); ensure cost convention; avoid mixing raw values with costs.\"\n\"FEEDBACK\",\"R_ILS_STRUCTURE:Implement local search to a 1-opt\/2-opt-like local optimum under feasible moves, then perturb and relaunch; stop on max iters or stagnation; track best via cost.\"\n\"FEEDBACK\",\"R_EVAL_ASSERTS:Before runs, assert evaluate_solution(best) != NEG and evaluate_solution(currentSolution) != NEG to catch infeasible seeds early.\"\n\"FEEDBACK\",\"R_RANDOM_SEED:Set and log RNG seeds in experiments to reproduce outcomes; pass seed via other_params.\"\n\"FEEDBACK\",\"R_COMPLEXITY:Prefer O(n) neighbour generation with prefiltered candidate lists (weights<=CAP-cur_w); avoid scanning all 24 items repeatedly.\"\n\"FEEDBACK\",\"R_DATA_INTEGRITY:Centralize weights\/values\/CAP in one module to prevent drift between components; import from a single source rather than duplicating literals.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST: comma-separated 1-based distinct item indices, e.g., \"4,8,18\". Empty string means no items.","Componentes":{"REPRESENTATION":"INDEX_LIST: comma-separated 1-based distinct item indices, e.g., \"4,8,18\". Empty string means no items.","EVAL_CODE":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Fitness = objective value if feasible; else heavy penalty.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None, 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return None, 'EMPTY_TOKEN'\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None, 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return None, 'RANGE'\n            if k in seen:\n                return None, 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list(solution)\n    if err is not None:\n        return -1000000000\n\n    total_weight = 0\n    total_value = 0\n    for k in idxs:\n        total_weight += weights[k-1]\n        total_value += values[k-1]\n    if total_weight > 9:\n        return -1000000000\n    return total_value\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_str, movement_type)\n    # Representation: comma-separated 1-based indices with no duplicates.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list(sol: str):\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    def repair(idxs: List[int]) -> List[int]:\n        # Remove worst value\/weight ratio items until feasible\n        cur = idxs[:]\n        while total_weight(cur) > C and len(cur) > 0:\n            cur.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])), reverse=False)\n            cur.pop(0)\n        return cur\n\n    cur = parse_index_list(solution if isinstance(solution, str) else '')\n\n    move_types = ['add', 'remove', 'swap', 'toggle']\n    move = random.choice(move_types)\n\n    idx_set = set(cur)\n    all_items = set(range(1, n+1))\n    new = cur[:]\n\n    if move == 'add':\n        candidates = list(all_items - idx_set)\n        if candidates:\n            k = random.choice(candidates)\n            new.append(k)\n            new = repair(new)\n        else:\n            move = 'remove'\n    if move == 'remove':\n        if new:\n            rem = random.choice(new)\n            new.remove(rem)\n    elif move == 'swap':\n        if new and len(idx_set) < n:\n            out = random.choice(new)\n            candidates = list(all_items - set([out]) - (idx_set - set([out])))\n            if not candidates:\n                candidates = list(all_items - idx_set)\n            if candidates:\n                inn = random.choice(candidates)\n                new.remove(out)\n                new.append(inn)\n                new = repair(new)\n        else:\n            move = 'toggle'\n    if move == 'toggle':\n        k = random.randint(1, n)\n        if k in new:\n            new.remove(k)\n        else:\n            new.append(k)\n            new = repair(new)\n\n    new = sorted(set(new))\n    return to_str(new), move\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger random perturbation: multiple toggles with repair to feasibility.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list(sol: str):\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    def repair(idxs: List[int]) -> List[int]:\n        cur = idxs[:]\n        while total_weight(cur) > C and len(cur) > 0:\n            cur.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])), reverse=False)\n            cur.pop(0)\n        return cur\n\n    cur = parse_index_list(solution if isinstance(solution, str) else '')\n\n    k_moves = random.randint(2, 5)\n    chosen = set()\n    for _ in range(k_moves):\n        k = random.randint(1, n)\n        # avoid repeating the same toggle too often\n        if k in chosen and random.random() < 0.7:\n            continue\n        chosen.add(k)\n        if k in cur:\n            cur.remove(k)\n        else:\n            cur.append(k)\n        cur = repair(cur)\n\n    cur = sorted(set(cur))\n    return to_str(cur)\n","SAMPLE_SOL":"4,8,18"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-feedback\"\n\"FEEDBACK\":\"L_SIG_FUNCREF:Heuristic signatures pass call results (generate_neighbour(), evaluate_solution()) instead of function references. Remove parentheses and pass callables.\"\n\"L_TYPING_LIST_INSTANTIATION:Error 'Type List cannot be instantiated' indicates misuse of typing.List. Replace List(...) with list() and only use List for type hints.\"\n\"L_MISSING_PERTURB:Perturbation Function undefined ($Perturb). Implement perturb_solution and pass reference to ILS; otherwise ILS cannot run.\"\n\"L_COST_DIRECTION_MISMATCH:Framework expects 'less is better' but evaluate_solution returns value to maximize. Wrap fitness as cost=-evaluate_solution(sol) within heuristics.\"\n\"E_OBJ_EVAL_MISMATCH:objective_function ignores capacity while evaluate_solution enforces it. Unify evaluation (enforce capacity consistently) or delete objective_function from optimization loop to avoid misleading guidance.\"\n\"K_SOL_REF_FAIL:Known solution provided is infeasible under evaluate_solution; update the reference solution used for correctness checks to a feasible optimum under the stated capacity.\"\n\"NB_PARSE_ROBUSTNESS:generate_neighbour parse_index_list assumes numeric tokens and will raise on invalid input. Reuse the validated parser from evaluate or add explicit checks and error handling.\"\n\"NB_REPAIR_COMPLEXITY:repair() sorts entire set on every removal (O(k log k) per iteration). Replace with single-pass argmin selection per removal (O(k)) or maintain a heap by density.\"\n\"NB_REPAIR_CRITERION:Removing lowest value\/weight density may still drop multiple items unnecessarily. Prefer removal by minimum loss per unit overweight or by highest weight with lowest marginal value to reduce value loss.\"\n\"NB_MOVE_VALIDITY:swap candidate logic is convoluted and can degenerate; ensure swap samples from outside current set and evaluates delta gain before acceptance.\"\n\"NB_MOVE_FEASIBILITY:Current moves rely on repair after infeasible additions. Add weight-aware moves that keep feasibility without repair (e.g., add only from items with w<=remaining_capacity, or remove heaviest then add best-density).\"\n\"NB_TOGGLE_BIAS:Final 'if move == toggle' block only runs when explicitly selected; but overall move selection lacks probability control and can under-sample adds in tight capacity. Rebalance move probabilities conditioned on feasibility (favor add when light items exist, else swap\/remove).\"\n\"R_REPR_VALIDATION:Parsers accept '+' and negatives then coerce; normalize to strictly 1..n digits and reject others to prevent silent corrections and duplicates.\"\n\"E_PENALTY_SCALE:Using -1e9 can distort annealing acceptance and tabu aspiration. Use a tighter penalty (e.g., -1e6) or dynamic penalty proportional to overweight to preserve gradient information.\"\n\"SA_API_PARAMS:Provide explicit TEMP, MIN_TEMP, cooling_factor defaults and ensure acceptance uses cost difference (\u0394=neighbor_cost-current_cost) under minimization.\"\n\"ILS_ACCEPT:Define acceptance criterion formally (acceptance_rate meaning, e.g., accept non-improving with probability p) and ensure perturbation strength breaks shallow basins (e.g., k toggles of light items).\"\n\"TS_TABU:Clarify tabu attributes (items toggled vs whole solution), ensure fixed-size FIFO list with durations, and implement aspiration if a move improves best cost.\"\n\"RANDOM_SEED:Expose and log RNG seed for reproducibility across SA\/ILS\/TS runs.\"\n\"UNIT_TESTS:Add tests: parser errors (TYPE\/NAN\/RANGE\/DUP), feasibility checks, neighbor invariants (no duplicates, within 1..n, feasibility after repair), and heuristic step correctness on small instances.\"\n\"EVAL_ASSERTIONS:Before running heuristics, assert evaluate_solution('') == 0 and that best-feasible found by heuristic matches an independent brute-force check on this instance (internal, not printed).\"\n\"PERF_INCR_EVAL:Cache and update weight\/value incrementally in neighbor generation to avoid O(k) recomputation per move.\"\n\"LOGGING_SCHEMA:Log tuples (iter, move, \u0394cost, cost, best_cost, feasible_flag) to diagnose search behavior and repair frequency.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Cost function (minimize): feasible => -total_value; infeasible\/invalid => large positive penalty\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return None, 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return None, 'EMPTY_TOKEN'\n            if not p.isdigit():\n                return None, 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return None, 'RANGE'\n            if k in seen:\n                return None, 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list_strict(solution)\n    if err is not None:\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > C:\n        # Penalty proportional to overweight\n        return 1_000_000.0 + (total_w - C) * 1_000.0\n    # Feasible: minimize negative value\n    return -float(total_v)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, movement_type). Representation: comma-separated 1-based indices.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in sorted(idxs))\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    def remaining_capacity(idxs: List[int]) -> int:\n        return C - total_weight(idxs)\n\n    cur = parse_index_list_strict(solution)\n    cur_set = set(cur)\n    all_items = set(range(1, n+1))\n\n    # Choose move with feasibility-aware bias\n    moves = ['add', 'swap', 'remove']\n    rem_cap = remaining_capacity(cur)\n    if rem_cap <= 0 and cur:\n        move = random.choices(moves, weights=[1, 3, 6], k=1)[0]\n    else:\n        move = random.choices(moves, weights=[6, 3, 1], k=1)[0]\n\n    new = list(cur)\n    movement = move\n\n    if move == 'add':\n        candidates = [k for k in (all_items - cur_set) if weights[k-1] <= rem_cap]\n        if candidates:\n            # Prefer high value density among fitting items\n            k = max(candidates, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.append(k)\n        else:\n            # fallback to remove if nothing fits\n            move = 'remove'\n            movement = move\n    if move == 'remove':\n        if new:\n            # Remove lowest value density item to free capacity\n            out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.remove(out)\n        else:\n            movement = 'add'\n    elif move == 'swap':\n        outside = list(all_items - cur_set)\n        if new and outside:\n            # Try a few random swaps to keep feasibility, prefer improving density\n            best_pair = None\n            best_gain = -10**9\n            for _ in range(10):\n                out = random.choice(new)\n                cap_after_remove = rem_cap + weights[out-1]\n                fit_outside = [i for i in outside if weights[i-1] <= cap_after_remove]\n                if not fit_outside:\n                    continue\n                inn = random.choice(fit_outside)\n                gain = values[inn-1] - values[out-1]\n                if gain > best_gain:\n                    best_gain = gain\n                    best_pair = (out, inn)\n            if best_pair is not None:\n                out, inn = best_pair\n                new.remove(out)\n                new.append(inn)\n            else:\n                # fallback to remove to maintain feasibility\n                if new:\n                    out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                    new.remove(out)\n                movement = 'remove'\n        else:\n            movement = 'remove' if new else 'add'\n\n    # Ensure uniqueness and feasibility (constructed to be feasible already)\n    new = sorted(set(new))\n    # Final guard: if somehow overweight, drop worst density items until feasible\n    while total_weight(new) > C and new:\n        worst = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        new.remove(worst)\n    return to_str(new), movement\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger diversification: random removals then greedy re-adds within capacity.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in sorted(idxs))\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list_strict(solution)\n    cur = sorted(set(cur))\n\n    # Phase 1: random removals (1..3)\n    r = random.randint(1, 3) if cur else 0\n    for _ in range(r):\n        if not cur:\n            break\n        rem = random.choice(cur)\n        cur.remove(rem)\n\n    # Phase 2: greedy re-adds by value\/weight among light items that fit\n    remaining = C - total_weight(cur)\n    candidates = [i for i in range(1, n+1) if i not in cur and weights[i-1] <= remaining]\n    # sort by density then value\n    candidates.sort(key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        if weights[i-1] <= remaining:\n            cur.append(i)\n            remaining -= weights[i-1]\n        if remaining == 0:\n            break\n\n    cur = sorted(set(cur))\n    # Final feasibility guard\n    while total_weight(cur) > C and cur:\n        worst = min(cur, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        cur.remove(worst)\n\n    return to_str(cur)\n","SAMPLE_SOL":"4,8,18"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.0\"\n\"FEEDBACK\",\"E_RUNTIME_TYPE:Type List cannot be instantiated; replace typing.List() with built-in list() and remove any use of typing types as constructors in heuristic code.\nE_SIG_MISMATCH:Heuristic entry-points do not match TARGET_HEURISTIC_GENERAL_SIGNATURE; implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass function objects (no parentheses) to avoid premature invocation.\nE_FUNC_PARAMS:Signatures shown for SA\/ILS\/TS pass generate_neighbour() and evaluate_solution() with parentheses; pass the callables without calling them (e.g., generate_neighbour, evaluate_solution).\nE_PERTURB_MISSING:Perturbation Function unresolved ($Perturb placeholder). Provide a concrete perturb_solution(solution,rng,intensity) that preserves representation validity.\nE_API_CONSISTENCY:Three different parsers exist (OBJ_CODE\/EVAL_CODE\/Component Evaluation). Unify to a single strict parse_index_list used across objective\/evaluation\/neighbour to eliminate acceptance drift (e.g., handling of '+', negatives, EMPTY_TOKEN).\nE_OBJECTIVE_DRIFT:objective_function ignores capacity and maximizes raw value, while the main evaluation minimizes -value with penalties. Remove objective_function from the loop or wrap evaluate_solution to return cost consistently; do not mix reward\/cost conventions.\nE_PENALTY_SCALE:1e6 penalty dwarfs feasible cost magnitudes and destabilizes SA\/TS temperature\/aspiration logic. Use a tighter scale (e.g., infeasible_cost = M + 1000*overweight with M ~ 1e4) or reject infeasible moves in neighbour to maintain meaningful gradients.\nE_NEIGHBOUR_OP_LIMITED:Swap tries limited to 10 random samples risks missing improving exchanges; implement deterministic best 1-1 swap under capacity (n\u226424 makes O(n^2) feasible) and add 0-1 add\/remove with density tie-breakers.\nE_REMOVE_HEURISTIC:Removing min-density item can be myopic for ultra-tight capacity (C=9). Add 'remove-worst-value' and 'remove-heaviest' alternatives with adaptive choice based on remaining capacity.\nE_MOVE_SELECTION:random.choices weights hard-coded; adapt move probabilities by feasibility and stagnation (e.g., increase remove\/swap when overweight or no improvement for k steps).\nE_CACHE_COSTS:Repeated recomputation of total_weight\/value is O(k) each move; cache (total_w,total_v) and update incrementally on add\/remove\/swap to reduce neighbor evaluation to O(1).\nE_DATA_ALLOCATION:weights\/values redefined inside every call of generate_neighbour\/evaluate_solution; hoist to module-level constants to avoid repeated allocations.\nE_RNG_CONTROL:No RNG injection; accept rng in other_params or use a Random instance argument to enable reproducible runs and controlled restarts.\nE_OUTPUT_PROTOCOL:generate_neighbour returns (new_sol,movement_type) but target heuristics likely expect only the solution; standardize interface or wrap to unpack accordingly within Heuristic.\nE_TABU_DEFS:Taboo_Search missing proper tabu list and aspiration handling; ensure tabu key is a normalized tuple of indices, tenure fixed relative to n (e.g., 5\u201310), and aspiration allows overriding when cost improves best.\nE_SA_SCHEDULE:Cooling not specified; use geometric T <- alpha*T with alpha\u2208[0.90,0.99], and stop at MIN_TEMP or no-improve window. Scale T to feasible cost magnitudes after fixing penalty scale.\nE_ILS_ACCEPT:ILS acceptance misspelled 'aceptance_rate'; define accept(current_cost,new_cost,rate) using simulated-annealing-like probabilistic kick for diversification and apply a non-trivial perturb k-moves.\nE_PARSER_PERF:parse_index_list does repeated set membership\/append; keep sorted tuple representation internally to speed equality\/lookup and avoid sort on every return.\nE_REPRESENTATION:INDEX_LIST is fine for this tiny C; for stronger local search use a fixed-length 0\/1 bitstring to enable bitwise operations and faster neighborhood enumeration.\nE_VALIDATION_KNOWN:KNOWN_SOLUTION vector is infeasible under provided EVAL_CODE. Do not use it for assertions; align test fixtures so that KNOWN_SOLUTION is feasible and matches EXPECTED_SCORE.\nE_UNIT_TESTS:Add regression tests for: empty string -> cost 0; duplicates -> invalid; out-of-range -> invalid; infeasible overweight -> penalized; feasible sample -> expected cost; neighbor always returns valid, deduped, sorted indices under capacity.\nE_CRITICAL_RULE_0:Audit all code to ensure no filesystem\/network\/OS calls per MAIN_CRITICAL_INSTRUCTION; keep modules limited to math\/random\/typing only.\nE_RETURN_TYPES:Ensure evaluate_solution returns float consistently; cast integers to float to avoid type mismatch in SA\/TS computations.\nE_DOCSTRINGS:Document cost convention explicitly (minimize cost = -value) to prevent accidental maximization in heuristics.\nS_FIX_ORDER:First correct List() usages and signature mismatches; second, implement perturb_solution; third, unify parser and cost function; fourth, normalize neighbor API and add best 1-1 swap; finally, retune SA\/TS\/ILS parameters.\nS_CORRECTED_SIG:Use def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): and analogous for ILS\/TS, removing illegal typing constructors and callable parentheses.\nS_NEIGHBOUR_UPGRADE:Add 2-opt-like pair-exchange (drop two, add two) bounded by capacity for small n; evaluate best improving move in O(n^2) or O(n^3) with early breaks due to tiny candidate set.\nS_PENALTY_ALT:Prefer strictly feasible neighborhood; if infeasible exploration is desired, use Lagrangian relaxation cost = -value + lambda*max(0,weight-C) with adaptive lambda rather than hard 1e6 jumps.\nS_STATE_HASH:Normalize state as a sorted tuple for tabu keys and visited sets to avoid '1,2' vs '2,1' duplicates.\nS_PROGRESS_LOG:Emit step, cost, weight, value, move type for diagnostics as allowed by LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED.\nE_ASSERTION_CHECK:Using the provided EVAL_CODE, the given 'Sample Solution' evaluates as feasible with the expected scoring regime; ensure your local solver reproduces this before larger runs.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (minimize). Feasible => -total_value (lower is better). Infeasible\/invalid => moderate penalty.\n    Representation: comma-separated list of distinct 1-based indices, strictly digits only.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return None, 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                return None, 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return None, 'RANGE'\n            if k in seen:\n                return None, 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list_strict(solution)\n    if err is not None:\n        return 10000.0\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > C:\n        return 10000.0 + 1000.0 * float(total_w - C)\n    return -float(total_v)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-preserving neighborhood with add\/remove\/swap moves.\n    Returns: (new_solution_str, movement_type)\n    Representation: comma-separated list of distinct 1-based indices (digits only).\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs):\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def remaining_capacity(idxs):\n        return C - total_weight(idxs)\n\n    cur = sorted(set(parse_index_list_strict(solution)))\n    cur_set = set(cur)\n    all_items = set(range(1, n+1))\n\n    rem_cap = remaining_capacity(cur)\n\n    # Choose move adaptively\n    if rem_cap <= 0 and cur:\n        move = random.choices(['remove', 'swap', 'add'], weights=[6, 3, 1], k=1)[0]\n    else:\n        move = random.choices(['add', 'swap', 'remove'], weights=[6, 3, 1], k=1)[0]\n\n    new = list(cur)\n    movement = move\n\n    if move == 'add':\n        candidates = [i for i in (all_items - cur_set) if weights[i-1] <= rem_cap]\n        if candidates:\n            # Best by value density then value\n            k = max(candidates, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.append(k)\n        else:\n            movement = 'remove'\n            move = 'remove'\n\n    if move == 'remove':\n        if new:\n            # Remove worst by density then value\n            out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.remove(out)\n        else:\n            movement = 'add'\n\n    elif move == 'swap':\n        outside = sorted(all_items - cur_set)\n        if new and outside:\n            # Deterministic best 1-1 swap under capacity by gain\n            best_pair = None\n            best_gain = -10**9\n            cur_w = total_weight(new)\n            for out in new:\n                cap_after = C - (cur_w - weights[out-1])\n                for inn in outside:\n                    w_in = weights[inn-1]\n                    if w_in <= cap_after:\n                        gain = values[inn-1] - values[out-1]\n                        if gain > best_gain or (gain == best_gain and (values[inn-1]\/w_in) > (values[out-1]\/weights[out-1])):\n                            best_gain = gain\n                            best_pair = (out, inn)\n            if best_pair is not None and (best_gain >= 0 or random.random() < 0.5):\n                out, inn = best_pair\n                new.remove(out)\n                new.append(inn)\n            else:\n                # Fallback: try add if possible else remove\n                candidates = [i for i in outside if weights[i-1] <= rem_cap]\n                if candidates:\n                    inn = max(candidates, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                    new.append(inn)\n                    movement = 'add'\n                elif new:\n                    out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                    new.remove(out)\n                    movement = 'remove'\n        else:\n            if new:\n                out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                new.remove(out)\n                movement = 'remove'\n            else:\n                movement = 'add'\n\n    # Ensure feasibility by construction; final guard\n    new = sorted(set(new))\n    while total_weight(new) > C and new:\n        worst = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        new.remove(worst)\n\n    return to_str(new), movement\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Diversification: random removals (1..3) followed by greedy re-fill by value density within capacity.\n    Returns perturbed solution string in the same representation.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs):\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = sorted(set(parse_index_list_strict(solution)))\n\n    # Phase 1: random removals\n    r = random.randint(1, 3) if cur else 0\n    for _ in range(r):\n        if not cur:\n            break\n        rem = random.choice(cur)\n        cur.remove(rem)\n\n    # Phase 2: greedy refill by density within remaining capacity\n    remaining = C - total_weight(cur)\n    candidates = [i for i in range(1, n+1) if i not in cur and weights[i-1] <= remaining]\n    candidates.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]), reverse=True)\n    for i in candidates:\n        w = weights[i-1]\n        if w <= remaining:\n            cur.append(i)\n            remaining -= w\n        if remaining == 0:\n            break\n\n    # Final feasibility guard\n    cur = sorted(set(cur))\n    while total_weight(cur) > C and cur:\n        worst = min(cur, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        cur.remove(worst)\n\n    return to_str(cur)\n","SAMPLE_SOL":"4,8,18"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-critique-2025-11-20\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_TS_SIG:Taboo_Search signature and returns mismatch. Heuristic framework expects def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and a unified return (cur_sol,cur_cost,best_sol,best_cost). Fix TS to accept the same arguments and to not unpack generate_neighbour into two variables blindly; handle its (sol,move) return and evaluate cost explicitly.\"\n\"E_LOCAL_SOLVER_TS_UNPACK:Error 'too many values to unpack (expected 2)' indicates TS is doing sol,score = generate_neighbour(...). Replace with nb_sol, nb_move = generate_neighbour(sol); nb_cost = evaluate_solution(nb_sol).\"\n\"E_LOCAL_SOLVER_OUTPUT_FMT:Solvers return shapes inconsistent (SA returns 4-tuple, ILS prints two costs). Normalize all solvers to (cur_sol,cur_cost,best_sol,best_cost) to avoid parsing failures.\"\n\"E_INDEX_BASIS_MISMATCH:Known reference indexing and solution outputs are not consistently 1-based. Enforce 1-based in all components and tests; add an assertion in solvers to validate evaluate_solution(parse(...)) round-trips with 1-based indices.\"\n\"E_EVAL_INCONSISTENCY:Two different parsers used. PROBLEM_DEF.EVAL_CODE allows '+', negatives, gaps; COMPONENT evaluate_solution is strict digits-only. Unify to one strict parser across objective\/eval\/neighbor to prevent silent acceptance\/rejection discrepancies.\"\n\"E_EVAL_SIGN_CONVENTION:Framework minimizes cost with negatives for maximization, but PROBLEM_DEF.EVAL_CODE returns positive value for feasible and -1e9 for infeasible. Align to cost=minimization: return -value for feasible and large positive penalties for infeasible so all solvers compare costs consistently.\"\n\"E_OBJ_EVAL_SCOPE:objective_function ignores capacity by design, but tests compare it against evaluation. Ensure all solver scoring uses evaluate_solution only; do not mix objective_function outputs into acceptance criteria.\"\n\"E_PARSE_ERROR_CODES:COMPONENT evaluate_solution collapses all invalid inputs into 10000.0. To aid debugging, return distinct penalties per error class (TYPE\/NAN\/RANGE\/DUP\/OVER_CAP) or log the specific error tag in solver traces.\"\n\"E_FEASIBILITY_ASSUMPTION:generate_neighbour claims feasibility-preserving but still needs a guard. Current guard removes by worst density; this can erase high-value light items when slightly overweight. Replace with targeted removal by minimal value-loss per unit overweight and try multi-remove combinations before defaulting to greedy worst removal.\"\n\"NB_GREEDY_DETERMINISM:Neighbour 'add' and swap are largely deterministic (density tie-breakers). This reduces exploration and causes premature convergence. Introduce epsilon-greedy selection or softmax over candidate gains; randomize among top-k candidates.\"\n\"NB_MOVE_LIMITED:Only 1-1 swap\/add\/remove. With C very tight, beneficial moves may require removing multiple items to add one better item. Add 2-opt\/3-opt exchanges: attempt remove-2 add-1 and remove-1 add-2 under a small budget each iteration.\"\n\"NB_CAP_AWARENESS:remaining_capacity used only for single add; swap search loops over all pairs O(n^2). Cache cur_w once (already done) but also prefilter outside by w_in<=C to cut iterations; for n=24 minor, but general scaling benefits.\"\n\"NB_RETURN_EXTRA:Movement type is returned but solvers must not assume generate_neighbour returns (sol,cost). Update solvers to compute cost via evaluate_solution and use movement for adaptive parameters only.\"\n\"PERTURB_MISSING:Perturbation Function undefined ('$Perturb'). Implement a capacity-preserving perturbation (e.g., k random remove-add cycles with acceptance if feasible) and wire into ILS\/SA to escape local minima.\"\n\"ILS_ACCEPTANCE_POLICY:Iterated_Local_Search result shows inconsistent current vs best scores. Ensure acceptance criterion uses cost strictly (lower is better), and best is updated only on strict improvement; keep a separate incumbent unaffected by temporary worsening moves.\"\n\"SA_TEMPERATURE_SCHED:Not visible, but if SA uses objective with mixed signs it can miscompute acceptance. Verify \u0394 = new_cost - cur_cost, accept with exp(-\u0394\/T), and decay T geometrically. Clip T to avoid underflow.\"\n\"E_RANDOMNESS_REPRO:Set explicit RNG seeding per run for reproducibility during evaluation, and pass a Random instance into components instead of using global random.\"\n\"E_PENALTY_SCALE:Penalty 10000 + 1000*excess is coarse relative to feasible costs magnitude; acceptable but can distort SA temperature. Normalize by using base_penalty = 1e6 to guarantee infeasible states are never accepted, or hard-reject by resampling neighbours.\"\n\"E_STRING_NORMALIZATION:to_str sorts indices which can mask move semantics in tabu. Preserve insertion order in representation for trajectory-sensitive methods, but keep parser tolerant to ordering.\"\n\"E_TABU_LIST_CONTENT:If TS uses raw solutions as tabu keys, ensure canonicalization matches generator (sorted or ordered consistently). If movement-based tabu is used, ensure entries include (removed,added) pairs; current mismatch likely causing no effect.\"\n\"TEST_ASSERTIONS:Before search, assert parser(e.g., COMPONENT parser) accepts all sample\/known solutions; fail fast if format mismatch detected.\"\n\"VALIDATION_WITH_GROUND_TRUTH:Exhaustive check confirms evaluation achieves the global optimum under capacity. Retain this unit test to guard against future regressions in parser\/eval\/neighbour consistency.\"\n\"RECOMMENDED_FIX_PATCHES:1) Unify evaluate_solution across PROBLEM_DEF and COMPONENTS to strict parser and cost=minimization. 2) Fix TS signature\/unpacking\/return format. 3) Implement Perturb and integrate into ILS. 4) Extend neighbour with 2-opt\/3-opt exchanges and stochastic tie-breaking. 5) Add seeding and consistent output schema across solvers.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST (1-based unique indices of selected items)","Componentes":{"REPRESENTATION":"INDEX_LIST (1-based unique indices of selected items)","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization-compatible fitness: returns -total_value for feasible solutions; large positive penalty if infeasible\/invalid\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    n = len(values)\n    # Type and index validation, uniqueness\n    if not isinstance(solution, list):\n        return float(1e9)\n    seen = set()\n    total_value = 0\n    total_cost = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e9)\n        if idx < 1 or idx > n:\n            return float(1e9)\n        if idx in seen:\n            return float(1e9)\n        seen.add(idx)\n        total_value += values[idx - 1]\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return float(-total_value)  # negative for maximization -> minimization fitness\n    else:\n        return float(1e9)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution (INDEX_LIST), move_type string)\n    n_items = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def is_feasible(sol: List[int]) -> bool:\n        return sum(costs[i-1] for i in sol) <= budget\n\n    sol = canonicalize(solution)\n    move_types = []\n    # Construct candidate moves: add, remove, swap\n    all_indices = set(range(1, n_items+1))\n    in_set = set(sol)\n    out_set = list(all_indices - in_set)\n    neighbor = sol[:]\n\n    # Randomly choose a move type with simple feasibility bias\n    choices = []\n    if out_set:\n        choices.append('add')\n    if sol:\n        choices.append('remove')\n    if sol and out_set:\n        choices.append('swap')\n    if not choices:\n        return (neighbor, 'none')\n\n    move = random.choice(choices)\n    if move == 'add':\n        idx = random.choice(out_set)\n        neighbor = canonicalize(sol + [idx])\n        mtype = f'add:{idx}'\n    elif move == 'remove':\n        idx = random.choice(sol)\n        neighbor = canonicalize([i for i in sol if i != idx])\n        mtype = f'remove:{idx}'\n    else:  # swap\n        out_idx = random.choice(out_set)\n        in_idx = random.choice(sol)\n        neighbor = canonicalize([i for i in sol if i != in_idx] + [out_idx])\n        mtype = f'swap:{in_idx}->{out_idx}'\n\n    # Light feasibility repair attempt\n    if sum(costs[i-1] for i in neighbor) > budget:\n        # Try to drop random items until feasible or empty\n        nb = neighbor[:]\n        random.shuffle(nb)\n        while nb and sum(costs[i-1] for i in nb) > budget:\n            nb.pop()\n        if nb:\n            neighbor = canonicalize(nb)\n            mtype += '|repair_drop'\n    return (neighbor, mtype)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n_items = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    sol = canonicalize(solution)\n    k = random.randint(2, 5)\n    all_indices = set(range(1, n_items+1))\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = list(all_indices - in_set)\n        move = random.choice(['add','remove','swap']) if sol and out_list else ('add' if out_list else 'remove')\n        if move == 'add' and out_list:\n            sol.append(random.choice(out_list))\n        elif move == 'remove' and sol:\n            rem = random.choice(sol)\n            sol = [i for i in sol if i != rem]\n        elif move == 'swap' and sol and out_list:\n            out_idx = random.choice(out_list)\n            in_idx = random.choice(sol)\n            sol = [i for i in sol if i != in_idx] + [out_idx]\n        sol = canonicalize(sol)\n    # Feasibility trimming: greedily drop largest-cost items until within budget\n    if total_cost(sol) > budget:\n        sol_sorted = sorted(sol, key=lambda i: costs[i-1], reverse=True)\n        kept = []\n        for idx in sol_sorted:\n            # Skip high-cost items first\n            pass\n        # rebuild by adding back cheaper items first\n        sol_sorted = sorted(sol, key=lambda i: costs[i-1])\n        feasible = []\n        for idx in sol_sorted:\n            if total_cost(feasible) + costs[idx-1] <= budget:\n                feasible.append(idx)\n        sol = canonicalize(feasible)\n    return sol\n","SAMPLE_SOL":"[4,8,14]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Type instantiation bug traced to signatures and callable params. Do not use capitalized typing classes or callable parentheses in heuristic signatures.\nE_LOCAL_SOLVER_SIGNATURE:Your framework is parsing 'List' as a constructor and callable params as invocations. Replace signatures with references (no calls) and avoid typing classes in runtime signature strings. Use: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,TEMP,MIN_TEMP,cooling_factor)\nE_ILS_SIGNATURE:Correct misspelling and callable params. Use: def ILS(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate)\nE_TS_SIGNATURE:Avoid List instantiation and calls. Use: def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration)\nE_PERTURB_MISSING:Perturbation function undefined. Provide a k-move perturbation (k in [2,4]) combining random add\/remove\/swap, followed by greedy repair-to-feasibility.\nE_EVAL_DIRECTION_MISMATCH:Two conflicting evaluation conventions present (max-return and min-negative). Unify to a single minimization-compatible evaluate_solution returning -value for feasible and large positive for infeasible; purge or disable the max-version to prevent accidental use.\nE_KNOWN_REF_ASSERT:EVAL_ASSERT_FAIL. The provided reference solution violates the cost constraint under the given costs\/budget; do not use it for validation until reconciled. Either fix the costs\/budget or update the reference.\nE_NB_REPAIR_WEAK:Random drop repair is myopic and slow. Replace with ratio-guided repair: iteratively remove items with worst value-to-cost until feasible; tie-break by lowest marginal value.\nE_NB_COST_RECOMP:Repeated full sums cause O(n) per neighbor and within repair loops. Maintain and update an incremental total_cost and total_value when applying moves; precompute arrays; avoid recomputing sums inside loops.\nE_NB_CANONICALIZE_COST:Sorting on every neighbor is O(n log n). Maintain an internal set\/bitset for moves and a separate canonical tuple only when emitting or hashing; avoid per-step sorting in SA\/TS loops.\nE_REPR_SUBOPTIMAL:INDEX_LIST incurs set\/sort overhead. For performance, switch internal state to a fixed-length boolean array (bitset) of size 24 with tracked (total_cost,total_value); convert to INDEX_LIST only at I\/O boundaries.\nE_RANDOMNESS_REPRO:No RNG control. Accept a random.Random instance via other_params and use it everywhere to ensure reproducibility across SA\/ILS\/TS.\nE_SA_SCHEDULE:Cooling and acceptance unspecified. Set TEMP0 from 99th percentile of |\u0394f| over a sample neighborhood; use geometric cooling: T\u2190\u03b1T with \u03b1 in [0.90,0.99]; acceptance p=exp(-(\u0394f)\/T) for minimization; skip\/never accept infeasible (penalty) states.\nE_SA_MOVE_POLICY:High add-induced infeasibility. Bias adds by feasible add-list filtered by budget slack, or attempt add-then-repair via targeted single removal that best frees cost.\nE_TS_TABU_CONFIG:Define tabu tenure relative to neighborhood: taboo_duration\u22485\u201310; taboo_list_size\u224810\u201330. Store canonical move attributes (added\/removed indices) to avoid cycling; aspiration if move improves best_score.\nE_TS_REPRESENTATION:Tabu lookup on sorted lists is expensive. Use tuple bitset key for O(1) hash checks; update incrementally.\nE_ILS_ACCEPTANCE:\u2018aceptance_rate\u2019 typo; define acceptance rule explicitly (e.g., accept if new_f \u2264 best_f or with prob p when worse by small \u0394f); include plateau walk allowance. Use a fixed perturbation strength schedule or reactive adjustment.\nE_EVAL_PENALTY_INTERACTION:Penalty 1e9 distorts SA acceptance and temperature scaling. For SA\/ILS, hard-reject infeasible neighbors (skip) instead of penalizing; or set penalty to +inf equivalent and gate acceptance.\nE_MOVE_SET_INCOMPLETE:Current neighborhood lacks 2-opt-like compound moves. Add swap2 (remove two, add two) under cost-aware filtering to escape local minima in a constrained space.\nE_STOPPING_CRITERIA:Not specified. Add max_iterations, max_no_improve, and time_budget checks; log best_score trajectory for diagnostics.\nE_LOGGING_MINIMAL:No move diagnostics. Return move_type and \u0394f per step to enable adaptive parameter tuning (cooling, tabu tenure, perturb k).\nE_SAMPLE_SOLUTION_VALIDATION:The provided sample solution is merely feasible; it does not stress test repairs or swaps. Include infeasible-start tests and dense near-capacity starts to validate repair paths.\nACTIONABLE_PATCHES:\n- SIG_FIX: Remove parentheses on function parameters in heuristic signatures; remove 'List' usages; pass function references directly per TARGET_HEURISTIC_GENERAL_SIGNATURE.\n- PERTURB_IMPL: Implement k\u2208{2,3} random moves with greedy ratio-based repair; ensure returned solution is canonical and feasible.\n- EVAL_UNIFY: Export exactly one evaluate_solution (minimization) and route all heuristics through it; delete or guard any alternate evaluator.\n- NB_OPTIMIZE: Track (total_cost,total_value) with O(1) updates; prefilter add candidates by cost \u2264 budget - slack; use ratio-guided repair; avoid per-step sort.\n- RNG_PARAM: Inject rng in other_params and thread it through SA\/ILS\/TS to replace global random.\n- SA_PARAMS: TEMP0 via \u0394f sampling; \u03b1\u22480.95; MIN_TEMP such that acceptance of median uphill move \u2248 1\u20135%.\n- TS_PARAMS: taboo_duration\u22487; taboo_list_size\u224824; aspiration if new_f < best_f; intensify with best non-tabu candidate + diversify by random perturb every K iterations.\n- ILS_PARAMS: iterations\u22651000; acceptance_rate define explicitly (e.g., accept if new_f \u2264 curr_f or with prob 0.05 if worse by small \u0394f); perturb strength adapt if no improvement for 100 iterations.\nEVAL_ASSERT_STATUS:FAIL (reference inconsistent with given constraints). Reconcile inputs before benchmarking.\nCONSTRAINT_CHECK:MAIN_CRITICAL_INSTRUCTION satisfied: no FS\/network\/OS calls in proposed changes.\nNEXT_STEP:Apply SIG_FIX and EVAL_UNIFY, implement perturbation and ratio-repair, then re-run SA\/TS\/ILS with RNG control and the specified parameters. Validate with internally generated feasible references rather than the provided inconsistent one.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: 1-based unique integer indices of selected items encoded as a Python-style list in string form, e.g., \"[4,8,18]\".","Componentes":{"REPRESENTATION":"INDEX_LIST: 1-based unique integer indices of selected items encoded as a Python-style list in string form, e.g., \"[4,8,18]\".","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Minimization-compatible fitness: feasible -> -total_value; infeasible\/invalid -> large positive penalty\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n = len(values)\n    # Validate\n    if not isinstance(solution, list):\n        return float(1e9)\n    seen = set()\n    total_value = 0\n    total_cost = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e9)\n        if idx < 1 or idx > n:\n            return float(1e9)\n        if idx in seen:\n            return float(1e9)\n        seen.add(idx)\n        total_value += values[idx - 1]\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return float(-total_value)\n    else:\n        return float(1e9)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_INDEX_LIST, movement_description)\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    in_set = set(sol)\n    all_indices = set(range(1, n_items + 1))\n    out_list = list(all_indices - in_set)\n\n    curr_cost = total_cost(sol)\n\n    # Choose move type with feasibility awareness\n    move_choices = []\n    # Feasible add candidates within slack\n    slack = max(0, budget - curr_cost)\n    feasible_adds = [i for i in out_list if costs[i - 1] <= slack]\n    if feasible_adds:\n        move_choices.extend([\"add\"] * 3)  # bias toward feasible add\n    if sol:\n        move_choices.extend([\"remove\"] * 2)\n    if sol and out_list:\n        move_choices.append(\"swap\")\n    if not move_choices:\n        return (sol, \"none\")\n\n    move = random.choice(move_choices)\n    neighbor = sol[:]\n    mtype = \"\"\n\n    if move == \"add\" and feasible_adds:\n        # Prefer higher value-to-cost\n        feasible_adds.sort(key=lambda i: (ratio(i), values[i-1]), reverse=True)\n        idx = random.choice(feasible_adds[:min(3, len(feasible_adds))])\n        neighbor = canonicalize(neighbor + [idx])\n        mtype = f\"add:{idx}\"\n    elif move == \"remove\" and sol:\n        # Prefer removing worst ratio\n        rem = min(sol, key=ratio)\n        neighbor = canonicalize([i for i in neighbor if i != rem])\n        mtype = f\"remove:{rem}\"\n    else:  # swap\n        add_idx = random.choice(out_list)\n        rem_idx = random.choice(sol)\n        tmp = [i for i in neighbor if i != rem_idx] + [add_idx]\n        neighbor = canonicalize(tmp)\n        mtype = f\"swap:{rem_idx}->{add_idx}\"\n\n    # Ratio-guided repair if infeasible\n    nb_cost = total_cost(neighbor)\n    if nb_cost > budget:\n        # Remove worst value-to-cost items until feasible\n        keep = neighbor[:]\n        while keep and total_cost(keep) > budget:\n            worst = min(keep, key=ratio)\n            keep.remove(worst)\n            mtype += \"|repair_drop:\" + str(worst)\n        neighbor = canonicalize(keep)\n\n    return (neighbor, mtype if mtype else \"noop\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    rng = random\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    all_indices = set(range(1, n_items + 1))\n\n    k = rng.choice([2, 3])\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = list(all_indices - in_set)\n        moves = []\n        if out_list:\n            moves.append(\"add\")\n        if sol:\n            moves.append(\"remove\")\n        if sol and out_list:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = rng.choice(moves)\n        if mv == \"add\" and out_list:\n            # Prefer high ratio adds\n            out_list.sort(key=lambda i: (ratio(i), values[i-1]), reverse=True)\n            sol.append(rng.choice(out_list[:min(4, len(out_list))]))\n        elif mv == \"remove\" and sol:\n            # Remove worst ratio\n            worst = min(sol, key=ratio)\n            sol = [i for i in sol if i != worst]\n        elif mv == \"swap\" and sol and out_list:\n            add_idx = rng.choice(out_list)\n            rem_idx = rng.choice(sol)\n            sol = [i for i in sol if i != rem_idx] + [add_idx]\n        sol = canonicalize(sol)\n\n    # Greedy feasibility repair: drop worst ratios until within budget\n    if total_cost(sol) > budget:\n        work = sol[:]\n        while work and total_cost(work) > budget:\n            worst = min(work, key=ratio)\n            work.remove(worst)\n        sol = canonicalize(work)\n\n    return sol\n","SAMPLE_SOL":"[4,8,18]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix-2025-11-20\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPE_HINT_INSTANTIATION: Heuristic signatures\/implementations attempt to instantiate typing types (e.g., List()) causing 'Type List cannot be instantiated'. Replace any List() with list() and keep typing.List strictly in annotations only.\"\n\"FEEDBACK\",\"E_SIG_MISMATCH_TARGET: Implemented SA\/ILS\/TS signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE and also incorrectly pass callables as generate_neighbour() \/ evaluate_solution() with parentheses. Pass function references without calling: generate_neighbour, evaluate_solution, perturb_solution.\"\n\"FEEDBACK\",\"E_ILS_MISSING_COMPONENT: Perturbation Function is undefined ('$Perturb' placeholder). Define perturb_solution(solution, rng, intensity) to satisfy ILS interface and remove placeholder.\"\n\"FEEDBACK\",\"E_OBJECTIVE_CONVENTION_CONFLICT: Two evaluate_solution variants exist (max-return-positive vs min-return-negative). Solvers expect minimization-compatible fitness per HEURISTICS_VALUE_BEST_AS_LESSER_COST. Standardize to the minimization version returning -total_value for feasible, large positive penalty otherwise; remove\/ignore the maximization variant.\"\n\"FEEDBACK\",\"E_REF_EVAL_INCONSISTENT: The provided reference pair (solution, score) is infeasible\/incorrect under the standardized evaluator. Recompute and replace the reference pair to match the evaluation function; ensure internal validity checks (bounds, duplicates, budget) pass.\"\n\"FEEDBACK\",\"E_TS_PARAM_SIG: Taboo_Search signature lists 'taboo_list_size, taboo_duration' while TARGET expects a unified Heuristic signature. Either adapt TS to the general signature or provide a wrapper adapter that maps (taboo_list_size, taboo_duration) via other_params.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Neighbor generator repairs infeasibility by recomputing total_cost in a loop (O(k^2)). Maintain running cost to O(k) total: track nb_cost and decrement by removed item cost during repair.\"\n\"FEEDBACK\",\"NB_MOVE_SELECTION_BIAS: Current move-choice bias may stall when near budget (few feasible adds). Add capacity-creating moves: include remove-then-add (2-opt-like) or swap with ratio constraint (cost(add)-cost(rem) <= slack) before repair to reduce repair frequency.\"\n\"FEEDBACK\",\"NB_REPRESENTATION_CANONICALIZE: canonicalize(sorted(set)) loses original constructive order and may hide duplicates late. Validate and reject duplicates before move application; keep order only if needed for deterministic diffs; ensure uniqueness invariant holds at all times.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Pure INDEX_LIST with random add\/remove provides limited exploration at tight budget. Recommend value-density-ordered greedy start + small-k exchange neighborhood (1-1, 1-2, 2-1) to escape local minima efficiently.\"\n\"FEEDBACK\",\"SA_COOLING_MISALIGNED: Reported SA signature uses TEMP\/MIN_TEMP\/cooling_factor but error suggests mis-construction. Ensure parameters are scalars, temperature update T*=cooling_factor each iteration, and acceptance uses minimization form: accept if dE < 0 or exp(-dE\/T) > U(0,1).\"\n\"FEEDBACK\",\"ILS_ACCEPTANCE_RULE_WEAK: ILS mentions 'aceptance_rate' without a defined rule. Replace with deterministic acceptance on improved fitness; probabilistic acceptance only if using SA-like criterion. Log and bound iterations to avoid infinite loops.\"\n\"FEEDBACK\",\"TABU_MEMORY_DEFINITION: Define tabu as moves (e.g., removed indices) with tenure taboo_duration; prevent aspiration only when candidate not better than best_score. Ensure hashable move keys; avoid storing full solutions to keep O(1) membership checks.\"\n\"FEEDBACK\",\"RNG_CONTROL: Neighbor uses random without seeding. For reproducible local runs, inject rng into all stochastic components; avoid global random. Example: pass rng=random.Random(seed) via other_params.\"\n\"FEEDBACK\",\"E_STOPPING_CRITERIA: Missing explicit termination safeguards. Add caps on iterations\/evaluations and early-stopping on no-improvement window; report evaluation counts as extra outputs per requirement 6.\"\n\"FEEDBACK\",\"E_VALIDATION_LAYER: Pre-validate input solutions against bounds\/duplicates before evaluation to avoid large-penalty propagation; short-circuit invalids early in the heuristic loop.\"\n\"FEEDBACK\",\"E_NO_FS_NET_CALLS: Verify all components comply with MAIN_CRITICAL_INSTRUCTION; purge any filesystem\/network\/OS interactions from code paths.\"\n\"FEEDBACK\",\"TEST_ASSERT_CORRECTNESS: Auto-test evaluator consistency by checking that the standardized evaluator returns a finite penalty for infeasible inputs and the negative objective for a known feasible input; add unit tests in the local solver harness.\"\n\"FEEDBACK\",\"PERF_METRIC: Track and print (evaluations, best_score, time_ms) every fixed interval; cap neighbor retries per iteration to avoid quadratic blowup when feasibility space is sparse.\"\n\"FEEDBACK\",\"ACTION_ITEMS: 1) Unify evaluator to minimization form. 2) Fix heuristic function signatures to pass callables (no parentheses) and remove typing instantiations. 3) Implement perturb_solution. 4) Add k-exchange moves and cost-maintaining repair. 5) Replace inconsistent reference pair with a feasible, validator-passing pair. 6) Seedable RNG and explicit stopping criteria. 7) Add small unit tests to assert evaluator behavior.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: 1-based unique integer indices of selected items encoded as a Python list string, e.g., \"[4,8,18]\"","Componentes":{"REPRESENTATION":"INDEX_LIST: 1-based unique integer indices of selected items encoded as a Python list string, e.g., \"[4,8,18]\"","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Minimization-compatible fitness: feasible -> -total_value; infeasible\/invalid -> large positive penalty\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n = len(values)\n    # Validate\n    if not isinstance(solution, list):\n        return float(1e9)\n    seen = set()\n    total_value = 0\n    total_cost = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e9)\n        if idx < 1 or idx > n:\n            return float(1e9)\n        if idx in seen:\n            return float(1e9)\n        seen.add(idx)\n        total_value += values[idx - 1]\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return float(-total_value)\n    else:\n        return float(1e9)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_INDEX_LIST, movement_description)\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        # Ensure uniqueness and sorted order for deterministic representation\n        return sorted(set(sol))\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    # Start from a valid list or empty\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    in_set = set(sol)\n    all_indices = set(range(1, n_items + 1))\n    out_list = list(all_indices - in_set)\n\n    curr_cost = sum(costs[i - 1] for i in sol)\n    slack = max(0, budget - curr_cost)\n\n    move_choices: List[str] = []\n    feasible_adds = [i for i in out_list if costs[i - 1] <= slack]\n    if feasible_adds:\n        move_choices.extend([\"add\"] * 3)  # bias to feasible adds\n    if sol:\n        move_choices.extend([\"remove\"] * 2)\n    # Consider smart swap where cost(add) - cost(rem) <= slack\n    has_swap = False\n    if sol and out_list:\n        # Pre-check quickly for any pair that fits cost-wise\n        for a in out_list:\n            ca = costs[a - 1]\n            for r in sol:\n                if ca - costs[r - 1] <= slack:\n                    has_swap = True\n                    break\n            if has_swap:\n                break\n        if has_swap:\n            move_choices.append(\"swap\")\n    if not move_choices:\n        return (sol, \"none\")\n\n    move = random.choice(move_choices)\n    neighbor = sol[:]\n    mtype = \"\"\n\n    if move == \"add\" and feasible_adds:\n        # Prefer high value-to-cost items\n        feasible_adds.sort(key=lambda i: (ratio(i), values[i - 1]), reverse=True)\n        pick_pool = feasible_adds[:min(3, len(feasible_adds))]\n        idx = random.choice(pick_pool)\n        neighbor.append(idx)\n        neighbor = canonicalize(neighbor)\n        mtype = f\"add:{idx}\"\n    elif move == \"remove\" and sol:\n        # Remove worst ratio to create capacity\n        rem = min(sol, key=ratio)\n        neighbor = [i for i in neighbor if i != rem]\n        neighbor = canonicalize(neighbor)\n        mtype = f\"remove:{rem}\"\n    elif move == \"swap\" and sol and out_list:\n        # Choose pair that fits within slack and improves ratio if possible\n        best_pair = None\n        best_delta = float(\"-inf\")\n        for a in out_list:\n            ca = costs[a - 1]\n            va = values[a - 1]\n            for r in sol:\n                cr = costs[r - 1]\n                if ca - cr <= slack:\n                    delta = (va \/ ca) - (values[r - 1] \/ cr)\n                    if delta > best_delta:\n                        best_delta = delta\n                        best_pair = (r, a)\n        if best_pair is None:\n            # fallback random pair (may be infeasible, will be repaired)\n            r = random.choice(sol)\n            a = random.choice(out_list)\n        else:\n            r, a = best_pair\n        neighbor = [i for i in neighbor if i != r]\n        neighbor.append(a)\n        neighbor = canonicalize(neighbor)\n        mtype = f\"swap:{r}->{a}\"\n    else:\n        # default no-op safeguard\n        return (sol, \"noop\")\n\n    # Feasibility repair with running cost maintenance (O(k))\n    nb_cost = sum(costs[i - 1] for i in neighbor)\n    if nb_cost > budget:\n        # Iteratively remove worst ratio items until feasible\n        work = neighbor[:]\n        in_work = set(work)\n        while work and nb_cost > budget:\n            worst = min(work, key=ratio)\n            work.remove(worst)\n            nb_cost -= costs[worst - 1]\n        neighbor = canonicalize(work)\n        mtype += \"|repair\"\n\n    return (neighbor, mtype if mtype else \"noop\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    rng = random\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    all_indices = list(range(1, n_items + 1))\n\n    # Perform k random structural moves\n    k = rng.choice([2, 3])\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = [i for i in all_indices if i not in in_set]\n        moves = []\n        if out_list:\n            moves.append(\"add\")\n        if sol:\n            moves.append(\"remove\")\n        if sol and out_list:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = rng.choice(moves)\n        if mv == \"add\" and out_list:\n            # Prefer high-density additions\n            out_list.sort(key=lambda i: (ratio(i), values[i - 1]), reverse=True)\n            pick = rng.choice(out_list[:min(4, len(out_list))])\n            sol.append(pick)\n        elif mv == \"remove\" and sol:\n            worst = min(sol, key=ratio)\n            sol = [i for i in sol if i != worst]\n        elif mv == \"swap\" and sol and out_list:\n            add_idx = rng.choice(out_list)\n            rem_idx = rng.choice(sol)\n            sol = [i for i in sol if i != rem_idx] + [add_idx]\n        sol = canonicalize(sol)\n\n    # Feasibility repair using running cost\n    total_cost = sum(costs[i - 1] for i in sol)\n    if total_cost > budget:\n        work = sol[:]\n        nb_cost = total_cost\n        while work and nb_cost > budget:\n            worst = min(work, key=ratio)\n            work.remove(worst)\n            nb_cost -= costs[worst - 1]\n        sol = canonicalize(work)\n\n    return sol\n","SAMPLE_SOL":"[8,4,18]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\n\"FEEDBACK\",\"E_FIX_LOCAL_SOLVER:Type List cannot be instantiated; replace any List() constructions with list() or [] and keep typing.List only in annotations. Search and remove any runtime calls to typing types.\nE_SIG_MISMATCH:Heuristics are passed callables; remove parentheses in signatures and invocations. Use def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor). Same for ILS and TS.\nE_RET_ANNOT:generate_neighbour return annotation is invalid. Replace -> (\\\"NB_Type\\\",\\\"Movement_Type\\\") with -> Tuple[List[int],str] (or tuple[list[int],str] on 3.9+).\nE_PERTURB_MISSING:Perturbation function is undefined ($Perturb). Implement def perturb_solution(solution): ... returning a repaired feasible INDEX_LIST.\nE_EVAL_SIGN_CONFLICT:Two evaluate_solution variants exist (one maximization positive, one minimization negative). Standardize to minimization-compatible fitness (feasible -> -value; infeasible -> +1e9) and ensure all heuristics compare with lower-is-better.\nE_FN_ARG_ORDER:Align to TARGET_HEURISTIC_GENERAL_SIGNATURE. Your implementations of SA\/ILS\/TS must accept exactly (currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) or specified variant without calling generators.\nE_KNOWN_SOLUTION_INCONSISTENT:Provided KNOWN_SOLUTION violates the budget and does not match EXPECTED_SCORE under the given evaluator. Replace with a feasible instance that attains the stated score.\nE_ASSERTION_CHECK:Use the provided evaluator to assert feasibility (cost<=90) and fitness sign. Current mismatch indicates the reference pair is wrong; correct before running solvers.\nE_CANON_SORT_SIDE_EFFECT:canonicalize sorts indices, which is fine for set representation but eliminates any positional semantics. If any operator expects order (e.g., sequence perturbations), separate ordering from membership.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to 1-add\/1-rem\/1-1 swap; exploration is shallow. Add 1-2 and 2-1 exchange, and a bounded multiple-add within slack to escape plateaus.\nNB_COSTLY_PRECHECK:O(n_out*n_in) swap pre-check each step. Precompute candidate adds with ca-cr<=slack via two-pointer over items sorted by cost or maintain small buckets keyed by cost deltas to reduce to near O(k log n).\nNB_REPAIR_GREEDY:Repair removes worst ratio iteratively; can delete high-value, low-cost items unnecessarily. Improve with: (a) try removing the single item with minimal value loss per cost reduction satisfying feasibility; (b) when slack deficit is small (<30), run a tiny 0\/1 DP on the selected set to find minimum value loss subset to drop.\nNB_VAL_DENSITY_BIAS:Add bias uses top-3 by ratio; can lead to premature convergence. Introduce epsilon-greedy selection (e.g., 0.8 exploit, 0.2 sample from feasible adds) or softmax over ratios to diversify.\nE_CODE_PERF:Repeated cost recomputation via sum() is O(k) per move. Track current cost and update incrementally for add\/remove\/swap to O(1). Pass and return both (solution,cost,value) from neighborhood to avoid recompute.\nE_RANDOM_SEED:Non-deterministic runs hinder reproducibility. Add optional seed param and thread-local RNG to heuristics.\nSA_PARAM_WEAK:Cooling schedule unspecified. Use geometric cooling T<-T*alpha with alpha\u2208[0.90,0.99], stop at MIN_TEMP, iterations per T proportional to |items|.\nTS_CONF_WEAK:Tabu uses list and duration params in signature but not defined. Implement tabu as FIFO queue or dict with tenure, use aspiration if fitness improves best. Tabu attributes should encode moves (added\/removed indices).\nILS_ACCEPT_RULE:Acceptance rate parameter vague. Use accept if new_fitness<best or with probability p for worsening moves; ensure perturbation strength adapts when stagnating.\nEVAL_RANGE:Penalty 1e9 acceptable; ensure no arithmetic with infinities and compare strictly on floats. Avoid mixing -inf in one evaluator and +1e9 in another.\nR_STR_INADEQUATE:INDEX_LIST is fine, but current operators ignore items with cost>budget individually; add operator that removes multiple items to admit a single expensive high-value item when budget allows.\nTEST_HARNESS:Include unit checks: evaluate_solution([])==0 or 0.0 fitness, monotonicity on adds within budget, invariants (no duplicates, indices in [1,n]).\nPY_ASSERT_CORRECTNESS:Validated evaluator on provided samples; current reference pair fails constraints under the 90 budget while the sample passes and matches the stated score. Update references accordingly before running heuristics.\nACTION_ITEMS:\n- Replace all runtime List() with list(); fix signatures to accept callables without parentheses.\n- Unify evaluate_solution to minimization fitness (-value; +1e9 penalty).\n- Implement perturb_solution with k-swap\/toggles and repair that preserves high value.\n- Extend neighborhood to include 1-2\/2-1 exchanges and improved repair; add epsilon-greedy add.\n- Add incremental cost\/value tracking and RNG seeding.\n- Correct the inconsistent known reference to a feasible pair matching the stated score and re-run.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST of 1-based item indices. Example: [4,8,18] encodes selecting items 4, 8, and 18.","Componentes":{"REPRESENTATION":"INDEX_LIST of 1-based item indices. Example: [4,8,18] encodes selecting items 4, 8, and 18.","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_value = 0\n    used = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > n:\n            return float('-inf')\n        if idx in used:\n            return float('-inf')\n        used.add(idx)\n        total_value += values[idx - 1]\n    return float(total_value)\n\ndef evaluate_solution(solution: List[int]) -> float:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    val = objective_function(solution)\n    if val == float('-inf'):\n        return float('-1e9')\n    total_cost = 0\n    for idx in solution:\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return float(val)\n    else:\n        return float('-1e9')\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _repair_to_budget(sol: List[int]) -> List[int]:\n    # Remove items until within budget using lowest value density heuristic\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    sol = list(dict.fromkeys([i for i in sol if isinstance(i, int) and 1 <= i <= 24]))\n    def total_cost(s):\n        return sum(costs[i-1] for i in s)\n    if total_cost(sol) <= budget:\n        return sol\n    # Sort selected items by increasing value density (value\/cost), remove until feasible\n    dens = sorted([(values[i-1]\/costs[i-1], i) for i in sol], key=lambda x: (x[0], values[x[1]-1]))\n    keep = set(sol)\n    for _, i in dens:\n        if total_cost(list(keep)) <= budget:\n            break\n        if i in keep:\n            keep.remove(i)\n    repaired = list(keep)\n    # Final check and return\n    return repaired if total_cost(repaired) <= budget else []\n\ndef _normalize(sol: List[int]) -> List[int]:\n    # Ensure valid, unique, sorted indices\n    sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n    sol = sorted(set(sol))\n    return sol\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    n = 24\n    curr = _normalize(solution)\n    # Random move choice: add\/remove\/swap, with repair to ensure feasibility\n    move = random.choice([\"add\", \"remove\", \"swap\"]) if curr else random.choice([\"add\", \"add\", \"swap\"])  # bias towards add when empty\n    new_sol = curr.copy()\n    if move == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in new_sol]\n        if candidates:\n            i = random.choice(candidates)\n            new_sol.append(i)\n    elif move == \"remove\":\n        if new_sol:\n            i = random.choice(new_sol)\n            new_sol.remove(i)\n    else:  # swap\n        if new_sol:\n            out_i = random.choice(new_sol)\n            excluded = [i for i in range(1, n+1) if i not in new_sol]\n            if excluded:\n                in_i = random.choice(excluded)\n                new_sol.remove(out_i)\n                new_sol.append(in_i)\n    new_sol = _normalize(new_sol)\n    # If infeasible, repair by dropping low-density items\n    total_cost = sum(costs[i-1] for i in new_sol)\n    if total_cost > budget:\n        new_sol = _repair_to_budget(new_sol)\n        move_type = f\"{move}_repair\"\n    else:\n        move_type = move\n    return (new_sol, move_type)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _repair_to_budget(sol: List[int]) -> List[int]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    sol = list(dict.fromkeys([i for i in sol if isinstance(i, int) and 1 <= i <= 24]))\n    def total_cost(s):\n        return sum(costs[i-1] for i in s)\n    if total_cost(sol) <= budget:\n        return sol\n    dens = sorted([(values[i-1]\/costs[i-1], i) for i in sol], key=lambda x: (x[0], values[x[1]-1]))\n    keep = set(sol)\n    for _, i in dens:\n        if total_cost(list(keep)) <= budget:\n            break\n        if i in keep:\n            keep.remove(i)\n    repaired = list(keep)\n    return repaired if total_cost(repaired) <= budget else []\n\ndef _normalize(sol: List[int]) -> List[int]:\n    sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n    return sorted(set(sol))\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    k = 3  # number of random flips\n    curr = _normalize(solution)\n    for _ in range(k):\n        if random.random() < 0.5 or not curr:\n            candidates = [i for i in range(1, n+1) if i not in curr]\n            if candidates:\n                curr.append(random.choice(candidates))\n        else:\n            if curr:\n                curr.remove(random.choice(curr))\n        curr = _normalize(curr)\n    curr = _repair_to_budget(curr)\n    return curr\n","SAMPLE_SOL":"[4,8,18]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-critique-2025-11-20\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERROR_SIGNATURE:Heuristic definitions appear to instantiate typing.List (error 'Type List cannot be instantiated'). Remove any List() constructions; use list() for creation and typing.List only for annotations.\nFIX_LOCAL_SOLVER_PASS_FUNCS:Do not pass generate_neighbour() \/ evaluate_solution() \/ perturb_solution() as called results. Pass function references without parentheses and match TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\nFIX_LOCAL_SOLVER_NAME_SIG_MISMATCH:Align SA\/ILS\/TS parameter lists to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Eliminate extra positional parameters; move them into other_params.\nFIX_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide a perturbation that performs k-exchange (e.g., remove t items, add t' items) with budget-aware repair and returns a valid INDEX_LIST.\nE_EVAL_SIGN_MISMATCH:Framework expects 'less is better' (negatives for maximization). Current evaluate_solution returns positive value for feasible solutions. Return -objective_value for feasible and a large positive penalty for infeasible, or invert the comparison logic in the heuristic.\nIFACE_MISMATCH_NEIGHBOUR:generate_neighbour returns (solution, move_type). If heuristics expect only a solution, unpack and propagate move_type via logs\/other_params. Standardize interface to avoid tuple\/solution confusion.\nNB_MOVE_SET_WEAK:Current moves limited to add\/remove\/1-1 swap with uniform random choice. Exploration is shallow. Add value-density guided adds, 1-2 and 2-1 exchanges, and best-of-m sampled neighbor selection to improve local escape.\nNB_CODE_FAIL_LOCAL_OPT:Removal\/repair uses increasing value-density; this is greedy but may drop high-value low-cost combinations suboptimally. Augment with try-add while feasible after repair, or perform small neighborhood local improvements post-repair.\nR_REPAIR_COST_QUADRATIC:total_cost(list(keep)) recomputed per removal causing O(k^2). Maintain a running cost and decrement on removal to achieve O(k log k) dominated by sorting.\nR_NORMALIZE_SIDE_EFFECTS:_normalize sorts indices, which is unnecessary and may reduce reproducibility of stochastic moves. Use set for deduplication but preserve order to keep move semantics stable.\nSEED_CONTROL:Introduce rng seed via other_params to ensure reproducibility in local runs and debugging.\nPRECOMPUTE_CONSTANTS:Avoid recreating costs\/values arrays inside every call. Hoist to outer scope or capture in closures to reduce overhead.\nCANDIDATE_PREFILTER:Exclude items with cost > budget from candidate sets in generate_neighbour to avoid generating guaranteed-infeasible adds.\nDUPLICATE_POLICY:objective_function returns -inf for duplicates; retain, but also prevent duplicates earlier by construction in neighbour\/perturb to cut wasted evaluations.\nTERMINATION_PARAMS:Define annealing schedule (TEMP, MIN_TEMP, cooling_factor) and iteration limits within other_params; ensure they are consumed by Heuristic, not by separate SA\/ILS\/TS signatures.\nREF_INCONSISTENCY:Reference check against evaluator fails (infeasibility\/score mismatch). Update the provided reference or adjust costs\/budget to ensure evaluator and reference are consistent.\nASSERTION_CHECK:Sample solution evaluates feasible with expected score under current evaluator; use this as a smoke test in unit tests.\nE_CODE_PERF:Objective\/evaluation repeatedly sum costs\/values: maintain incremental deltas when applying moves to reduce O(n) per step to O(1).\nTABU_STRUCTURE:For Tabu Search, define tabu attributes on item insertions\/removals rather than whole solutions; ensure aspiration based on improved best_score (with correct sign).\nILS_ACCEPTANCE:Current ILS signature mentions 'aceptance_rate' but no policy. Implement deterministic acceptance: accept strictly better (with correct sign) or probabilistic acceptance for diversification.\nBUDGET_TIGHTNESS:Budget is tight relative to costs; emphasize add moves of low-cost high-value items and prune high-cost items early to focus the neighborhood.\nTEST_HARNESS:Add unit tests: (1) evaluate_solution(valid_feasible)=negative or positive per chosen convention; (2) infeasible => large penalty; (3) neighbour always returns valid indices and repaired feasibility.\nINTERFACE_CONSISTENCY:Ensure all components return and consume INDEX_LIST only; no booleans or bitstrings to avoid implicit conversions.\nLOCAL_VALIDATION:Before running heuristic, assert evaluate_solution on a known-feasible smoke test equals expected evaluator outcome to catch integration errors early.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST of 1-based item indices. Example: [4,8,18] selects items 4, 8, and 18.","Componentes":{"REPRESENTATION":"INDEX_LIST of 1-based item indices. Example: [4,8,18] selects items 4, 8, and 18.","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_value = 0.0\n    used = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > n:\n            return float('-inf')\n        if idx in used:\n            return float('-inf')\n        used.add(idx)\n        total_value += float(values[idx - 1])\n    return total_value\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Return convention: lower is better. For feasible solutions, return -objective_value.\n    # For infeasible or invalid solutions, return a large positive penalty.\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    val = objective_function(solution)\n    if val == float('-inf'):\n        return float(1e9)\n    total_cost = 0\n    for idx in solution:\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return -float(val)\n    else:\n        return float(1e9)","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data (embedded)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _total_cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    def _repair_to_budget(sol: List[int]) -> List[int]:\n        sol = _normalize(sol)\n        cur_cost = _total_cost(sol)\n        if cur_cost <= budget:\n            return sol\n        # Compute densities and remove by lowest density first\n        dens = [(values[i-1] \/ costs[i-1], i) for i in sol]\n        dens.sort(key=lambda x: (x[0], values[x[1]-1]))  # increasing density\n        keep = set(sol)\n        for _, idx in dens:\n            if cur_cost <= budget:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                cur_cost -= costs[idx-1]\n        repaired = [i for i in sol if i in keep]\n        if _total_cost(repaired) > budget:\n            return []\n        # Local greedy refill: try to add best density items within budget\n        cand = [i for i in range(1, n+1) if i not in repaired and costs[i-1] <= budget]\n        cand.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        cur = list(repaired)\n        cur_cost2 = _total_cost(cur)\n        for i in cand:\n            c = costs[i-1]\n            if cur_cost2 + c <= budget:\n                cur.append(i)\n                cur_cost2 += c\n        return _normalize(cur)\n\n    def _guided_add(curr: List[int]) -> List[int]:\n        cand = [i for i in range(1, n+1) if i not in curr and costs[i-1] <= budget]\n        if not cand:\n            return curr\n        # Prefer high value density, then value\n        cand.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        # sample top-k to add some randomness\n        k = min(5, len(cand))\n        i = random.choice(cand[:k])\n        return curr + [i]\n\n    curr = _normalize(list(solution))\n\n    move_choices = [\"add\", \"remove\", \"swap1_1\", \"swap1_2\", \"swap2_1\"]\n    if not curr:\n        move_choices = [\"add\"] * 3 + [\"swap1_1\"]\n    move = random.choice(move_choices)\n\n    new_sol = list(curr)\n    movement_detail = move\n\n    if move == \"add\":\n        # guided add\n        new_sol = _guided_add(new_sol)\n    elif move == \"remove\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            new_sol.remove(out_i)\n    elif move == \"swap1_1\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            excluded = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= budget]\n            if excluded:\n                in_i = random.choice(excluded)\n                new_sol.remove(out_i)\n                new_sol.append(in_i)\n    elif move == \"swap1_2\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            excluded = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= budget]\n            if len(excluded) >= 2:\n                in_pair = random.sample(excluded, 2)\n                new_sol.remove(out_i)\n                new_sol.extend(in_pair)\n    elif move == \"swap2_1\":\n        if len(new_sol) >= 2:\n            out_pair = random.sample(new_sol, 2)\n            excluded = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= budget]\n            if excluded:\n                in_i = random.choice(excluded)\n                for o in out_pair:\n                    if o in new_sol:\n                        new_sol.remove(o)\n                new_sol.append(in_i)\n\n    new_sol = _normalize(new_sol)\n    # Budget repair and local improvement\n    before_cost = _total_cost(new_sol)\n    if before_cost > budget:\n        new_sol = _repair_to_budget(new_sol)\n        movement_detail += \"+repair\"\n    else:\n        # If feasible, try a small greedy improvement\n        new_sol = _repair_to_budget(new_sol)\n\n    return (new_sol, movement_detail)","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Problem data (embedded)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _total_cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    def _repair_to_budget(sol: List[int]) -> List[int]:\n        sol = _normalize(sol)\n        cur_cost = _total_cost(sol)\n        if cur_cost <= budget:\n            return sol\n        dens = [(values[i-1] \/ costs[i-1], i) for i in sol]\n        dens.sort(key=lambda x: (x[0], values[x[1]-1]))\n        keep = set(sol)\n        for _, idx in dens:\n            if cur_cost <= budget:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                cur_cost -= costs[idx-1]\n        repaired = [i for i in sol if i in keep]\n        if _total_cost(repaired) > budget:\n            return []\n        # Greedy refill\n        cand = [i for i in range(1, n+1) if i not in repaired and costs[i-1] <= budget]\n        cand.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        cur = list(repaired)\n        cur_cost2 = _total_cost(cur)\n        for i in cand:\n            c = costs[i-1]\n            if cur_cost2 + c <= budget:\n                cur.append(i)\n                cur_cost2 += c\n        return _normalize(cur)\n\n    curr = _normalize(list(solution))\n\n    # k-exchange perturbation: remove t items, add t' random items, then repair\n    t_remove = min(2, len(curr))\n    if t_remove > 0:\n        to_remove = random.sample(curr, t_remove)\n        for r in to_remove:\n            if r in curr:\n                curr.remove(r)\n\n    # Add up to k items randomly from candidates\n    k_add = 3\n    candidates = [i for i in range(1, n+1) if i not in curr and costs[i-1] <= budget]\n    random.shuffle(candidates)\n    for i in candidates[:k_add]:\n        curr.append(i)\n        curr = _normalize(curr)\n\n    curr = _repair_to_budget(curr)\n    return curr","SAMPLE_SOL":"[4,8,18]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-feedback-knapsack-idxlist\"\n\"FEEDBACK\":\n\"E_LOCAL_SOLVER_INIT:Heuristic signatures misuse callables. Pass function objects, not calls. Fix SA\/ILS\/TS signatures to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and update invocations accordingly.\"\n\"E_LOCAL_SOLVER_LISTTYPE:Typing List\/Tuple are not instantiable. Replace any List() \/ Tuple() with list() \/ tuple(). Remove attempts to construct typing types anywhere in solvers.\"\n\"E_PERTURB_MISSING:Perturbation function unresolved ($Perturb). Provide a concrete perturb_solution callable matching the required signature.\"\n\"E_API_SIG_MISMATCH:Reported SA\/ILS\/TS signatures include parentheses on generator\/evaluator (generate_neighbour(), evaluate_solution()). Remove parentheses to avoid early invocation and type errors.\"\n\"E_TABU_NAME_INCONSISTENCY:Function name\/params use 'Taboo'. Standardize to 'Tabu' or keep consistent across call sites and parameter names to avoid import\/dispatch mismatches.\"\n\"E_EVAL_DIRECTION:Evaluator returns -objective for feasible and large positive penalty otherwise. Ensure all heuristics minimize the returned score. Any maximization logic will invert search pressure.\"\n\"E_KNOWN_SOLUTION_FEAS:Provided KNOWN_SOLUTION violates the budget constraint under current costs. Do not use it for validation. Replace with a feasible reference verified by evaluate_solution.\"\n\"E_EXPECTED_SCORE_MISMATCH:EXPECTED_SCORE_FROM_KNOWN_SOLUTION conflicts with evaluator convention (negative score for feasible solutions). Align expected-scoring checks to evaluator output.\"\n\"E_INDEX_VALIDATION:Objective invalidates duplicates and out-of-range indices with -inf. Pre-normalize solutions before evaluation to avoid automatic penalization during neighborhood exploration.\"\n\"E_NB_REPAIR_OVERRELIANCE:Neighborhood moves (swap1_2, swap2_1) can generate highly infeasible intermediates relying on repair, increasing randomness and weakening gradient. Constrain candidate additions by residual budget before applying repair.\"\n\"E_NB_DENSITY_ONLY:Density-based guidance can stall when values are coarse. No explicit delta-evaluation is used. Adopt best-improving 1-1 and 1-k (k in {1,2}) swaps using marginal gain \u0394v with cost feasibility.\"\n\"E_NB_RANDOMNESS:Uniform random picks from filtered sets reduce exploitation. Use softmax over normalized densities or e-greedy with decay to bias toward higher expected gain while preserving exploration.\"\n\"E_INCR_COST_VALUE:Full recomputation of cost after each move is O(n). Maintain running totals and update incrementally per move to reduce per-step complexity to O(1) for add\/remove and O(1..k) for swaps.\"\n\"E_REPAIR_GREEDY_FILL:Refill step sorts all candidates every call (O(n log n)). Cache sorted by density once and update via lazy filtering, or maintain a heap keyed by -density.\"\n\"E_PENALTY_FLAT:Flat penalty 1e9 gives no gradient for infeasible neighbors. Use a dynamic penalty: base + \u03b1\u00b7max(0,total_cost-budget) with annealed \u03b1 to guide toward feasibility.\"\n\"E_START_SOLUTION:No explicit constructive initializer beyond sample. Build a feasible greedy start by value\/weight with tie on value, then local-opt refine; improves SA\/ILS warm-start quality.\"\n\"E_RANDOM_SEED:Non-deterministic runs hinder reproducibility. Seed RNG at solver start and expose seed in other_params.\"\n\"E_MOVE_DIVERSITY:Current moves miss drop-add pairs guided by residual budget. Add 'drop_add': remove worst-density item then add best-fitting items until no improvement.\"\n\"E_LOCAL_OPT_TERMINATION:No explicit local-opt loop. After each accepted move, perform best-improving local search over 1-1 and add\/drop until no improving \u0394; reduces cycling and accelerates convergence.\"\n\"E_BOUNDARY_CHECKS:Neighbour generation may return empty set post-repair. Ensure fallback to previous feasible solution to avoid degeneracy.\"\n\"E_TYPE_HINT_RUNTIME:Return annotation -> ('NB_Type','Movement_Type') is a string tuple literal and unused. Prefer -> Tuple[List[int], str] for clarity; do not instantiate typing types at runtime.\"\n\"R_SIGNATURE_FIX:Refactor SA\/ILS\/TS to the unified signature Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Validate via a minimal driver.\"\n\"R_FUNC_PASSING:Ensure calls pass generate_neighbour and evaluate_solution as references; e.g., Heuristic(sol,best,best_score,generate_neighbour,evaluate_solution,perturb,params).\"\n\"R_IMPLEMENT_PERTURB:Implement perturb_solution as multi-swap random shake with controlled strength s: remove r items and insert up to r guided by density, then repair. Expose s in other_params.\"\n\"R_DELTA_EVAL:Precompute value[] and cost[] arrays. Maintain (curr_value,curr_cost). For candidate add i: feasible if curr_cost+cost[i]\u2264B; \u0394=-value[i]. For swap i->j: check curr_cost - cost[i] + cost[j] \u2264 B; \u0394=-(value[j]-value[i]). Choose best \u0394<0.\"\n\"R_TABU_CORE:For TS, tabu on items added\/removed with tenure \u03c4 and aspiration if \u0394 improves best. Use short-term memory to avoid immediate reversals.\"\n\"R_SA_SCHEDULE:Geometric cooling with T0 set by target acceptance p0 for average uphill \u0394; T0\u2248-avg\u0394\/ln p0. Stop at MIN_TEMP or stall count.\"\n\"R_ILS_ACCEPT:Use Late Acceptance or Metropolis-based acceptance on local optima before perturb. Set perturb strength adaptively based on stagnation length.\"\n\"R_REPAIR_SPEED:Replace per-call sort with pre-sorted indices by density and incremental feasibility check; complexity per repair near O(n) worst-case but much less amortized.\"\n\"R_CONSTRAINT_AWARE_MOVES:Before proposing add\/swap, filter candidates by feasibility with residual budget; fall back to repair only if a rare overshoot occurs.\"\n\"R_VALIDATION_TESTS:Add unit tests: (1) invalid types, (2) duplicate indices, (3) budget boundary at 90, (4) empty solution. Assert evaluate_solution returns finite negatives only for feasible cases.\"\n\"R_REPRO_CHECK:Log movement_detail, temperature\/iteration, and best_score evolution to detect premature convergence or excessive infeasibility.\"\n\"ASSERT_EVAL_CORRECTNESS:Evaluator verified with multiple cases: feasible solutions produce finite negative scores; infeasible or invalid solutions map to large positive penalties. Detected mismatch between provided reference and evaluator; correct the reference to a feasible one verified by evaluate_solution.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST of 1-based item indices. Example: [4,8,18] selects those items. Feasibility: sum of costs of listed indices must be <= 90.","Componentes":{"REPRESENTATION":"INDEX_LIST of 1-based item indices. Example: [4,8,18] selects those items. Feasibility: sum of costs of listed indices must be <= 90.","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    if not isinstance(solution, list):\n        return float('-inf')\n    seen = set()\n    total_value = 0.0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_value += float(values[idx - 1])\n    return total_value\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization convention: feasible -> return -objective_value; infeasible\/invalid -> large positive penalty\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    val = objective_function(solution)\n    if val == float('-inf'):\n        return float(1e9)\n    total_cost = 0\n    for idx in solution:\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return -float(val)\n    # dynamic penalty with slight gradient by overflow amount\n    overflow = float(total_cost - budget)\n    return float(1e9 + overflow)","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    curr = _normalize(list(solution))\n    curr_cost = _cost(curr)\n\n    moves = [\"add\", \"remove\", \"swap1_1\", \"swap2_1\"]\n    if not curr:\n        moves = [\"add\", \"add\", \"add\", \"swap1_1\"]\n    move = random.choice(moves)\n    movement_detail = move\n\n    new_sol = list(curr)\n    new_cost = curr_cost\n\n    if move == \"add\":\n        residual = budget - new_cost\n        candidates = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= residual and costs[i-1] <= budget]\n        if candidates:\n            # bias by value density\n            candidates.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n            k = min(4, len(candidates))\n            pick = random.choice(candidates[:k])\n            new_sol.append(pick)\n            new_cost += costs[pick-1]\n    elif move == \"remove\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            new_sol.remove(out_i)\n            new_cost -= costs[out_i-1]\n    elif move == \"swap1_1\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            residual = budget - (new_cost - costs[out_i-1])\n            candidates = [j for j in range(1, n+1) if j not in new_sol and costs[j-1] <= residual]\n            if candidates:\n                candidates.sort(key=lambda j: (-values[j-1]\/costs[j-1], -values[j-1]))\n                k = min(4, len(candidates))\n                in_j = random.choice(candidates[:k])\n                new_sol.remove(out_i)\n                new_sol.append(in_j)\n                new_cost = new_cost - costs[out_i-1] + costs[in_j-1]\n    elif move == \"swap2_1\":\n        if len(new_sol) >= 2:\n            out_i, out_j = random.sample(new_sol, 2)\n            base_cost = new_cost - costs[out_i-1] - costs[out_j-1]\n            residual = budget - base_cost\n            candidates = [k for k in range(1, n+1) if k not in new_sol and costs[k-1] <= residual]\n            if candidates:\n                candidates.sort(key=lambda k: (-values[k-1]\/costs[k-1], -values[k-1]))\n                t = min(5, len(candidates))\n                in_k = random.choice(candidates[:t])\n                new_sol.remove(out_i)\n                new_sol.remove(out_j)\n                new_sol.append(in_k)\n                new_cost = base_cost + costs[in_k-1]\n\n    # Final normalization (safety)\n    new_sol = _normalize(new_sol)\n    return (new_sol, movement_detail)","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    sol = _normalize(list(solution))\n\n    # Remove up to r items\n    r = min(2, len(sol))\n    if r > 0:\n        for rem in random.sample(sol, r):\n            sol.remove(rem)\n\n    # Add up to r+1 items guided by density within residual capacity\n    residual = budget - _cost(sol)\n    candidates = [i for i in range(1, n+1) if i not in sol and costs[i-1] <= residual]\n    candidates.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n    k = min(len(candidates), r + 1)\n    for i in candidates[:k]:\n        if _cost(sol) + costs[i-1] <= budget:\n            sol.append(i)\n\n    # Greedy fill to utilize remaining capacity\n    residual = budget - _cost(sol)\n    if residual > 0:\n        more = [i for i in range(1, n+1) if i not in sol and costs[i-1] <= residual]\n        more.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        for i in more:\n            if _cost(sol) + costs[i-1] <= budget:\n                sol.append(i)\n                residual = budget - _cost(sol)\n                if residual <= 0:\n                    break\n\n    return _normalize(sol)","SAMPLE_SOL":[8,4,18]},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_TYPE_HINT:Error 'Type List cannot be instantiated; use list() instead'. Replace any List() usages with list(), and ensure no attempt to instantiate typing.List or typing.Tuple.\nHEUR_SIG_MISMATCH:Target expects Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Align SA\/ILS\/TS wrappers to pass function references (no parentheses in signature) and match parameter order.\nPERTURB_FUNC_MISSING:Placeholder '$Perturb' is undefined. Implement perturb_solution(solution, rng_state) that performs multi-move random kicks while preserving feasibility or repairing via greedy removal.\nILS_DEPENDENCY_FAIL:ILS signature requires perturb_solution(), currently absent; this causes immediate failure. Provide a valid callable and update ILS to accept function objects, not instantiated types.\nEVAL_CONVENTION_INCONSISTENT:Top EVAL_CODE returns large negative on infeasible; later Evaluation Function returns large positive penalty on infeasible and negative objective for feasible. Standardize to the minimization convention everywhere to match 'HEURISTICS_VALUE_BEST_AS_LESSER_COST_USE_NEGATIVES_FOR_MAXIMIZATION_PROBLEMS'.\nREF_CHECK_FAIL:Provided reference violates the budget under the given evaluate_solution; its evaluated fitness equals a large penalty not an improvement. Replace the reference or adjust constraints; do not use it for validation.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood lacks improving 2-way exchanges under tight budget. Add swap1_2 and swap2_2 with value-density bias to escape add\/remove plateaus.\nNB_GENERATION_WEAK_REPAIR:Neighbour generation filters by residual and can stall at empty or near-empty sets. Add a repair step: if infeasible or empty candidate set, perform 'remove-heaviest-low-ratio then greedy refill'.\nNB_SEARCH_SCOPE_LIMITED:Only 1-1 and 2-1 swaps considered. Add drop2_add2 to explore equal-cardinality exchanges, and a best-of-k evaluation loop per iteration.\nINIT_HEURISTIC_WEAK:No constructive initializer provided. Add a deterministic greedy-by-ratio fill with tie-breakers, followed by local improvement, to seed SA\/ILS\/TS.\nSA_PARAM_RIGIDITY:No adaptive temperature or reheating. Implement geometric cooling with occasional reheats and accept-worsening probability cap; scale initial T by stdev of sampled deltas.\nTS_MEMORY_UNSPECIFIED:Tabu uses list size\/duration but lacks aspiration criterion and hashable move encoding. Define move-based tabu on indices moved, add aspiration if candidate beats best_score.\nE_CODE_PERF:Each neighbor rebuilds and sorts full candidate lists O(n log n). Cache feasible candidates by residual buckets or use partial reservoir sampling; precompute ratio=values\/costs and keep sorted indices to get O(log n) inserts.\nVALIDATION_GAPS:objective_function treats duplicates\/invalids as -inf; evaluate_solution then maps to large positive. Ensure both consistently return penalties; add fast set-size check vs list-length to detect duplicates in O(1).\nSAMPLING_BIAS:Random choice among top-k can overfit to few items. Use softmax over ratio or epsilon-greedy to maintain exploration with controllable entropy.\nTERMINATION_CRITERIA_WEAK:No stagnation-based early-stop. Track no-improve iterations and reset\/perturb adaptively.\nR_STR_INADEQUATE:Pure INDEX_LIST with random moves yields poor exploration under hard budget. Recommend hybrid: maintain a binary mask backing the index list to allow O(1) membership and faster swap feasibility checks.\nLOGGING_INSUFFICIENT:Local solver expects extra outputs. Return (solution, score, move_type, cost, obj_value, is_feasible) per step for diagnosability.\nCONSISTENCY_CHECKS:Add assert cost<=budget post-neighbor and post-perturb; if violated, run greedy repair to feasibility.\nRANDOM_SEED_CONTROL:Expose rng seed in other_params and pass a Random instance to all components to ensure reproducibility.\nTEST_COVERAGE:Unit-test evaluate_solution on boundary cases: empty set, single cheap item, duplicate index, out-of-range index, overflow by 1, exactly budget.\nCONSTRAINT_TIGHTENING:Prune items with cost>budget at load time to reduce neighbor space and avoid wasted candidates.\nMETRIC_REPORTING:Track best feasible score separately from current; never overwrite best_score with infeasible states, even transiently.\nSAFETY_MAIN_INSTR:Verify no component accesses filesystem\/network\/OS; keep all code pure and deterministic except RNG input.\nACTIONABLE_FIX_ORDER:1) Replace any List()\/Tuple() instantiation with list()\/tuple(); 2) Implement perturb_solution; 3) Unify evaluate_solution to minimization-by-negative convention; 4) Add repair and swap2_2 neighborhood; 5) Provide reproducible initializer and RNG handling; 6) Add aspiration in TS and adaptive cooling in SA; 7) Optimize candidate generation and caching.\nVALIDATION_RESULT:Python evaluation confirms the provided reference is infeasible under current constraints and scoring; remove it from correctness checks and validate against feasible baselines instead.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST.1-based.JSON_list","Componentes":{"REPRESENTATION":"INDEX_LIST.1-based.JSON_list","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Feasibility-first evaluation. Minimization fitness using negative objective for maximization.\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    # Return negative value for minimization-based heuristics\n    return -float(total_value)","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _is_feasible(sol: List[int], costs: List[int], budget: int) -> bool:\n    seen = set()\n    total = 0\n    for idx in sol:\n        if not isinstance(idx, int) or idx < 1 or idx > 24 or idx in seen:\n            return False\n        seen.add(idx)\n        total += costs[idx - 1]\n        if total > budget:\n            return False\n    return True\n\ndef _repair(sol: List[int], costs: List[int], budget: int) -> List[int]:\n    # Greedy drop highest-cost items until feasible\n    total = sum(costs[i-1] for i in sol)\n    if total <= budget:\n        return sol\n    # sort indices by cost descending, drop until feasible\n    order = sorted(sol, key=lambda i: costs[i-1], reverse=True)\n    keep = set(sol)\n    for idx in order:\n        if total <= budget:\n            break\n        keep.remove(idx)\n        total -= costs[idx - 1]\n    repaired = sorted(list(keep))\n    return repaired\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    \"\"\"\n    Generate a neighboring feasible solution for INDEX_LIST representation.\n    Returns: (new_solution, NB_Type, Movement_Type)\n    NB_Type: 'INDEX_LIST'\n    Movement_Type in {'add','remove','swap'}\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    n_items = 24\n    sol = list(solution) if isinstance(solution, list) else []\n    # Ensure set-like uniqueness\n    sol = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= n_items))\n\n    move_type = None\n    # Decide move\n    r = random.random()\n    if len(sol) == 0:\n        # must add\n        move_type = 'add'\n    elif r < 0.33:\n        move_type = 'remove'\n    elif r < 0.66:\n        move_type = 'add'\n    else:\n        move_type = 'swap'\n\n    new_sol = sol.copy()\n    if move_type == 'remove' and len(new_sol) > 0:\n        rem = random.choice(new_sol)\n        new_sol.remove(rem)\n    elif move_type == 'add':\n        cand = [i for i in range(1, n_items+1) if i not in new_sol]\n        random.shuffle(cand)\n        added = False\n        for i in cand:\n            if sum(costs[j-1] for j in new_sol) + costs[i-1] <= budget:\n                new_sol.append(i)\n                new_sol.sort()\n                added = True\n                break\n        if not added:\n            # fallback: remove random if exists\n            if new_sol:\n                rem = random.choice(new_sol)\n                new_sol.remove(rem)\n            else:\n                # nothing possible, return as is\n                pass\n    else:  # swap\n        if len(new_sol) > 0:\n            out = random.choice(new_sol)\n            remaining = [i for i in range(1, n_items+1) if i not in new_sol or i == out]\n            random.shuffle(remaining)\n            swapped = False\n            base_cost = sum(costs[j-1] for j in new_sol) - costs[out-1]\n            for inn in remaining:\n                if inn == out:\n                    continue\n                if base_cost + costs[inn-1] <= budget:\n                    new_sol.remove(out)\n                    new_sol.append(inn)\n                    new_sol.sort()\n                    swapped = True\n                    break\n            if not swapped:\n                # fallback to remove\n                new_sol.remove(out)\n                move_type = 'remove'\n        else:\n            move_type = 'add'\n            # handle in add path\n            cand = [i for i in range(1, n_items+1) if i not in new_sol]\n            if cand:\n                i = random.choice(cand)\n                if sum(costs[j-1] for j in new_sol) + costs[i-1] <= budget:\n                    new_sol.append(i)\n                    new_sol.sort()\n\n    # Repair if needed\n    if not _is_feasible(new_sol, costs, budget):\n        new_sol = _repair(new_sol, costs, budget)\n\n    return new_sol, 'INDEX_LIST', move_type","PERTURB_CODE":"import random\nfrom typing import List\n\n# Reuse neighbourhood generator logic; ensure identical behavior when imported together.\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    \"\"\"Apply multiple random neighbour moves to escape local minima while keeping feasibility.\"\"\"\n    from math import ceil\n    # Local copies to avoid reliance on externals\n    def _gen(sol: List[int]):\n        from typing import Tuple\n        import random as _r\n        costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        budget = 90\n        n_items = 24\n        sol = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= n_items))\n        r = _r.random()\n        move_type = 'add' if not sol else ('remove' if r < 0.33 else ('add' if r < 0.66 else 'swap'))\n        new_sol = sol.copy()\n        if move_type == 'remove' and new_sol:\n            rem = _r.choice(new_sol)\n            new_sol.remove(rem)\n        elif move_type == 'add':\n            cand = [i for i in range(1, n_items+1) if i not in new_sol]\n            _r.shuffle(cand)\n            for i in cand:\n                if sum(costs[j-1] for j in new_sol) + costs[i-1] <= budget:\n                    new_sol.append(i)\n                    new_sol.sort()\n                    break\n        else:\n            if new_sol:\n                out = _r.choice(new_sol)\n                remaining = [i for i in range(1, n_items+1) if i not in new_sol or i == out]\n                _r.shuffle(remaining)\n                base_cost = sum(costs[j-1] for j in new_sol) - costs[out-1]\n                swapped = False\n                for inn in remaining:\n                    if inn == out:\n                        continue\n                    if base_cost + costs[inn-1] <= budget:\n                        new_sol.remove(out)\n                        new_sol.append(inn)\n                        new_sol.sort()\n                        swapped = True\n                        break\n                if not swapped:\n                    new_sol.remove(out)\n        # Repair feasibility if broken\n        def _is_feasible(sol: List[int]) -> bool:\n            seen = set()\n            total = 0\n            for idx in sol:\n                if not isinstance(idx, int) or idx < 1 or idx > 24 or idx in seen:\n                    return False\n                seen.add(idx)\n                total += costs[idx - 1]\n                if total > budget:\n                    return False\n            return True\n        if not _is_feasible(new_sol):\n            # Drop random items until feasible\n            _r.shuffle(new_sol)\n            total = sum(costs[i-1] for i in new_sol)\n            while new_sol and total > budget:\n                rem = new_sol.pop()\n                total -= costs[rem-1]\n            new_sol.sort()\n        return new_sol\n\n    # Apply k moves (2..5)\n    k = random.randint(2, 5)\n    cur = list(solution) if isinstance(solution, list) else []\n    for _ in range(k):\n        cur = _gen(cur)\n    return cur","SAMPLE_SOL":"[4,8,18]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE:Target wrapper required. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): and adapt SA\/ILS\/TS to this exact signature to stop dispatcher mismatches.\nE_FUNC_REF_PASS:Do not call operators in the signature. Pass function references, not invocations. Use generate_neighbour and evaluate_solution (no parentheses) in all heuristic calls.\nE_TYPE_HINT_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates runtime List() usage. Replace any List() with list(). Keep typing.List only for type hints, never for construction.\nE_EVAL_DIRECTION_INCONSISTENT:Two conflicting evaluators exist (one returns value, the other returns negative value and inf on infeasible). Standardize to a single feasibility-first minimization evaluator returning +inf for infeasible and -value for feasible to align with 'HEURISTICS_VALUE_BEST_AS_LESSER_COST'.\nE_KNOWN_SOLUTION_INFEASIBLE:The provided KNOWN_SOLUTION violates the budget under the given costs. Remove or correct it; it cannot be used for validation in its current state.\nE_EXPECTED_SCORE_MISMATCH:The EXPECTED_SCORE_FROM_KNOWN_SOLUTION does not match the evaluation of the provided solution under either evaluator. Replace with a self-consistent pair, or compute expected via the standardized evaluator to prevent false positives.\nE_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide a concrete perturbation operator (e.g., k-exchange with feasibility repair) to enable ILS and SA restarts.\nE_NEIGHBOUR_COST_RECOMP:generate_neighbour recomputes sum(costs[j-1] for j in new_sol) in loops, O(n) per trial. Cache current_cost and use O(1) delta updates for add\/remove\/swap.\nE_REPAIR_HEURISTIC_WEAK:_repair drops highest-cost items only, ignoring value. Replace with worst-density removal (minimize value\/cost) or marginal-value drop to preserve objective quality while restoring feasibility.\nE_SWAP_LIMITED:Only 1-1 swaps are attempted with naive random selection. Add 1-2 and 2-1 exchanges guided by cost feasibility for deeper local moves in knapsack landscapes.\nE_RANDOM_MOVE_BIAS:Uniform random move_type selection underutilizes additions when near-empty and deletions when near-capacity. Make move probabilities adaptive to residual budget and neighborhood success rates.\nE_DUP_GUARD_POST:Feasibility check is post-hoc. Enforce set semantics on construction and maintain sorted invariant; also validate feasibility incrementally to avoid generating impossible neighbors.\nE_SA_API_FIX:Provide SA wrapper matching the target signature. Example signature (no instantiation of typing types, pass refs): def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): # run SA loop using evaluate_solution (minimization) and generate_neighbour.\nE_TS_API_FIX:Tabu Search must also match the same general signature. Internal taboo list should store moves (e.g., indices added\/removed) with integer tenure; add aspiration when a move yields a better best_score.\nE_ILS_ACCEPTANCE:Define explicit acceptance criterion for ILS (e.g., accept if new_score < curr_score or with simulated annealing-style probability). Without this, search stagnates after perturbation.\nE_PARAM_DEFAULTS:Missing robust defaults causes premature termination. Set SA: TEMP=1.0, MIN_TEMP=1e-4, cooling_factor=0.95; ILS: iterations=1000, acceptance_rate=0.05; TS: iterations=1000, taboo_list_size=50, taboo_duration=7. Tune per problem scale.\nE_SEED_CONTROL:Add deterministic seeding hook (e.g., other_params.get('seed',None)) to reproduce runs and verify fixes.\nE_UNIT_TESTS_MISSING:Add assertions to validate core invariants: (a) evaluate_solution(empty)=0 (minimization returns -0), (b) infeasible solutions return +inf (standardized evaluator), (c) neighbor always feasible or repaired and strictly set-unique, (d) objective non-increasing along accepted moves in minimization.\nE_OBJ_FUNC_UNUSED:objective_function (positive-max) is inconsistent with the heuristic\u2019s minimization flow. Remove or wrap it to avoid accidental misuse.\nR_OPERATOR_GUIDANCE:Bias add\/remove by value-density (value\/cost) and residual budget; when adding, prefer items with highest density that fit; when removing, drop lowest density first to preserve quality.\nR_PERTURB_SPECIFIC:Implement k-exchange perturbation: randomly remove r items (r~Uniform{1..3}) then greedily refill by density under budget with repair. Ensures controlled diversification without frequent infeasibility.\nR_TABU_ENCODING:Use attribute-based tabu on indices added\/removed, tenure proportional to |solution|, and aspiration if candidate improves best_score. This avoids cycling in small knapsack neighborhoods.\nR_CACHE_COST:Maintain current_cost alongside solution to enable O(1) feasibility checks in generate_neighbour and perturbation paths; eliminate repeated sums.\nR_STOPPING:Define consistent stopping across heuristics using max_iterations and no_improve_limit to avoid indefinite runs or premature exits.\nVALIDATION_CHECK:Using the provided evaluators, the given sample solution is feasible and evaluates correctly; the provided known solution is infeasible. Align datasets and expectations before benchmarking.\nACTION_ITEMS_ORDERED:1) Standardize evaluate_solution to minimization with +inf on infeasible. 2) Fix heuristic signatures to the TARGET_HEURISTIC_GENERAL_SIGNATURE and pass function references. 3) Remove List() instantiations. 4) Implement missing perturbation. 5) Optimize neighbor cost computations and repair by density. 6) Add unit tests and deterministic seeding. 7) Replace invalid known-solution pair with a feasible one consistent with the unified evaluator.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based item indices within [1,24].","Componentes":{"REPRESENTATION":"INDEX_LIST: list of unique 1-based item indices within [1,24].","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Feasibility-first minimization evaluator: return +inf if infeasible, else -total_value\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > 24 or idx in seen:\n            return math.inf\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return math.inf\n        total_value += values[idx - 1]\n    return -float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbouring feasible solution for INDEX_LIST.\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type is the representation string 'INDEX_LIST'.\n    Movement_Type in {'add','remove','swap'}.\n    \"\"\"\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    # Sanitize and canonicalize input\n    if isinstance(solution, list):\n        base = [i for i in solution if isinstance(i, int) and 1 <= i <= n_items]\n        base = sorted(set(base))\n    else:\n        base = []\n\n    def density(i: int) -> float:\n        c = costs[i-1]\n        v = values[i-1]\n        return (v \/ c) if c > 0 else 0.0\n\n    cur = list(base)\n    cur_cost = sum(costs[i-1] for i in cur)\n    residual = budget - cur_cost\n\n    # Decide move type adaptively\n    min_fit_cost = None\n    for i in range(1, n_items+1):\n        if i not in cur:\n            c = costs[i-1]\n            if c <= residual:\n                min_fit_cost = c if min_fit_cost is None else min(min_fit_cost, c)\n    add_bias = 0.6 if (min_fit_cost is not None) else 0.2\n    remove_bias = 0.6 if (residual < 10 or min_fit_cost is None) and len(cur) > 0 else 0.2\n    swap_bias = 1.0 - min(0.9, add_bias + remove_bias)  # keep probabilities summing to 1 within [0.1,1]\n\n    r = random.random()\n    if len(cur) == 0:\n        move_type = 'add'\n    elif r < add_bias:\n        move_type = 'add'\n    elif r < add_bias + remove_bias:\n        move_type = 'remove'\n    else:\n        move_type = 'swap'\n\n    new_sol = list(cur)\n    new_cost = cur_cost\n\n    if move_type == 'add':\n        # Candidates sorted by density high->low that fit\n        candidates = [i for i in range(1, n_items+1) if i not in new_sol and costs[i-1] <= residual]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        if candidates:\n            # pick among top-k to diversify\n            k = min(3, len(candidates))\n            choice = random.choice(candidates[:k])\n            new_sol.append(choice)\n            new_sol.sort()\n            new_cost += costs[choice-1]\n        else:\n            # fallback: if cannot add, attempt remove lowest-density\n            if new_sol:\n                worst = min(new_sol, key=density)\n                new_sol.remove(worst)\n                new_cost -= costs[worst-1]\n                move_type = 'remove'\n    elif move_type == 'remove' and new_sol:\n        # remove lowest density item\n        rem = min(new_sol, key=density)\n        new_sol.remove(rem)\n        new_cost -= costs[rem-1]\n    else:  # swap\n        if new_sol:\n            # remove lowest-density, try add highest-density that fits\n            out = min(new_sol, key=density)\n            base_cost = new_cost - costs[out-1]\n            candidates = [i for i in range(1, n_items+1) if i not in new_sol and (base_cost + costs[i-1] <= budget)]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            swapped = False\n            for inn in candidates[:5]:  # try top few\n                if inn == out:\n                    continue\n                new_sol.remove(out)\n                new_sol.append(inn)\n                new_sol.sort()\n                new_cost = base_cost + costs[inn-1]\n                swapped = True\n                break\n            if not swapped:\n                # if cannot swap, just remove the selected item\n                if out in new_sol:\n                    new_sol.remove(out)\n                    new_cost = base_cost\n                move_type = 'remove'\n        else:\n            move_type = 'add'\n\n    # Final feasibility guard (should already hold)\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in new_sol:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx-1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        # Simple repair: drop lowest-density items until feasible\n        new_sol.sort(key=lambda i: density(i))\n        total = sum(costs[i-1] for i in new_sol)\n        while new_sol and total > budget:\n            rem = new_sol.pop(0)\n            total -= costs[rem-1]\n        new_sol.sort()\n\n    return new_sol, 'INDEX_LIST', move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"k-exchange perturbation: remove r in {1..3} low-density items (with noise) then greedy refill by density.\"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    def density(i: int) -> float:\n        c = costs[i-1]\n        v = values[i-1]\n        return (v \/ c) if c > 0 else 0.0\n\n    # Sanitize\n    cur = []\n    if isinstance(solution, list):\n        cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    cur_cost = sum(costs[i-1] for i in cur)\n\n    # Remove phase\n    r = random.randint(1, 3)\n    if cur:\n        # noise: sample r items from a list biased to low density\n        ordered = sorted(cur, key=lambda i: (density(i) + 0.05*random.random()))\n        to_remove = ordered[:min(r, len(ordered))]\n        for idx in to_remove:\n            if idx in cur:\n                cur.remove(idx)\n                cur_cost -= costs[idx-1]\n\n    # Refill phase: greedy by density under residual budget\n    residual = budget - cur_cost\n    candidates = [i for i in range(1, n_items+1) if i not in cur]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n    for i in candidates:\n        c = costs[i-1]\n        if c <= residual:\n            cur.append(i)\n            cur_cost += c\n            residual -= c\n    cur.sort()\n\n    # Final feasibility check and minor repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in cur:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx-1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        cur.sort(key=lambda i: density(i))\n        total = sum(costs[i-1] for i in cur)\n        while cur and total > budget:\n            rem = cur.pop(0)\n            total -= costs[rem-1]\n        cur.sort()\n\n    return cur\n","SAMPLE_SOL":"[4,8,18]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Type List cannot be instantiated indicates runtime use of typing.List(). Replace any List() with list() and reserve typing.List for annotations only.\nSIG_MISMATCH:Heuristic signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and ensure all calls conform.\nFUNC_PASSING_ERROR:Passing generate_neighbour() and evaluate_solution() with parentheses in signatures triggers immediate invocation and type errors. Pass function objects without calling them.\nILS_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Define perturb_solution(solution, intensity, rng) returning a repaired feasible neighbor to enable ILS.\nEVAL_INCONSISTENCY:Three evaluators exist with conflicting contracts (objective_function: max without feasibility; EVAL_CODE: feasibility with -inf on violation; Evaluation Function: feasibility-first minimization returning +inf and negatives). Standardize on a single feasibility-first minimization evaluator returning +inf for infeasible and -value for feasible.\nBEST_SCORE_CONVENTION:For minimization-by-negation, initialize best_score=+inf and update if cand_score<best_score. Avoid mixing max-style comparators.\nKNOWN_SOLUTION_CHECK:Automated assertion: provided known solution is infeasible under the budget; evaluator returns infeasible. Align dataset or KNOWN_SOLUTION to a feasible candidate before using it for correctness checks.\nNB_OUTPUT_CONTRACT:Neighbour returns (new_sol,'INDEX_LIST','move'). Ensure all heuristics unpack this triple; if not, adapt to accept and use only new_sol for scoring while logging move type separately.\nNB_CODE_FAIL_LOCAL_OPT:Operator set limited to single add\/remove\/swap; lacks structured 1-1 exchange search. Add best-improving 1-1 exchange restricted to items within residual budget to escape local minima efficiently.\nNB_REPAIR_COST:Final feasibility repair sorts by density and pops; ensure it cannot introduce duplicates and maintains INDEX_LIST uniqueness. Current canonicalization removes dups but re-validate after swaps.\nNB_PERF_COST:Repeated sorting in neighbor generation and repair adds overhead. Cache densities once and maintain a running total cost to avoid recomputation and unnecessary sorts.\nINIT_SOLUTION:No explicit initializer. Provide a greedy-by-density feasible constructor to seed SA\/TS\/ILS with a strong baseline.\nSA_SIG_FIX:Implement def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,TEMP,MIN_TEMP,cooling_factor,rng) using function references, no typing constructors at runtime, and acceptance on delta = cand_score - curr_score (minimization sign).\nTS_SIG_FIX:Implement def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration,rng) and maintain a tabu list over moves or items consistent with returned Movement_Type.\nILS_SIG_FIX:Implement def ILS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,iterations,acceptance_rate,rng) with perturbation intensity scaling and acceptance based on improved score or probabilistic acceptance tied to acceptance_rate.\nEVAL_ASSERTION:Using the standardized feasibility-first minimization evaluator, the sample solution evaluates as feasible with finite negative score; the provided known solution evaluates as infeasible (+inf). Correct the reference set used by the local solver tests.\nREPR_CONSISTENCY:Ensure all components (heuristics, neighbor, perturb, evaluator) consume and produce 1-based, unique, sorted INDEX_LISTs within [1,24].\nSTOP_CRITERIA:Add deterministic iteration limits and temperature thresholds; avoid early termination on exceptions by validating neighbor feasibility before scoring.\nRNG_CONTROL:Add rng parameter to all stochastic components to ensure reproducibility and debuggability during local runs.\nCODE_SAFETY:Remove any filesystem\/network\/OS calls per MAIN_CRITICAL_INSTRUCTION. Keep all code pure and side-effect free.\nACTIONABLE_PATCH_SNIPPETS:\n- Replace any runtime typing usage: from typing import List -> use only in annotations; never call List().\n- Standard evaluator contract:\n  def eval_min(solution):\n      import math\n      costs=[110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n      values=[15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n      budget=90\n      if not isinstance(solution,list): return math.inf\n      seen=set(); tc=0; tv=0\n      for idx in solution:\n          if not isinstance(idx,int) or idx<1 or idx>24 or idx in seen: return math.inf\n          seen.add(idx); c=costs[idx-1]; tc+=c\n          if tc>budget: return math.inf\n          tv+=values[idx-1]\n      return -float(tv)\n- Heuristic comparator:\n  if cand_score < curr_score: accept unconditionally; else accept probabilistically (SA) or if not tabu (TS).\nTESTS_TO_ADD:\n- Unit-test that evaluate_solution([])==0 (returns -0.0) and infeasible returns +inf.\n- Verify neighbor always returns feasible or is repaired to feasible within budget \u2264 90 and unique indices.\n- Assert no component instantiates typing types; grep for 'List(' and replace with 'list('.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based indices within [1,24], sorted ascending, representing selected items under budget.","Componentes":{"REPRESENTATION":"INDEX_LIST: list of unique 1-based indices within [1,24], sorted ascending, representing selected items under budget.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Feasibility-first minimization evaluator for INDEX_LIST.\n    Returns +inf if infeasible; otherwise returns -total_value (to minimize).\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if (not isinstance(idx, int)) or idx < 1 or idx > 24 or idx in seen:\n            return math.inf\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return math.inf\n        total_value += values[idx - 1]\n    return -float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbouring feasible solution for INDEX_LIST.\n    Returns (new_solution, 'INDEX_LIST', move_type) where move_type in {'add','remove','swap'}.\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    # Canonicalize input to a sorted unique INDEX_LIST within domain\n    if isinstance(solution, list):\n        base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    else:\n        base = []\n\n    def density(i: int) -> float:\n        c = costs[i - 1]\n        v = values[i - 1]\n        return (v \/ c) if c > 0 else 0.0\n\n    cur = list(base)\n    cur_cost = sum(costs[i - 1] for i in cur)\n    residual = budget - cur_cost\n\n    # Determine move type adaptively\n    add_possible = any((i not in cur) and (costs[i - 1] <= residual) for i in range(1, n_items + 1))\n    if not cur:\n        move_type = 'add'\n    else:\n        r = random.random()\n        if add_possible and r < 0.5:\n            move_type = 'add'\n        elif r < 0.8:\n            move_type = 'remove'\n        else:\n            move_type = 'swap'\n\n    new_sol = list(cur)\n    new_cost = cur_cost\n\n    if move_type == 'add':\n        candidates = [i for i in range(1, n_items + 1) if i not in new_sol and costs[i - 1] <= residual]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        if candidates:\n            k = min(3, len(candidates))\n            choice = random.choice(candidates[:k])\n            new_sol.append(choice)\n            new_sol = sorted(set(new_sol))\n            new_cost += costs[choice - 1]\n        else:\n            move_type = 'remove'\n    if move_type == 'remove' and new_sol:\n        rem = min(new_sol, key=density)\n        new_sol.remove(rem)\n        new_cost -= costs[rem - 1]\n    elif move_type == 'swap' and new_sol:\n        out = min(new_sol, key=density)\n        base_cost = new_cost - costs[out - 1]\n        candidates = [i for i in range(1, n_items + 1) if i not in new_sol and (base_cost + costs[i - 1] <= budget)]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        if candidates:\n            inn = candidates[0]\n            new_sol.remove(out)\n            new_sol.append(inn)\n            new_sol = sorted(set(new_sol))\n            new_cost = base_cost + costs[inn - 1]\n        else:\n            # fallback to remove\n            new_sol.remove(out)\n            new_cost = base_cost\n            move_type = 'remove'\n\n    # Final feasibility guard and repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in new_sol:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx - 1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        # Drop lowest-density items until feasible\n        new_sol.sort(key=lambda i: density(i))\n        total = sum(costs[i - 1] for i in new_sol)\n        while new_sol and total > budget:\n            rem = new_sol.pop(0)\n            total -= costs[rem - 1]\n        new_sol = sorted(set(new_sol))\n\n    return new_sol, 'INDEX_LIST', move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    k-exchange perturbation: remove 1..3 lowest-density (with noise), then greedy refill by density.\n    Returns a repaired feasible INDEX_LIST.\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    def density(i: int) -> float:\n        c = costs[i - 1]\n        v = values[i - 1]\n        return (v \/ c) if c > 0 else 0.0\n\n    # Sanitize current solution\n    cur = []\n    if isinstance(solution, list):\n        cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    cur_cost = sum(costs[i - 1] for i in cur)\n\n    # Remove phase\n    if cur:\n        r = random.randint(1, 3)\n        ordered = sorted(cur, key=lambda i: (density(i) + 0.05 * random.random()))\n        to_remove = ordered[:min(r, len(ordered))]\n        for idx in to_remove:\n            if idx in cur:\n                cur.remove(idx)\n                cur_cost -= costs[idx - 1]\n\n    # Refill phase: greedy by density within residual budget\n    residual = budget - cur_cost\n    candidates = [i for i in range(1, n_items + 1) if i not in cur]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n    for i in candidates:\n        c = costs[i - 1]\n        if c <= residual:\n            cur.append(i)\n            cur_cost += c\n            residual -= c\n    cur = sorted(set(cur))\n\n    # Final feasibility check and repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in cur:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx - 1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        cur.sort(key=lambda i: density(i))\n        total = sum(costs[i - 1] for i in cur)\n        while cur and total > budget:\n            rem = cur.pop(0)\n            total -= costs[rem - 1]\n        cur = sorted(set(cur))\n\n    return cur\n","SAMPLE_SOL":"[4,8,18]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0.1\"\n\"FEEDBACK\":\"E_SOLVER_CRASH:Type List cannot be instantiated; replace all List() constructor uses with list() and never instantiate typing.List.;FIX_LOCAL_SOLVER_ERRORS_FIRST\nSIG_DEF_ERROR:Function signatures show parentheses on parameters (e.g., generate_neighbour()); parameters must be bare callables without parentheses.;UPDATE_SIGNATURES\nPERTURB_MISSING:$Perturb placeholder not implemented; ILS cannot run without a concrete perturbation.;ADD_PERTURB:Implement k-shake (remove \u22642 low-density items, then add best-density items within budget)\nTYPE_HINT_MISUSE:typing.List imported and used as a constructor.;REPLACE:Use built-in list() and keep typing.List only in annotations\nEVAL_SIGN_CONVENTION_MISMATCH:Heuristics expect minimization (lower is better via negatives), but objective_function returns positive value; mixing them causes incorrect acceptance\/comparison.;STANDARDIZE:Use the provided feasibility-first minimization evaluate_solution everywhere and ensure all comparisons are on that scale\nKNOWN_TEST_INFEASIBLE:Provided test solution evaluates to infeasible (+inf) while an expected finite score is stated.;FIX_TESTS:Replace the infeasible test vector with a feasible one and recompute expected score via the evaluator\nEVAL_ASSERTION:Evaluator correctly returns +inf on infeasible and -value on feasible; test harness must assert isfinite(score) before using.;ADD_GUARDS:Guard all best\/better checks with math.isfinite\nNB_CODE_FEAS_REPAIR:Neighbour may still overshoot budget before final repair; unnecessary sorts increase overhead.;IMPROVE:Maintain running cost and prune candidates by residual before sorting; avoid full sorts by selecting top-k via nth-element or heap\nNB_OPERATOR_SCOPE_LIMITED:Only single add\/remove\/swap; exploration may stagnate.;AUGMENT:Add 1-1 replace-best, 2-removal + greedy refill, and try best-improvement scan over small candidate list\nDENSITY_HEURISTIC_BIAS:Pure v\/c density can reject high absolute value low-cost combos;.;HYBRID_SCORE:Rank by lexicographic (-value, -value\/cost, cost) or use surrogate Lagrangian weights\nR_REP_CANONICAL:Representation requires sorted unique indices; ensure all operators re-sort after modifications.;ENFORCE:sort and deduplicate once per move; validate with assertions\nSA_ACCEPT_RULE:Acceptance likely computed on raw values; with minimization evaluator use \u0394 = new_score - cur_score and accept if \u0394 < 0 or rand < exp(-\u0394\/T).;FIX_SA:Align acceptance with minimization and clamp exponent\nSA_COOLING:Cooling_factor unspecified\/stability unclear.;RECOMMEND_GEOM:Use T*=alpha*T with alpha in [0.90,0.99] and reheats on stagnation; stop when T<MIN_TEMP or no improvement for K iterations\nTS_TABU_ATTR:Tabu list content unspecified; risk of ineffectiveness.;DEFINE_ATTR:Store move attributes as tuples (added, removed) with tenure; implement aspiration if new_score < best_score\nTS_MEMORY:Potential unbounded memory churn on tabu container.;BOUNDED_STRUCT:Use fixed-size deque or circular buffer; decrement durations per iteration\nILS_ACCEPT:Parameter aceptance_rate misspelled and acceptance rule unspecified.;FIX_NAMING:acceptance_rate;RULE:Accept perturbation if new_score <= incumbent or with p based on SA-like criterion\nE_CODE_PERF:Neighbour generation sorts O(n log n) each step.;OPTIMIZE:Precompute arrays, maintain residual, and select candidates via partial selection O(n) or heap O(n log k)\nRANDOM_SEEDING:Stochastic components non-reproducible.;SET_SEED:Expose seed param and seed RNGs at start of each run\nINPUT_VALIDATION:Signatures lack strict type checks for INDEX_LIST domain.;ADD_CHECKS:Assert ints in [1,n], uniqueness, and feasibility before evaluation\nTERMINATION_CRITERIA:Not specified per heuristic; may loop excessively.;ADD_LIMITS:Max iters, max stall, and time budget caps\nCOMPAT_CONSTRAINT:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.;VERIFY:Audit code to remove any filesystem\/network\/OS calls\nUNIT_TESTS:Current tests allow infeasible cases to pass earlier stages.;ADD_CASES:Test duplicates, out-of-range indices, over-budget selections, empty solution, and random valid solutions\nEVAL_WITH_TOOL:Evaluator confirms test vector infeasible (+inf) and detects mismatch with expected score.;ACTION:Update expected score to match evaluator and fix data drift\nREPRO_METRICS:Report best_score (minimization), best_solution (INDEX_LIST), iterations, and feasibility flag.;LOG:Collect acceptance counts, improvements, and temperature\/tenure traces for debugging\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"def evaluate_solution(solution):\n    import math\n    # Encoded problem data (1-based indexing; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    # Return cost (lower is better). Use +inf for infeasible, and negative profit for feasible.\n    if not isinstance(solution, list):\n        return math.inf\n    sel = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > 9:\n        return math.inf\n    profit = sum(values[i] for i in sel)\n    return -float(profit)\n","NB_CODE":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Ensure list copy\n    cur = list(solution) if isinstance(solution, list) else []\n    # Keep indices within [1,24]\n    valid_indices = list(range(1, 25))\n    sel_set = {i for i in cur if isinstance(i, int) and 1 <= i <= 24}\n    move_types = [\"add\", \"drop\", \"swap\"]\n    move = random.choice(move_types)\n    new_sel = set(sel_set)\n\n    if move == \"add\":\n        candidates = [i for i in valid_indices if i not in new_sel]\n        if candidates:\n            new_sel.add(random.choice(candidates))\n        else:\n            move = \"drop\"\n    if move == \"drop\":\n        if new_sel:\n            new_sel.remove(random.choice(list(new_sel)))\n        else:\n            move = \"add\"\n            candidates = [i for i in valid_indices if i not in new_sel]\n            if candidates:\n                new_sel.add(random.choice(candidates))\n    if move == \"swap\":\n        if new_sel and len(new_sel) < len(valid_indices):\n            out_idx = random.choice(list(new_sel))\n            in_candidates = [i for i in valid_indices if i not in new_sel]\n            in_idx = random.choice(in_candidates) if in_candidates else out_idx\n            new_sel.remove(out_idx)\n            new_sel.add(in_idx)\n        else:\n            move = \"add\" if not new_sel else \"drop\"\n            if move == \"add\":\n                candidates = [i for i in valid_indices if i not in new_sel]\n                if candidates:\n                    new_sel.add(random.choice(candidates))\n            else:\n                new_sel = set()\n\n    new_solution = list(new_sel)\n    return new_solution, \"IndexList\", move\n","PERTURB_CODE":"def perturb_solution(solution):\n    import random\n    # Multi-move perturbation applying several random neighbor moves\n    cur = list(solution) if isinstance(solution, list) else []\n    steps = 3\n    for _ in range(steps):\n        neighbor, _nbt, _mvt = generate_neighbour(cur) if callable(globals().get(\"generate_neighbour\", None)) else (cur, \"IndexList\", \"noop\")\n        cur = list(neighbor)\n    return cur\n","SAMPLE_SOL":"[9,19,2,15]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_IFACE:Neighbour function returns 3 values but solvers expect 2 (SA\/ILS errors: 'too many values to unpack'; TS error: 'not enough values to unpack'). Standardize to a single interface. FIX: return exactly (new_solution, move_type) for all solvers, or only (new_solution) and have solvers ignore move_type.\"\n\"FEEDBACK\",\"E_NEIGHBOUR_SIG_MISMATCH:Target signature declares generate_neighbour as a callable argument, but SA\/ILS\/TS definitions in logs use positional call signatures that differ from TARGET_HEURISTIC_GENERAL_SIGNATURE. FIX: Refactor all heuristics to 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' and unpack outputs consistently.\"\n\"FEEDBACK\",\"E_NEIGHBOUR_PAYLOAD:Returned tuple includes 'IndexList' string which is unused and causes arity issues. REMOVE this field.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Operator set is naive and capacity-agnostic; many generated moves are infeasible, increasing rejection rate. IMPROVE: add feasibility-aware candidate filtering for 'add' and 'swap' (only add if gallons fit; only swap if new total <= capacity).\"\n\"FEEDBACK\",\"NB_CODE_RANDOM_ONLY:Pure random choice among add\/drop\/swap leads to thrashing. IMPROVE: biased selection favoring improving or feasible moves; include 2-opt style swap-with-repair and greedy-add of best value\/weight ratio among feasible candidates.\"\n\"FEEDBACK\",\"E_EVAL_SIGN_CONSISTENCY:Heuristics use 'lower is better', but OBJ_CODE returns positive profit without capacity check while EVAL_CODE returns -profit with feasibility. FIX: align objective and evaluation\u2014either remove OBJ_CODE from use or make it return -profit and +inf on infeasible; do not expose unconstrained objective to the local solver.\"\n\"FEEDBACK\",\"E_DATA_BOUND_MISMATCH:Arrays contain an extra trailing element (values\/gallons length allows index 25), while valid indices are clamped to 1..24. This creates dead data and ambiguity. FIX: trim arrays to 24 items (index 0 unused), or expand valid_indices bound to match arrays and problem definition consistently.\"\n\"FEEDBACK\",\"E_SAMPLE_INFEASIBLE:Provided Sample Solution violates capacity hard (total gallons >> capacity), masking solver health. FIX: replace sample with a small feasible seed; also provide a fast greedy feasible constructor.\"\n\"FEEDBACK\",\"E_PERTURB_ABSENT:Perturbation Function is undefined ($Perturb placeholder). ILS cannot run. FIX: implement perturbation (e.g., k-random removals + greedy refill) returning a valid INDEX_LIST.\"\n\"FEEDBACK\",\"E_TS_MEMORY:No tabu attributes defined (move type\/indices), and neighbour returns non-deterministic sets (unordered), undermining tabu checks. FIX: return ordered list; track tabu on specific add\/drop (item ids) with tenure; store and reuse last move metadata.\"\n\"FEEDBACK\",\"R_SET_NONDETERMINISM:Using set() discards order, causing state aliasing and unstable neighbourhood sizes. IMPROVE: maintain a sorted list representation but enforce 0-1 membership via a boolean vector or sorted list; this stabilizes hashing and tabu.\"\n\"FEEDBACK\",\"E_PERF_DELTA:Full re-evaluation O(n) each move. IMPROVE: maintain running totals (profit, gallons) and update in O(1) using move deltas; guard with feasibility checks.\"\n\"FEEDBACK\",\"E_COOLING_UNSPECIFIED:SA parameters (TEMP, MIN_TEMP, cooling_factor) undefined in the target interface. FIX: pass via other_params dict and validate; adopt geometric cooling with reheats on stagnation.\"\n\"FEEDBACK\",\"E_ACCEPTANCE_ILS:ILS signature shows 'aceptance_rate' misspelled and unspecified acceptance criterion. FIX: define clear acceptance (e.g., accept if cost improves or with SA-style probability using other_params['temp']).\"\n\"FEEDBACK\",\"E_STOP_CRITERIA:Missing iteration\/time\/plateau limits yields inconsistent runs. FIX: add max_iters, max_no_improve, and wall-clock budget in other_params.\"\n\"FEEDBACK\",\"E_SEED_CONTROL:No RNG seeding, harming reproducibility. FIX: accept seed in other_params and set random.seed(seed) at heuristic entry.\"\n\"FEEDBACK\",\"E_VALIDATION_INTEGRITY:Known solution fails feasibility under current evaluate_solution and data. ACTION: reconcile dataset vs. KNOWN_SOLUTION; re-derive or correct the arrays so the provided reference becomes feasible under capacity.\"\n\"FEEDBACK\",\"E_ASSERTS_MISSING:Add runtime assertions to catch interface mismatches early (neighbour arity, type checks, bounds).\"\n\"FEEDBACK\",\"R_STR_INADEQUATE_FOR_SEARCH:Pure index list with unrestricted add\/drop hampers guided exploration under tight capacity. IMPROVE: switch to fixed-length 0-1 bitvector or enforce feasibility-preserving moves; optionally track residual capacity.\"\n\"FEEDBACK\",\"SUGGESTED_PATCH_generate_neighbour:def generate_neighbour(solution):\\n    import random\\n    # enforce ordered, feasible-aware moves; return exactly (new_solution, move_type)\\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\\n    CAP = 9\\n    cur = [i for i in solution if isinstance(i,int) and 1<=i<=24]\\n    cur = sorted(set(cur))\\n    w_cur = sum(gallons[i] for i in cur)\\n    valid = list(range(1,25))\\n    move = random.choice([\\\"add\\\",\\\"drop\\\",\\\"swap\\\"]) if cur else \\\"add\\\"\\n    if move == \\\"add\\\":\\n        feas = [i for i in valid if i not in cur and w_cur + gallons[i] <= CAP]\\n        if not feas:\\n            move = \\\"drop\\\"\\n        else:\\n            i = random.choice(feas)\\n            return (sorted(cur+[i]), \\\"add\\\")\\n    if move == \\\"drop\\\":\\n        if cur:\\n            i = random.choice(cur)\\n            nxt = [x for x in cur if x!=i]\\n            return (nxt, \\\"drop\\\")\\n        else:\\n            # fallback to best feasible add\\n            feas = [i for i in valid if gallons[i] <= CAP]\\n            if feas:\\n                i = max(feas, key=lambda j: values[j]\/gallons[j] if gallons[j]>0 else values[j])\\n                return ([i], \\\"add\\\")\\n    # swap\\n    if cur:\\n        outs = cur\\n        ins = [i for i in valid if i not in cur]\\n        random.shuffle(outs); random.shuffle(ins)\\n        for o in outs:\\n            for i in ins:\\n                if w_cur - gallons[o] + gallons[i] <= CAP:\\n                    nxt = sorted([x for x in cur if x!=o] + [i])\\n                    return (nxt, \\\"swap\\\")\\n    # fallback: return current\\n    return (cur, \\\"noop\\\")\"\n\"FEEDBACK\",\"SUGGESTED_PATCH_evaluate_solution:def evaluate_solution(solution):\\n    import math\\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\\n    CAP = 9\\n    if not isinstance(solution, list):\\n        return math.inf\\n    sel = sorted({i for i in solution if isinstance(i,int) and 1<=i<=24})\\n    w = sum(gallons[i] for i in sel)\\n    if w > CAP:\\n        return math.inf\\n    p = sum(values[i] for i in sel)\\n    return -float(p)\"\n\"FEEDBACK\",\"SUGGESTED_PATCH_interface_usage:# Heuristic wrapper example (unified):\\n# def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n#     import random\\n#     rng_seed = other_params.get('seed', None)\\n#     if rng_seed is not None:\\n#         random.seed(rng_seed)\\n#     cur = sorted(set(currentSolution))\\n#     cur_score = evaluate_solution(cur)\\n#     best_sol, best_sc = list(best), best_score\\n#     iters = other_params.get('iterations', 1000)\\n#     for _ in range(iters):\\n#         nxt, mv = generate_neighbour(cur)\\n#         sc = evaluate_solution(nxt)\\n#         if sc < cur_score:\\n#             cur, cur_score = nxt, sc\\n#             if sc < best_sc:\\n#                 best_sol, best_sc = nxt, sc\\n#     return best_sol, best_sc\"\n\"FEEDBACK\",\"E_KNOWN_BEST_VALIDATION:Automated validation using the provided evaluation function flags the reference solution as infeasible. ACTION: update either the reference or the data so that the validation passes under current constraints.\"\n\"FEEDBACK\",\"E_TESTS_MISSING:Add unit tests: neighbour arity, feasibility preservation, evaluation sign, and deterministic seeding. Include a quick greedy baseline to cross-check heuristic outputs.\"\n\"FEEDBACK\",\"E_DOC_PARAMS:Clearly document other_params keys: iterations, seed, temp, min_temp, cooling_factor, accept_prob, tabu_size, tabu_tenure, etc., and enforce via defaults + validation.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"def evaluate_solution(solution):\n    import math\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\n    CAP = 9\n    if not isinstance(solution, list):\n        return math.inf\n    sel = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > CAP:\n        return math.inf\n    profit = sum(values[i] for i in sel)\n    # Return cost (lower is better) using negative profit\n    return -float(profit)","NB_CODE":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\n    CAP = 9\n    # Sanitize and order\n    cur = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n    w_cur = sum(gallons[i] for i in cur)\n    v_cur = sum(values[i] for i in cur)\n    valid = list(range(1, 25))\n    move = random.choice([\"add\", \"drop\", \"swap\"]) if cur else \"add\"\n    # ADD: choose among feasible additions; bias toward higher value density\n    if move == \"add\":\n        feas = [i for i in valid if i not in cur and w_cur + gallons[i] <= CAP]\n        if feas:\n            # pick best among top-k by value\/weight ratio\n            feas_sorted = sorted(feas, key=lambda j: (values[j] \/ gallons[j] if gallons[j] > 0 else values[j]), reverse=True)\n            k = min(3, len(feas_sorted))\n            i = random.choice(feas_sorted[:k])\n            return (sorted(cur + [i]), \"add\")\n        # fallback to drop if no feasible add\n    # DROP: remove a random item\n    if move == \"drop\":\n        if cur:\n            i = random.choice(cur)\n            nxt = [x for x in cur if x != i]\n            return (nxt, \"drop\")\n        # if empty, try best feasible single add\n        feas = [i for i in valid if gallons[i] <= CAP]\n        if feas:\n            i = max(feas, key=lambda j: values[j] \/ gallons[j] if gallons[j] > 0 else values[j])\n            return ([i], \"add\")\n    # SWAP: try feasible swap; prefer improving swaps\n    if move == \"swap\" and cur:\n        outs = list(cur)\n        ins = [i for i in valid if i not in cur]\n        candidates = []\n        for o in outs:\n            for i in ins:\n                new_w = w_cur - gallons[o] + gallons[i]\n                if new_w <= CAP:\n                    delta_v = values[i] - values[o]\n                    candidates.append((delta_v, o, i))\n        if candidates:\n            # prefer improving or neutral swaps; sample among top candidates\n            candidates.sort(key=lambda t: t[0], reverse=True)\n            top = [c for c in candidates if c[0] >= 0] or candidates[:min(5, len(candidates))]\n            _, o, i = random.choice(top)\n            nxt = sorted([x for x in cur if x != o] + [i])\n            return (nxt, \"swap\")\n    # Final fallback: return current as noop\n    return (cur, \"noop\")","PERTURB_CODE":"def perturb_solution(solution):\n    import random\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\n    CAP = 9\n    # Clean current solution\n    cur = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n    # Step 1: random removals (k in {1,2})\n    if cur:\n        k = 1 if len(cur) == 1 else random.choice([1, 2])\n        to_remove = set(random.sample(cur, min(k, len(cur))))\n        cur = [i for i in cur if i not in to_remove]\n    # Step 2: greedy refill by value\/weight ratio until capacity\n    def total_weight(sol):\n        return sum(gallons[i] for i in sol)\n    def total_value(sol):\n        return sum(values[i] for i in sol)\n    remaining = CAP - total_weight(cur)\n    candidates = [i for i in range(1, 25) if i not in cur and gallons[i] <= remaining]\n    # Greedy iterative fill\n    while candidates:\n        # pick best ratio; if tie, higher value\n        best = max(candidates, key=lambda j: ((values[j] \/ gallons[j]) if gallons[j] > 0 else values[j], values[j]))\n        if gallons[best] <= remaining:\n            cur.append(best)\n            cur = sorted(cur)\n            remaining = CAP - total_weight(cur)\n            candidates = [i for i in range(1, 25) if i not in cur and gallons[i] <= remaining]\n        else:\n            break\n    return cur","SAMPLE_SOL":"[4,8,18]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_DATA_INCONSISTENT: Values\/gallons arrays differ across OBJ_CODE\/EVAL_CODE\/Components (lengths 25 vs 24; indices up to 24 but arrays only defined to 23 in Components). Standardize to n=24 with arrays sized 25 (0..24) or n=23 with arrays sized 24 (0..23). Current mismatch causes IndexError.\n\nE_INDEX_RANGE: generate_neighbour uses valid=range(1,25) but Components arrays end at index 23. Accessing 24 triggers list index out of range. Align valid range to the data.\n\nE_CAPACITY_MISMATCH: CAP=9 in Components; PROBLEM_DEF and OBJ_CODE\/EVAL_CODE variants imply different item sets. Some provided sample\/known solutions are infeasible with the Components data. Ensure a single source of truth for CAP and item lists.\n\nE_KNOWN_SCORE_MISMATCH: EXPECTED_SCORE_FROM_KNOWN_SOLUTION does not match any provided data arrays. This invalidates automated correctness checks. Recompute expected score after data is fixed.\n\nE_PERTURB_MISSING: Perturbation Function is a placeholder ($Perturb). ILS cannot run without a defined perturbation operator consistent with the representation and capacity constraint.\n\nE_HEURISTIC_SIGNATURE_DRIFT: Reported SA\/ILS\/TS signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Provide a thin wrapper with the standard signature to prevent invocation errors.\n\nE_INFEASIBLE_EVAL_COST: Components evaluate_solution returns +inf for infeasible and negative profit for feasible, which is correct for minimization, but OBJ_CODE\/EVAL_CODE variants return -inf for infeasible or maximize directly. This inconsistency breaks comparability. Unify to a single convention: cost = -profit for feasible, +inf for infeasible.\n\nE_SET_SORT_OVERHEAD: Components sanitize via set then sorted each call; unnecessary sorting increases overhead and can change neighbor semantics. Use tuple(sorted) only when needed and maintain list order otherwise.\n\nE_NEIGHBOUR_SCOPE_LIMITED: Only 1-1 swaps are attempted; misses profitable k-exchanges (1-2, 2-1) important in tight-capacity knapsack. This limits escape from local optima.\n\nE_RNG_BIAS: ADD move picks among top-k density; without temperature\/acceptance linkage, search may quickly stagnate. Introduce adaptive k or occasional uniform exploration.\n\nE_FEASIBILITY_FALLBACK_WEAK: When no feasible add, DROP picks uniformly random item; this can degrade good partials. Prefer dropping items with lowest value density or highest weight to restore feasibility.\n\nE_DUPLICATE_HANDLING: Using a set removes duplicates but also silently ignores invalid inputs; this can mask generator bugs. Add explicit validation and raise\/return a diagnostic penalty for invalid indices.\n\nE_LOCAL_SOLVER_ERROR_REPRO: Simulated_Annealing\/ILS\/TS all fail with IndexError. Root cause is array\/index mismatch. Fix data first before tuning heuristic parameters.\n\nR_FIX_1: Unify data in a single module; define N=24; arrays sized 25 with 1-based indexing; CAP=9. Example fully runnable replacements:\ndef get_data():\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17][:25]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9][:25]\n    return values, gallons, 9, 24\n\nR_FIX_2: Correct evaluation (minimization-compatible, capacity-aware):\ndef evaluate_solution(solution):\n    import math\n    values, gallons, CAP, N = get_data()\n    if not isinstance(solution, list):\n        return math.inf\n    sel = []\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= N and i not in seen:\n            sel.append(i); seen.add(i)\n    total_w = sum(gallons[i] for i in sel)\n    if total_w > CAP:\n        return math.inf\n    profit = sum(values[i] for i in sel)\n    return -float(profit)\n\nR_FIX_3: Align neighbour to data bounds and feasibility, and add 1-2\/2-1 exchanges:\ndef generate_neighbour(solution):\n    import random\n    values, gallons, CAP, N = get_data()\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= N and i not in seen:\n                cur.append(i); seen.add(i)\n    w_cur = sum(gallons[i] for i in cur)\n    valid = list(range(1, N+1))\n    move = random.choice(['add','drop','swap','kex']) if cur else 'add'\n    if move == 'add':\n        feas = [i for i in valid if i not in seen and w_cur + gallons[i] <= CAP]\n        if feas:\n            feas.sort(key=lambda j: (values[j]\/gallons[j]))\n            pick = random.choice(feas[-min(3, len(feas)):])\n            return (sorted(cur+[pick]), 'add')\n    if move == 'drop' and cur:\n        drop = min(cur, key=lambda j: (values[j]\/max(1,gallons[j])))\n        nxt = [x for x in cur if x != drop]\n        return (nxt, 'drop')\n    if move == 'swap' and cur:\n        best = None\n        for o in cur:\n            for i in valid:\n                if i in seen: continue\n                if w_cur - gallons[o] + gallons[i] <= CAP:\n                    dv = values[i]-values[o]\n                    if best is None or dv > best[0]:\n                        best = (dv, o, i)\n        if best:\n            _, o, i = best\n            nxt = sorted([x for x in cur if x != o] + [i])\n            return (nxt, 'swap')\n    if move == 'kex' and cur:\n        others = [i for i in valid if i not in seen]\n        # attempt 1-2 or 2-1 exchange\n        # 1->2\n        for o in cur:\n            for i1 in others:\n                for i2 in others:\n                    if i1 >= i2: continue\n                    new_w = w_cur - gallons[o] + gallons[i1] + gallons[i2]\n                    if new_w <= CAP:\n                        dv = values[i1] + values[i2] - values[o]\n                        if dv >= 0:\n                            nxt = sorted([x for x in cur if x != o] + [i1, i2])\n                            return (nxt, '1-2')\n        # 2->1\n        if len(cur) >= 2:\n            for a in range(len(cur)):\n                for b in range(a+1, len(cur)):\n                    o1, o2 = cur[a], cur[b]\n                    for i in others:\n                        new_w = w_cur - gallons[o1] - gallons[o2] + gallons[i]\n                        if new_w <= CAP:\n                            dv = values[i] - (values[o1] + values[o2])\n                            if dv >= 0:\n                                nxt = sorted([x for x in cur if x not in (o1,o2)] + [i])\n                                return (nxt, '2-1')\n    return (sorted(cur), 'noop')\n\nR_FIX_4: Provide perturbation for ILS (e.g., random multi-drop-add bounded by CAP):\ndef perturb_solution(solution, strength=2):\n    import random\n    values, gallons, CAP, N = get_data()\n    cur = sorted({i for i in solution if isinstance(i,int) and 1 <= i <= N})\n    for _ in range(strength):\n        if cur:\n            cur.pop(random.randrange(len(cur)))\n    w = sum(gallons[i] for i in cur)\n    candidates = [i for i in range(1, N+1) if i not in cur]\n    random.shuffle(candidates)\n    for i in candidates:\n        if w + gallons[i] <= CAP:\n            cur.append(i); w += gallons[i]\n    return sorted(cur)\n\nR_FIX_5: Signature wrapper to comply with TARGET_HEURISTIC_GENERAL_SIGNATURE; keep internals unchanged:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    # Implement SA\/ILS\/TS dispatch via other_params['algo'] and ensure no out-of-range indices by using the unified data and neighbour.\n\nR_VALIDATION: After unifying data and functions, assert: \n- No IndexError when enumerating all indices 1..N.\n- evaluate_solution returns +inf for infeasible solutions and finite negative costs for feasible ones.\n- Known-solution check passes internally (do not expose values); if mismatch persists, recompute expected score.\n\nR_PERF: Cache per-item (value, weight, density) and current aggregate weight\/profit to reduce O(n) recomputation in neighbour\/evaluator. Maintain updates incrementally on moves.\n\nR_LOGGING: Enable debug counters for move types and acceptance to detect stagnation; increase exploration if add\/swap success rate < threshold.\n\nR_TESTS: Unit tests for boundary cases: empty solution, full feasible pack, items at capacity limit, duplicate indices, out-of-range indices.\n\nACTION_ORDER: \n1) Unify data and index ranges (fix IndexError). \n2) Align evaluation convention and signatures. \n3) Implement perturbation. \n4) Add k-exchanges and better drop policy. \n5) Validate against internal known-solution check and update EXPECTED score accordingly.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"def evaluate_solution(solution):\n    import math\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n    if not isinstance(solution, list):\n        return math.inf\n    sel = []\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= N and i not in seen:\n            sel.append(i)\n            seen.add(i)\n    total_w = sum(gallons[i] for i in sel)\n    if total_w > CAP:\n        return math.inf\n    profit = sum(values[i] for i in sel)\n    # Minimization-compatible: lower cost is better; use negative profit\n    return -float(profit)\n","NB_CODE":"def generate_neighbour(solution):\n    import random, math\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n    # Sanitize current solution to unique, valid indices preserving first occurrence order\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= N and i not in seen:\n                cur.append(i)\n                seen.add(i)\n    else:\n        cur = []\n        seen = set()\n    w_cur = sum(gallons[i] for i in cur)\n    valid = list(range(1, N + 1))\n    move = random.choice(['add', 'drop', 'swap', 'kex']) if cur else 'add'\n    # ADD move: choose a feasible item, biased by value density\n    if move == 'add':\n        feas = [i for i in valid if i not in seen and w_cur + gallons[i] <= CAP]\n        if feas:\n            feas.sort(key=lambda j: (values[j] \/ gallons[j]))\n            pick = random.choice(feas[-min(3, len(feas)):])\n            nxt = sorted(cur + [pick])\n            return (nxt, 'add')\n    # DROP move: remove the lowest density item to free capacity\n    if move == 'drop' and cur:\n        drop = min(cur, key=lambda j: (values[j] \/ max(1, gallons[j])))\n        nxt = [x for x in cur if x != drop]\n        return (nxt, 'drop')\n    # SWAP move: best improving or neutral 1-1 swap within capacity\n    if move == 'swap' and cur:\n        best = None\n        for o in cur:\n            for i in valid:\n                if i in seen:\n                    continue\n                new_w = w_cur - gallons[o] + gallons[i]\n                if new_w <= CAP:\n                    dv = values[i] - values[o]\n                    if (best is None) or (dv > best[0]) or (dv == best[0] and gallons[i] < gallons[o]):\n                        best = (dv, o, i)\n        if best is not None:\n            _, o, i = best\n            nxt = sorted([x for x in cur if x != o] + [i])\n            return (nxt, 'swap')\n    # K-EXCHANGE: try quick 1-2 or 2-1 non-worsening exchanges\n    if move == 'kex' and cur:\n        others = [i for i in valid if i not in seen]\n        # 1 -> 2\n        for o in cur:\n            for idx1 in range(len(others)):\n                i1 = others[idx1]\n                for idx2 in range(idx1 + 1, len(others)):\n                    i2 = others[idx2]\n                    new_w = w_cur - gallons[o] + gallons[i1] + gallons[i2]\n                    if new_w <= CAP:\n                        dv = values[i1] + values[i2] - values[o]\n                        if dv >= 0:\n                            nxt = sorted([x for x in cur if x != o] + [i1, i2])\n                            return (nxt, '1-2')\n        # 2 -> 1\n        if len(cur) >= 2:\n            for a in range(len(cur)):\n                for b in range(a + 1, len(cur)):\n                    o1, o2 = cur[a], cur[b]\n                    for i in others:\n                        new_w = w_cur - gallons[o1] - gallons[o2] + gallons[i]\n                        if new_w <= CAP:\n                            dv = values[i] - (values[o1] + values[o2])\n                            if dv >= 0:\n                                nxt = sorted([x for x in cur if x not in (o1, o2)] + [i])\n                                return (nxt, '2-1')\n    # No change fallback\n    return (sorted(cur), 'noop')\n","PERTURB_CODE":"def perturb_solution(solution):\n    import random\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n    # Clean current solution\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= N and i not in seen:\n                cur.append(i)\n                seen.add(i)\n    # Randomly remove 1-2 items\n    if cur:\n        k = 1 if len(cur) == 1 else random.choice([1, 2])\n        for _ in range(min(k, len(cur))):\n            idx = random.randrange(len(cur))\n            cur.pop(idx)\n    # Greedy refill by value density within capacity\n    def total_w(sol):\n        return sum(gallons[i] for i in sol)\n    remaining = CAP - total_w(cur)\n    candidates = [i for i in range(1, N + 1) if i not in cur and gallons[i] <= remaining]\n    candidates.sort(key=lambda j: (values[j] \/ gallons[j]), reverse=True)\n    for i in candidates:\n        if gallons[i] <= remaining:\n            cur.append(i)\n            remaining -= gallons[i]\n    return sorted(cur)\n","SAMPLE_SOL":"[4,9,19]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_FIX_PRIORITY:Local solver inconsistency between objective and evaluation; unify cost semantics before tuning heuristics.\nE_OBJ_IGNORES_CAP:Object function omits capacity constraint; remove or align with evaluator to prevent infeasible selections scoring finite.\nE_EVAL_SIGN:Evaluator returns negative profit for minimization while some results\/logic treat higher magnitude negatives inconsistently; standardize to cost=min(-profit).\nE_OBJ_EVAL_MISMATCH:Mixing objective_function (max, unconstrained) with evaluate_solution (min, constrained) corrupts acceptance\/best tracking; use only evaluate_solution everywhere.\nE_SAMPLE_INFEASIBLE:Provided sample [4,9,19] violates capacity; replace with a feasible seed or add a repair step at initialization.\nE_TS_SIGNATURE:Tabu Search expects function objects but the signature indicates calls (generate_neighbour(), evaluate_solution()); pass functions, not results, and fix unpacking mismatch.\nE_TS_UNPACK:Tabu move handler expects (neigh,move) but received single value; enforce generate_neighbour to always return a 2-tuple and update TS to unpack safely.\nE_PERTURB_MISSING:Perturbation Function placeholder '$Perturb' is undefined; ILS cannot diversify correctly; implement a concrete perturbation.\nE_ILS_SCORE_DRIFT:ILS shows inconsistent current vs best scores (-5 vs -59); ensure all components use the same cost (minimization) and capacity-feasible evaluator.\nE_NEIGH_FEASIBILITY:Neighbour generator can return 'noop' on infeasible inputs; add mandatory feasibility repair or biased 'drop' when overweight.\nE_NEIGH_SORTING:Sorting indices on every move reduces search diversity and adds O(k log k) overhead; preserve order or maintain canonical form only at evaluation.\nE_DUPLICATE_SILENCE:Evaluation silently deduplicates indices; reject duplicates explicitly to avoid masking representation errors.\nE_RANDOM_SEED:Non-deterministic results without seeding hinder reproducibility; expose seed control in other_params.\nE_MOVE_BIAS:Random move selection without context reduces efficiency; bias choices based on residual capacity and marginal value-density gaps.\nE_SWAP_SCOPE:1-1 swap scans all pairs O(nk); cache weight and delta values or sample candidates to reduce per-step cost.\nE_KEX_LIMIT:K-exchange stops at first non-worsening; allow best-improving within bounded neighborhood to escape shallow local minima.\nE_ACCEPTANCE_RULE:Ensure SA\/ILS acceptance compares costs (lower is better) and rejects math.inf; log-reject infeasible neighbors early.\nE_STOPPING_CRITERIA:No clear convergence or stall detection; add no-improve iterations cap and time budget to prevent wasteful runs.\nE_LOGGING_DIAG:Current outputs insufficient to diagnose; add per-iteration: cost, feasibility flag, move, delta, and best_cost.\nR_EVAL_UNIFY:Delete objective_function and route all scoring through evaluate_solution returning finite costs only for feasible solutions.\nR_COST_NORMALIZE:Return tuple (cost, feasible_flag) or large finite penalty for infeasible to avoid infinities in annealing temperature math.\nR_INIT_CONSTRUCT:Build initial feasible solution via greedy value\/weight ratio under CAP, then local-optimize before metaheuristics.\nR_REPAIR_OPERATOR:Add repair(step): while overweight, drop items with lowest value-density or lowest value, then optionally refill with best-fit.\nR_PERTURB_SPEC:Implement perturb_solution by random k-removals plus greedy refill within capacity; parameterize k with temperature or stagnation.\nR_TABU_IMPL:Define TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration); maintain tabu on items and aspiration for improving moves.\nR_MOVE_SET:Augment with 0-1 knapsack-specific exchanges: (add, drop, swap, 2-1, 1-2) with best-improving selection per iteration until local optimum.\nR_DUP_POLICY:Validate solution as a set of unique indices; if duplicates detected, treat as invalid and repair rather than silently ignoring.\nR_CACHE_STATS:Maintain current total weight and value to compute deltas O(1) per move instead of recomputing sums each time.\nR_TEMPERATURE:Simplify SA temperature schedule and ensure acceptance uses delta_cost; avoid mixing raw profits with costs.\nR_TEST_HARNESS:Add unit tests: feasibility check, evaluator consistency, neighbor feasibility, and signature compliance to prevent runtime failures.\nREF_CHECK:Reference evaluation confirms your local solver\u2019s reported best does not consistently align with the true optimum under the provided evaluator; fix cost-sign, capacity handling, and function-passing to close the gap.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of selected customer indices (1-based)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    if not isinstance(solution, list):\n        return float('-inf')\n    sel = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > 9:\n        return float('-inf')\n    return sum(values[i] for i in sel)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: INDEX_LIST (unique 1-based indices in [1,24])\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # sanitize input\n    if not isinstance(solution, list):\n        sol_set = set()\n    else:\n        sol_set = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    sol = list(sol_set)\n\n    def total_g(sol_list: List[int]) -> int:\n        return sum(gallons[i] for i in set(sol_list))\n\n    def feasible(sol_list: List[int]) -> bool:\n        return total_g(sol_list) <= capacity\n\n    universe = list(range(1, 25))\n\n    move_types = [\"ADD\", \"REMOVE\", \"SWAP\", \"TOGGLE\"]\n    move = random.choice(move_types)\n\n    new_sol = sol.copy()\n\n    if move == \"ADD\":\n        candidates = [i for i in universe if i not in new_sol]\n        random.shuffle(candidates)\n        for c in candidates:\n            trial = new_sol + [c]\n            if feasible(trial):\n                new_sol = trial\n                break\n        else:\n            # try repairing by adding then removing until feasible\n            if candidates:\n                new_sol.append(candidates[0])\n                while not feasible(new_sol) and new_sol:\n                    new_sol.pop(random.randrange(len(new_sol)))\n                new_sol = list(dict.fromkeys([i for i in new_sol if 1 <= i <= 24]))\n\n    elif move == \"REMOVE\":\n        if new_sol:\n            new_sol.pop(random.randrange(len(new_sol)))\n\n    elif move == \"SWAP\":\n        if new_sol:\n            out_idx = random.choice(new_sol)\n            candidates = [i for i in universe if i not in new_sol]\n            if candidates:\n                in_idx = random.choice(candidates)\n                trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                if feasible(trial):\n                    new_sol = trial\n                else:\n                    # try alternative swaps up to limited attempts\n                    attempts = 10\n                    ok = False\n                    for _ in range(attempts):\n                        out_idx = random.choice(new_sol)\n                        in_idx = random.choice(candidates)\n                        trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                        if feasible(trial):\n                            new_sol = trial\n                            ok = True\n                            break\n                    if not ok:\n                        # fallback: remove one item to ensure a change\n                        new_sol = [i for i in new_sol if i != out_idx]\n\n    else:  # TOGGLE\n        idx = random.choice(universe)\n        if idx in new_sol:\n            new_sol = [i for i in new_sol if i != idx]\n        else:\n            trial = new_sol + [idx]\n            if feasible(trial):\n                new_sol = trial\n            else:\n                # try to make room by removing random items\n                trial = trial.copy()\n                while not feasible(trial) and len(trial) > 1:\n                    # remove a random existing item (excluding the newly added idx first)\n                    rem_choices = [i for i in trial if i != idx]\n                    if not rem_choices:\n                        break\n                    trial.remove(random.choice(rem_choices))\n                if feasible(trial):\n                    new_sol = list(dict.fromkeys([i for i in trial if 1 <= i <= 24]))\n\n    # final repair to ensure feasibility and canonical unique list\n    new_sol = list(dict.fromkeys([i for i in new_sol if 1 <= i <= 24]))\n    while total_g(new_sol) > capacity and new_sol:\n        # remove the lowest value-per-gallon item first (greedy repair)\n        ratios = [(i, values[i] \/ gallons[i] if gallons[i] > 0 else float('inf')) for i in new_sol]\n        worst = min(ratios, key=lambda x: x[1])[0]\n        new_sol = [i for i in new_sol if i != worst]\n\n    return new_sol, \"INDEX_LIST\", move\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # sanitize input\n    if not isinstance(solution, list):\n        sol_set = set()\n    else:\n        sol_set = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    sol = list(sol_set)\n\n    def total_g(sol_list: List[int]) -> int:\n        return sum(gallons[i] for i in set(sol_list))\n\n    def feasible(sol_list: List[int]) -> bool:\n        return total_g(sol_list) <= capacity\n\n    universe = list(range(1, 25))\n\n    # number of random edits\n    k = random.randint(2, 4)\n    new_sol = sol.copy()\n\n    for _ in range(k):\n        move = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])  # stronger perturbations\n        if move == \"ADD\":\n            candidates = [i for i in universe if i not in new_sol]\n            if not candidates:\n                continue\n            idx = random.choice(candidates)\n            trial = new_sol + [idx]\n            if feasible(trial):\n                new_sol = trial\n            else:\n                # remove random items until feasible\n                trial = trial.copy()\n                while not feasible(trial) and len(trial) > 1:\n                    rem_choices = [i for i in trial if i != idx]\n                    if not rem_choices:\n                        break\n                    trial.remove(random.choice(rem_choices))\n                if feasible(trial):\n                    new_sol = list(dict.fromkeys([i for i in trial if 1 <= i <= 24]))\n        elif move == \"REMOVE\":\n            if new_sol:\n                new_sol.pop(random.randrange(len(new_sol)))\n        else:  # SWAP\n            if new_sol:\n                out_idx = random.choice(new_sol)\n                candidates = [i for i in universe if i not in new_sol]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                    if feasible(trial):\n                        new_sol = trial\n                    else:\n                        # fallback: just remove an item\n                        new_sol = [i for i in new_sol if i != out_idx]\n\n    # final greedy repair for feasibility\n    new_sol = list(dict.fromkeys([i for i in new_sol if 1 <= i <= 24]))\n    while total_g(new_sol) > capacity and new_sol:\n        ratios = [(i, values[i] \/ gallons[i] if gallons[i] > 0 else float('inf')) for i in new_sol]\n        worst = min(ratios, key=lambda x: x[1])[0]\n        new_sol = [i for i in new_sol if i != worst]\n\n    return new_sol\n","SAMPLE_SOL":"[8,4,18]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\",\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE:Function signatures include calls in parameter list. Replace with function references. Ex: def SA(solution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor). E_TYPE_INSTANTIATION:Typing types used as constructors cause 'Type List cannot be instantiated'. Use list() at runtime; keep typing.List only in annotations. E_SIGNATURE_MISMATCH:Standardize all solvers to TARGET_HEURISTIC_GENERAL_SIGNATURE with additional params bundled in other_params to avoid parser errors. E_ILS_PARAM_TYPO:Parameter 'aceptance_rate' misspelled; use 'acceptance_rate' and document range [0,1]. E_NEIGHBOUR_RET_FORMAT:generate_neighbour returns triple (sol,'INDEX_LIST',move); expected (sol,move). Remove representation token from return. E_NEIGHBOUR_FEASIBILITY:Neighbour occasionally returns infeasible and then repairs; enforce feasibility before return to reduce rejection cycles. E_DUPLICATE_HANDLING:Set-casting in evaluation hides duplicates; canonicalize neighbours to unique list (sorted) pre-return to ensure deterministic evaluation. E_MOVE_SET_WEAK:Operator palette lacks value-aware additions. Add 'ADD_BEST_FIT' and 'K-EXCHANGE (k\u2208{2,3})' guided by value\/gallon ratio to escape shallow basins. E_REPAIR_HEURISTIC:Greedy removal by min(value\/gal) can stall; add tie-break by higher gallons, and consider one-step lookahead (remove-then-best-add). E_RANDOM_SEED:Expose RNG seed via other_params for reproducibility in local tests. E_BOUNDARY_CHECKS:All arrays are 1-based with sentinel at 0; assert 1<=i<=24 in solvers before indexing to avoid IndexError. E_TABUO_CORE:Tabu search lacks explicit move attributes for tabu list; store moves as (ADD i),(REMOVE i),(SWAP i->j) with tenure and aspiration by better-than-best. E_SA_SCHEDULE:Cooling factor and min temp unspecified; adopt geometric cooling alpha\u2208[0.90,0.99] and reheating or restarts in other_params to prevent premature freezing. E_ILS_PERTURB_MISSING:perturb_solution undefined ($Perturb). Provide explicit K-random toggles or ejection chain; ensure feasibility-preserving perturb. E_ACCEPT_CRITERIA:ILS acceptance not defined; implement 'accept if better OR with p if within delta' to avoid cycling. E_MOVE_EVAL_COST:Current neighbour attempts multiple random trials; cap attempts and cache weight\/value to O(1) updates using incremental delta instead of recomputing sums. E_VALIDATION_MISMATCH:Provided known solution fails feasibility under current evaluate; expected score reference does not match its evaluation. Align KNOWN_SOLUTION with evaluate_solution or correct dataset. E_TEST_HARNESS_ARGS:Ensure local runner passes function objects (no calls) and simple Python builtins only, satisfying MAIN_CRITICAL_INSTRUCTION. E_OUTPUT_NOISE:Local solvers should only emit structured extra outputs (scores, temps, tabu status) as specified; remove prints that break parser. S_FIX_SIGNATURE_SA:Use def SA(solution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor,other_params=None). S_FIX_SIGNATURE_ILS:Use def ILS(solution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,iterations,acceptance_rate,other_params=None). S_FIX_SIGNATURE_TS:Use def TS(solution,best,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration,other_params=None). S_NEIGHBOUR_RET:Return (new_sol,move) only; ensure new_sol is feasible, unique, and within [1,24]. S_REPAIR_RULE:When overweight, iteratively remove argmin(value\/gal) with tie-break on larger gallons, then try greedy refill by descending value\/gal until capacity. S_MOVE_INTENSIFICATION:Add 'ADD best ratio until full' and 'SWAP remove worst ratio, add best fitting' moves every k steps. S_CACHE_STATS:Maintain current weight and value in the state to avoid recomputation in O(1) per move. S_ASSERTS:Embed lightweight assertions in dev mode to catch invalid indices and overweight states before evaluation. S_VALIDATION_STEP:Automate check that reference solutions pass evaluate_solution and that reported scores equal evaluate(solution) before running solvers.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of selected customer indices (1-based)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    if not isinstance(solution, list):\n        return float('-inf')\n    sel = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > 9:\n        return float('-inf')\n    return sum(values[i] for i in sel)\n","NB_CODE":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: INDEX_LIST (unique 1-based indices in [1,24])\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # sanitize and canonicalize input\n    if not isinstance(solution, list):\n        sol_set = set()\n    else:\n        sol_set = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    sol = sorted(sol_set)\n\n    def total_g(sol_list: List[int]) -> int:\n        return sum(gallons[i] for i in sol_list)\n\n    def feasible(sol_list: List[int]) -> bool:\n        return total_g(sol_list) <= capacity\n\n    def canonical(sol_list: List[int]) -> List[int]:\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list: List[int]) -> List[int]:\n        s = canonical(sol_list)\n        # remove worst ratio (value\/gal), tie-break by larger gallons\n        while total_g(s) > capacity and s:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        # greedy refill by best ratio while possible\n        remaining = [i for i in range(1, 25) if i not in s]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        for i in remaining:\n            if total_g(s) + gallons[i] <= capacity:\n                s.append(i)\n        return canonical(s)\n\n    universe = list(range(1, 25))\n    move_types = [\"ADD\", \"REMOVE\", \"SWAP\", \"TOGGLE\", \"ADD_BEST_FIT\", \"K_EXCHANGE\"]\n    move = random.choice(move_types)\n\n    new_sol = sol.copy()\n\n    if move == \"ADD\":\n        candidates = [i for i in universe if i not in new_sol]\n        if candidates:\n            random.shuffle(candidates)\n            for c in candidates:\n                trial = new_sol + [c]\n                if feasible(trial):\n                    new_sol = trial\n                    break\n            else:\n                new_sol = repair_feasible(new_sol + [random.choice(candidates)])\n\n    elif move == \"REMOVE\":\n        if new_sol:\n            new_sol.pop(random.randrange(len(new_sol)))\n\n    elif move == \"SWAP\":\n        if new_sol:\n            out_idx = random.choice(new_sol)\n            candidates = [i for i in universe if i not in new_sol]\n            if candidates:\n                in_idx = random.choice(candidates)\n                trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                if feasible(trial):\n                    new_sol = trial\n                else:\n                    # try limited attempts; otherwise repair\n                    ok = False\n                    for _ in range(8):\n                        out_idx = random.choice(new_sol)\n                        in_idx = random.choice(candidates)\n                        trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                        if feasible(trial):\n                            new_sol = trial\n                            ok = True\n                            break\n                    if not ok:\n                        new_sol = repair_feasible(trial)\n\n    elif move == \"TOGGLE\":\n        idx = random.choice(universe)\n        if idx in new_sol:\n            new_sol = [i for i in new_sol if i != idx]\n        else:\n            new_sol = repair_feasible(new_sol + [idx])\n\n    elif move == \"ADD_BEST_FIT\":\n        candidates = [i for i in universe if i not in new_sol]\n        if candidates:\n            # pick highest value\/gal that fits; tie-break by value\n            candidates.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n            for c in candidates:\n                if total_g(new_sol) + gallons[c] <= capacity:\n                    new_sol.append(c)\n                    break\n            else:\n                # if none fits directly, try repair with best candidate\n                new_sol = repair_feasible(new_sol + [candidates[0]])\n\n    else:  # K_EXCHANGE with k in {2,3}\n        if new_sol:\n            k = random.choice([2, 3])\n            remove_count = min(k, len(new_sol))\n            to_remove = random.sample(new_sol, remove_count)\n            remaining = [i for i in new_sol if i not in to_remove]\n            pool = [i for i in universe if i not in remaining]\n            random.shuffle(pool)\n            trial = remaining.copy()\n            for i in pool[:k]:\n                trial.append(i)\n            new_sol = repair_feasible(trial)\n\n    new_sol = canonical(new_sol)\n    if not feasible(new_sol):\n        new_sol = repair_feasible(new_sol)\n    new_sol = canonical(new_sol)\n\n    return new_sol, move\n","PERTURB_CODE":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    if not isinstance(solution, list):\n        sol_set = set()\n    else:\n        sol_set = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    sol = sorted(sol_set)\n\n    def total_g(sol_list: List[int]) -> int:\n        return sum(gallons[i] for i in sol_list)\n\n    def feasible(sol_list: List[int]) -> bool:\n        return total_g(sol_list) <= capacity\n\n    def canonical(sol_list: List[int]) -> List[int]:\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list: List[int]) -> List[int]:\n        s = canonical(sol_list)\n        while total_g(s) > capacity and s:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        remaining = [i for i in range(1, 25) if i not in s]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        for i in remaining:\n            if total_g(s) + gallons[i] <= capacity:\n                s.append(i)\n        return canonical(s)\n\n    universe = list(range(1, 25))\n    k_edits = random.randint(2, 4)\n    new_sol = sol.copy()\n\n    for _ in range(k_edits):\n        op = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])  # stronger shake\n        if op == \"ADD\":\n            candidates = [i for i in universe if i not in new_sol]\n            if not candidates:\n                continue\n            idx = random.choice(candidates)\n            trial = new_sol + [idx]\n            if feasible(trial):\n                new_sol = trial\n            else:\n                new_sol = repair_feasible(trial)\n        elif op == \"REMOVE\":\n            if new_sol:\n                new_sol.pop(random.randrange(len(new_sol)))\n        else:  # SWAP\n            if new_sol:\n                out_idx = random.choice(new_sol)\n                candidates = [i for i in universe if i not in new_sol]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                    if feasible(trial):\n                        new_sol = trial\n                    else:\n                        new_sol = repair_feasible(trial)\n\n    new_sol = canonical(new_sol)\n    if not feasible(new_sol):\n        new_sol = repair_feasible(new_sol)\n    return canonical(new_sol)\n","SAMPLE_SOL":"[5,9,19]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses on function parameters (pass callables, not invoked) and align names\/arity exactly.\nE_LOCAL_SOLVER_TYPING:Error 'Type List cannot be instantiated' indicates misuse of typing.List. Replace typing.List annotations with built-in list and ensure no List() construction anywhere.\nE_LOCAL_SOLVER_PLACEHOLDER:Perturbation function unresolved ('$Perturb'). Provide a concrete perturbation callable matching the required signature.\nE_OBJ_EVAL_MISMATCH:objective_function ignores capacity; evaluate_solution enforces it. Unify to a single feasibility-checked evaluator to avoid divergence and wrong scoring.\nE_KNOWN_SOLUTION_INVALID:Provided KNOWN_SOLUTION violates capacity under evaluate_solution. Replace with a feasible optimal set; verify programmatically before shipping.\nE_VALUE_SIGN_CONVENTION:Framework expects 'best as lesser cost'. For maximization, return negative of revenue when interfacing with SA\/ILS\/TS and compare costs consistently.\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood relies on ratio-greedy repair and random K-exchange only; misses systematic improving moves under tight capacity.\nNB_REDUNDANCY:TOGGLE\/ADD paths often call repair_feasible even when unnecessary, adding stochasticity that hinders reproducibility and convergence checks.\nNB_CANONICALIZATION_OVERHEAD:Multiple canonical() calls per move add O(n log n) overhead unnecessarily.\nEVAL_DUPLICATE_HANDLING:Using set() in evaluation silently drops duplicates; if representation guarantees uniqueness, enforce during generation, not at evaluation.\nOBJ_VALUE_DRIFT:OBJ_CODE and EVAL_CODE maintain separate value arrays; risk of divergence. Centralize constants to a single source.\nR_STR_INADEQUATE:INDEX_LIST is fine, but lack of pre-screened candidates by capacity\/gallons causes wasted search on infeasible-heavy items.\nE_TEST_COVERAGE:No unit tests for feasibility\/score invariants; local solver crashed before heuristic execution.\nRANDOMNESS_SEEDING:No seeding control reduces reproducibility; impedes debugging and benchmarking.\nSUG_FIX_SIGNATURES:Refactor SA\/ILS\/TS to def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) and pass callable references; remove '()' in parameter list.\nSUG_TYPING:Use 'list[int]' for annotations or omit types; ensure any empty solution uses list(), not List().\nSUG_PERTURB:Implement perturbation as multi-toggle with bounded k (e.g., k in {2..4}) plus feasibility-preserving repair; ensure idempotent canonicalization.\nSUG_UNIFY_EVAL:Delete objective_function or wrap evaluate_solution so both enforce capacity; expose a single scorer to all components.\nSUG_VERIFICATION:Add assert-based checks: gallons(sum)<=capacity, monotonicity under subset adds; fail fast before heuristic loop.\nSUG_COST_NORMALIZATION:Define cost(solution) = -evaluate_solution(solution) and update all acceptance\/comparison logic accordingly.\nSUG_NB_2OPT:Augment neighbor with deterministic 1-1 and 2-1 exchanges scanning best improving move under capacity; iterate until no improvement (first\/best improvement).\nSUG_NB_BEST_FILL:Precompute feasible_items = {i | gallons[i] <= capacity} and restrict candidates to these; prune dominated items by (gallon,value) pairs.\nSUG_NB_EFFICIENCY:Avoid repeated canonical() calls; canonicalize once at entry\/exit. Cache total_gallons to O(1) incremental updates inside a move.\nSUG_REPAIR_TIES:In repair_feasible, break ties by higher value then lower gallons to reduce oscillations; limit refill to items that still fit exactly under remaining capacity.\nSUG_RANDOM_SEED:Add optional seed parameter in other_params to set random.seed for reproducible runs.\nSUG_CONSTANTS:Store values\/gallons\/capacity in a shared module-level structure to prevent divergence between OBJ and EVAL.\nSUG_TESTS:Create tests covering evaluation of sample and random solutions, neighbour feasibility postconditions, and invariants after perturb.\nEVAL_WITH_REFERENCE:Automated check shows the provided 'KNOWN_SOLUTION' is infeasible under the current evaluator; update the reference to a feasible optimal and ensure EXPECTED_SCORE aligns without exposing it in logs.\nE_CODE_PERF:Neighbour generation currently O(n log n) per move due to sorts\/canonicalization; shift to O(1)\/O(log n) updates and pre-sorted candidate lists.\nE_LOGGING:No move\/score tracing; add lightweight telemetry (move type, delta, feasibility repairs) to diagnose stagnation and acceptance behavior.\nE_STOPPING_CRITERIA:No explicit iteration\/temperature\/tenure validation shown; ensure bounds prevent infinite loops when repair fails.\nACTION_ITEMS_ORDERED:\n1) Fix signatures and typing to eliminate runtime errors.\n2) Implement perturb_solution callable.\n3) Unify evaluation and cost sign; add assertions.\n4) Replace random-only neighbors with 1-1 and 2-1 improving exchanges loop.\n5) Pre-filter candidates to gallons<=capacity and prune dominated items.\n6) Add reproducible seeding and minimal logging.\n7) Update KNOWN_SOLUTION to a feasible optimal verified by the evaluator; keep value hidden from feedback outputs.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST (unique 1-based customer indices in [1,24])","Componentes":{"REPRESENTATION":"INDEX_LIST (unique 1-based customer indices in [1,24])","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of selected customer indices (1-based)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    if not isinstance(solution, list):\n        return float('-inf')\n    sel = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > capacity:\n        return float('-inf')\n    return sum(values[i] for i in sel)\n","NB_CODE":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: INDEX_LIST (unique 1-based indices in [1,24])\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # sanitize and canonicalize input once\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n\n    def total_g(sol_list):\n        return sum(gallons[i] for i in sol_list)\n\n    def feasible(sol_list):\n        return total_g(sol_list) <= capacity\n\n    def canonical(sol_list):\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list):\n        s = canonical(sol_list)\n        # remove worst by value\/weight until feasible\n        while s and total_g(s) > capacity:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i], values[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[3], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        # greedy refill by best ratio then value then smaller gallon\n        remaining = [i for i in range(1, 25) if i not in s and gallons[i] <= capacity]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i], -gallons[i]), reverse=True)\n        g = total_g(s)\n        for i in remaining:\n            if g + gallons[i] <= capacity:\n                s.append(i)\n                g += gallons[i]\n        return canonical(s)\n\n    universe = [i for i in range(1, 25) if gallons[i] <= capacity]\n\n    # Try a mix of improving exchanges and random local moves\n    move_types = [\"BEST_11\", \"BEST_21\", \"ADD\", \"REMOVE\", \"SWAP\", \"TOGGLE\", \"K_EXCHANGE\"]\n    move = random.choice(move_types)\n\n    new_sol = sol.copy()\n\n    # Helper: deterministic best 1-1 exchange (first improvement)\n    if move == \"BEST_11\" and new_sol:\n        current_set = set(new_sol)\n        best_delta = 0\n        best_pair = None\n        cur_val = sum(values[i] for i in new_sol)\n        cur_g = total_g(new_sol)\n        outsiders = [i for i in universe if i not in current_set]\n        for out_idx in new_sol:\n            for in_idx in outsiders:\n                g_new = cur_g - gallons[out_idx] + gallons[in_idx]\n                if g_new <= capacity:\n                    delta = values[in_idx] - values[out_idx]\n                    if delta > best_delta:\n                        best_delta = delta\n                        best_pair = (out_idx, in_idx)\n        if best_pair is not None:\n            out_idx, in_idx = best_pair\n            new_sol = [i for i in new_sol if i != out_idx]\n            new_sol.append(in_idx)\n            new_sol = canonical(new_sol)\n        else:\n            move = \"NO_IMPROVE_11\"\n\n    # Best 2-1 exchange (replace up to 2 items with 1 better item)\n    elif move == \"BEST_21\" and new_sol:\n        current_set = set(new_sol)\n        best_delta = 0\n        best_trip = None\n        cur_val = sum(values[i] for i in new_sol)\n        cur_g = total_g(new_sol)\n        outsiders = [i for i in universe if i not in current_set]\n        ln = len(new_sol)\n        for a in range(ln):\n            for b in range(a + 1, ln):\n                out_a, out_b = new_sol[a], new_sol[b]\n                g_base = cur_g - gallons[out_a] - gallons[out_b]\n                v_base = cur_val - values[out_a] - values[out_b]\n                for in_idx in outsiders:\n                    if g_base + gallons[in_idx] <= capacity:\n                        delta = values[in_idx] - (values[out_a] + values[out_b])\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_trip = (out_a, out_b, in_idx)\n        if best_trip is not None:\n            out_a, out_b, in_idx = best_trip\n            new_sol = [i for i in new_sol if i not in (out_a, out_b)]\n            new_sol.append(in_idx)\n            new_sol = canonical(new_sol)\n        else:\n            move = \"NO_IMPROVE_21\"\n\n    elif move == \"ADD\":\n        candidates = [i for i in universe if i not in new_sol]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n            for c in candidates:\n                if total_g(new_sol) + gallons[c] <= capacity:\n                    new_sol.append(c)\n                    break\n            else:\n                # try repair with best candidate\n                new_sol = repair_feasible(new_sol + [candidates[0]])\n\n    elif move == \"REMOVE\":\n        if new_sol:\n            new_sol.pop(random.randrange(len(new_sol)))\n\n    elif move == \"SWAP\":\n        if new_sol:\n            out_idx = random.choice(new_sol)\n            candidates = [i for i in universe if i not in new_sol]\n            if candidates:\n                in_idx = random.choice(candidates)\n                trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                if total_g(trial) <= capacity:\n                    new_sol = trial\n                else:\n                    new_sol = repair_feasible(trial)\n\n    elif move == \"TOGGLE\":\n        idx = random.choice(universe)\n        if idx in new_sol:\n            new_sol = [i for i in new_sol if i != idx]\n        else:\n            trial = new_sol + [idx]\n            if total_g(trial) <= capacity:\n                new_sol = trial\n            else:\n                new_sol = repair_feasible(trial)\n\n    else:  # K_EXCHANGE strong move\n        k = 2 if len(new_sol) < 3 else random.choice([2, 3])\n        remove_count = min(k, len(new_sol))\n        to_remove = random.sample(new_sol, remove_count) if new_sol else []\n        remaining = [i for i in new_sol if i not in to_remove]\n        pool = [i for i in universe if i not in remaining]\n        random.shuffle(pool)\n        trial = remaining + pool[:k]\n        new_sol = repair_feasible(trial)\n\n    # finalize\n    new_sol = canonical(new_sol)\n    if not feasible(new_sol):\n        new_sol = repair_feasible(new_sol)\n    new_sol = canonical(new_sol)\n\n    return new_sol, move\n","PERTURB_CODE":"import math\nimport random\n\ndef perturb_solution(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n\n    def total_g(sol_list):\n        return sum(gallons[i] for i in sol_list)\n\n    def canonical(sol_list):\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list):\n        s = canonical(sol_list)\n        while s and total_g(s) > capacity:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i], values[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[3], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        remaining = [i for i in range(1, 25) if i not in s and gallons[i] <= capacity]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i], -gallons[i]), reverse=True)\n        g = total_g(s)\n        for i in remaining:\n            if g + gallons[i] <= capacity:\n                s.append(i)\n                g += gallons[i]\n        return canonical(s)\n\n    universe = [i for i in range(1, 25) if gallons[i] <= capacity]\n\n    k_edits = random.randint(2, 4)\n    new_sol = sol.copy()\n\n    for _ in range(k_edits):\n        op = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])  # stronger shake\n        if op == \"ADD\":\n            candidates = [i for i in universe if i not in new_sol]\n            if not candidates:\n                continue\n            idx = random.choice(candidates)\n            trial = new_sol + [idx]\n            if total_g(trial) <= capacity:\n                new_sol = trial\n            else:\n                new_sol = repair_feasible(trial)\n        elif op == \"REMOVE\":\n            if new_sol:\n                new_sol.pop(random.randrange(len(new_sol)))\n        else:  # SWAP\n            if new_sol:\n                out_idx = random.choice(new_sol)\n                candidates = [i for i in universe if i not in new_sol]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                    if total_g(trial) <= capacity:\n                        new_sol = trial\n                    else:\n                        new_sol = repair_feasible(trial)\n\n    new_sol = canonical(new_sol)\n    if total_g(new_sol) > capacity:\n        new_sol = repair_feasible(new_sol)\n    return canonical(new_sol)\n","SAMPLE_SOL":"[4,8,18]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_FIX_LOCAL_SOLVER_0:SimulatedAnnealing returns -inf because solver minimizes cost while evaluate_solution returns revenue. Implement a cost wrapper: cost(x)=+inf if infeasible else -evaluate_solution(x). Ensure all solvers use cost, not raw value.\"\n\"FEEDBACK\",\"E_TYPE_REPR:SA passes solution as string ('[4,8,18]'), evaluate_solution expects list => -inf. Enforce list[int] throughout; add assert isinstance(sol,list) and cast from str via ast.literal_eval only at I\/O boundary, not inside solver.\"\n\"FEEDBACK\",\"E_INIT_INFEAS:Sample init [4,8,18] is feasible, but other runs show infeasible starts causing -inf traps. Add feasible initializer: greedy by value\/weight with capacity check; verify feasibility after every move.\"\n\"FEEDBACK\",\"TS_SIG_ERROR:Tabu signature misuse passing function calls not handles; also unpack expects 2. Fix signature to def TS(solution,best,best_score,generate_neighbour,evaluate_cost,iterations,tabu_list_size,tabu_duration) and return (best, best_score).\"\n\"FEEDBACK\",\"P_FUNC_MISSING:Perturbation function undefined ($Perturb). Provide deterministic, capacity-safe perturbation (e.g., drop 1\u20132 items then refill greedily) to escape local minima; expose strength parameter.\"\n\"FEEDBACK\",\"E_OBJ_INCONSISTENCY:OBJ_CODE objective_function ignores capacity and silently dedups via set, diverging from evaluator. Remove objective_function or align: return -inf when capacity violated; reject duplicates explicitly.\"\n\"FEEDBACK\",\"E_EVAL_DUP_HANDLING:Set-based dedup hides representation errors. Replace with validation: if len(solution)!=len(set(solution)): return +inf cost (or -inf value) to penalize duplicates; also filter non-int\/out-of-range elements explicitly.\"\n\"FEEDBACK\",\"E_COST_STANDARD:Heuristics expect 'less is better'. Define evaluate_cost(x)=+inf if infeasible else -evaluate_solution(x). Use this across SA\/ILS\/TS to avoid sign mistakes.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighborhood lacks strong exchanges for tight capacity; BEST_11\/BEST_21 only. Add 0-1 (ADD), 1-0 (REMOVE) with feasibility-aware gains, and 2-2 exchanges to improve exploration under capacity 9.\"\n\"FEEDBACK\",\"NB_PERF:BEST_21 is O(n^3). Reduce by bounding candidates: prefilter outsiders by max feasible weight and top-k by ratio\/value; early prune if value upper bound \u2264 current.\"\n\"FEEDBACK\",\"NB_REPAIR_BIAS:Deterministic ratio refill causes cycling. Add randomized tie-breaking and occasional value-first selection; include don't-fill-to-capacity option to allow future 2-1 improvements.\"\n\"FEEDBACK\",\"NB_CANONICAL:Multiple canonical() calls add overhead. Maintain sorted invariant and apply canonical once at function exit.\"\n\"FEEDBACK\",\"E_UNIVERSE_GEN:Universe filters gallons<=capacity correctly. Cache universe and per-item (value,weight,ratio) to avoid recomputation inside loops.\"\n\"FEEDBACK\",\"RANDOM_SEED:No seeding -> irreproducible results. Add seed in other_params and propagate to random for consistent debugging.\"\n\"FEEDBACK\",\"KNOWN_SOL_INVALID:The provided 'KNOWN_SOLUTION' is infeasible under current evaluator; 'EXPECTED_SCORE' mismatches evaluator output. Validate by calling evaluate_solution on the provided known solution; correct the reference pair before benchmarking.\"\n\"FEEDBACK\",\"E_LOGGING:Record (iteration, move_type, delta, cost, feasible_flag). Current outputs are insufficient for diagnosing acceptance decisions and constraint handling.\"\n\"FEEDBACK\",\"ACCEPT_RULES:Ensure SA acceptance uses cost difference; for infeasible neighbors, skip or assign +inf cost, never accept by mistake due to NaN\/-inf.\"\n\"FEEDBACK\",\"ILS_COMPONENTS:Define local_search using generate_neighbour until no-improve; perturb, then relaunch. Current ILS output ([2,4,8,14],5,[],0) indicates state fields mis-ordered; standardize return=(best_sol,best_cost,extras).\"\n\"FEEDBACK\",\"PARAM_TUNING:Set cooling schedule (SA), tabu tenure (TS), and perturb strength (ILS) as explicit, validated parameters; current defaults likely too weak for tight capacities.\"\n\"FEEDBACK\",\"UNIT_TESTS:Add tests: type-check solutions; infeasible neighbor repaired; cost sign correctness; TS signature; perturbation non-empty and capacity-safe.\"\n\"FEEDBACK\",\"PY_ASSERTIONS:Use python to verify evaluator consistency across components; ensure evaluate_solution aligns with cost wrapper and that reference solutions are feasible under capacity constraints.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs (e.g., \"4,8,18\"). No spaces required; order ignored.","Componentes":{"REPRESENTATION":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs (e.g., \"4,8,18\"). No spaces required; order ignored.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated customer IDs (e.g., \"4,8,18\")\n    # returns fitness = revenue if feasible; returns a large negative number if invalid\/infeasible\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    PENALTY = -1e18\n    if not isinstance(solution, str):\n        return PENALTY\n    raw_tokens = solution.split(',')\n    # Normalize and basic lexical validation\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return PENALTY\n        tokens.append(s)\n    # Parse and validate IDs\n    ids_list = [int(t) for t in tokens]\n    # Check duplicates\n    if len(ids_list) != len(set(ids_list)):\n        return PENALTY\n    # Range check\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return PENALTY\n    # Feasibility (capacity) check\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return PENALTY\n    return float(total_v)","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, move_type)\n    # Representation: CSV of unique indices in [1,24]\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol_str):\n        if not isinstance(sol_str, str) or sol_str.strip() == \"\":\n            return set()\n        ids = set()\n        for t in sol_str.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if s.isdigit():\n                i = int(s)\n                if 1 <= i <= 24:\n                    ids.add(i)\n        return ids\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def total_weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    ids = parse(solution)\n    universe = list(range(1, 25))\n\n    move = random.choices([\"add\",\"remove\",\"swap\"],[0.4,0.3,0.3])[0]\n\n    if move == \"add\":\n        candidates = [i for i in universe if i not in ids]\n        random.shuffle(candidates)\n        for i in candidates:\n            if total_weight(ids) + offers[i][1] <= CAP:\n                ids.add(i)\n                return to_str(ids), \"add\"\n        # if no feasible add, fallback to remove\n        move = \"remove\"\n\n    if move == \"remove\":\n        if ids:\n            i = random.choice(tuple(ids))\n            ids.remove(i)\n            return to_str(ids), \"remove\"\n        else:\n            # fallback to add smallest weight if possible\n            smallest = min(universe, key=lambda k: offers[k][1])\n            if offers[smallest][1] <= CAP:\n                ids.add(smallest)\n            return to_str(ids), \"add\"\n\n    # swap\n    if ids:\n        out_i = random.choice(tuple(ids))\n        remaining = total_weight(ids) - offers[out_i][1]\n        candidates = [j for j in universe if j not in ids and remaining + offers[j][1] <= CAP]\n        if candidates:\n            in_j = random.choice(candidates)\n            ids.remove(out_i)\n            ids.add(in_j)\n            return to_str(ids), \"swap\"\n    # fallback: return as-is with no-op tag\n    return to_str(ids), \"noop\"","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Stronger multi-move perturbation preserving feasibility when possible\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol_str):\n        if not isinstance(sol_str, str) or sol_str.strip() == \"\":\n            return set()\n        ids = set()\n        for t in sol_str.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if s.isdigit():\n                i = int(s)\n                if 1 <= i <= 24:\n                    ids.add(i)\n        return ids\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def w(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    ids = parse(solution)\n\n    # random number of operations\n    ops = random.randint(2, 5)\n    for _ in range(ops):\n        move = random.choices([\"add\",\"remove\",\"swap\"],[0.5,0.2,0.3])[0]\n        if move == \"add\":\n            candidates = [i for i in range(1,25) if i not in ids]\n            random.shuffle(candidates)\n            for i in candidates:\n                if w(ids) + offers[i][1] <= CAP:\n                    ids.add(i)\n                    break\n        elif move == \"remove\":\n            if ids:\n                ids.remove(random.choice(tuple(ids)))\n        else:  # swap\n            if ids:\n                out_i = random.choice(tuple(ids))\n                rem = w(ids) - offers[out_i][1]\n                cands = [j for j in range(1,25) if j not in ids and rem + offers[j][1] <= CAP]\n                if cands:\n                    in_j = random.choice(cands)\n                    ids.remove(out_i)\n                    ids.add(in_j)\n    # Final repair: if overweight (should be rare), greedily drop largest weight until feasible\n    while True:\n        total_w = sum(offers[i][1] for i in ids)\n        if total_w <= CAP:\n            break\n        drop = max(ids, key=lambda i: offers[i][1])\n        ids.remove(drop)\n    return to_str(ids)","SAMPLE_SOL":"8,4,14,2"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"LSE_SIG_MISMATCH:Heuristic signature must match TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove parentheses on function arguments to avoid calling them at definition.\nLSE_TYPING_INSTANTIATION:Do not instantiate typing.Tuple or annotate with Tuple(...) at runtime. Use -> tuple for returns or omit typing. Error trace indicates attempted instantiation: 'Type Tuple cannot be instantiated; use tuple() instead.'\nLSE_RET_ANNOTATION:generate_neighbour return annotation is invalid (->('NB_Type','Movement_Type')). Replace with -> tuple or omit; ensure it actually returns (new_solution_str, move_type).\nLSE_MISSING_PERTURB:Perturbation Function is placeholder ($Perturb). Provide a concrete perturb_solution(solution,rng,scale) that preserves feasibility (e.g., multi-swap with re-pack under CAP).\nLSE_COST_SIGN_CONSISTENCY:Framework requires 'less is better'. Convert revenue R to cost C=-R consistently for best_score, acceptance, and comparisons. Audit all heuristics (SA\/ILS\/TS) to ensure they minimize cost.\nE_CODE_INCONSISTENCY_OBJ_EVAL:objective_function ignores capacity and deduplicates via set, while evaluate_solution penalizes duplicates and enforces CAP. Remove objective_function from comparisons or make it mirror evaluate_solution to prevent false 'improvements'.\nE_DUP_POLICY_INCONSISTENT:objective_function collapses duplicates silently; evaluate_solution treats duplicates as infeasible. Standardize: reject duplicates everywhere.\nEVAL_ASSERT:PASS. No discrepancy detected between evaluation logic and internal feasibility checks.\nE_KNOWN_SOLUTION_INFEASIBLE:Provided KNOWN_SOLUTION violates capacity under evaluate_solution; EXPECTED_SCORE_FROM_KNOWN_SOLUTION conflicts with feasibility. Replace with a feasible ground-truth pair aligned with CAP and offers.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour operator set is limited; lacks 2-opt-like local reordering (irrelevant for set problems) and multi-add\/remove moves. Add a bounded 'k-exchange' (k in {2,3}) with feasibility check to escape plateaus.\nNB_FEASIBILITY_CHECK_COST:total_weight(ids) recomputed repeatedly during add\/swap loops. Cache current_weight and update incrementally to O(1) per move to reduce overhead.\nNB_MOVE_PROBS_STATIC:Fixed move probabilities [0.4,0.3,0.3] can stall in tight capacity regimes. Adapt probabilities based on recent acceptance (e.g., increase 'remove' when stuck or near CAP, increase 'add' when weight<<CAP).\nNB_NOOP_RATE:swap frequently falls back to 'noop' when no candidate fits. Add 'remove+add' two-step swap (drop heaviest, then best-fit add) before emitting noop.\nNB_VALUE_AWARE:Add value\/weight bias when selecting add\/swap candidates (e.g., sample by softmax over v\/w) to improve exploitation without greedy determinism.\nR_REPR_CANONICAL:Always output sorted, comma-separated, no-spaces CSV to reduce duplicate states. Enforce in all operators; reject malformed strings early.\nSA_PARAM_WEAK:Missing temperature schedule\/acceptance consistent with cost minimization. Use Metropolis with cost delta \u0394C and T schedule T_k=T0*alpha^k with floor MIN_TEMP; ensure acceptance uses exp(-\u0394C\/T).\nILS_ACCEPTANCE_AMBIGUOUS:Undefined acceptance rule. Use 'accept if improved cost; else accept with small prob p' or use better-restart with time-based diversification. Maintain incumbent best separately from current.\nTS_MEMORY_INADEQUATE:Tabu list lacks aspiration criteria and tenure logic tied to problem size. Use tenure in [5,10] moves; add aspiration to allow overriding tabu if new best cost found; store moves on indices rather than entire solution strings.\nINIT_SOLUTION_QUALITY:Random or empty-start often suboptimal in tight CAP. Build greedy feasible seed by ratio v\/w with a repair step to ensure CAP, then start local search from there.\nE_STOPPING_CRITERIA:Missing robust stopping. Add max_evals, no_improve_limit, and wall-clock guard to prevent endless runs.\nGROUND_TRUTH_VALIDATION:Before running heuristics, assert evaluate_solution on seed and after each move; abort or rollback on PENALTY to guarantee feasibility invariant.\nSCORING_CACHE:Add memoization for evaluate_solution(solution_str) to avoid re-evaluating repeats; use LRU keyed by canonical string.\nRNG_CONTROL:Set and expose RNG seed for reproducibility across SA\/ILS\/TS; pass rng object through generate_neighbour and perturb_solution rather than using global random.\nPERF_MICRO:Precompute arrays v[i], w[i] and a feasible_mask (w<=CAP) outside inner loops; skip infeasible indices when generating candidates to reduce branching.\nUNIT_TESTS:Create tests for parse\/to_str\/feasibility\/duplicate handling; include adversarial cases ('', ' , ', '1,1', '0', '25', 'a', '1,2,3').\nAPI_CONTRACT_ENFORCEMENT:Ensure all heuristics accept callable objects (not invoked) for generate_neighbour, evaluate_solution, perturb_solution per signature; remove parentheses in parameters to prevent premature calls.\nLOGGING_MINIMAL:Emit structured logs: iter, cost, move, accepted, temp (SA), tenure (TS). Avoid verbose prints that break parsers; use single-line JSON per iteration if needed.\nBENCH_CHECK:Verify that best_score is updated only when improved cost discovered; never overwrite incumbent with worse solution unless explicitly permitted by acceptance rule.\nSAFE_ROLLBACK:On rejected move, revert to previous solution state; never mutate in-place shared sets\u2014operate on copies to avoid state leakage across operators.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs (e.g., \"4,8,18\"). Order ignored; always output sorted, no spaces.","Componentes":{"REPRESENTATION":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs (e.g., \"4,8,18\"). Order ignored; always output sorted, no spaces.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns cost (to minimize): cost = -total_value if feasible; large positive penalty if invalid\/infeasible.\n    Representation: CSV of unique IDs in [1,24].\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    PENALTY = 1e18  # large positive since we minimize\n    if not isinstance(solution, str):\n        return PENALTY\n    raw_tokens = solution.split(',')\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return PENALTY\n        tokens.append(s)\n    ids_list = [int(t) for t in tokens]\n    # duplicates invalid\n    if len(ids_list) != len(set(ids_list)):\n        return PENALTY\n    # range check\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return PENALTY\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return PENALTY\n    # minimize cost = -revenue\n    return float(-total_v)","NB_CODE":"import random\nfrom typing import Optional\n\ndef generate_neighbour(solution) -> tuple:\n    \"\"\"\n    Returns (new_solution_str, move_type).\n    Representation: CSV of unique indices in [1,24], canonical sorted, no spaces.\n    Moves: add, remove, swap, k_exchange (k in {2,3}); preserves feasibility when possible.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol_str: Optional[str]):\n        if not isinstance(sol_str, str) or sol_str.strip() == \"\":\n            return set(), 0\n        ids = set()\n        w = 0\n        for t in sol_str.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if s.isdigit():\n                i = int(s)\n                if 1 <= i <= 24 and i not in ids:\n                    v_i, w_i = offers[i]\n                    if w + w_i <= CAP:\n                        ids.add(i)\n                        w += w_i\n        return ids, w\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    ids, cur_w = parse(solution)\n    universe = list(range(1, 25))\n    not_in = [i for i in universe if i not in ids]\n\n    # Adaptive move probabilities based on slack\n    slack = CAP - cur_w\n    if slack <= 1:\n        probs = [0.15, 0.45, 0.25, 0.15]  # add, remove, swap, k-exchange\n    elif slack <= 3:\n        probs = [0.35, 0.25, 0.25, 0.15]\n    else:\n        probs = [0.50, 0.15, 0.20, 0.15]\n\n    move = random.choices([\"add\",\"remove\",\"swap\",\"k_exchange\"], probs)[0]\n\n    # helper: biased pick by value\/weight ratio\n    def best_fit_candidates(candidates, budget):\n        scored = []\n        for j in candidates:\n            v, w = offers[j]\n            if w <= budget:\n                scored.append((-(v\/max(w,1)), -v, w, j))  # primary: high v\/w, tie: high v, then low w\n        scored.sort()\n        return [j for _,__,___,j in scored]\n\n    # add\n    if move == \"add\":\n        if not_in and cur_w < CAP:\n            cands = best_fit_candidates(not_in, CAP - cur_w)\n            if cands:\n                j = cands[0]\n                ids.add(j)\n                return to_str(ids), \"add\"\n        # fallback to remove if cannot add\n        move = \"remove\"\n\n    # remove\n    if move == \"remove\":\n        if ids:\n            # remove lowest value density first to free capacity\n            rem = sorted(list(ids), key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1] > 0 else float('inf')))[0]\n            ids.remove(rem)\n            return to_str(ids), \"remove\"\n        else:\n            # fallback: add lightest feasible item\n            light = min(universe, key=lambda i: offers[i][1])\n            if offers[light][1] <= CAP:\n                ids.add(light)\n            return to_str(ids), \"add\"\n\n    # swap: replace one selected with one outside, maintain feasibility\n    if move == \"swap\":\n        if ids and not_in:\n            out_i = random.choice(tuple(ids))\n            rem_w = cur_w - offers[out_i][1]\n            budget = CAP - rem_w\n            cands = best_fit_candidates(not_in, budget)\n            if cands:\n                in_j = cands[0]\n                ids.remove(out_i)\n                ids.add(in_j)\n                return to_str(ids), \"swap\"\n        # fallback to k-exchange\n        move = \"k_exchange\"\n\n    # k-exchange: drop up to k in {2,3}, insert best-fitting items greedily\n    if move == \"k_exchange\":\n        if ids:\n            k = 3 if len(ids) >= 3 and random.random() < 0.5 else 2\n            drop = random.sample(list(ids), k=min(k, len(ids)))\n            for d in drop:\n                ids.remove(d)\n                cur_w -= offers[d][1]\n            # refill greedily by v\/w\n            candidates = [i for i in universe if i not in ids]\n            while True:\n                budget = CAP - cur_w\n                if budget <= 0:\n                    break\n                cands = best_fit_candidates(candidates, budget)\n                if not cands:\n                    break\n                j = cands[0]\n                wj = offers[j][1]\n                if cur_w + wj <= CAP:\n                    ids.add(j)\n                    cur_w += wj\n                    candidates.remove(j)\n                else:\n                    break\n            return to_str(ids), \"k_exchange\"\n        # fallback: no-op\n    return to_str(ids), \"noop\"","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multiple random add\/remove\/swap operations with final feasibility repair.\n    Returns a canonical CSV string.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol_str):\n        if not isinstance(sol_str, str) or sol_str.strip() == \"\":\n            return set()\n        ids = set()\n        for t in sol_str.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if s.isdigit():\n                i = int(s)\n                if 1 <= i <= 24:\n                    ids.add(i)\n        return ids\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    ids = parse(solution)\n\n    ops = random.randint(3, 6)\n    for _ in range(ops):\n        move = random.choices([\"add\",\"remove\",\"swap\"], [0.45, 0.2, 0.35])[0]\n        if move == \"add\":\n            candidates = [i for i in range(1,25) if i not in ids]\n            random.shuffle(candidates)\n            # biased by value\/weight\n            candidates.sort(key=lambda j: (-(offers[j][0]\/offers[j][1] if offers[j][1]>0 else offers[j][0]), -offers[j][0]))\n            for j in candidates:\n                if weight(ids) + offers[j][1] <= CAP:\n                    ids.add(j)\n                    break\n        elif move == \"remove\":\n            if ids:\n                # remove lowest value density\n                rem = sorted(list(ids), key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1]>0 else float('inf')))[0]\n                ids.remove(rem)\n        else:  # swap\n            if ids:\n                out_i = random.choice(tuple(ids))\n                rem_w = weight(ids) - offers[out_i][1]\n                budget = CAP - rem_w\n                cands = [j for j in range(1,25) if j not in ids and offers[j][1] <= budget]\n                if cands:\n                    # pick best by v\/w\n                    j = max(cands, key=lambda k: (offers[k][0]\/offers[k][1] if offers[k][1]>0 else offers[k][0], offers[k][0]))\n                    ids.remove(out_i)\n                    ids.add(j)\n    # Final repair to ensure feasibility\n    while weight(ids) > CAP:\n        # drop item with worst value density first\n        drop = min(ids, key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1]>0 else float('inf')))\n        ids.remove(drop)\n    return to_str(ids)","SAMPLE_SOL":"2,8,14,18"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-fix1\"\n\"FEEDBACK\":\"E_HEUR_SIG:Heuristic signatures incorrectly use callable parameters as generate_neighbour() and evaluate_solution() in the definitions. Remove parentheses; pass function objects. Required: def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).;E_TYPING_OPTIONAL:Neighbour code imports typing.Optional and annotates parse(sol_str: Optional[str]). This triggers 'Cannot instantiate typing.Optional' in the host. Remove the typing.Optional import and annotation entirely; use def parse(sol_str) without typing.;E_PARSE_IDEMPOTENCE:parse() enforces capacity and greedily drops items based on input order, making it non-idempotent and silently repairing solutions. This breaks reproducibility and acceptance logic. Fix: parse should only normalize IDs (dedupe, range-check) and compute current weight exactly without removing items.;E_CANONICAL_OUT:Ensure representation is strictly canonical: sorted ascending, no spaces. Enforce only at the to_str() boundary, not during parse.;E_EVAL_CONSISTENCY:Two different evaluation definitions exist (OBJ_CODE revenue-only vs. cost-minimizing EVAL_CODE with penalties). Unify to a single evaluate_solution that returns cost=-value and large positive penalty for infeasibility. Do not use the revenue-only OBJ_CODE in the solver loop.;E_CAP_CHECK_OBJ:objective_function ignores capacity entirely. If kept for reporting, it must not be used for acceptance\/selection. Rely solely on evaluate_solution for correctness.;NB_MOVE_SET:Current moves rely on value\/weight ratio heuristics. Replace ratio-based selection with exact delta-cost feasibility checks: for add\/swap\/k-exchange, select items\/joint sets that maximize -delta_cost under CAP. Include explicit 1-1 and 2-1 exchanges to escape local plateaus with tiny capacity.;NB_PARSE_WEIGHT:cur_w computed after parse is incorrect when parse drops items. After fixing parse, recompute cur_w as sum(offers[i][1] for i in ids) once, and update it consistently after each move.;NB_ADD_POLICY:best_fit_candidates sorts by -(v\/w) then -v then w. This can reject globally better combinations in tight CAP=9. Improve by trying all feasible candidates and picking argmin(delta_cost) instead of density.;NB_REMOVE_POLICY:Removing lowest density first may stall when all items have w in {1,2,3,5,6,8,9}. Prefer removing the item with worst marginal contribution relative to the best feasible replacement (lookahead of length-1 swap).;NB_KX_GREEDY:Greedy refill by density in k_exchange can reinsert recently dropped low-value items. Add a tabu on dropped items for the refill step or compute a small bounded knapsack fill (exact DP up to CAP=9) over the candidate set to optimality.;SA_ACC_INIT:Initialize best_score=+inf (since minimizing cost). Acceptance should compare new_cost vs. current_cost; temperature schedule should use T *= cooling_factor with bounds [MIN_TEMP,TEMP]. Avoid reheating unless explicitly configured.;ILS_ACCEPT:Acceptance rate parameter misspelled (aceptance_rate). Define explicit acceptance: accept if new_cost <= current_cost or random()<acceptance_rate. Ensure perturbation returns a valid canonical solution.;TS_TABU:Tabu parameters present but no aspiration or tabu tenure logic described. Implement: store recent moves (added\/removed IDs) with tenure taboo_duration; allow aspiration if new_cost < best_score.;EVAL_VERIFICATION:Reference solution provided by KNOWN_SOLUTION does not satisfy the feasibility\/objective under the given EVAL_CODE. Recompute the reference using the same evaluation to prevent solver misguidance.;PENALTY_SCALE:Use consistent penalties: for minimization, infeasible -> +1e18; for maximization (if ever used), infeasible -> -1e18. Do not mix signs across components.;INIT_SOL:Sample solution '2,8,14,18' is feasible but suboptimal under CAP=9. Use a constructive greedy by exact marginal gains (or small exact DP since CAP is tiny) to seed the heuristics.;LOCAL_OPT_OPERATOR:Current operator set lacks exact bounded-exchange evaluation. Add a small exact DP over the remaining capacity to evaluate best subset to insert when dropping up to k items (k\u2208{1,2,3}); CAP=9 makes this O(n*CAP) per move practical.;STOPPING_CRIT:Define deterministic iteration or no-improvement budget to ensure repeatable runs for evaluation. Avoid randomness-only termination.;RANDOM_SEED:Set and expose a seed parameter to allow reproducibility during evaluation.;INPUT_VALIDATION:Reject duplicates and out-of-range IDs in generator before returning new solutions; never rely on evaluator-side penalties for generator output.;COMPLEXITY_NOTE:Neighbour generation currently O(n log n) due to sorting every step. Cache v,w, and maintain a priority structure for candidates keyed by delta-cost to reduce to amortized O(log n) per move.;ACTIONABLE_FIX_SUMMARY:1) Remove typing.Optional and any annotation that requires typing instantiation. 2) Fix all heuristic function signatures to accept function objects (no parentheses) and match TARGET_HEURISTIC_GENERAL_SIGNATURE. 3) Make parse idempotent (no capacity enforcement), compute cur_w exactly, and keep to_str canonical. 4) Unify evaluate_solution to cost=-value with +penalty for infeasible; deprecate revenue-only OBJ_CODE in solver loop. 5) Replace density-based candidate choice with exact delta-cost checks; add explicit 1-1 and 2-1 exchanges and bounded DP refill in k_exchange. 6) Initialize best_score=+inf; standardize SA\/ILS\/TS acceptance and tabu logic. 7) Recompute and update the reference solution using the provided EVAL_CODE; current reference is inconsistent.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs in ascending order with no spaces (e.g., \"4,8,18\"). Order is canonical and ignored semantically.","Componentes":{"REPRESENTATION":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs in ascending order with no spaces (e.g., \"4,8,18\"). Order is canonical and ignored semantically.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric cost to minimize.\n    Feasible: cost = -total_value (maximize value)\n    Infeasible\/invalid: large positive penalty.\n    Representation: canonical CSV of unique IDs in [1,24].\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    PENALTY = 1e18\n    if not isinstance(solution, str):\n        return PENALTY\n    # tokenize and basic validation\n    tokens = []\n    for t in solution.split(','):\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return PENALTY\n        tokens.append(s)\n    # parse ids\n    try:\n        ids_list = [int(t) for t in tokens]\n    except Exception:\n        return PENALTY\n    # check duplicates and range\n    if len(ids_list) != len(set(ids_list)):\n        return PENALTY\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return PENALTY\n    # compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return PENALTY\n    return float(-total_v)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution_str, move_type).\n    Representation: CSV of unique indices in [1,24], canonical sorted, no spaces.\n    Moves: add, remove, swap, two_for_one, k_exchange (drop up to 3 then optimal refill via DP).\n    Ensures returned solution is valid and canonical; if unable to improve\/modify, may return the input canonicalized with move 'noop'.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def parse(sol_str):\n        ids = set()\n        if isinstance(sol_str, str) and sol_str.strip() != \"\":\n            for t in sol_str.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if s.isdigit():\n                    i = int(s)\n                    if 1 <= i <= 24:\n                        ids.add(i)\n        return ids\n\n    def total_weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    def total_value(ids_set):\n        return sum(offers[i][0] for i in ids_set)\n\n    def best_single_add(cand_ids, budget):\n        best = None\n        best_v = -1\n        for j in cand_ids:\n            vj, wj = offers[j]\n            if wj <= budget and vj > best_v:\n                best = j\n                best_v = vj\n        return best\n\n    def best_pair_fill(cand_ids, budget):\n        # exact best of up to 2 items within budget\n        best = set()\n        best_v = -1\n        c_list = list(cand_ids)\n        n = len(c_list)\n        for idx in range(n):\n            j = c_list[idx]\n            vj, wj = offers[j]\n            if wj <= budget and vj > best_v:\n                best = {j}\n                best_v = vj\n            for k in range(idx+1, n):\n                j2 = c_list[k]\n                v2, w2 = offers[j2]\n                w = wj + w2\n                if w <= budget:\n                    v = vj + v2\n                    if v > best_v:\n                        best = {j, j2}\n                        best_v = v\n        return best, best_v\n\n    def dp_best_subset(cand_ids, budget):\n        # 0-1 knapsack exact DP for small CAP\n        items = list(cand_ids)\n        dp = [0] * (budget + 1)\n        choose = [[False]*(budget+1) for _ in range(len(items))]\n        for idx, j in enumerate(items):\n            vj, wj = offers[j]\n            for c in range(budget, wj-1, -1):\n                if dp[c - wj] + vj > dp[c]:\n                    dp[c] = dp[c - wj] + vj\n                    choose[idx][c] = True\n        # reconstruct\n        res = set()\n        c = budget\n        for idx in range(len(items)-1, -1, -1):\n            j = items[idx]\n            vj, wj = offers[j]\n            if choose[idx][c]:\n                res.add(j)\n                c -= wj\n        return res, dp[budget]\n\n    ids = parse(solution)\n    cur_w = total_weight(ids)\n\n    universe = set(range(1, 25))\n    outside = universe - ids\n\n    # Ensure feasibility; if infeasible, repair by DP immediately\n    if cur_w > CAP:\n        # drop then refill optimally\n        # drop worst-density items first to reduce quickly, then DP refill\n        ordered = sorted(list(ids), key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1] > 0 else float('inf')))\n        while cur_w > CAP and ordered:\n            rem = ordered.pop(0)\n            ids.remove(rem)\n            cur_w -= offers[rem][1]\n        # refill\n        budget = CAP - cur_w\n        add_set, _ = dp_best_subset(universe - ids, budget)\n        ids |= add_set\n        return to_str(ids), \"repair\"\n\n    slack = CAP - cur_w\n    moves = [\"add\", \"remove\", \"swap\", \"two_for_one\", \"k_exchange\"]\n    if slack <= 1:\n        probs = [0.15, 0.35, 0.30, 0.10, 0.10]\n    elif slack <= 3:\n        probs = [0.35, 0.20, 0.25, 0.10, 0.10]\n    else:\n        probs = [0.45, 0.15, 0.20, 0.10, 0.10]\n    move = random.choices(moves, probs)[0]\n\n    # ADD\n    if move == \"add\":\n        if slack > 0 and outside:\n            best = best_single_add(outside, slack)\n            if best is not None:\n                ids.add(best)\n                return to_str(ids), \"add\"\n        # fallback to swap if cannot add\n        move = \"swap\"\n\n    # REMOVE\n    if move == \"remove\":\n        if ids:\n            # remove the item with lowest value; simple and fast\n            rem = min(ids, key=lambda i: offers[i][0])\n            ids.remove(rem)\n            return to_str(ids), \"remove\"\n        else:\n            # nothing to remove, try add smallest weight high value\n            best = best_single_add(outside, CAP)\n            if best is not None:\n                ids.add(best)\n            return to_str(ids), \"add\"\n\n    # SWAP 1-1\n    if move == \"swap\":\n        if ids and outside:\n            best_delta = 0  # improvement in value\n            best_pair = None\n            cur_v = total_value(ids)\n            for i in list(ids):\n                wi = offers[i][1]\n                for j in list(outside):\n                    vj, wj = offers[j]\n                    if cur_w - wi + wj <= CAP:\n                        delta = vj - offers[i][0]\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                ids.remove(i)\n                ids.add(j)\n                return to_str(ids), \"swap\"\n        # fallback\n        move = \"two_for_one\"\n\n    # TWO FOR ONE (drop up to 2, add best single)\n    if move == \"two_for_one\":\n        if len(ids) >= 2:\n            best_gain = 0\n            best_action = None\n            ids_list = list(ids)\n            n = len(ids_list)\n            for a in range(n):\n                i = ids_list[a]\n                wi = offers[i][1]\n                for b in range(a+1, n):\n                    k = ids_list[b]\n                    wk = offers[k][1]\n                    budget = CAP - (cur_w - wi - wk)\n                    if budget <= 0:\n                        continue\n                    j = best_single_add(outside - {i, k}, budget)\n                    if j is not None:\n                        gain = offers[j][0] - (offers[i][0] + offers[k][0])\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_action = (i, k, j)\n            if best_action is not None:\n                i, k, j = best_action\n                ids.remove(i)\n                ids.remove(k)\n                ids.add(j)\n                return to_str(ids), \"two_for_one\"\n        move = \"k_exchange\"\n\n    # K-EXCHANGE with optimal refill (drop up to 3, then DP refill)\n    if move == \"k_exchange\":\n        if ids:\n            k = 3 if len(ids) >= 3 and random.random() < 0.5 else 2\n            drop_cnt = min(k, len(ids))\n            dropped = random.sample(list(ids), drop_cnt)\n            for d in dropped:\n                ids.remove(d)\n            cur_w2 = total_weight(ids)\n            budget = CAP - cur_w2\n            cand = universe - ids\n            add_set, _ = dp_best_subset(cand, budget)\n            ids |= add_set\n            return to_str(ids), \"k_exchange\"\n\n    return to_str(ids), \"noop\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation with random removals and optimal refill via small DP.\n    Ensures final solution is feasible and canonical CSV.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def parse(sol_str):\n        ids = set()\n        if isinstance(sol_str, str) and sol_str.strip() != \"\":\n            for t in sol_str.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if s.isdigit():\n                    i = int(s)\n                    if 1 <= i <= 24:\n                        ids.add(i)\n        return ids\n\n    def total_weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    def dp_best_subset(cand_ids, budget):\n        items = list(cand_ids)\n        dp = [0] * (budget + 1)\n        choose = [[False]*(budget+1) for _ in range(len(items))]\n        for idx, j in enumerate(items):\n            vj, wj = offers[j]\n            for c in range(budget, wj-1, -1):\n                if dp[c - wj] + vj > dp[c]:\n                    dp[c] = dp[c - wj] + vj\n                    choose[idx][c] = True\n        res = set()\n        c = budget\n        for idx in range(len(items)-1, -1, -1):\n            if choose[idx][c]:\n                j = items[idx]\n                _, wj = offers[j]\n                res.add(j)\n                c -= wj\n        return res\n\n    ids = parse(solution)\n\n    # Randomly remove some items (0-3) to escape basin\n    if ids:\n        remove_cnt = random.randint(1, min(3, len(ids)))\n        for _ in range(remove_cnt):\n            if not ids:\n                break\n            rem = random.choice(tuple(ids))\n            ids.remove(rem)\n\n    # Optionally add a random feasible item\n    cur_w = total_weight(ids)\n    budget = max(0, CAP - cur_w)\n    if budget > 0:\n        candidates = [j for j in range(1,25) if j not in ids and offers[j][1] <= budget]\n        if candidates and random.random() < 0.6:\n            j = random.choice(candidates)\n            ids.add(j)\n\n    # Repair\/refill optimally via DP\n    cur_w = total_weight(ids)\n    budget = max(0, CAP - cur_w)\n    cand = set(range(1,25)) - ids\n    add_set = dp_best_subset(cand, budget)\n    ids |= add_set\n\n    # Final feasibility guard: if overweight (shouldn't happen), drop random until feasible\n    while total_weight(ids) > CAP and ids:\n        ids.remove(random.choice(tuple(ids)))\n\n    return to_str(ids)\n","SAMPLE_SOL":"4,8,18"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER:TS_SIG_MISMATCH: Tabu implementation returns\/accepts wrong arity. Enforce signature def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_duration) and return (best_sol,best_score) only.\nFIX_LOCAL_SOLVER:PERTURB_MISSING: Perturbation Function is undefined. Provide def perturb_solution(solution, strength, rng): randomized drop-and-DP-refill to escape local minima. Wire it into ILS\/SA as required by the Heuristic signature.\nE_EVAL_INCONSISTENCY:OBJ_VS_EVAL: objective_function ignores capacity and duplicate\/range checks and sums over a set; evaluate_solution is capacity-constrained and cost=-value. Remove or align objective_function with evaluate_solution to prevent diagnostic drift.\nE_EVAL_DUP_RANGE: Ambiguity in handling non-canonical\/duplicate IDs between OBJ_CODE and EVAL_CODE. Keep a single source of truth (the minimization evaluate_solution) and deprecate OBJ_CODE in solver loops.\nE_KNOWN_BEST_MISMATCH: Provided known-best metadata is infeasible under the current evaluator (CAP=9, offers table). Replace the metadata or update the instance to ensure internal validation passes. Do not expose this to the solver outputs.\nE_CODE_PERF:NB_ADD\/PAIR_SCAN: O(U) and O(U^2) per step are acceptable here, but k_exchange invokes DP after random drops causing noisy complexity. Prefer bounded, deterministic enumerations of drop sets of size \u22643 with memoized DP for refill to improve stability.\nNB_CODE_FAIL_LOCAL_OPT:REMOVE_RULE: Removing the lowest value ignores weight. Switch to removing worst density (v\/w) or worst marginal contribution to enable capacity recovery with minimal value loss.\nNB_CODE_FAIL_LOCAL_OPT:SWAP_RULE: Only accepts strictly improving swaps (delta>0). For SA\/ILS, allow non-improving neighbors to be returned and let the metaheuristic decide acceptance; additionally consider best-improving and first-improving variants.\nNB_SEARCH_SPACE:LIMITED_TWO_FOR_ONE: two_for_one uses greedy best_single_add; extend to exact best_pair_fill or DP refill given freed capacity for better exploitation.\nNB_SEARCH_SPACE:RANDOM_K_EXCHANGE: Random drops without evaluating drop sets wastes iterations. Enumerate all 1-,2-,3-drop combinations from current solution (bounded by C(<=|S|,3)) and choose the best refill via DP to guarantee non-worsening neighbors for LS phases.\nINIT_STRATEGY_WEAK: Starting from sample '4,8,18' locks SA\/ILS in status quo. Add multi-start seeds: empty set + DP fill, greedy by v\/w then DP repair, and singletons with best DP completion.\nREP_CANONICALIZATION: Ensure every neighbor returns strictly sorted, comma-separated IDs with no spaces. Current to_str does this; enforce same canonicalization at all solver entry\/exit points.\nSA_ACCEPTANCE_POLICY: If SA currently filters neighbors by improvement inside generate_neighbour, remove that logic. Acceptance should be handled by SA using exp(-\u0394\/T), enabling exploration.\nILS_PERTURB_TUNING: Use strength proportional to stagnation (e.g., drop 1\u21923 items adaptively), followed by exact DP refill to maintain feasibility and quality.\nTEST_VALIDATION: Using the provided evaluator, sample '4,8,18' yields cost -59 (feasible). The supplied known-best metadata fails feasibility under the same evaluator. Update tests to assert (a) feasibility, (b) non-increasing best_cost across iterations, (c) canonical output format.\nPARAM_CONSISTENCY: Heuristics require cost minimization; ensure all modules compare by lower-is-better and invert value once in evaluate_solution only.\nROBUSTNESS_CHECKS: Add fast infeasibility repair path at the start of generate_neighbour (already present). Extend to early reject moves that exceed CAP and fallback deterministically to next move type instead of random cascades.\nSUGGESTED_IMPROVEMENTS: \n- Replace REMOVE with density-based removal; \n- Extend SWAP to include 2\u21922 exchanges where budget allows; \n- Replace greedy two_for_one add with DP over outside set for freed budget; \n- Implement deterministic k-exchange enumerations with DP refill; \n- Add multi-start initialization; \n- Fix TS signature and returns; \n- Implement perturb_solution and integrate into SA\/ILS; \n- Unify on evaluate_solution as the sole objective to avoid inconsistency.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST; unique 1-based attraction indices; order irrelevant; duplicates ignored in scoring\/evaluation.","Componentes":{"REPRESENTATION":"INDEX_LIST; unique 1-based attraction indices; order irrelevant; duplicates ignored in scoring\/evaluation.","EVAL_CODE":"import math\nfrom typing import List, Set\n\ndef objective_function(solution: List[int]) -> int:\n    # solution: list of 1-based indices (ints)\n    # Returns total score of unique selected attractions\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return -10**9\n    total_score = 0\n    seen: Set[int] = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(scores):\n            if idx not in seen:\n                total_score += scores[idx]\n                seen.add(idx)\n        else:\n            continue\n    return total_score\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Evaluate objective under time constraint (<= 90 minutes)\n    # Returns a cost to minimize (negative score for feasible, large positive for infeasible)\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    if not isinstance(solution, list):\n        return 10**9\n    unique: List[int] = []\n    seen: Set[int] = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(times) and idx not in seen:\n            unique.append(idx)\n            seen.add(idx)\n    total_time = sum(times[i] for i in unique)\n    if total_time > 90:\n        return 10**9\n    # feasible: minimize negative score\n    return -objective_function(unique)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _valid_indices() -> List[int]:\n    # 1..24 inclusive as per embedded data arrays\n    return list(range(1, 25))\n\ndef _make_unique(lst: List[int]) -> List[int]:\n    # preserves original order of first occurrences\n    seen = set()\n    out = []\n    for x in lst:\n        if isinstance(x, int) and x not in seen and 1 <= x <= 24:\n            seen.add(x)\n            out.append(x)\n    return out\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list):\n        solution = []\n    current = _make_unique(solution[:])\n    actions = [\"add\", \"remove\", \"swap\", \"replace\"]\n    action = random.choice(actions) if current else \"add\"\n    indices = _valid_indices()\n\n    if action == \"add\":\n        candidates = [i for i in indices if i not in current]\n        if candidates:\n            add_idx = random.choice(candidates)\n            neighbor = current + [add_idx]\n            neighbor = _make_unique(neighbor)\n            return neighbor, \"SetIndex\", \"Add\"\n        else:\n            action = \"replace\"\n\n    if action == \"remove\":\n        if current:\n            rem = random.choice(current)\n            neighbor = [x for x in current if x != rem]\n            return neighbor, \"SetIndex\", \"Remove\"\n        else:\n            return current, \"SetIndex\", \"NoOp\"\n\n    if action == \"swap\":\n        if len(current) >= 2:\n            i, j = random.sample(range(len(current)), 2)\n            neighbor = current[:]\n            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]\n            neighbor = _make_unique(neighbor)\n            return neighbor, \"SetIndex\", \"Swap\"\n        else:\n            action = \"add\"\n\n    if action == \"replace\":\n        if current:\n            pos = random.randrange(len(current))\n            candidates = [i for i in indices if i not in current or i == current[pos]]\n            if candidates:\n                new_val = random.choice(candidates)\n                neighbor = current[:]\n                neighbor[pos] = new_val\n                neighbor = _make_unique(neighbor)\n                return neighbor, \"SetIndex\", \"Replace\"\n        # fallback\n        return current, \"SetIndex\", \"NoOp\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _valid_indices() -> List[int]:\n    return list(range(1, 25))\n\ndef _make_unique(lst: List[int]) -> List[int]:\n    seen = set()\n    out = []\n    for x in lst:\n        if isinstance(x, int) and x not in seen and 1 <= x <= 24:\n            seen.add(x)\n            out.append(x)\n    return out\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Stronger random shake: random removals and random additions\n    if not isinstance(solution, list):\n        solution = []\n    current = _make_unique(solution[:])\n    n = len(current)\n\n    # Remove r elements (0..ceil(n\/2))\n    r = random.randint(0, (n + 1) \/\/ 2)\n    if r > 0 and n > 0:\n        to_remove = set(random.sample(current, min(r, n)))\n        current = [x for x in current if x not in to_remove]\n\n    # Add a random number of new elements (1..3)\n    add_count = random.randint(1, 3)\n    pool = [i for i in _valid_indices() if i not in current]\n    if pool:\n        add_count = min(add_count, len(pool))\n        adds = random.sample(pool, add_count)\n        current.extend(adds)\n\n    return _make_unique(current)\n","SAMPLE_SOL":"[2,9,15,19]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_SIG_MISMATCH:Heuristic signatures pass callables incorrectly. Remove parentheses in parameters (use generate_neighbour, evaluate_solution, perturb_solution) to pass functions, not their return values.\nE_TYPING_INSTANTIATION:Runtime error 'Type List cannot be instantiated'. Replace any List() usage with list(); never instantiate typing.List\/Set.\nE_MISSING_PERTURB:Perturbation function undefined ($Perturb placeholder). Provide a concrete perturb_solution to unblock ILS\/SA.\nE_SA_SIG:Simulated_Annealing signature must match TARGET_HEURISTIC_GENERAL_SIGNATURE. Current signature shows function parameters being invoked; fix to accept callables and a params dict or explicit scalars without calling them.\nE_TS_SIG:Tabu Search signature incorrectly invokes inputs and deviates from target signature. Align to accept callables and explicit params; no parentheses.\nE_ILS_SIG:ILS signature incorrectly invokes inputs and omits a valid perturbation. Accept callables; implement and pass a working perturb_solution.\nE_REF_SOL_INFEASIBLE:Provided reference solution fails the time constraint under evaluate_solution; test harness expecting it to pass is incorrect. Update tests\/fixtures.\nE_REF_SCORE_MISMATCH:Provided expected score does not match evaluation for the reference solution. Recompute expectations from the evaluator; do not hardcode mismatched values.\nE_EVAL_INCONSISTENCY:objective_function returns -inf for invalid input in one block and -1e9 in another. Standardize sentinel values and signs with evaluate_solution to avoid silent bugs.\nE_DUP_HANDLING:Neighbour ops rely on _make_unique but 'replace' can be a no-op if it picks the same value. Ensure replacements change the set or re-sample.\nNB_CODE_FAIL_LOCAL_OPT:'swap' is ineffective because order is irrelevant and duplicates are ignored. Remove or replace with set-improving moves (add\/remove\/exchange).\nR_INIT_SOL:Initialize with a greedy feasible set (maximize score\/time ratio with tie-breaking on absolute score) to improve starting quality and reduce SA\/ILS burn-in.\nR_MOVE_SET:Introduce 1-1 exchange (drop i, add j) guided by marginal gain per time and 2-exchange for tight capacity (drop {i,k}, add {j,l}) to escape small-plateau traps.\nR_GUIDED_ADD:When adding, restrict candidates to those whose time fits remaining capacity; otherwise you generate immediate infeasibles that get rejected wholesale.\nR_FEAS_PENALTY:Use a graded penalty for infeasible neighbours (e.g., cost = large_constant + overflow_time) instead of a hard 1e9 to provide a descent direction back to feasibility.\nR_CACHE_EVAL:Cache evaluate_solution by frozenset(solution) to avoid O(n) recomputation on repeats; clear cache when parameters change.\nR_CANON_REPR:Canonicalize solutions as sorted unique lists (or frozenset internally) to make equality checks O(1) and remove order-only moves from the neighbourhood.\nR_TABU_DEF:Tabu list should store moves (e.g., last added\/removed indices) rather than full solutions to reduce memory and allow aspiration criteria by best-known cost.\nR_SA_SCHED:Adopt a robust SA schedule (geometric cooling T<-alpha*T with alpha in [0.90,0.99], reheats optional) and set MIN_TEMP to stop when acceptance rate < 1%.\nR_ILS_PERTURB:Perturb via k random 1-1 exchanges or drop-add with capacity-respecting adds; k=2..4 typical. Ensure post-perturb local search is applied until no improving 1-move exists.\nR_TERMINATION:Terminate when no improvement for X iterations or time budget reached; expose X as param to avoid infinite runs with no-op moves.\nR_VALIDATION:Add unit tests: (a) neighbour never duplicates, (b) neighbour respects index bounds, (c) evaluate_solution monotone in added time, (d) infeasible detection at total_time>90.\nR_LOGGING:Log (iter, cost, move_type, delta, |S|, total_time) to debug stagnation and verify acceptance rules.\nE_CODE_PERF:Current evaluate_solution is O(n) per call; with caching and canonicalization you can cut repeats drastically on SA\/TS loops.\nR_BOUNDING:Precompute upper bounds (sum of top-k values that can still fit by time) to prune obviously non-improving branches in local improvement steps.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST; unique 1-based attraction indices; order irrelevant; duplicates ignored.","Componentes":{"REPRESENTATION":"INDEX_LIST; unique 1-based attraction indices; order irrelevant; duplicates ignored.","EVAL_CODE":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Returns a cost to minimize: feasible => negative total score; infeasible => large positive with graded penalty\n    def objective_function(sol: List[int]) -> int:\n        scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        if not isinstance(sol, list):\n            return -10**9\n        total = 0\n        seen: Set[int] = set()\n        for idx in sol:\n            if isinstance(idx, int) and 1 <= idx < len(scores) and idx not in seen:\n                total += scores[idx]\n                seen.add(idx)\n        return total\n\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    if not isinstance(solution, list):\n        return 10**9\n    # make unique, filter bounds, preserve first occurrence order\n    seen: Set[int] = set()\n    unique: List[int] = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(times) and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n    total_time = sum(times[i] for i in unique)\n    capacity = 90\n    if total_time <= capacity:\n        return -objective_function(unique)\n    # graded penalty for infeasible\n    overflow = total_time - capacity\n    base_penalty = 10**6\n    return float(base_penalty + overflow)","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Capacity-aware add\/exchange; order-independent unique set representation\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    def make_unique_sorted(sol: List[int]) -> List[int]:\n        s = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in s:\n                s.add(x)\n                out.append(x)\n        return sorted(out)\n\n    cur = make_unique_sorted(solution if isinstance(solution, list) else [])\n    cur_time = sum(times[i] for i in cur)\n    all_idx = list(range(1, 25))\n\n    if not cur:\n        # add one feasible index with best score\/time ratio\n        candidates = [i for i in all_idx if times[i] <= capacity]\n        if not candidates:\n            return (cur, \"SetIndex\", \"NoOp\")\n        # simple bias towards better density using fixed arrays inside\n        scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        densities = sorted(candidates, key=lambda i: (-scores[i]\/times[i], -scores[i]))\n        return (make_unique_sorted(cur + [random.choice(densities[:min(5, len(densities))])]), \"SetIndex\", \"Add\")\n\n    move = random.choice([\"add\", \"remove\", \"exchange\"]) if cur else \"add\"\n\n    if move == \"add\":\n        remaining = capacity - cur_time\n        feas = [i for i in all_idx if i not in cur and times[i] <= remaining]\n        if feas:\n            return (make_unique_sorted(cur + [random.choice(feas)]), \"SetIndex\", \"Add\")\n        # fallback: if no feasible add, try a 1-1 exchange instead\n        move = \"exchange\"\n\n    if move == \"remove\":\n        rem = random.choice(cur)\n        nxt = [x for x in cur if x != rem]\n        return (make_unique_sorted(nxt), \"SetIndex\", \"Remove\")\n\n    if move == \"exchange\":\n        # drop one, add one that fits\n        drop = random.choice(cur)\n        after_drop_time = cur_time - times[drop]\n        remaining = capacity - after_drop_time\n        pool = [i for i in all_idx if i != drop and i not in cur and times[i] <= remaining]\n        if pool:\n            add = random.choice(pool)\n            nxt = [x for x in cur if x != drop] + [add]\n            return (make_unique_sorted(nxt), \"SetIndex\", \"Exchange\")\n        # if no fitting add, fall back to remove\n        nxt = [x for x in cur if x != drop]\n        return (make_unique_sorted(nxt), \"SetIndex\", \"Remove\")\n\n    return (cur, \"SetIndex\", \"NoOp\")","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Stronger shake while keeping feasibility preference\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    def make_unique_sorted(sol: List[int]) -> List[int]:\n        s = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in s:\n                s.add(x)\n                out.append(x)\n        return sorted(out)\n\n    cur = make_unique_sorted(solution if isinstance(solution, list) else [])\n    cur_time = sum(times[i] for i in cur)\n\n    # Randomly remove up to ceil(n\/2)\n    n = len(cur)\n    r = random.randint(0, (n + 1) \/\/ 2)\n    if r > 0 and n > 0:\n        to_remove = set(random.sample(cur, min(r, n)))\n        cur = [x for x in cur if x not in to_remove]\n        cur_time = sum(times[i] for i in cur)\n\n    # Add up to k new feasible elements\n    k = random.randint(1, 3)\n    for _ in range(k):\n        remaining = capacity - cur_time\n        if remaining <= 0:\n            break\n        pool = [i for i in range(1,25) if i not in cur and times[i] <= remaining]\n        if not pool:\n            break\n        pick = random.choice(pool)\n        cur.append(pick)\n        cur = make_unique_sorted(cur)\n        cur_time += times[pick]\n\n    return make_unique_sorted(cur)","SAMPLE_SOL":"[4,8,18]"},"Version":1,"Feedback":"COMPONENT_VERSION:1.0.0\nFEEDBACK:\nE_EVAL_SIGN:Infeasible returns -1e9 (very attractive under cost minimization). Replace with large positive penalty (e.g., 1e6+overflow) and return -objective for feasible.\nE_FUNC_REF_INVOKED:Heuristic signatures pass generate_neighbour(), evaluate_solution() as calls. Pass callables, not invoked functions (remove parentheses).\nE_TYPE_HINT_INSTANTIATION:Using typing.List() causes \"Type List cannot be instantiated\". Replace with built-in list() and keep typing.List only for annotations.\nE_SIG_MISMATCH:Heuristic signatures differ from TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_PERTURB_MISSING:Perturbation Function undefined (\"$Perturb\"). Implement a state-respecting perturbation callable and wire it into ILS per target signature.\nE_DATA_SINGLE_SOURCE:Scores\/times are hardcoded in multiple places. Centralize into a single shared module\/object to avoid drift between evaluator and neighbor.\nE_REF_INCONSISTENT:Provided reference pair is infeasible under current times\/capacity. Recompute ground-truth with the current evaluator and update tests accordingly.\nE_INIT_REPRO:Randomness unseeded. Inject rng or seed parameter into Heuristic and neighbor for reproducible runs and fair evaluation.\nE_OBJ_UNIQUE:objective_function called on full solution in EVAL_CODE, but feasibility is computed on unique. Call objective_function(unique) to keep semantics aligned and avoid duplicate-induced bias.\nE_NO_FEAS_CHECK_IN_SA_ILS_TS:Heuristics should reject\/repair infeasible neighbors. Enforce evaluate_solution cost semantics (feasible negative better; infeasible large positive) in acceptance logic.\nE_CODE_PERF:Per-call set building and sums are O(n). Precompute arrays; cache per-solution total_time and delta updates for add\/remove\/exchange to O(1) amortized.\nNB_CODE_FAIL_LOCAL_OPT:Neighbor uses uniform random add\/remove\/exchange. Add best-improvement 1-1, 1-2, and 2-1 exchanges guided by marginal gain per unit time; prefer shuffled deterministic scan over random choice to intensify.\nNB_DENSITY_HEURISTIC:Initial add uses score\/time density but then reverts to random. Maintain density-guided candidate lists; optionally adopt GRASP (alpha) for controlled randomness.\nNB_CANONICALIZATION:make_unique_sorted sorts indices, introducing bias and unnecessary reallocations. Maintain insertion order unique list; canonicalize only for hashing\/tabu, not for search dynamics.\nNB_FEAS_REPAIR:When add not feasible, attempt multi-drop repairs (drop smallest-marginal items until capacity allows adding a higher-density item) before falling back to remove.\nSA_ACCEPTANCE:Use acceptance = exp(-(new_cost - cur_cost)\/T) with costs where feasible are negative; clamp probability and ensure T schedule T = T*cooling_factor with MIN_TEMP guard.\nILS_PERTURB_STRENGTH:Adaptive perturb strength (e.g., random k-exchange with k in {2,3} scaled by stagnation) to escape local minima while preserving feasibility.\nTS_TABU_REP:Define tabu attributes on moves (dropped\/added indices) with tenure taboo_duration; do not tabu entire solution. Include aspiration criterion when new_cost < best_cost.\nTS_LIST_BOUNDS:Manage bounded tabu list size taboo_list_size with FIFO; ensure hashing uses frozenset of indices to avoid order-induced duplicates.\nTEST_EVAL_FEAS:Unit tests\u2014feasible set returns negative cost; infeasible always > 1e6; duplicates do not change objective\/time; out-of-bounds indices ignored.\nTEST_NEIGHBOR_CONTRACT:Neighbor must return (solution, \"SetIndex\", Movement_Type) with solution respecting representation; verify feasibility preservation or explicit Remove fallback.\nTEST_SIGNATURES:Automated checks that heuristic signatures exactly match TARGET; verify parameters are callables and no typing objects are instantiated.\nDATA_VALIDATION:Static check that all items with time > capacity cannot appear in any feasible solution; pre-filter candidate set to shrink search space.\nINIT_STRATEGY:Construct feasible initial solution via greedy by score\/time, then local repair; avoid infeasible seeds in annealing\/ILS to prevent penalty traps.\nLOGGING_MINIMAL:Log only cost, time, and move type per iteration to satisfy \"extra outputs expected\" without I\/O side-effects; avoid any filesystem\/network\/OS access per MAIN_CRITICAL_INSTRUCTION."}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Cost to minimize: feasible => negative total score; infeasible => large positive with graded penalty\n    def objective_function(sol: List[int]) -> int:\n        scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        if not isinstance(sol, list):\n            return -10**9\n        total = 0\n        seen: Set[int] = set()\n        for idx in sol:\n            if isinstance(idx, int) and 1 <= idx < len(scores) and idx not in seen:\n                total += scores[idx]\n                seen.add(idx)\n        return total\n\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    if not isinstance(solution, list):\n        return 10**9\n\n    # make unique, filter bounds, preserve first occurrence order\n    seen: Set[int] = set()\n    unique: List[int] = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(times) and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n\n    total_time = sum(times[i] for i in unique)\n    capacity = 90\n    if total_time <= capacity:\n        # feasible: minimize negative score\n        return float(-objective_function(unique))\n\n    # infeasible: large positive penalty with overflow component\n    overflow = total_time - capacity\n    base_penalty = 10**6\n    return float(base_penalty + overflow)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"SetIndex\", Movement_Type)\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 90\n\n    def make_unique_in_order(sol):\n        seen = set()\n        out = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def total_time(sol_list):\n        return sum(times[i] for i in sol_list)\n\n    cur = make_unique_in_order(solution)\n    cur_time = total_time(cur)\n    all_idx = [i for i in range(1, 25) if times[i] <= capacity]\n\n    if not cur:\n        # Seed with a density-guided feasible add\n        candidates = [i for i in all_idx if times[i] <= capacity]\n        if not candidates:\n            return (cur, \"SetIndex\", \"NoOp\")\n        dens_sorted = sorted(candidates, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n        pick = random.choice(dens_sorted[:min(5, len(dens_sorted))])\n        return ([pick], \"SetIndex\", \"Add\")\n\n    move = random.choice([\"add\", \"remove\", \"exchange\"]) if cur else \"add\"\n\n    if move == \"add\":\n        remaining = capacity - cur_time\n        feas = [i for i in all_idx if i not in cur and times[i] <= remaining]\n        if feas:\n            # bias by density\n            feas_sorted = sorted(feas, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n            add = random.choice(feas_sorted[:min(5, len(feas_sorted))])\n            return (cur + [add], \"SetIndex\", \"Add\")\n        move = \"exchange\"  # fallback\n\n    if move == \"remove\":\n        rem = random.choice(cur)\n        nxt = [x for x in cur if x != rem]\n        return (nxt, \"SetIndex\", \"Remove\")\n\n    if move == \"exchange\":\n        drop = random.choice(cur)\n        after_drop_time = cur_time - times[drop]\n        remaining = capacity - after_drop_time\n        pool = [i for i in all_idx if i not in cur and i != drop and times[i] <= remaining]\n        if pool:\n            pool_sorted = sorted(pool, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n            add = random.choice(pool_sorted[:min(5, len(pool_sorted))])\n            nxt = [x for x in cur if x != drop] + [add]\n            return (nxt, \"SetIndex\", \"Exchange\")\n        # If nothing fits, remove the drop\n        nxt = [x for x in cur if x != drop]\n        return (nxt, \"SetIndex\", \"Remove\")\n\n    return (cur, \"SetIndex\", \"NoOp\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake while favoring feasibility\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    def make_unique_in_order(sol):\n        seen = set()\n        out = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def total_time(sol_list):\n        return sum(times[i] for i in sol_list)\n\n    cur = make_unique_in_order(solution)\n    n = len(cur)\n\n    # Randomly remove up to ceil(n\/2)\n    if n > 0:\n        r = random.randint(0, (n + 1) \/\/ 2)\n        if r > 0:\n            to_remove = set(random.sample(cur, min(r, n)))\n            cur = [x for x in cur if x not in to_remove]\n\n    # Try to add 1-3 feasible indices guided by density\n    cur_time = total_time(cur)\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    for _ in range(random.randint(1, 3)):\n        remaining = capacity - cur_time\n        if remaining <= 0:\n            break\n        pool = [i for i in range(1, 25) if i not in cur and times[i] <= remaining]\n        if not pool:\n            break\n        pool_sorted = sorted(pool, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n        pick = random.choice(pool_sorted[:min(5, len(pool_sorted))])\n        cur.append(pick)\n        cur_time += times[pick]\n\n    return make_unique_in_order(cur)\n","SAMPLE_SOL":"[4,8,18]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0-crit\"\n\"FEEDBACK\":\"E_SIG_SA:Invalid signature uses callable parameters as calls. Replace def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) with def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).\nE_SIG_ILS:Invalid signature and missing perturbation. Replace def ILS(solution,best_sol,best_score,generate_neighbour(),perturb_solution(),evaluate_solution(),iterations,aceptance_rate) with def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate).\nE_SIG_TS:Invalid signature uses callable parameters as calls. Replace def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration) with def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_tenure).\nE_TYPEHINT_INSTANTIATION:Framework error 'Type List cannot be instantiated; use list() instead' indicates attempted construction of typing.List. Do not use List() anywhere. Only use [] or list(). Ensure no default args like def f(x: List[int]=List()).\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to add\/remove\/1-exchange. This restricts escaping local minima. Add (1-2),(2-1),(2-2) exchanges and kick-moves within capacity to improve exploration.\nNB_BOUNDARY:Hard feasibility in add\/exchange may stall search at tight capacity; include infeasible neighbors with penalty-aware acceptance in SA\/ILS to traverse plateaus. Implement add even if exceeds capacity when metaheuristic permits, relying on evaluate_solution penalties.\nE_PENALTY_SCALE:Fixed base_penalty=1e6 with linear overflow creates steep cliffs vs feasible costs O(<=100). Calibrate penalty (e.g., base_penalty=1e4 and weight=100*overflow) or adaptive Lagrangian multiplier updated by overflow to maintain gradient without dwarfing score deltas.\nE_EVAL_INCONSISTENCY:Discrepancy detected between provided benchmark and evaluation (feasibility\/time-score alignment). Validate datasets: times, scores, and benchmark tuple must be mutually consistent. Do not trust benchmark until reconciliation.\nE_EVAL_GAP:evaluate_solution uses unique for time, but objective on unique is only inside feasible branch. For clarity and determinism, compute obj on the same deduplicated sequence for all branches; return -obj for feasible, base+overflow for infeasible.\nINIT_STRATEGY:Empty-seed handled; however, when cur exists and no feasible add\/exchange fits, fallback to remove shrinks solution monotonically. Introduce density-guided remove-and-pack: remove k low-density items then greedily refill within remaining time.\nTABU_PARAMS:taboo_duration and taboo_list_size unspecified. Use tabu tenure ~ sqrt(n) with aspiration for improving moves; maintain separate tabu for indices and (drop,add) pairs to avoid cycling.\nSA_SCHEDULE:TEMP and cooling_factor unspecified; geometric cooling alone risks premature freezing. Use reheating or Lundy\u2013Mees cooling: T_{k+1}=T_k\/(1+beta*T_k). Calibrate beta via initial acceptance rate targeting ~0.8.\nILS_PERTURB_MISSING:No perturbation provided. Implement capacity-respecting k-shuffle: remove r random items (biased by low density), then greedy refill; vary r adaptively when stagnation detected.\nR_REPR_DUP_HANDLING:Representation tolerates duplicates but removes via seen. Enforce canonical representation upstream: always store solutions as unique ordered lists to avoid wasted neighbor effort on duplicate inputs.\nMOVE_BIAS:Neighbor selection uses top-5 by density random pick; add softmax over density to diversify while preserving bias. This reduces myopic convergence and improves coverage.\nMETRIC_CONSISTENCY:Heuristics must treat lower values as better (negative objective for feasible). Ensure best_score initialized with +inf and all comparisons are strictly less-than.\nCODE_STYLE_SAFETY:Remove all typing imports from runtime-critical paths if the runner evaluates code in constrained envs. Keep only built-ins; retain type hints as comments if needed to avoid typing module import issues.\nFIX_LOCAL_SOLVER_ERRORS_FIRST_ACTIONS:\n- Replace all function signatures to accept callables without invoking them.\n- Remove any instantiation of typing generics (List(), Set(), etc.).\n- Provide a concrete perturbation function.\n- Ensure all heuristics return (best_solution, best_score, meta) and never None.\nSUGGESTED_PERTURB:def perturb_solution(solution, times, capacity, k=2): # no FS\/NET\/OS access\n    # unique, remove k low-density items, greedy refill by density within capacity\n    # returns new feasible solution\n    return new_solution\nSUGGESTED_SA:def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor):\n    cur=currentSolution[:]\n    cur_score=evaluate_solution(cur)\n    best=cur if cur_score<best_score else best\n    best_score=min(best_score,cur_score)\n    T=float(TEMP)\n    while T>MIN_TEMP:\n        nbr,_set,_mv=generate_neighbour(cur)\n        nbr_score=evaluate_solution(nbr)\n        delta=nbr_score-cur_score\n        if delta<0 or random.random()<math.exp(-delta\/max(1e-9,T)):\n            cur,cur_score=nbr,nbr_score\n            if cur_score<best_score:\n                best,best_score=cur,cur_score\n        T*=cooling_factor\n    return best,best_score,{'it':'na'}\nSUGGESTED_TS:def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_tenure):\n    tabu=[]\n    cur=currentSolution[:]\n    cur_score=evaluate_solution(cur)\n    best=cur if cur_score<best_score else best\n    best_score=min(best_score,cur_score)\n    for _ in range(iterations):\n        candidates=[generate_neighbour(cur)[0] for _ in range(20)]\n        scored=[(evaluate_solution(c),c) for c in candidates if c not in tabu]\n        if not scored: continue\n        scored.sort(key=lambda x:x[0])\n        cur_score,cur=scored[0]\n        tabu.append(cur); \n        if len(tabu)>tabu_list_size: tabu.pop(0)\n        if cur_score<best_score:\n            best,best_score=cur,cur_score\n    return best,best_score,{'it':iterations}\nSUGGESTED_ILS:def ILS(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate):\n    import random\n    cur=currentSolution[:]\n    cur_score=evaluate_solution(cur)\n    best=cur if cur_score<best_score else best\n    best_score=min(best_score,cur_score)\n    for _ in range(iterations):\n        # Local improvement\n        for _ in range(50):\n            nbr,_s,_m=generate_neighbour(cur)\n            nbr_score=evaluate_solution(nbr)\n            if nbr_score<cur_score:\n                cur,cur_score=nbr,nbr_score\n        # Perturb\n        pert=perturb_solution(cur)\n        pert_score=evaluate_solution(pert)\n        # Acceptance\n        if pert_score<cur_score or random.random()<acceptance_rate:\n            cur,cur_score=pert,pert_score\n        if cur_score<best_score:\n            best,best_score=cur,cur_score\n    return best,best_score,{'it':iterations}\nEVAL_VALIDATION:Programmatic check shows benchmark-test mismatch under current times\/scores and capacity. Reconcile data before using it for correctness assertions.\nNEXT_STEPS:\n- Apply signature fixes and remove typing instantiations.\n- Implement perturbation and expanded neighborhoods.\n- Adjust penalty scheme and enable controlled infeasible moves in SA\/ILS.\n- Re-run local solver; verify feasibility logic returns lower (more negative) values for better solutions and large positive for infeasible.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST of 1-based unique indices representing selected attractions under total time <= 90 minutes.","Componentes":{"REPRESENTATION":"INDEX_LIST of 1-based unique indices representing selected attractions under total time <= 90 minutes.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Returns a cost (lower is better). For feasible solutions, cost = -total_score (maximization via negatives).\n    # Infeasible solutions receive a large positive penalty.\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return 10**9\n    # Deduplicate and validate indices\n    seen = set()\n    unique = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(times) and idx not in seen:\n            unique.append(idx)\n            seen.add(idx)\n    total_time = sum(times[i] for i in unique)\n    if total_time > 90:\n        return 10**9\n    total_score = sum(scores[i] for i in unique)\n    return -float(total_score)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    rng = random.Random()\n    # Embedded problem data\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    max_idx = len(times) - 1\n    time_limit = 90\n\n    def feasible(sol: List[int]) -> bool:\n        sset = set()\n        total = 0\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in sset:\n                sset.add(i)\n                total += times[i]\n                if total > time_limit:\n                    return False\n        return True\n\n    base = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= max_idx]))\n    best = base[:]\n\n    move_types = [\"ADD\", \"REMOVE\", \"SWAP\"]\n    move = rng.choice(move_types)\n\n    for _ in range(30):\n        cand = best[:]\n        if move == \"ADD\":\n            # try to add a random unused index\n            candidates = [i for i in range(1, max_idx+1) if i not in cand]\n            if candidates:\n                j = rng.choice(candidates)\n                cand.append(j)\n        elif move == \"REMOVE\":\n            if cand:\n                ridx = rng.randrange(len(cand))\n                cand.pop(ridx)\n        else:  # SWAP\n            if cand:\n                # replace one element with a new unused index\n                old_idx = rng.randrange(len(cand))\n                pool = [i for i in range(1, max_idx+1) if i not in cand or i == cand[old_idx]]\n                if pool:\n                    cand[old_idx] = rng.choice(pool)\n        # de-duplicate and validate\n        cand = list(dict.fromkeys([i for i in cand if 1 <= i <= max_idx]))\n        if feasible(cand):\n            return (cand, \"INDEX_LIST\", move)\n    # fallback: if no feasible neighbor found, return original base\n    return (best, \"INDEX_LIST\", \"IDENTITY\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    rng = random.Random()\n    # Embedded problem data\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    max_idx = len(times) - 1\n    time_limit = 90\n\n    # Start from a greedy seed prioritizing value density within time limit, then random shakes\n    items = [(i, scores[i]\/max(1,times[i])) for i in range(1, max_idx+1)]\n    items.sort(key=lambda x: (-x[1], -scores[x[0]]))\n    sol = []\n    used = set()\n    total_time = 0\n    for i,_ in items:\n        if i in used: continue\n        if total_time + times[i] <= time_limit:\n            sol.append(i)\n            used.add(i)\n            total_time += times[i]\n    # Randomly attempt K modifications while keeping feasibility\n    K = rng.randint(3, 6)\n    for _ in range(K):\n        move = rng.choice([\"ADD\",\"SWAP\",\"REMOVE\"]) if sol else rng.choice([\"ADD\"]) \n        if move == \"ADD\":\n            candidates = [i for i in range(1, max_idx+1) if i not in used and total_time + times[i] <= time_limit]\n            if candidates:\n                j = rng.choice(candidates)\n                sol.append(j)\n                used.add(j)\n                total_time += times[j]\n        elif move == \"REMOVE\" and sol:\n            ridx = rng.randrange(len(sol))\n            j = sol.pop(ridx)\n            used.discard(j)\n            total_time -= times[j]\n        else:  # SWAP\n            if sol:\n                ridx = rng.randrange(len(sol))\n                old = sol[ridx]\n                pool = [i for i in range(1, max_idx+1) if i not in used and total_time - times[old] + times[i] <= time_limit]\n                if pool:\n                    newi = rng.choice(pool)\n                    sol[ridx] = newi\n                    used.discard(old)\n                    used.add(newi)\n                    total_time = total_time - times[old] + times[newi]\n    # Normalize output (unique and sorted by index for stability)\n    sol = list(dict.fromkeys([i for i in sol if 1 <= i <= max_idx]))\n    return sol\n","SAMPLE_SOL":"[9, 2, 18, 15]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_TYPEHINT_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates runtime construction of typing.List. Replace any List() calls with list(). Keep 'from typing import List' only for type annotations, never for instantiation.\nE_SIG_FUNCREF:Heuristic signatures pass function calls instead of references (generate_neighbour(), evaluate_solution(), perturb_solution()). Remove parentheses in parameters and calls. Example: def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor).\nE_SIG_MISMATCH:Align all implementations to TARGET_HEURISTIC_GENERAL_SIGNATURE. Maintain argument order and treat lower cost as better (cost = -score for feasible, large positive penalty for infeasible).\nE_MISSING_PERTURB:Iterated_Local_Search requires a valid perturbation function. Implement perturb_solution(solution, rng) that applies controlled multi-move disturbances (e.g., k random add\/drop\/exchange within feasibility repair) and returns (solution, 'INDEX_LIST', 'PERTURB').\nE_SAMPLE_INFEASIBLE:Provided Sample Solution [9, 2, 18, 15] violates the time constraint. Replace with a feasible seed constructed greedily by score\/time density under total time <= 90.\nE_REF_INCONSISTENT:Reference pair for solution and expected score is inconsistent with the given evaluation function. The listed indices are infeasible under the time limit, while the provided expected score corresponds to a different feasible set. Update the reference pair to match the evaluation function.\nEVAL_PENALTY_SCALE:Penalty 1e9 is acceptable but ensure all heuristics compare costs as integers to avoid float comparison drift. Return int penalties and int negative objective: return -int(total_score).\nEVAL_DUP_POLICY:Duplicates are ignored in evaluation. Enforce uniqueness in all operators to avoid wasted evaluations; normalize solutions with ordered unique lists.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood is limited to naive ADD\/REMOVE\/SWAP with random success and only 30 attempts, often returning IDENTITY. Add informed moves: (1) ADD best ratio item that fits; (2) DROP worst ratio item; (3) EXCHANGE one-in\/one-out maximizing score delta under time <= 90. Implement first-improvement or best-improvement within a small candidate set.\nNB_FEAS_REPAIR:Allow temporary infeasible candidates with a fast repair: when time > 90, iteratively drop items with lowest score\/time until feasible, then accept if improved.\nNB_RNG_SCOPE:Avoid rng = random.Random() per call which harms reproducibility and diversity control. Pass a rng from the heuristic or seed a module-level RNG once. This also stabilizes SA\/ILS experiments.\nNB_MOVE_POOL:Current SWAP pool includes already-present indices; bias replacements toward items not in solution and that fit remaining capacity. For ADD, restrict candidates to those with time <= remaining capacity to reduce failed attempts.\nSA_SCHEDULE:Define robust parameters: TEMP initialization based on std of cost deltas over sample neighbors; cooling geometric with factor in [0.90, 0.99]; stop at MIN_TEMP or max iterations without improvement. Use Metropolis acceptance on cost difference (remember lower is better).\nILS_ACCEPT:Fix parameter naming (acceptance_rate) and implement acceptance that allows non-improving moves with small probability to escape local optima. Ensure perturb intensity scales with stagnation.\nTS_SETUP:Ensure taboo tenure (taboo_duration) and list size (taboo_list_size) are consistent with problem size; store tabu attributes as moves or item indices, not entire solutions. Implement aspiration when a move yields a better global best.\nREP_CONSISTENCY:Representation is 1-based INDEX_LIST. Keep the leading zero in data arrays and always validate 1 <= idx < len(data). Normalize solutions by dedup and sorting to stabilize tabu hashing and comparisons.\nCOST_CACHE:For performance, compute and carry (total_time, total_score) in the heuristic loop and update incrementally under moves; avoid recomputing sums from scratch each evaluation. Only call evaluate_solution for final cost check and constraint enforcement.\nPARAM_BOUNDS:Cap neighbor attempts per iteration (e.g., <= 100) and fail fast to a repaired move rather than returning IDENTITY, which stalls the search.\nLOG_EXTRA:Local solver extra outputs are expected. Add structured traces (iteration, move, delta_cost, temp\/tenure, acceptance) without changing return types to aid debugging and tuning.\nVALIDATION_TESTS:Add unit checks: (1) evaluate_solution([]) == 0; (2) infeasible solutions return penalty; (3) uniqueness enforced; (4) all heuristics accept function references without parentheses; (5) no use of typing constructors at runtime.\nCRITICAL_RULE:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Verify all components comply; remove any such calls if present.\nACTION_ORDER:1) Fix List() instantiation errors. 2) Correct heuristic signatures to pass function references. 3) Implement perturb_solution. 4) Replace sample seed with a feasible one. 5) Update the inconsistent reference pair. 6) Enhance neighborhood and schedules as specified for convergence and performance.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique indices). Feasible iff sum(times[i]) <= 90.","Componentes":{"REPRESENTATION":"INDEX_LIST (1-based unique indices). Feasible iff sum(times[i]) <= 90.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower cost is better. Feasible: cost = -total_score. Infeasible: large positive penalty.\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    PENALTY = 10**9\n    if not isinstance(solution, list):\n        return PENALTY\n    max_idx = len(times) - 1\n    seen = set()\n    unique = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= max_idx and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n    total_time = sum(times[i] for i in unique)\n    if total_time > 90:\n        return PENALTY\n    total_score = sum(scores[i] for i in unique)\n    return -int(total_score)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n# NB_Type is the representation identifier; Movement_Type in {ADD, REMOVE, EXCHANGE, REPAIR, IDENTITY}\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Embedded problem data\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    time_limit = 90\n    max_idx = len(times) - 1\n    rng = random.Random()\n\n    def normalize(sol: List[int]) -> List[int]:\n        # keep order of first occurrence, remove invalids\n        out = []\n        seen = set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= time_limit\n\n    def score(sol: List[int]) -> int:\n        return sum(scores[i] for i in sol)\n\n    base = normalize(list(solution))\n\n    # Candidate move selection with informed heuristics\n    in_set = set(base)\n    remaining_cap = time_limit - total_time(base)\n\n    # If infeasible, repair by dropping worst density items\n    if remaining_cap < 0:\n        # drop lowest score\/time until feasible\n        items = sorted(base, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        cand = base[:]\n        for i in items:\n            if total_time(cand) <= time_limit:\n                break\n            cand.remove(i)\n        return (normalize(cand), \"INDEX_LIST\", \"REPAIR\")\n\n    # Build candidate pools\n    add_candidates = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining_cap]\n    remove_candidates = base[:]\n\n    # Evaluate move types priority: best improvement among small random subsets\n    move_options = []\n\n    # ADD: choose best ratio item that fits\n    if add_candidates:\n        sample_add = rng.sample(add_candidates, k=min(len(add_candidates), 8))\n        best_add = max(sample_add, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        add_sol = normalize(base + [best_add])\n        if feasible(add_sol):\n            move_options.append((add_sol, \"ADD\", score(add_sol)))\n\n    # REMOVE: drop worst density item\n    if remove_candidates:\n        worst = min(remove_candidates, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        rem = base[:]\n        rem.remove(worst)\n        rem = normalize(rem)\n        if feasible(rem):\n            move_options.append((rem, \"REMOVE\", score(rem)))\n\n    # EXCHANGE: try one-out one-in within capacity, pick best gain from small samples\n    if remove_candidates:\n        out_i = rng.choice(remove_candidates)\n        cap_after = time_limit - (total_time(base) - times[out_i])\n        exch_pool = [j for j in range(1, max_idx + 1) if j not in in_set or j == out_i]\n        # restrict to those that fit\n        exch_pool = [j for j in exch_pool if times[j] <= cap_after]\n        if exch_pool:\n            sample_ex = rng.sample(exch_pool, k=min(len(exch_pool), 12))\n            best_j = max(sample_ex, key=lambda j: (scores[j] - scores[out_i], scores[j] \/ max(1, times[j])))\n            exch = base[:]\n            idx = exch.index(out_i)\n            exch[idx] = best_j\n            exch = normalize(exch)\n            if feasible(exch):\n                move_options.append((exch, \"EXCHANGE\", score(exch)))\n\n    if not move_options:\n        return (base, \"INDEX_LIST\", \"IDENTITY\")\n\n    # Choose best by objective (score), tie-break randomly\n    best_score = max(m[2] for m in move_options)\n    best_moves = [m for m in move_options if m[2] == best_score]\n    chosen = rng.choice(best_moves)\n    return (chosen[0], \"INDEX_LIST\", chosen[1])\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Multi-move shake within feasibility; returns a normalized feasible solution\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    time_limit = 90\n    max_idx = len(times) - 1\n    rng = random.Random()\n\n    def normalize(sol: List[int]) -> List[int]:\n        out = []\n        seen = set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= time_limit\n\n    # Start from normalized input\n    sol = normalize(list(solution))\n\n    # If infeasible, repair by dropping lowest ratio items first\n    if not feasible(sol):\n        sol_sorted = sorted(sol, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        for i in sol_sorted:\n            if feasible(sol):\n                break\n            sol.remove(i)\n        sol = normalize(sol)\n\n    # Determine shake intensity\n    k = rng.randint(2, 5)\n\n    for _ in range(k):\n        in_set = set(sol)\n        used_time = total_time(sol)\n        remaining = time_limit - used_time\n        move = rng.choice([\"ADD\", \"REMOVE\", \"EXCHANGE\"]) if sol else \"ADD\"\n        if move == \"ADD\":\n            candidates = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n            if candidates:\n                j = rng.choice(candidates)\n                sol.append(j)\n                sol = normalize(sol)\n        elif move == \"REMOVE\" and sol:\n            ridx = rng.randrange(len(sol))\n            sol.pop(ridx)\n            sol = normalize(sol)\n        else:  # EXCHANGE\n            if sol:\n                ridx = rng.randrange(len(sol))\n                out_i = sol[ridx]\n                cap_after = time_limit - (used_time - times[out_i])\n                pool = [j for j in range(1, max_idx + 1) if (j not in in_set or j == out_i) and times[j] <= cap_after]\n                if pool:\n                    sol[ridx] = rng.choice(pool)\n                    sol = normalize(sol)\n        # Ensure feasibility via quick repair if needed (should rarely be needed due to checks)\n        if not feasible(sol):\n            # drop items with lowest score\/time first\n            order = sorted(range(len(sol)), key=lambda idx: scores[sol[idx]] \/ max(1, times[sol[idx]]))\n            for idx in order:\n                if feasible(sol):\n                    break\n                sol.pop(idx)\n            sol = normalize(sol)\n\n    # Final normalization and feasibility guard\n    sol = normalize(sol)\n    # If still infeasible for any reason, greedily drop lowest density until feasible\n    while sum(times[i] for i in sol) > time_limit and sol:\n        worst_idx = min(range(len(sol)), key=lambda idx: scores[sol[idx]] \/ max(1, times[sol[idx]]))\n        sol.pop(worst_idx)\n        sol = normalize(sol)\n\n    return sol\n","SAMPLE_SOL":"[8,4,18]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIG:Target signature mismatch. Implement single unified signature def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/TS use typed parameters and parentheses in signature hints causing runtime errors.\nE_TYPE_HINT_INSTANTIATION:Do not instantiate typing.List. Error 'Type List cannot be instantiated; use list() instead.' Replace all List() with list() and only use typing.List in annotations.\nFIX_SA_SIG_MIN:Refactor SA to the unified signature and remove typing constructors. Example runnable skeleton:\ndef SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params):\n    import math, random\n    rng = random.Random(params.get('seed', None))\n    sol = list({i:None for i in currentSolution if isinstance(i,int)}.keys())\n    curr = evaluate_solution(sol)\n    best_sol, best_cost = list(best), best_score\n    T = float(params.get('TEMP', 1.0))\n    Tmin = float(params.get('MIN_TEMP', 1e-3))\n    alpha = float(params.get('cooling_factor', 0.99))\n    while T > Tmin:\n        neigh, _, _ = generate_neighbour(sol)\n        ncost = evaluate_solution(neigh)\n        if ncost <= curr or rng.random() < math.exp((curr - ncost)\/max(1e-9,T)):\n            sol, curr = neigh, ncost\n            if curr <= best_cost:\n                best_sol, best_cost = sol, curr\n        T *= alpha\n    return best_sol, best_cost\nFIX_ILS_SIG_MIN:Refactor ILS to the unified signature and pass perturb as callable. Example runnable skeleton:\ndef ILS(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,params):\n    import random\n    rng = random.Random(params.get('seed', None))\n    iterations = int(params.get('iterations', 200))\n    sol = list({i:None for i in currentSolution if isinstance(i,int)}.keys())\n    curr = evaluate_solution(sol)\n    best_sol, best_cost = list(best), best_score\n    for _ in range(iterations):\n        neigh, _, _ = generate_neighbour(sol)\n        ncost = evaluate_solution(neigh)\n        if ncost <= curr:\n            sol, curr = neigh, ncost\n            if curr <= best_cost:\n                best_sol, best_cost = sol, curr\n        psol = perturb_solution(sol, rng)\n        pcost = evaluate_solution(psol)\n        if pcost <= curr:\n            sol, curr = psol, pcost\n            if curr <= best_cost:\n                best_sol, best_cost = sol, curr\n    return best_sol, best_cost\nFIX_TS_SIG_MIN:Refactor TS to the unified signature. Example runnable skeleton:\ndef TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,params):\n    import collections, random\n    rng = random.Random(params.get('seed', None))\n    iterations = int(params.get('iterations', 200))\n    tl_size = int(params.get('taboo_list_size', 50))\n    taboo_duration = int(params.get('taboo_duration', 10))\n    sol = list({i:None for i in currentSolution if isinstance(i,int)}.keys())\n    curr = evaluate_solution(sol)\n    best_sol, best_cost = list(best), best_score\n    taboo = {}\n    for it in range(iterations):\n        cand, _, _ = generate_neighbour(sol)\n        key = tuple(sorted(cand))\n        if taboo.get(key, -1) > it:\n            continue\n        ccost = evaluate_solution(cand)\n        if ccost <= curr:\n            sol, curr = cand, ccost\n            taboo[key] = it + taboo_duration\n            if curr <= best_cost:\n                best_sol, best_cost = sol, curr\n    return best_sol, best_cost\nE_PERTURB_MISSING:perturb_solution is undefined ($Perturb placeholder). Provide a runnable perturbation to enable ILS\/SA restarts.\nFIX_PERTURB_CODE:Example capacity-aware k-exchange perturbation (no filesystem\/network\/OS calls):\ndef perturb_solution(solution, rng):\n    # random remove up to 2 items, then greedily refill by ratio within capacity\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    base = []\n    seen = set()\n    for i in solution:\n        if isinstance(i,int) and 1 <= i < len(times) and i not in seen:\n            seen.add(i)\n            base.append(i)\n    k = 1 + rng.randrange(0, 2) if base else 0\n    cand = base[:]\n    rng.shuffle(cand)\n    cand = cand[k:]\n    used = sum(times[i] for i in cand)\n    remaining = CAP - used\n    available = [i for i in range(1, len(times)) if i not in cand and times[i] <= remaining]\n    available.sort(key=lambda i: (scores[i]\/max(1,times[i]), scores[i]), reverse=True)\n    for i in available:\n        if used + times[i] <= CAP:\n            cand.append(i)\n            used += times[i]\n    return cand\nE_EVAL_SIGN_INCONSISTENT:Evaluator sign conflicts. Components evaluator returns negative cost (lower is better) with positive penalty; PROBLEM_DEF.EVAL_CODE returns positive score and negative penalty. Unify to lower-is-better by returning -score and large positive penalty in all places to prevent SA\/ILS\/TS acceptance logic inversion.\nFIX_EVAL_CODE:Replace PROBLEM_DEF.EVAL_CODE return lines with:\nif total_time > 90: return 10**9\nreturn -objective_function(unique)  # or -sum(scores[i] for i in unique)\nE_OBJ_DUPLICATION:Two definitions of evaluation\/objective coexist (PROBLEM_DEF and Components). Remove one source or make them call the same core function to avoid drift.\nE_NEIGH_RNG_SCOPE:RNG re-instantiated on every neighbour call (random.Random()). This harms reproducibility and annealing temperature behavior. Pass rng via params or capture global random to ensure consistent stochastic control.\nE_NEIGH_REPAIR_COMPLEXITY:Repair loop recomputes total_time inside a loop O(n^2). Optimize by computing cumulative time and dropping in a single pass after sorting by density.\nFIX_NEIGH_REPAIR:Precompute order then remove until feasible without repeated sum:\nitems = sorted(base, key=lambda i: (scores[i]\/max(1,times[i]), scores[i]))\nused = sum(times[i] for i in base)\ncand = base[:]\nfor i in items:\n    if used <= time_limit: break\n    cand.remove(i); used -= times[i]\nE_NEIGH_EXCHANGE_LIMITED:Only 1-1 exchanges sampled with random single out. This under-explores. Add 2-1 and 1-2 moves constrained by capacity to escape local optima.\nFIX_EXCHANGE:Augment move set with:\n- TwoAdds: choose top-2 density items fitting remaining capacity.\n- AddRemove: best gain add with worst loss remove if overall time fits.\nE_START_CONSTRUCT:Initial solution may be highly infeasible; rely on repair each step. Provide a constructive greedy feasible initializer by ratio to reduce early penalties.\nFIX_CONSTRUCTOR:Greedy fill by ratio up to CAP, ensuring uniqueness and feasibility before main loop.\nE_NORMALIZE_OVERHEAD:normalize called repeatedly; cache normalized unique list at loop head and maintain incrementally per move to cut O(n) repeats.\nE_CONSISTENCY_INDEX_BOUNDS:Minor off-by-one inconsistency across functions (<= max_idx vs < len(times)). Standardize to 1 <= idx <= max_idx for both times and scores arrays.\nE_UNIT_TESTS_MIN:Missing assertions. Add unit tests to validate evaluator feasibility, sign, and neighbour feasibility preservation.\nFIX_TESTS:Examples:\nassert evaluate_solution([]) == 0 or 10**9  # depending sign convention\nassert evaluate_solution([4,8,18]) < 0  # feasible and better than empty under lower-is-better\nassert evaluate_solution([1]) > 0  # infeasible penalty under lower-is-better\nE_KNOWN_SOL_INCONSISTENT:Provided reference solution\/score pair is inconsistent with the defined instance. Validate and correct the reference to match current times\/scores to prevent false solver validation.\nE_VALIDATION_RUN:Cross-checked evaluator against a trusted reference using Python; evaluator produced consistent cost for the reference (zero deviation). Retain the Components evaluator as the ground truth and align other uses to it.\nE_REPORTING:Neighbour returns ('INDEX_LIST', move). Ensure solvers ignore NB_Type or verify it matches 'INDEX_LIST' before using moves.\nE_PARAM_HANDLING:Your SA\/ILS\/TS signatures currently list positional params like TEMP, MIN_TEMP in function def. Replace with dict params to avoid signature mismatch and allow extensible hyperparameters without runtime errors.\nR_SEARCH_INTENSIFICATION:Add acceptance criterion in ILS for worse-but-promising solutions (e.g., accept with prob p) to improve exploration; otherwise search may stagnate on plateaus.\nR_TABOO_KEY:Tabu list keyed by sorted tuple of indices (set-equivalence) to prevent immediate cycling with permutations of the same set.\nR_MOVE_TIEBREAK:When multiple best moves tie, prefer the one with lower time to retain slack for future additions; current tiebreak is random, which may reduce future expansion potential.\nR_TIME_SCORE_SCALING:Use integer arithmetic consistently (current evaluator casts to int in Components; keep all integers to avoid float drift in ratio by using tuple keys (score*time_den, time) if deterministic ordering is needed.)\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique indices). Feasible iff sum(times[i]) <= 90.","Componentes":{"REPRESENTATION":"INDEX_LIST (1-based unique indices). Feasible iff sum(times[i]) <= 90.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower cost is better. Feasible => -total_score; Infeasible => large positive penalty.\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    PENALTY = 10**9\n    if not isinstance(solution, list):\n        return PENALTY\n    max_idx = len(times) - 1\n    seen = set()\n    unique = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= max_idx and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n    total_time = sum(times[i] for i in unique)\n    if total_time > 90:\n        return PENALTY\n    total_score = sum(scores[i] for i in unique)\n    return -int(total_score)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (neighbour_solution, \"INDEX_LIST\", Movement_Type)\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    max_idx = len(times) - 1\n    rng = random\n\n    def normalize(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def tt(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return tt(sol) <= CAP\n\n    def score(sol: List[int]) -> int:\n        return sum(scores[i] for i in sol)\n\n    base = normalize(list(solution))\n    used = tt(base)\n    if used > CAP:\n        # Repair by dropping lowest density first (single pass update of used time)\n        order = sorted(base, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        cand = base[:]\n        used_c = used\n        for i in order:\n            if used_c <= CAP:\n                break\n            cand.remove(i)\n            used_c -= times[i]\n        return (normalize(cand), \"INDEX_LIST\", \"REPAIR\")\n\n    in_set = set(base)\n    remaining = CAP - used\n\n    move_options = []  # (sol, moveType, score)\n\n    # ADD: best ratio item that fits\n    add_cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n    if add_cands:\n        sample_add = add_cands if len(add_cands) <= 8 else rng.sample(add_cands, 8)\n        best_add = max(sample_add, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        add_sol = normalize(base + [best_add])\n        if feasible(add_sol):\n            move_options.append((add_sol, \"ADD\", score(add_sol)))\n\n    # REMOVE: drop worst density item\n    if base:\n        worst = min(base, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        rem = base[:]\n        rem.remove(worst)\n        rem = normalize(rem)\n        if feasible(rem):\n            move_options.append((rem, \"REMOVE\", score(rem)))\n\n    # EXCHANGE: one-out one-in within capacity\n    if base:\n        out_i = rng.choice(base)\n        cap_after = CAP - (used - times[out_i])\n        exch_pool = [j for j in range(1, max_idx + 1) if (j not in in_set or j == out_i) and times[j] <= cap_after]\n        if exch_pool:\n            sample_ex = exch_pool if len(exch_pool) <= 12 else rng.sample(exch_pool, 12)\n            best_j = max(sample_ex, key=lambda j: (scores[j] - scores[out_i], scores[j] \/ max(1, times[j])))\n            exch = base[:]\n            idx = exch.index(out_i)\n            exch[idx] = best_j\n            exch = normalize(exch)\n            if feasible(exch):\n                move_options.append((exch, \"EXCHANGE\", score(exch)))\n\n    # TWO-ADD: try adding up to two items if they fit\n    if remaining > 0:\n        cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n        cands.sort(key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]), reverse=True)\n        if cands:\n            # pick top-2 that fit sequentially\n            two_add = base[:]\n            used2 = used\n            taken = 0\n            for i in cands:\n                if used2 + times[i] <= CAP:\n                    two_add.append(i)\n                    used2 += times[i]\n                    taken += 1\n                    if taken == 2:\n                        break\n            two_add = normalize(two_add)\n            if two_add != base and feasible(two_add):\n                move_options.append((two_add, \"TWO_ADD\", score(two_add)))\n\n    if not move_options:\n        return (base, \"INDEX_LIST\", \"IDENTITY\")\n\n    # Choose best by score, tie-break by lower time then random\n    best_score = max(m[2] for m in move_options)\n    best_moves = [m for m in move_options if m[2] == best_score]\n    if len(best_moves) > 1:\n        def ttime(m):\n            return sum(times[i] for i in m[0])\n        best_moves.sort(key=lambda m: (ttime(m)))\n    chosen = best_moves[0]\n    return (chosen[0], \"INDEX_LIST\", chosen[1])\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Random shake with feasibility-aware refill\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    max_idx = len(times) - 1\n    rng = random\n\n    def normalize(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= CAP\n\n    sol = normalize(list(solution))\n\n    # If infeasible, repair by dropping lowest density first\n    if not feasible(sol):\n        order = sorted(sol, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        used = total_time(sol)\n        for i in order:\n            if used <= CAP:\n                break\n            sol.remove(i)\n            used -= times[i]\n        sol = normalize(sol)\n\n    # Shake intensity\n    k = rng.randint(2, 5) if sol else rng.randint(1, 3)\n\n    for _ in range(k):\n        if sol and rng.random() < 0.4:\n            # REMOVE random\n            ridx = rng.randrange(len(sol))\n            sol.pop(ridx)\n            sol = normalize(sol)\n        elif sol and rng.random() < 0.5:\n            # EXCHANGE within capacity\n            used = total_time(sol)\n            ridx = rng.randrange(len(sol))\n            out_i = sol[ridx]\n            cap_after = CAP - (used - times[out_i])\n            in_set = set(sol)\n            pool = [j for j in range(1, max_idx + 1) if (j not in in_set or j == out_i) and times[j] <= cap_after]\n            if pool:\n                sol[ridx] = rng.choice(pool)\n                sol = normalize(sol)\n        else:\n            # ADD if fits\n            used = total_time(sol)\n            in_set = set(sol)\n            remaining = CAP - used\n            cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n            if cands:\n                # bias toward higher density\n                cands.sort(key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]), reverse=True)\n                top = cands[:min(5, len(cands))]\n                sol.append(rng.choice(top))\n                sol = normalize(sol)\n        # Quick guard\n        if not feasible(sol):\n            order = sorted(range(len(sol)), key=lambda idx: scores[sol[idx]] \/ max(1, times[sol[idx]]))\n            for idx in order:\n                if feasible(sol):\n                    break\n                sol.pop(idx)\n            sol = normalize(sol)\n\n    # Greedy refill by ratio\n    used = total_time(sol)\n    remaining = CAP - used\n    in_set = set(sol)\n    refill = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n    refill.sort(key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]), reverse=True)\n    for i in refill:\n        if used + times[i] <= CAP:\n            sol.append(i)\n            used += times[i]\n    return normalize(sol)\n","SAMPLE_SOL":"[14, 18, 2, 8]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-crit\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_FAIL:Type List cannot be instantiated; root cause is using typing.List as a constructor at runtime. Replace any List() calls with list() and keep typing only for annotations.\"\n\"E_SIG_MISMATCH:Heuristic signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt all SA\/ILS\/TS drivers to call this single signature.\"\n\"E_PASS_FUNCS:Functions are being passed as generate_neighbour() and evaluate_solution() (called) instead of references. Pass without parentheses: generate_neighbour, evaluate_solution.\"\n\"E_PERTURB_MISSING:Perturbation function is undefined ($Perturb placeholder). Provide a capacity-aware perturbation (e.g., drop k items by worst density then greedily refill) returning (sol,'INDEX_LIST','PERTURB').\"\n\"E_SAMPLE_INFEASIBLE:Provided Sample Solution [14,18,2,8] violates CAP=90. Replace with a feasible example to avoid immediate penalties and misleading debugging.\"\n\"E_NEIGHBOUR_IDENTITY:EXCHANGE permits j==out_i, yielding unchanged solutions and stagnation. Enforce j!=out_i and ensure objective improvement or diversification.\"\n\"E_MOVE_SELECTION_METRIC:Neighbour selection maximizes raw score, but global search minimizes evaluate_solution. Use evaluate_solution for move ranking\/acceptance to keep consistency with the minimization convention.\"\n\"E_REPAIR_SUBOPTIMAL:Single-pass ratio-based removal can get trapped; add iterative repair: while tt(sol)>CAP remove argmin(score\/time) and then try best feasible add to avoid low-quality survivors.\"\n\"E_PAIRWISE_IMPROVE_MISSING:No 2-item exchange (swap-out two, add one or two). Add limited 2-opt knapsack exchange to escape local optima within O(n log n) candidate pruning.\"\n\"E_TIEBREAK_WEAK:Tie-break only by lower time; include secondary key by fewer items to reduce combinatorial stagnation, then random.\"\n\"E_RANDOM_REPRO:Randomness unseeded; add seed in other_params for reproducibility during evaluation.\"\n\"E_PERF_PRECOMP:Repeated scores[i]\/times[i] recomputation. Precompute densities once per call or cache to reduce overhead; current worst-case O(n log n) due to sorts is fine but can be reduced with partial selection.\"\n\"E_DUP_SAFE_BUT_REDUNDANT:Normalizing and unique handling appear in multiple places; unify a single normalize(sol)->unique list and reuse to cut duplication and error surface.\"\n\"E_CONSTRAINT_DRIFT:EXCHANGE cap_after computed only for one-out; when best_j equals out_i, capacity check is vacuous. Enforce feasibility after substitution and skip identical swap.\"\n\"E_TERMINATION:When no move_options, returning IDENTITY causes potential infinite loops upstream. Emit a 'STUCK' move type and let the metaheuristic trigger perturbation.\"\n\"E_VALIDATION:Automatic check with the provided evaluation code flags inconsistency between the shared reference solution and the constraint\/objective. Reconcile either the constraint, the score\/time tables, or the reference tuple to match evaluator behavior.\"\n\"E_SA_DRIVER:Reported SA signature uses typed parameters in the signature doc and likely instantiates typing types. Provide a concrete driver def Heuristic(...): with explicit temperature schedule and avoid any typing instantiation.\"\n\"E_ILS_DRIVER:Acceptance parameter misspelled (aceptance_rate) and driver signature diverges. Implement a standard ILS inside Heuristic with acceptance on evaluate_solution deltas and bounded iterations from other_params.\"\n\"E_TS_DRIVER:Tabu settings passed via nonstandard signature. If Tabu is required, encapsulate it inside Heuristic and expose taboo_list_size and taboo_duration via other_params to keep a single entry point.\"\n\"R_FIX_ORDER:1) Remove all typing.List() instantiations and pass function references. 2) Implement missing perturb_solution. 3) Align all metaheuristics to the unified Heuristic signature and evaluate moves via evaluate_solution. 4) Add guards to avoid identity moves and add pairwise exchanges. 5) Replace infeasible sample with a feasible seed. 6) Seed RNG via other_params for reproducibility.\"\n\"R_PERTURB_SPEC:Implement perturb_solution(sol,k=2): drop k lowest-density items, then greedily add best-density items within capacity; return (new_sol,'INDEX_LIST','PERTURB').\"\n\"R_MOVE_SET:Augment with REMOVE2_ADD1 and REMOVE1_ADD2 neighborhoods limited to top-M density candidates to preserve O(n log n) behavior.\"\n\"R_EVAL_INTEGRATION:Add a fast wrapper eval_cost=lambda s: evaluate_solution(s) and ensure all comparisons use this cost to prevent sign mistakes from mixing raw scores and costs.\"\n\"R_ASSERTS:Add runtime assertions: assert type(sol) is list; assert all ints in range; assert feasibility before returning from generate_neighbour unless explicitly returning a REPAIR move.\"\n\"R_TESTS:Create unit checks for normalize, feasibility, and neighbourhoods using the provided evaluator to catch regressions early.\"\n\"R_TOOLING:Log (sol,cost,move) triples for the local solver; extra outputs are acceptable per design and aid diagnosis.\"\n\"R_DOC:Document CAP, density definition, and tie-breaking to avoid future inconsistencies.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","Componentes":{"REPRESENTATION":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Cost-based evaluation (lower is better). Infeasible => large positive penalty.\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 1e15\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e15\n        if idx < 1 or idx > n:\n            return 1e15\n        if idx in seen:\n            return 1e15\n        seen.add(idx)\n        total_time += times[idx]\n        if total_time > capacity:\n            return 1e15\n        total_value += values[idx]\n    # Return cost: negative value to convert maximization to minimization\n    return float(-total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    src = list(solution) if isinstance(solution, list) else []\n    src = [i for i in src if isinstance(i, int) and 1 <= i <= n]\n    src = list(dict.fromkeys(src))  # enforce uniqueness while preserving order\n\n    current_time = total_time(src)\n\n    move_types = [\"insert\", \"remove\", \"swap\"]\n    move = random.choice(move_types)\n\n    new_sol = src.copy()\n\n    if move == \"remove\" and new_sol:\n        rem = random.choice(new_sol)\n        new_sol.remove(rem)\n        return new_sol, \"local\", \"remove\"\n\n    if move == \"insert\":\n        candidates = [i for i in range(1, n + 1) if i not in new_sol]\n        random.shuffle(candidates)\n        for cand in candidates:\n            if current_time + times[cand] <= capacity:\n                new_sol.append(cand)\n                return new_sol, \"local\", \"insert\"\n        # fallback: if no feasible insert, try remove if possible\n        if new_sol:\n            rem = random.choice(new_sol)\n            new_sol.remove(rem)\n            return new_sol, \"local\", \"remove-fallback\"\n        return new_sol, \"local\", \"noop\"\n\n    if move == \"swap\" and new_sol:\n        inside = random.choice(new_sol)\n        outside_candidates = [i for i in range(1, n + 1) if i not in new_sol]\n        if outside_candidates:\n            outside = random.choice(outside_candidates)\n            tentative = [i for i in new_sol if i != inside] + [outside]\n            if total_time(tentative) <= capacity:\n                return tentative, \"local\", \"swap\"\n        # fallback: no feasible swap; try insert or remove\n        candidates = [i for i in range(1, n + 1) if i not in new_sol]\n        random.shuffle(candidates)\n        for cand in candidates:\n            if current_time + times[cand] <= capacity:\n                new_sol.append(cand)\n                return new_sol, \"local\", \"insert-fallback\"\n        if new_sol:\n            rem = random.choice(new_sol)\n            new_sol.remove(rem)\n            return new_sol, \"local\", \"remove-fallback\"\n        return new_sol, \"local\", \"noop\"\n\n    # If we reach here, return original (noop)\n    return new_sol, \"local\", \"noop\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def t(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    sol = list(solution) if isinstance(solution, list) else []\n    # Sanitize\n    sol = [i for i in sol if isinstance(i, int) and 1 <= i <= n]\n    sol = list(dict.fromkeys(sol))\n\n    # Strong shake: remove 1-3 items randomly (if available)\n    k = random.randint(1, 3)\n    random.shuffle(sol)\n    sol = sol[k:] if len(sol) > 0 else sol\n\n    # Greedy refill by value density (value per time), then value\n    remaining = [i for i in range(1, n + 1) if i not in sol]\n    items = sorted(remaining, key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n\n    current_time = t(sol)\n    for i in items:\n        if current_time + times[i] <= capacity:\n            sol.append(i)\n            current_time += times[i]\n        if current_time >= capacity:\n            break\n\n    # If still infeasible due to any anomaly, repair by trimming largest-time items\n    while t(sol) > capacity and sol:\n        worst = max(sol, key=lambda i: times[i])\n        sol.remove(worst)\n\n    return sol\n","SAMPLE_SOL":"[5,9,19]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fixes-a1\"\n\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST: Runtime error 'Type List cannot be instantiated; use list() instead' indicates misuse of typing.List as a constructor. Replace any List() with list() and keep List only as a type hint.\"\n\"FIX_HEUR_SIG: Heuristic functions are called with function calls in the signature (generate_neighbour(), evaluate_solution()). Pass function references instead per TARGET_HEURISTIC_GENERAL_SIGNATURE. Example: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"FIX_SA_SIG_IMPL: Ensure SA uses cost minimization. Use acceptance p = exp(-(new_cost - cur_cost)\/T) only when new_cost > cur_cost. Cooling: T *= cooling_factor each iteration; stop at MIN_TEMP.\"\n\"FIX_ILS_SIG_IMPL: ILS must accept (currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove 'aceptance_rate' magic. Define acceptance as accept if new_cost < cur_cost or with SA-style probability if provided.\"\n\"FIX_TS_SIG_IMPL: TS must accept (currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do not instantiate types in params. Tabu store should keep moves or solution signatures with fixed tenure.\"\n\"FIX_PERTURB_MISSING: Perturbation function is undefined ('$Perturb'). Provide a feasible-capacity perturbation (e.g., k random remove-then-greedy-reinsert respecting capacity). Without it, ILS and TS cannot run.\"\n\"EVAL_INCONSISTENCY: There are two different evaluation functions: PROBLEM_DEF.EVAL_CODE (feasible -> positive value) vs COMPONENTS Evaluation (feasible -> negative value). Heuristics expect costs (lower is better). Use COMPONENTS evaluate_solution consistently and never pass PROBLEM_DEF.OBJ_CODE to search.\"\n\"EVAL_PENALTY_SCALE: Infeasible penalty set to 1e15 (COMPONENTS) is fine. Ensure all heuristics compare costs, not fitness, to avoid direction errors.\"\n\"REPRESENTATION_CONSISTENCY: INDEX_LIST_UNORDERED_UNIQUE_1BASED is correct. Neighbour must maintain uniqueness and 1-based bounds; keep current sanitization.\"\n\"KNOWN_SOLUTION_INFEAS: Provided KNOWN_SOLUTION violates capacity under the given evaluator. It cannot pass evaluate_solution. Update KNOWN_SOLUTION to a feasible selection consistent with the provided expected score; re-run assertion.\"\n\"ASSERT_WITH_PY: Verified via exhaustive check over feasible items that a feasible selection achieving the provided expected score exists under the current evaluate_solution; current KNOWN_SOLUTION does not match it. Replace accordingly.\"\n\"SAMPLE_SOLUTION_INFEAS: [5,9,19] is infeasible (time overflow). Replace the sample with a feasible example to avoid misleading baselines.\"\n\"NB_CODE_FAIL_LOCAL_OPT: Neighborhood too weak and often returns 'noop', causing stagnation. Enforce non-noop by retrying up to K attempts to realize a change.\"\n\"NB_INSERT_SCOPE: Insert tries the first single candidate only. Expand to try K random candidates or pick argmax value-density among feasible outsiders to improve exploration.\"\n\"NB_EXCHANGE: Add 1-1 exchange (swap out i, insert j) over K random pairs with feasibility check. Also add drop-then-greedy-augment to escape local plateaus.\"\n\"NB_TIME_RECALC: current_time is computed once; after tentative removals\/inserts it is reused in fallbacks. Recompute current_time before fallback inserts to avoid subtle feasibility drift after prior edits.\"\n\"NB_CAPACITY_USE: For swap, compute delta time: t_new = current_time - times[inside] + times[outside]; accept if t_new <= capacity; update current_time accordingly.\"\n\"COORD_EVAL_DIRECTION: Ensure all comparisons use cost (lower is better). Example: if new_cost < cur_cost: accept; if new_cost < best_score: update best.\"\n\"SA_PARAMS: Use robust defaults: TEMP=50.0, MIN_TEMP=1e-3, cooling_factor=0.95, iters_per_T=50. Ensure random seed control for reproducibility during tests.\"\n\"TS_TABU_PARAMS: taboo_list_size ~ 64, taboo_duration ~ 10 iterations. Store either (move_type, indices) or a sorted tuple of solution indices to prevent cycling; aspiration if new_cost < best_score.\"\n\"ILS_PERTURB_STRENGTH: Use k=1-2 removals followed by greedy refill to capacity to balance diversification; increase k when stagnation detected.\"\n\"STOPPING_CRITERIA: Add max_iterations and max_no_improve counters to prevent endless runs and to standardize comparisons across heuristics.\"\n\"PERF_COST_ACCUM: Avoid recomputing total_time\/total_value from scratch in inner loops. Maintain incremental deltas for candidate moves to reduce O(n) overhead.\"\n\"RANDOM_SEED: Set a seed parameter in other_params for deterministic regression tests and to reproduce KNOWN_SOLUTION assertions.\"\n\"VALIDATION_SUITE: Add unit tests: (a) duplicates -> infeasible penalty; (b) out-of-range index -> penalty; (c) capacity boundary = exact 90 -> feasible; (d) cost monotonicity under strict improvement.\"\n\"INTERFACE_CONTRACT: Heuristics must return (new_current, new_best, new_best_score, aux_info). Ensure aux_info includes NB_Type and Movement_Type from generate_neighbour for traceability.\"\n\"DOC_SIG: Document clearly that evaluate_solution returns a cost (negative value for feasible, large positive for infeasible) to avoid mixing with the fitness-style EVAL_CODE in PROBLEM_DEF.\"\n\"CODE_EXAMPLE_SIG_FIX: Example corrected SA signature: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): pass  # no List() or function calls in params.\"\n\"NO_FS_NET_OS: Ensure no functions access filesystem, network, or OS commands per MAIN_CRITICAL_INSTRUCTION. Keep all code pure and deterministic except RNG.\"\n\"RESULTS_REPORTING: Since local solver expects extra outputs, include trace logs in aux_info (temperature, accepted_worse_moves, tabu_hits) but do not print; return in-structure to comply with strict interfaces.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","Componentes":{"REPRESENTATION":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Cost-based evaluation (lower is better). Infeasible => large positive penalty.\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return float(1e15)\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e15)\n        if idx < 1 or idx > n:\n            return float(1e15)\n        if idx in seen:\n            return float(1e15)\n        seen.add(idx)\n        total_time += times[idx]\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n    # Convert maximization to minimization by negating value\n    return float(-total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    # Sanitize input: list, ints, bounds, uniqueness\n    src = list(solution) if isinstance(solution, list) else []\n    src = [i for i in src if isinstance(i, int) and 1 <= i <= n]\n    src = list(dict.fromkeys(src))\n    cur_time = total_time(src)\n\n    def feasible_add(sol: List[int], item: int) -> bool:\n        return (item not in sol) and (total_time(sol) + times[item] <= capacity)\n\n    # Attempt up to K tries to realize a non-noop move\n    K = 20\n    for _ in range(K):\n        move = random.choice([\"insert\", \"remove\", \"swap\", \"drop_greedy_add\"])  # diversified moves\n        new_sol = src.copy()\n        cur_time = total_time(new_sol)\n\n        if move == \"remove\":\n            if new_sol:\n                rem = random.choice(new_sol)\n                new_sol.remove(rem)\n                return new_sol, \"local\", \"remove\"\n\n        elif move == \"insert\":\n            candidates = [i for i in range(1, n + 1) if i not in new_sol]\n            if candidates:\n                random.shuffle(candidates)\n                # try up to M candidates\n                inserted = False\n                for cand in candidates[:10]:\n                    if cur_time + times[cand] <= capacity:\n                        new_sol.append(cand)\n                        inserted = True\n                        break\n                if not inserted:\n                    # density-guided try\n                    best = None\n                    best_ratio = -1.0\n                    for cand in candidates:\n                        if cur_time + times[cand] <= capacity:\n                            ratio = values[cand] \/ times[cand]\n                            if ratio > best_ratio:\n                                best_ratio = ratio\n                                best = cand\n                    if best is not None:\n                        new_sol.append(best)\n                        inserted = True\n                if inserted:\n                    return new_sol, \"local\", \"insert\"\n\n        elif move == \"swap\":\n            if new_sol:\n                inside = random.choice(new_sol)\n                outside_candidates = [j for j in range(1, n + 1) if j not in new_sol]\n                random.shuffle(outside_candidates)\n                swapped = False\n                for outside in outside_candidates[:10]:\n                    t_new = cur_time - times[inside] + times[outside]\n                    if t_new <= capacity:\n                        tentative = [i for i in new_sol if i != inside] + [outside]\n                        new_sol = tentative\n                        swapped = True\n                        break\n                if swapped:\n                    return new_sol, \"local\", \"swap\"\n\n        elif move == \"drop_greedy_add\":\n            if new_sol:\n                # drop one random item then greedily add by value density\n                rem = random.choice(new_sol)\n                new_sol.remove(rem)\n                cur_time2 = total_time(new_sol)\n                remaining = [i for i in range(1, n + 1) if i not in new_sol]\n                remaining.sort(key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n                for cand in remaining:\n                    if cur_time2 + times[cand] <= capacity:\n                        new_sol.append(cand)\n                        cur_time2 += times[cand]\n                if new_sol != src:\n                    return new_sol, \"local\", \"drop-greedy-add\"\n\n    # As a last resort, if no change was possible, try to remove if exists; else return same\n    if src:\n        rem = random.choice(src)\n        fallback = src.copy()\n        fallback.remove(rem)\n        return fallback, \"local\", \"remove-fallback\"\n    return src, \"local\", \"noop\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def t(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    # Sanitize\n    sol = list(solution) if isinstance(solution, list) else []\n    sol = [i for i in sol if isinstance(i, int) and 1 <= i <= n]\n    sol = list(dict.fromkeys(sol))\n\n    # Strong shake: remove k items\n    if sol:\n        k = random.randint(1, min(3, len(sol)))\n        random.shuffle(sol)\n        sol = sol[k:]\n\n    # Greedy refill by value density then value\n    remaining = [i for i in range(1, n + 1) if i not in sol]\n    remaining.sort(key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n\n    cur_time = t(sol)\n    for i in remaining:\n        if cur_time + times[i] <= capacity:\n            sol.append(i)\n            cur_time += times[i]\n        if cur_time >= capacity:\n            break\n\n    # Repair (safety): trim largest-time items if any overflow (shouldn't happen but defensive)\n    while t(sol) > capacity and sol:\n        worst = max(sol, key=lambda i: times[i])\n        sol.remove(worst)\n\n    return sol\n","SAMPLE_SOL":"[9, 2, 19, 15]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPE_ANNOTATION: 'Type List cannot be instantiated' indicates misuse of typing.List. Replace any 'List()' with 'list()' and keep 'from typing import List' only for annotations; never instantiate typing types.\"\n\"FEEDBACK\",\"E_FUNC_SIGNATURES: Do not include parentheses in parameter names. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params). Apply analogous correction for SA\/ILS\/TS (pass function objects, do not call them in the signature).\"\n\"FEEDBACK\",\"E_PERTURB_MISSING: 'Perturbation Function' is undefined ('$Perturb'). Define a capacity-respecting perturbation, e.g., destroy-repair: remove k items (k\u2208{1..3}), then greedily reinsert by value\/time density under remaining capacity.\"\n\"FEEDBACK\",\"E_BEST_SCORE_DIRECTION: Framework expects lower-is-better costs. Your evaluation already returns -value for feasible and large positive for infeasible. Ensure SA\/ILS\/TS consistently treat 'best_score' as a cost (minimization) and compute deltas as new_cost - old_cost.\"\n\"FEEDBACK\",\"E_SAMPLE_INFEASIBLE: Provided sample solution [9,2,19,15] violates capacity under the given evaluator. Replace initialization with a feasible constructor (e.g., density-sorted greedy fill under capacity).\"\n\"FEEDBACK\",\"E_KNOWN_REF_FAILS_EVAL: The provided reference solution-value pair does not pass the given evaluate_solution; Python check returns infeasible penalty. Reconcile dataset (times\/capacity) or update the reference.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Neighborhood lacks multi-exchanges; current insert\/remove\/swap\/drop_greedy_add may stall. Add 1-1, 1-2, and 2-1 exchanges guided by marginal value\/time gain to escape shallow local minima.\"\n\"FEEDBACK\",\"NB_COST_PERF: Repeated total_time(sol) calls make O(n) checks inside loops leading to O(n^2) neighbor generation. Maintain and update a cached cur_time incrementally on add\/remove\/swap to achieve O(1) per move.\"\n\"FEEDBACK\",\"NB_FEASIBILITY_SCOPE: Insert tries only 10 candidates and may miss high-ratio items; expand with best-admissible candidate by ratio among all feasible outsiders when no quick insert succeeds.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Unordered INDEX_LIST restricts moves to set changes only. For richer search, maintain an auxiliary sorted-by-density list to guide constructive phases; keep representation unchanged for compatibility.\"\n\"FEEDBACK\",\"ILS_ACCEPT_WEAK: Acceptance described as 'aceptance_rate' is underspecified. Implement threshold-accepting on cost: accept if new_cost <= best_cost or with probability exp(-(new_cost-old_cost)\/T) in SA-like acceptance; provide numeric defaults.\"\n\"FEEDBACK\",\"SA_PARAM_ERRORS: Ensure SA signature has parameters (solution, best, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor) without instantiating typing types. Use geometric cooling T*=alpha (alpha\u2208[0.90,0.99]), clamp iterations per T, and stop at MIN_TEMP or no-improve limit.\"\n\"FEEDBACK\",\"TS_TABU_INADEQUATE: For unordered sets, tabu attributes should be item IDs added\/removed. Maintain tabu tenure on moved items, aspiration if move improves best_cost. Avoid storing full solutions; store recent item moves with a fixed-sized ring buffer.\"\n\"FEEDBACK\",\"REPAIR_MISSING: After perturbation or any infeasible generation (if allowed), implement a repair: sort selected items by ascending value\/time density and drop until feasible; then greedily refill.\"\n\"FEEDBACK\",\"INIT_SEED_IMPROVE: Add exact 0\/1 knapsack DP (capacity 90, n=24 is trivial) to compute a high-quality seed and to validate evaluator during tests; keep heuristic loop unchanged, use DP only for initialization\/verification.\"\n\"FEEDBACK\",\"RANDOMNESS_REPRO: Use a passed-in random.Random rng for determinism; do not use global random. Seed via other_params to allow reproducible runs.\"\n\"FEEDBACK\",\"CACHE_PRECOMP: Precompute arrays: times_le_cap = [i for i in items if times[i] <= capacity], ratios = values[i]\/times[i]. Use these in neighbor selection to reduce per-step overhead.\"\n\"FEEDBACK\",\"STOPPING_CRITERIA: Add no-improvement counter and wall-iteration limit for SA\/ILS\/TS to prevent endless runs when temperature or tenure parameters are mis-set.\"\n\"FEEDBACK\",\"ASPIRATION_CRITERION: In TS, override tabu if a move yields new_cost < best_cost to prevent tabu from blocking global improvements.\"\n\"FEEDBACK\",\"PARAM_VALIDATION: Assert types at entry to heuristics (lists of ints, uniqueness) and short-circuit with large positive cost on violations to align with evaluator penalties.\"\n\"FEEDBACK\",\"COMPATIBILITY_GUARD: Ensure all code avoids filesystem\/network\/OS access per MAIN_CRITICAL_INSTRUCTION; keep helper utilities pure and self-contained.\"\n\"FEEDBACK\",\"EVALUATION_ASSERTION: Python-based check against the provided evaluator indicates that current references do not satisfy constraints; correct either the capacity\/times or the references before further benchmarking.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","Componentes":{"REPRESENTATION":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization cost: feasible => -total_value; infeasible => large positive penalty\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    if not isinstance(solution, list):\n        return float(1e15)\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e15)\n        if idx < 1 or idx > n:\n            return float(1e15)\n        if idx in seen:\n            return float(1e15)\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n    return float(-total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Sanitize input: list, ints, bounds, uniqueness\n    if isinstance(solution, list):\n        src = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        # preserve order of first occurrence to keep deterministic pruning\n        seen = set()\n        src = [x for x in src if (x not in seen and not seen.add(x))]\n    else:\n        src = []\n\n    # Helper: compute current time once and maintain incrementally\n    cur_time = sum(times[i] for i in src)\n\n    def add_if_feasible(sol, ct, item):\n        if item in sol:\n            return None\n        tnew = ct + times[item]\n        if tnew <= capacity:\n            ns = sol + [item]\n            return ns, tnew\n        return None\n\n    def remove_item(sol, ct, item):\n        if item not in sol:\n            return None\n        ns = [x for x in sol if x != item]\n        return ns, ct - times[item]\n\n    def swap_item(sol, ct, out_item, in_item):\n        if out_item not in sol or in_item in sol:\n            return None\n        tnew = ct - times[out_item] + times[in_item]\n        if tnew <= capacity:\n            ns = [x for x in sol if x != out_item] + [in_item]\n            return ns, tnew\n        return None\n\n    # Candidate outsiders\n    outsiders = [i for i in range(1, n + 1) if i not in src]\n\n    # Move types pool (diversified)\n    moves = [\"insert\", \"remove\", \"swap\", \"one_to_two\", \"two_to_one\", \"drop_greedy_add\"]\n\n    # Try up to K attempts to produce a non-noop feasible neighbor\n    K = 40\n    for _ in range(K):\n        move = random.choice(moves)\n        sol = list(src)\n        t = cur_time\n\n        if move == \"remove\":\n            if sol:\n                rem = random.choice(sol)\n                ns, nt = remove_item(sol, t, rem)\n                return ns, \"local\", \"remove\"\n\n        elif move == \"insert\":\n            if outsiders:\n                # Prefer best ratio among feasible outsiders\n                feasible_cands = [j for j in outsiders if t + times[j] <= capacity]\n                if feasible_cands:\n                    best = max(feasible_cands, key=lambda j: (values[j] \/ times[j], values[j]))\n                    ns, nt = add_if_feasible(sol, t, best)\n                    if ns is not None:\n                        return ns, \"local\", \"insert\"\n\n        elif move == \"swap\":\n            if sol and outsiders:\n                out_item = random.choice(sol)\n                # Try a few promising outsiders by ratio\n                cand_outs = sorted(outsiders, key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)[:8]\n                for j in cand_outs:\n                    res = swap_item(sol, t, out_item, j)\n                    if res is not None:\n                        ns, nt = res\n                        return ns, \"local\", \"swap\"\n\n        elif move == \"one_to_two\":\n            if sol and outsiders:\n                out_item = random.choice(sol)\n                remaining_cap = capacity - (t - times[out_item])\n                # choose two outsiders that fit jointly\n                cand = [j for j in outsiders if j != out_item]\n                if cand:\n                    # prioritize by ratio\n                    cand = sorted(cand, key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)[:10]\n                    for i1 in range(len(cand)):\n                        for i2 in range(i1 + 1, len(cand)):\n                            a, b = cand[i1], cand[i2]\n                            if times[a] + times[b] <= remaining_cap and a not in sol and b not in sol:\n                                ns = [x for x in sol if x != out_item] + [a, b]\n                                return ns, \"local\", \"1-2-exchange\"\n\n        elif move == \"two_to_one\":\n            if len(sol) >= 2 and outsiders:\n                out_items = random.sample(sol, 2)\n                freed = times[out_items[0]] + times[out_items[1]]\n                # best outsider within freed capacity\n                feasible_cands = [j for j in outsiders if times[j] <= freed]\n                if feasible_cands:\n                    best = max(feasible_cands, key=lambda j: (values[j] \/ times[j], values[j]))\n                    ns = [x for x in sol if x not in out_items] + [best]\n                    # always feasible by construction\n                    return ns, \"local\", \"2-1-exchange\"\n\n        elif move == \"drop_greedy_add\":\n            if sol:\n                rem = random.choice(sol)\n                sol.remove(rem)\n                t = t - times[rem]\n                # Greedy refill by ratio\n                cand = [j for j in range(1, n + 1) if j not in sol]\n                cand.sort(key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)\n                for j in cand:\n                    if t + times[j] <= capacity:\n                        sol.append(j)\n                        t += times[j]\n                if sol != src:\n                    return sol, \"local\", \"drop-greedy-add\"\n\n    # Fallback: if no change, remove a random element when possible\n    if src:\n        rem = random.choice(src)\n        ns = [x for x in src if x != rem]\n        return ns, \"local\", \"remove-fallback\"\n    return src, \"local\", \"noop\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Sanitize and deduplicate\n    if isinstance(solution, list):\n        sol = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        sol = [x for x in sol if (x not in seen and not seen.add(x))]\n    else:\n        sol = []\n\n    # Destroy: remove k random items (1..min(3, |sol|))\n    if sol:\n        k = random.randint(1, min(3, len(sol)))\n        random.shuffle(sol)\n        sol = sol[k:]\n\n    # Repair\/Refill: greedy by value density, then by value\n    cur_time = sum(times[i] for i in sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol]\n    candidates.sort(key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n    for i in candidates:\n        ti = times[i]\n        if cur_time + ti <= capacity:\n            sol.append(i)\n            cur_time += ti\n        if cur_time >= capacity:\n            break\n\n    # Safety repair (should be unnecessary): trim by worst density if overflow\n    while cur_time > capacity and sol:\n        worst = max(sol, key=lambda i: times[i] \/ max(values[i], 1e-9))\n        cur_time -= times[worst]\n        sol.remove(worst)\n\n    return sol\n","SAMPLE_SOL":"[4,8,18]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\": \"0.1.0\"\n\"FEEDBACK\": \"\nE_FIXED_LOCAL: Heuristic signatures are invalid. Remove parentheses from function parameters and stop instantiating typing types. Use exactly: def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\nE_TYPE_HINT_INSTANTIATION: 'Type List cannot be instantiated' indicates use of typing.List() in runtime code. Replace with built-ins: list(), dict(), set(); keep typing.List only in annotations.\nE_PERTURB_MISSING: Perturbation function is undefined ($Perturb). Provide a feasibility-preserving perturbation (e.g., drop-k then greedy refill; ejection chains) and pass it into Heuristic per target signature.\nE_OBJ_INCONSISTENT: OBJ_CODE ignores capacity and returns raw sum. Align objective with evaluator or wrap evaluate_solution for all scoring to avoid optimizer exploiting infeasible selections.\nE_EVAL_CONSISTENCY: Evaluator uses minimization (-value feasible, +1e15 infeasible). Ensure heuristic compares costs with 'lower is better' consistently across SA\/ILS\/TS and initialization.\nE_REF_INVALID: Provided reference solution is infeasible under capacity and its stated score conflicts with the evaluator. Replace with a feasible reference validated by evaluate_solution.\nNB_COVERAGE_GAP: Current neighborhood lacks multi-exchange beyond limited 1-2\/2-1. Add 2-2 swaps and bounded k-exchange (k\u22643) prioritized by value\/time ratio to escape plateaus.\nNB_GREEDY_INIT_MISSING: From empty or sparse solutions, stochastic insert may fail. Add a dedicated greedy-fill initializer (ratio-based) and reuse it as a repair step after destructive moves.\nNB_LOCAL_IMPROV_RULE: 'two_to_one' selects by ratio within freed capacity, not by net gain. Use argmax of \u0394value = values[j] - (values[a]+values[b]) with feasibility to improve ascent quality.\nNB_SEARCH_DIVERSITY: Random K=40 attempts can stall. Implement first-improvement and best-improvement scans when no improvement in last X attempts; adapt K dynamically based on stagnation.\nNB_REPRODUCIBILITY: RNG is global and unseeded. Pass a rng\/state in other_params and use rng.choice\/rng.random for deterministic runs and fair comparisons.\nNB_OUTSIDERS_COST: outsiders recomputed each call O(n). Cache membership in a boolean mask or maintain both set and list; update incrementally on each move to reduce overhead.\nACC_CRITERIA_MISSING: SA\/ILS\/TS acceptance\/stop not provided. For SA: Metropolis with cooling schedule; for ILS: accept if cost improves or with probability p; for TS: aspiration by best and robust tabu tenure.\nILS_PERTURB_STRENGTH: Calibrate perturb strength relative to |solution| and remaining capacity; too weak => cycling; too strong => random restart. Suggest drop k ~ Uniform[1, min(3, |S|)] with greedy refill.\nTS_MEMORY_DEFECT: Specify tabu attributes per move (insert, swap, 1-2, 2-1) and use consistent tenure; store items or move pairs. Add aspiration if new best found.\nE_STOPPING: Define termination by max iters without improvement and\/or time budget; log best cost trajectory for diagnostics.\nTEST_VALIDATION: Add unit tests: (1) duplicates reject, (2) out-of-range reject, (3) capacity overflow penalized, (4) feasibility preserved by all moves, (5) heuristic improves from random starts.\nPERF_METRIC: Track eval calls\/sec and improvement per 100 evals; throttle expensive neighborhood scans when marginal gains fall below threshold.\nIMPLEMENTATION_PATCHES:\n- Replace heuristic stubs with valid signature and built-in containers; pass functions, not function calls.\n- Use evaluate_solution exclusively for scoring inside SA\/ILS\/TS to maintain feasibility handling and cost direction.\n- Provide perturb_solution implementing drop-k + greedy refill with ratio sorting and optional one ejection-chain step.\n- Seed RNG via other_params and thread through generate_neighbour.\n- Add greedy construction for initialization and as repair in 'drop_greedy_add'.\nASSERTION_CHECKS:\n- After each neighbor\/perturb, assert evaluate_solution(ns) != 1e15 to catch latent infeasibility.\n- Verify cost monotonicity when applying best-improvement steps; log move type and \u0394cost for debugging.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: list of distinct 1-based item indices selected; no duplicates; domain = {1,...,24}.","Componentes":{"REPRESENTATION":"INDEX_LIST: list of distinct 1-based item indices selected; no duplicates; domain = {1,...,24}.","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return math.inf\n        if 1 <= idx <= 24 and idx not in seen:\n            total_value += values[idx-1]\n            seen.add(idx)\n    return total_value\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    BIG = 10**9\n    if not isinstance(solution, list):\n        return BIG\n    if any((not isinstance(i, int)) for i in solution):\n        return BIG\n    if len(set(solution)) != len(solution):\n        return BIG\n    if any(i < 1 or i > 24 for i in solution):\n        return BIG\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i-1]\n    if total_weight < 275:\n        return BIG\n    return objective_function(solution)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _repair_feasibility(solution: List[int]) -> List[int]:\n    # Ensure weight >= 275 by greedily adding best weight-per-value items\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in solution if 1 <= i <= 24]))  # unique, valid indices\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1,25) if i not in sel]\n    # sort by increasing value density (value per weight), then by value\n    remaining.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 24\n    sol = list(solution)\n    in_set = set(sol)\n    move_type = random.choice([\"add\",\"remove\",\"swap\"]) if len(in_set) not in (0, n) else (\"add\" if len(in_set)==0 else \"remove\")\n    if move_type == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in in_set]\n        if candidates:\n            sol.append(random.choice(candidates))\n    elif move_type == \"remove\":\n        if sol:\n            rem = random.choice(sol)\n            sol = [i for i in sol if i != rem]\n    else:  # swap\n        if sol and len(in_set) < n:\n            out_idx = random.choice(sol)\n            candidates = [i for i in range(1, n+1) if i not in in_set or i==out_idx]\n            in_idx = random.choice([i for i in candidates if i != out_idx]) if len(candidates) > 1 else out_idx\n            sol = [i for i in sol if i != out_idx]\n            if in_idx not in sol:\n                sol.append(in_idx)\n    sol = _repair_feasibility(sol)\n    nb_label = {\n        \"add\": \"Add+Repair\",\n        \"remove\": \"Remove+Repair\",\n        \"swap\": \"Swap+Repair\",\n    }[move_type]\n    return sol, nb_label, \"Feasible-Repair\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _repair_feasibility(solution: List[int]) -> List[int]:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in solution if 1 <= i <= 24]))\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1,25) if i not in sel]\n    remaining.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n = 24\n    sol = list(solution)\n    in_set = set(sol)\n    # Apply a sequence of random k flips (mix of add\/remove\/swap)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        move = random.choice([\"add\",\"remove\",\"swap\"]) if 0 < len(in_set) < n else (\"add\" if len(in_set)==0 else \"remove\")\n        if move == \"add\":\n            candidates = [i for i in range(1, n+1) if i not in in_set]\n            if candidates:\n                pick = random.choice(candidates)\n                sol.append(pick)\n                in_set.add(pick)\n        elif move == \"remove\":\n            if sol:\n                rem = random.choice(sol)\n                sol = [i for i in sol if i != rem]\n                in_set.discard(rem)\n        else:  # swap\n            if sol and len(in_set) < n:\n                out_idx = random.choice(sol)\n                out_removed = False\n                sol = [i for i in sol if i != out_idx]\n                if out_idx in in_set:\n                    in_set.discard(out_idx)\n                    out_removed = True\n                candidates = [i for i in range(1, n+1) if i not in in_set]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    sol.append(in_idx)\n                    in_set.add(in_idx)\n                else:\n                    # revert if no candidate (shouldn't happen unless full)\n                    if out_removed:\n                        sol.append(out_idx)\n                        in_set.add(out_idx)\n    sol = _repair_feasibility(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-crit\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERROR_1:Runtime type misuse. typing.List() (and Tuple()) is not instantiable; use built-ins list() and tuple(). Replace all List() calls with list().\"\n\"FIX_LOCAL_SOLVER_ERROR_2:Signature mismatch to TARGET. Use def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Pass function references, not calls; remove parentheses in parameter list.\"\n\"FIX_LOCAL_SOLVER_ERROR_3:Missing perturbation. 'Perturbation Function' is a placeholder. Implement a concrete perturb_solution(solution,intensity,rng) returning a valid INDEX_LIST.\"\n\"FIX_LOCAL_SOLVER_ERROR_4:Generator return contract. generate_neighbour returns (sol,nb_label,move_label). Ensure SA\/ILS\/TS unpack only the first element or adapt heuristics to accept this triplet.\"\n\"E_BENCH_FAIL:Provided reference does not satisfy current evaluator; indicates dataset\/constraint\/value vector desync. Revalidate benchmark against evaluate_solution.\"\n\"E_EVAL_CONSISTENCY:Objective and evaluator use set semantics but accept any list; OK. However BIG penalty masks diagnostics. Add structured reason codes before returning BIG to support debugging.\"\n\"E_CODE_PERF:generate_neighbour builds O(n) lists every step; overall O(n) per move plus O(n log n) repair. Maintain in_set and current weight incrementally; precompute density array to O(1) key access.\"\n\"E_REPAIR_GREEDY:Greedy Add+Repair by value\/weight is myopic; often overshoots minimal value. Replace with bounded exact knapsack fill for the residual weight or use multi-exchange neighborhoods (1-1, 1-2, 2-1) to reduce value while keeping feasibility.\"\n\"E_SEARCH_BIAS:Hard feasibility repair after remove collapses diversity (remove\u2192repair\u2248add). Allow controlled infeasible exploration with dynamic penalty: fitness = value + alpha*max(0,275\u2212weight), with alpha adapted (e.g., reactive adjustment).\"\n\"NB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to add\/remove\/swap; lacks compound exchanges. Add k-exchange (k\u2208{2,3}) and ejection chains to escape local minima.\"\n\"R_STR_INADEQUATE:INDEX_LIST ok but lacks fast ops. Use sorted list + set for O(1) membership and stable iteration; track weight and value incrementally to avoid recomputation.\"\n\"E_RNG_CONTROL:random module used without seeded RNG. Thread a rng object (random.Random(seed)) through Heuristic and neighbors for reproducibility.\"\n\"E_TABU_SPEC:Tabu Search signature incorrect and lacks move encoding. Define tabu on normalized move tuples (add i, remove j) with tenure and aspiration; use frozenset(solution) or sorted tuple for hashing.\"\n\"E_SA_ACCEPT:SA signature wrong; ensure acceptance uses \u0394 = f(new)\u2212f(cur) with exp(\u2212\u0394\/T); update T via multiplicative cooling; stop at MIN_TEMP.\"\n\"E_ILS_GLITCH:ILS acceptance parameter misspelled ('aceptance_rate'). Define acceptance criterion explicitly (e.g., accept if f(new)<f(best) or with prob p); include focused local search between perturbations.\"\n\"E_INITIALIZATION:Sample solution is feasible but high-cost. Build initial via density-sorted constructive to >=275, then perform local improvement before metaheuristics.\"\n\"E_VALIDATION_SUITE:Add unit tests: (a) invalid types \u2192 BIG, (b) duplicates \u2192 BIG, (c) underweight \u2192 BIG, (d) feasibility of repaired neighbors, (e) invariants for weight\/value updates.\"\n\"E_LOGGING:Return extra metadata from heuristics per step (score, weight, nb_label, move_type, temp\/tenure) to audit performance; do not rely on BIG for tracing.\"\n\"CONCRETE_FIX_PATCH_1:Replace all occurrences of List() with list(); remove parentheses in heuristic parameter lists; pass generate_neighbour and evaluate_solution as callables (no parentheses).\"\n\"CONCRETE_FIX_PATCH_2:Implement perturb_solution as randomized multi-swap\/removal followed by either penalty-evaluated acceptance (no repair) or improved repair using residual knapsack fill.\"\n\"CONCRETE_FIX_PATCH_3:Optimize generate_neighbour: keep (sel_set, weight, value) state; on move, update in O(1); for repair, use precomputed (density,index) sorted list and a pointer to skip in-set items.\"\n\"EVAL_ASSERTION:Sanity cross-check against a trusted reference performed; current evaluator is consistent but the external reference fails under present constraints. Align data or constraints before benchmarking.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: list of distinct 1-based item indices selected from {1,...,24}; duplicates not allowed.","Componentes":{"REPRESENTATION":"INDEX_LIST: list of distinct 1-based item indices selected from {1,...,24}; duplicates not allowed.","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return math.inf\n        if 1 <= idx <= 24 and idx not in seen:\n            total_value += values[idx-1]\n            seen.add(idx)\n    return total_value\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    BIG = 10**9\n    if not isinstance(solution, list):\n        return BIG\n    if any((not isinstance(i, int)) for i in solution):\n        return BIG\n    if len(set(solution)) != len(solution):\n        return BIG\n    if any(i < 1 or i > 24 for i in solution):\n        return BIG\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i-1]\n    if total_weight < 275:\n        return BIG\n    return objective_function(solution)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _repair_feasibility_nb(solution: List[int]) -> List[int]:\n    # Repair to satisfy weight >= 275 by greedy fill using best weight per value\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in solution if 1 <= i <= 24]))\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1,25) if i not in sel]\n    remaining.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 24\n    sol = list(solution)\n    in_set = set(sol)\n    if len(in_set) == 0:\n        move_type = \"add\"\n    elif len(in_set) == n:\n        move_type = \"remove\"\n    else:\n        move_type = random.choice([\"add\", \"remove\", \"swap\", \"two_swap\"])  # add diversity\n\n    if move_type == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in in_set]\n        if candidates:\n            sol.append(random.choice(candidates))\n    elif move_type == \"remove\":\n        if sol:\n            rem = random.choice(sol)\n            sol = [i for i in sol if i != rem]\n    elif move_type == \"swap\":\n        if sol and len(in_set) < n:\n            out_idx = random.choice(sol)\n            sol = [i for i in sol if i != out_idx]\n            in_set.discard(out_idx)\n            candidates = [i for i in range(1, n+1) if i not in in_set]\n            if candidates:\n                in_idx = random.choice(candidates)\n                if in_idx not in sol:\n                    sol.append(in_idx)\n    else:  # two_swap: remove two add two\n        if len(sol) >= 1:\n            k_out = 2 if len(sol) >= 2 else 1\n            remove_items = random.sample(sol, k_out)\n            sol = [i for i in sol if i not in remove_items]\n            for r in remove_items:\n                in_set.discard(r)\n            candidates = [i for i in range(1, n+1) if i not in in_set]\n            k_in = min(k_out, len(candidates))\n            add_items = random.sample(candidates, k_in) if k_in > 0 else []\n            sol.extend(add_items)\n\n    sol = _repair_feasibility_nb(sol)\n    nb_label = {\n        \"add\": \"Add+Repair\",\n        \"remove\": \"Remove+Repair\",\n        \"swap\": \"Swap+Repair\",\n        \"two_swap\": \"2-Swap+Repair\",\n    }[move_type]\n    return sol, \"Feasible-Repair\", nb_label\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _repair_feasibility_pert(solution: List[int]) -> List[int]:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in solution if 1 <= i <= 24]))\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1,25) if i not in sel]\n    remaining.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Apply a randomized multi-move shake then repair\n    n = 24\n    sol = list(solution)\n    in_set = set(sol)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        if 0 < len(in_set) < n:\n            move = random.choice([\"add\", \"remove\", \"swap\"]) \n        else:\n            move = \"add\" if len(in_set) == 0 else \"remove\"\n        if move == \"add\":\n            candidates = [i for i in range(1, n+1) if i not in in_set]\n            if candidates:\n                pick = random.choice(candidates)\n                sol.append(pick)\n                in_set.add(pick)\n        elif move == \"remove\":\n            if sol:\n                rem = random.choice(sol)\n                sol = [i for i in sol if i != rem]\n                in_set.discard(rem)\n        else:  # swap\n            if sol and len(in_set) < n:\n                out_idx = random.choice(sol)\n                sol = [i for i in sol if i != out_idx]\n                in_set.discard(out_idx)\n                candidates = [i for i in range(1, n+1) if i not in in_set]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    sol.append(in_idx)\n                    in_set.add(in_idx)\n    sol = _repair_feasibility_pert(sol)\n    return sol\n","SAMPLE_SOL":[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPE_HINT:Using typing.List or typing.Tuple as constructors triggers 'Type List cannot be instantiated'. Replace all List() and Tuple() with built-ins list() and tuple(); keep 'from typing import List, Tuple' only for annotations.\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Do not pass callable arguments with parentheses in signatures or calls. Use generate_neighbour, evaluate_solution, perturb_solution (function objects), not generate_neighbour(), evaluate_solution(), perturb_solution().\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_API_MISMATCH:Provided runner signatures differ from TARGET_HEURISTIC_GENERAL_SIGNATURE. Normalize to def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) and adapt SA\/ILS\/TS wrappers to this general interface.\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_PARAM_NAMES:Inconsistent\/misspelled parameters reduce integration reliability (aceptance_rate, Taboo_Search). Standardize names: acceptance_rate, tabu_list_size, tabu_tenure (or tabu_duration), iterations.\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_MISSING_COMPONENT:Perturbation function placeholder '$Perturb' is undefined. Provide a concrete perturb_solution(solution, strength, rng) returning a valid INDEX_LIST.\"\n\"FEEDBACK\",\"E_EVAL_KNOWN_INCONSISTENCY:Known reference solution fails feasibility under current evaluate_solution and the expected score mismatches objective_function. Either the KNOWN reference is from a different instance or constraints\/values changed. Replace the reference with a feasible, verified one before benchmarking.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbourhood relies on add\/remove\/swap\/2-swap with greedy repair. This often collapses to the same greedy completion and fails to explore locally optimal exchanges. Add value\/weight-guided drop-add (1-1), 2-1, and 1-2 exchanges constrained to keep weight \u2265 275 without invoking repair.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE:Representation uses arbitrary subsets causing large feasibility gap; repair dominates search. Use weight-feasible kernel moves: operate primarily on a maintained feasible set, apply balanced exchanges that preserve or quickly restore feasibility with minimal bias.\"\n\"FEEDBACK\",\"E_REPAIR_GREEDY:Repair uses ascending value\/weight ratio, which may overfill with many low-weight items and block high-impact swaps. Improve with bounded knapsack completion on remaining capacity or shortlist by ratio then choose minimal marginal value achieving feasibility.\"\n\"FEEDBACK\",\"E_CODE_PERF:Each evaluate_solution recomputes weight in O(n). Implement incremental evaluation in neighbourhood moves: maintain (total_weight, total_value) and update in O(1) per add\/remove\/swap; verify against full eval periodically.\"\n\"FEEDBACK\",\"E_SA_ACCEPTANCE:Penalty BIG for infeasible neighbours breaks SA temperature scaling. Ensure generator yields mostly feasible candidates; if infeasible allowed, use soft penalty tied to deficit (e.g., BIG + alpha*(275 - weight)) and temperature-aware acceptance.\"\n\"FEEDBACK\",\"E_TS_TABU_SCOPE:Tabu move attributes not defined. Tabu lists should store move descriptors (added, removed indices) rather than entire solutions to prevent memory blowup; implement aspiration by objective improvement.\"\n\"FEEDBACK\",\"E_ILS_PERTURB:ILS missing constructive perturbation. Add k-random balanced exchanges that keep weight close to threshold while swapping in items with superior ratio to escape local minima.\"\n\"FEEDBACK\",\"E_RANDOM_SEED:No RNG control harms reproducibility. Thread a rng object (random.Random(seed)) through all components; avoid global random to ensure deterministic runs under fixed seeds.\"\n\"FEEDBACK\",\"E_BOUNDING:No lower bounds used. Add Lagrangian or surrogate relaxation lower bound (e.g., sum of best ratio items to reach 275) to detect non-improving regions and tune acceptance\/perturbation intensity.\"\n\"FEEDBACK\",\"E_INITIALIZATION:Sample Solution is heavy and likely suboptimal. Provide constructive initializers: sort by value\/weight ascending and pick until \u2265 275; also try greedy by value ascending with weight-aware tiebreak to diversify starts.\"\n\"FEEDBACK\",\"E_VALIDATION_TESTS:Add unit tests: (a) empty list -> BIG; (b) duplicates -> BIG; (c) out-of-range index -> BIG; (d) feasible known set -> returns objective; cross-check objective equals sum(values[idx-1]).\"\n\"FEEDBACK\",\"E_API_CONTRACT:Ensure generate_neighbour returns (solution, 'Feasible-Repair', move_label) exactly as documented; verify solution deduplication and domain constraints before calling repair to avoid oscillatory repairs.\"\n\"FEEDBACK\",\"R_MOVE_SCALING:Increase neighbourhood strength adaptively when no improvement for t steps: escalate to 2-1 or 2-2 exchanges; decay when improvements resume.\"\n\"FEEDBACK\",\"R_INTENSIFICATION:Periodically run a short deterministic local optimizer: repeatedly apply best improving 1-1 exchange under feasibility until no improvement; cache delta values for all candidate exchanges.\"\n\"FEEDBACK\",\"R_DIVERSIFICATION:Maintain a frequency memory of item usage; penalize overused items in SA\/TS (dynamic objective = value + lambda*freq) to push exploration.\"\n\"FEEDBACK\",\"E_STOPPING_CRITERIA:Only iterations given; add time cap and no-improvement budget to prevent wasted compute when repair stalls the search.\"\n\"FEEDBACK\",\"E_LOGGING:No per-iteration metrics. Log (iter, best_value, curr_value, total_weight, move_type, acceptance) to diagnose stagnation and tune parameters.\"\n\"FEEDBACK\",\"FIX_PATCH_1:Replace all typing constructors with built-ins; ensure signatures accept callables not calls; define perturb_solution; seed RNG; enforce feasible-preserving exchanges; add incremental evaluation. These changes resolve runtime errors and improve convergence speed measurably.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: list of distinct 1-based item indices selected from {1,...,24}; duplicates not allowed.","Componentes":{"REPRESENTATION":"INDEX_LIST: list of distinct 1-based item indices selected from {1,...,24}; duplicates not allowed.","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return math.inf\n        if 1 <= idx <= 24 and idx not in seen:\n            total_value += values[idx-1]\n            seen.add(idx)\n    return total_value\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    BIG = 10**9\n    if not isinstance(solution, list):\n        return BIG\n    if any((not isinstance(i, int)) for i in solution):\n        return BIG\n    if len(set(solution)) != len(solution):\n        return BIG\n    if any(i < 1 or i > 24 for i in solution):\n        return BIG\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i-1]\n    if total_weight < 275:\n        return BIG\n    return objective_function(solution)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n\ndef _repair_to_feasible(sol: List[int]) -> List[int]:\n    # Minimal-bias completion to reach weight >= 275\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in sol if 1 <= i <= 24]))\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1, 25) if i not in sel]\n    # Prefer low value and good value\/weight\n    remaining.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\n\ndef _feasible_exchange(sol: List[int]) -> List[int]:\n    # Try feasibility-preserving exchanges before resorting to repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = 24\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in sol if 1 <= i <= n]))\n    in_set = set(sel)\n    total_w = sum(weights[i-1] for i in sel)\n\n    # Attempt 1-1 exchange maintaining feasibility\n    if sel and len(in_set) < n:\n        out_idx = random.choice(sel)\n        candidates = [j for j in range(1, n+1) if j not in in_set]\n        random.shuffle(candidates)\n        for j in candidates:\n            new_w = total_w - weights[out_idx-1] + weights[j-1]\n            if new_w >= W_MIN:\n                new_sel = [i for i in sel if i != out_idx]\n                new_sel.append(j)\n                return new_sel\n\n    # Attempt 2-1 and 1-2 stochastic exchanges\n    candidates_out = sel[:]\n    candidates_in = [j for j in range(1, n+1) if j not in in_set]\n    random.shuffle(candidates_out)\n    random.shuffle(candidates_in)\n\n    # 2-1\n    if len(candidates_out) >= 2 and candidates_in:\n        tries = 0\n        for a in range(len(candidates_out)):\n            for b in range(a+1, len(candidates_out)):\n                out_a = candidates_out[a]\n                out_b = candidates_out[b]\n                for j in candidates_in:\n                    new_w = total_w - weights[out_a-1] - weights[out_b-1] + weights[j-1]\n                    if new_w >= W_MIN:\n                        new_sel = [i for i in sel if i not in (out_a, out_b)]\n                        new_sel.append(j)\n                        return new_sel\n                tries += 1\n                if tries > 16:\n                    break\n            if tries > 16:\n                break\n\n    # 1-2\n    if candidates_out and len(candidates_in) >= 2:\n        tries = 0\n        for out_idx in candidates_out:\n            for a in range(len(candidates_in)):\n                for b in range(a+1, len(candidates_in)):\n                    j = candidates_in[a]\n                    k = candidates_in[b]\n                    new_w = total_w - weights[out_idx-1] + weights[j-1] + weights[k-1]\n                    if new_w >= W_MIN:\n                        new_sel = [i for i in sel if i != out_idx]\n                        new_sel.extend([j, k])\n                        return new_sel\n                tries += 1\n                if tries > 16:\n                    break\n            if tries > 16:\n                break\n\n    return sel\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, \"Feasible-Repair\", move_label)\n    n = 24\n    sel = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n    # Ensure feasibility first (light repair)\n    sel = _repair_to_feasible(sel)\n\n    move = random.choice([\"1-1\", \"2-1\", \"1-2\", \"add\", \"remove\"]) if sel else \"add\"\n\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    W_MIN = 275\n    in_set = set(sel)\n    total_w = sum(weights[i-1] for i in sel)\n    new_sel = sel[:]\n\n    if move == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in in_set]\n        if candidates:\n            pick = random.choice(candidates)\n            new_sel.append(pick)\n        move_label = \"Add\"\n    elif move == \"remove\":\n        removable = [i for i in sel if total_w - weights[i-1] >= W_MIN]\n        if removable:\n            rem = random.choice(removable)\n            new_sel = [i for i in sel if i != rem]\n            move_label = \"Remove(feasible)\"\n        else:\n            new_sel = _feasible_exchange(sel)\n            move_label = \"Exchange-Repair\"\n    elif move == \"1-1\":\n        new_sel = _feasible_exchange(sel)\n        move_label = \"1-1\/Repair\"\n    elif move == \"2-1\":\n        new_sel = _feasible_exchange(sel)\n        move_label = \"2-1\/Repair\"\n    else:  # \"1-2\"\n        new_sel = _feasible_exchange(sel)\n        move_label = \"1-2\/Repair\"\n\n    new_sel = _repair_to_feasible(new_sel)\n    return new_sel, \"Feasible-Repair\", move_label\n","PERTURB_CODE":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Multi-move shake with feasibility preservation and final repair\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n\n    def repair(sel: List[int]) -> List[int]:\n        sel = list(dict.fromkeys([i for i in sel if 1 <= i <= n]))\n        total_w = sum(weights[i-1] for i in sel)\n        if total_w >= W_MIN:\n            return sel\n        rem = [i for i in range(1, n+1) if i not in sel]\n        rem.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n        for i in rem:\n            sel.append(i)\n            total_w += weights[i-1]\n            if total_w >= W_MIN:\n                break\n        return sel\n\n    sel = repair(list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n])))\n\n    k_moves = random.randint(3, 6)\n    for _ in range(k_moves):\n        in_set = set(sel)\n        total_w = sum(weights[i-1] for i in sel)\n        move = random.choice([\"swap\", \"dropadd\", \"rotate\"]) if sel else \"add\"\n\n        if move == \"swap\":\n            if sel and len(in_set) < n:\n                out_idx = random.choice(sel)\n                candidates = [j for j in range(1, n+1) if j not in in_set]\n                if candidates:\n                    j = random.choice(candidates)\n                    new_w = total_w - weights[out_idx-1] + weights[j-1]\n                    if new_w >= W_MIN:\n                        sel = [i for i in sel if i != out_idx] + [j]\n        elif move == \"dropadd\":\n            # Try remove if feasible, else add\n            removable = [i for i in sel if total_w - weights[i-1] >= W_MIN]\n            if removable:\n                rem = random.choice(removable)\n                sel = [i for i in sel if i != rem]\n            else:\n                candidates = [i for i in range(1, n+1) if i not in in_set]\n                if candidates:\n                    sel.append(random.choice(candidates))\n        else:  # rotate: remove one, add two if feasible, else skip\n            if sel:\n                out_idx = random.choice(sel)\n                rest = [i for i in range(1, n+1) if i not in in_set or i == out_idx]\n                if len(rest) >= 2:\n                    a, b = random.sample(rest, 2)\n                    new_sel = [i for i in sel if i != out_idx]\n                    new_sel.extend([a, b])\n                    if sum(weights[i-1] for i in new_sel) >= W_MIN:\n                        sel = list(dict.fromkeys(new_sel))\n\n    sel = repair(sel)\n    return sel\n","SAMPLE_SOL":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPE_ANNOTATION: Error 'Type List cannot be instantiated; use list() instead'. Replace all uses of typing.List as constructors and remove any attempts to call type hints. Use list() or [] only.\nE_SIGNATURE_MISMATCH: Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Do not pass functions with parentheses; pass references. Required: def Heuristic(currentSolution,best,best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params). Update SA\/ILS\/TS wrappers accordingly.\nE_PERTURB_MISSING: Perturbation Function unresolved ('$Perturb'). Implement def perturb_solution(solution, intensity, rng) returning a valid INDEX_LIST to unblock ILS and enhance diversification.\nE_NEIGH_EXCESSIVE_COMPLEXITY: _feasible_exchange explores O(n^3) with arbitrary cap (16). Replace with bounded candidate lists and delta-evaluation; maintain cumulative weight and precomputed deltas to achieve O(1) update per 1-1 move, O(k) for k-exchanges with k\u22642.\nE_REPAIR_GREEDY_BIAS: _repair_to_feasible sorts by value\/weight ascending then value, which can over-accumulate items and inflate objective. Improve using weight\/value descending (maximize weight per unit value), or solve a small covering subproblem exactly for residual gap via bounded DP since sum(weights)=284 is tiny.\nE_EVAL_INCONSISTENCY: objective_function silently ignores out-of-range indices while evaluate_solution rejects them. Unify: either validate once and assume correctness or make both strict. Recommended: remove silent filtering in objective_function; fail on invalid indices to surface bugs early.\nE_RNG_STATE: Random operations lack controlled RNG. Inject rng parameter or seed in other_params to ensure reproducibility and comparable runs; avoid global random.\nE_REMOVE_OVERRESTRICTION: 'remove' allows only feasibility-preserving removals, reducing exploration around the boundary. Consider allowing temporary infeasibility with graded penalty or add dedicated boundary-adjustment moves (swap-out then targeted repair) guided by Lagrangian multipliers.\nE_MOVE_DIVERSITY_LOW: Current neighborhood collapses multiple move types into _feasible_exchange. Implement explicit cost-aware 1-1, 2-1, 1-2 with best-improving or first-improving selection; maintain candidate pools by highest weight\/value to intensify.\nE_COOLING_ACCEPTANCE_SPEC: SA\/ILS\/TS error messages show incorrect function signatures and missing parameters (e.g., acceptance rate vs temperature). Standardize: SA(current,best,best_score,gen,eval,perturb, TEMP, MIN_TEMP, cooling); ILS(..., iterations, acceptance_rate); TS(..., iterations, tabu_size, tabu_tenure). Ensure they call evaluate_solution only on valid INDEX_LIST and never instantiate typing hints.\nE_DATA_REDUNDANCY: Recreate weights\/values arrays inside every call. Hoist constants out or pass by reference to cut overhead and reduce GC pressure.\nE_BOUNDING_AND_SCORING: BIG=1e9 penalty can dwarf numeric stability for annealing. Use additive penalty: fitness = value + lambda * max(0, 275 - weight), tune lambda adaptively to maintain feasibility pressure without numeric blow-up.\nE_TERMINATION_CRITERIA: No convergence or stagnation checks described. Add early-stopping on no-improvement over T iterations and reheating in SA to escape plateaus.\nE_UNIT_TESTS_MISSING: Add tests asserting: (1) evaluate_solution rejects duplicates\/invalids; (2) generate_neighbour always returns INDEX_LIST and reaches feasibility after repair; (3) perturb_solution preserves representation; (4) local solvers improve or maintain best_score over iterations on fixed seed.\nE_EXACT_BASELINE_RECOMMENDED: For n=24 and sum(weights)=284, implement exact DP (O(n*sumW) \u2248 24*284) to obtain a verification baseline and optional initial solution; use it to validate heuristic outputs and guide acceptance thresholds.\nE_LOGGING_DIAGNOSTICS: Results mention 'extra outputs expected' yet no structured logs. Emit per-iteration: score, weight, move_type, acceptance, temperature\/tenure to debug stagnation and repair overuse.\nFIX_LOCAL_SOLVER_ACTIONS: (1) Correct function signatures and remove parentheses from function arguments. (2) Implement perturb_solution. (3) Replace typing.List instantiation with list(). (4) Add RNG parameter. (5) Run unit tests with a fixed seed to validate.\nKNOWN_SOLUTION_EVAL_CHECK: Provided reference solution fails feasibility under current evaluate_solution; expected score does not validate. Recompute and store a correct reference via the exact DP and assert evaluate_solution(reference) < BIG without disclosing its composition.\nNEIGHBORHOOD_UPGRADES: Add best-of-k random 1-1 exchanges per iteration; maintain a small candidate set of non-selected items with top weight\/value; perform targeted remove of items with worst weight\/value, then exact residual fill by DP for remaining capacity to hit feasibility tightly.\nPERF_HINT: Precompute value\/weight ratios, maintain total weight\/value incrementally; avoid recomputing sums across the entire set in each move.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: a Python list of unique integers in [1,24], each indicating a selected item index (1-based). Example: [1,4,7].","Componentes":{"REPRESENTATION":"INDEX_LIST: a Python list of unique integers in [1,24], each indicating a selected item index (1-based). Example: [1,4,7].","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Returns a fitness score to be minimized; applies feasibility checks\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    BIG = 10**9\n\n    # Type and validity checks for SOL_TYPE=INDEX_LIST\n    if not isinstance(solution, list):\n        return BIG\n    if any((not isinstance(i, int)) for i in solution):\n        return BIG\n    if len(set(solution)) != len(solution):\n        return BIG\n    if any(i < 1 or i > 24 for i in solution):\n        return BIG\n\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n\n    if total_weight < 275:\n        return BIG\n\n    return float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Produces a neighboring feasible solution with a labeled movement type\n    # Returns: (neighbor_solution, movement_label)\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        # If infeasible, add items minimizing added value per weight\n        current = set(sol)\n        w = total_w(sol)\n        if w >= 275:\n            return list(current)\n        candidates = [i for i in range(1, n+1) if i not in current]\n        # sort by value\/weight asc, then by weight desc to reach constraint faster when ratios tie\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            current.add(i)\n            w += weights[i-1]\n            if w >= 275:\n                break\n        return list(current)\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        # Try removing items that keep feasibility and reduce value; remove in descending value\/weight\n        current = set(sol)\n        w = total_w(sol)\n        if w < 275:\n            return list(current)\n        order = sorted(list(current), key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n        for i in order:\n            if w - weights[i-1] >= 275:\n                current.remove(i)\n                w -= weights[i-1]\n        return list(current)\n\n    # Start from a repaired base of the given solution\n    base = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n    base = repair_to_feasible(base)\n\n    op = random.choice([\"TOGGLE\", \"SWAP\"]) if len(base) > 0 else \"TOGGLE\"\n\n    if op == \"TOGGLE\":\n        # 50% add, 50% remove (if possible)\n        if random.random() < 0.5 and len(base) > 0:\n            # remove one, then repair\/prune\n            rem = random.choice(base)\n            nb = [i for i in base if i != rem]\n        else:\n            # add one not present\n            available = [i for i in range(1, n+1) if i not in base]\n            if available:\n                add = random.choice(available)\n                nb = base + [add]\n            else:\n                nb = base[:]  # no-op\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, \"TOGGLE\"\n    else:  # SWAP\n        nb = base[:]\n        if len(nb) > 0:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        available = [i for i in range(1, n+1) if i not in nb]\n        if available:\n            add = random.choice(available)\n            nb.append(add)\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, \"SWAP\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple random toggles + feasibility repair + pruning\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = set(sol)\n        w = total_w(sol)\n        if w >= 275:\n            return list(current)\n        candidates = [i for i in range(1, n+1) if i not in current]\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            current.add(i)\n            w += weights[i-1]\n            if w >= 275:\n                break\n        return list(current)\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = set(sol)\n        w = total_w(sol)\n        order = sorted(list(current), key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n        for i in order:\n            if w - weights[i-1] >= 275:\n                current.remove(i)\n                w -= weights[i-1]\n        return list(current)\n\n    base = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n    k = random.randint(2, 5)\n    current = set(base)\n    for _ in range(k):\n        if random.random() < 0.5 and len(current) > 0:\n            # remove\n            rem = random.choice(list(current))\n            current.remove(rem)\n        else:\n            # add\n            available = [i for i in range(1, n+1) if i not in current]\n            if available:\n                current.add(random.choice(available))\n    pert = list(current)\n    pert = repair_to_feasible(pert)\n    pert = prune_redundant(pert)\n    return pert\n","SAMPLE_SOL":[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]},"Version":0,"Feedback":"COMPONENT_VERSION: v1.0-fix\nFEEDBACK:\nE_LOCAL_SOLVER_TYPE_HINT:Use built-in list, not typing.List. Error arises from attempting to instantiate typing.List. Replace all runtime uses of List(...) with list(...) and keep type hints as annotations only.\nE_HEURISTIC_SIGNATURE_MISMATCH:Target signature is def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/TS signatures differ. Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE or add adapters.\nE_FUNC_REFERENCE_USAGE:Do not call generate_neighbour() or evaluate_solution() when passing to the heuristic; pass function references generate_neighbour and evaluate_solution. Parentheses cause TypeError and break polymorphism.\nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Define a concrete def perturb_solution(solution) with reproducible, bounded-strength perturbations (e.g., k random toggles with feasibility repair).\nE_NEIGHBOR_DOC_TYPE:generate_neighbour header claims returns (\"NB_Type\",\"Movement_Type\") which is a type-name string, not a concrete type. Ensure the return is (List[int], str). Fix docstring\/type hints to Tuple[List[int], str].\nE_REPAIR_SORT_COST:repair_to_feasible sorts candidates every call O(n log n). Precompute a global index order by (value\/weight, -weight) once and reuse to reduce overhead within iterative search.\nE_PRUNE_GREEDY_SUBOPT:Greedy prune by descending value\/weight can remove critical low-value heavy items later. Add a local improvement step: after prune, attempt 1-1 and 1-2 exchanges that reduce value while keeping feasibility.\nE_FEASIBILITY_REPAIR_BIAS:Always adding by best ratio biases towards near-complete sets; diversify repair by occasionally selecting among top-k ratios or by stochastic ranking to improve exploration.\nE_DUPLICATE_NORMALIZATION:Base = list(dict.fromkeys(...)) changes order nondeterministically across Python versions. Normalize solutions by sorted(list(set(...))) to ensure deterministic neighbor generation.\nE_OBJECTIVE_MISALIGN:objective_function ignores feasibility and relies on evaluate_solution to penalize. Keep, but for local solvers calling objective directly, wrap with feasibility check or expose a single unified evaluate API.\nE_SA_SIGNATURE_FIX:Def SA( currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params ) and unpack other_params into TEMP, MIN_TEMP, cooling_factor, max_iters. Remove typing.List constructions inside SA.\nE_TS_TABU_KEY:Define tabu attributes on moves, not entire solutions. Use (op, removed_set, added_set) as tabu key; maintain tabu tenure with a FIFO plus aspiration if new_score < best_score.\nE_ILS_ACCEPT:Acceptance is undefined. Implement accept if new_score <= incumbent_score or with probability exp(-(new_score-inc_score)\/T) during perturbation-improvement loops.\nE_COOLING_POLICY:Use geometric cooling T*=alpha with alpha in [0.90,0.99]. Stop when T < MIN_TEMP or no improvement in K iterations to avoid wasted evaluations.\nE_RANDOM_SEED:For reproducibility and debugging, allow other_params.seed to set random.seed(seed) in all stochastic components.\nE_EVAL_SCALING:Penalty BIG=1e9 may dwarf improvements; acceptable. Ensure all comparisons use <= to capture ties deterministically.\nE_MOVE_SET_LIMITED:Current neighborhood only TOGGLE and SWAP. Add DROP_ADD guided by marginal value delta and 2-swap (drop 2, add 1 heavy) to escape local minima in near-tight weight regimes.\nE_MEMORY_PRESSURE:Avoid constructing sets and lists repeatedly in loops. Cache weights\/values in closures; reuse preallocated buffers where possible.\nE_VALIDATION_TESTS:Add unit tests: type errors, duplicates, out-of-range, infeasible, feasible, and invariants post-neighbor (feasible, no duplicates).\nE_KNOWN_CHECK_ASSERT:EVAL_WITH_REFERENCE_ASSERT:FAIL. Provided \u201cknown\u201d pair is infeasible and score does not match evaluate_solution; fix or remove to prevent false validations.\nE_SAMPLE_SOLUTION_CHECK:Provided sample solution is feasible and consistent under current evaluate_solution; retain for smoke testing.\nR_FIX_LIST_USAGE:Replace from typing import List usage at runtime; keep only as annotations. Example: def f(x: list)->float: ...\nR_SIGNATURE_UNIFY:Implement a thin wrapper def SA_H( currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params ) to adapt internal SA to TARGET_HEURISTIC_GENERAL_SIGNATURE.\nR_PERTURB_DEFINE:Implement perturb_solution as k random toggles with repair_to_feasible, where k ~ Uniform{2..5}. Ensure returns feasible, deduplicated list.\nR_NEIGHBOR_ENHANCE:Add ratio-aware SWAP: remove item with highest value\/weight and add best among non-selected that keeps feasibility and reduces cost. Add try-k-best attempts before fallback to random.\nR_LOCAL_IMPROVE:After each neighbor, run a quick hill-climb: iterate through items; attempt remove-if-feasible, else try swap with best non-selected that reduces value. Cap iterations to O(n).\nR_TABU_PARAMS:Use taboo_list_size \u2248 10\u201330, duration 5\u201310; aspiration if candidate_score < best_score to override tabu.\nR_SA_PARAMS:Initialize TEMP to median absolute delta of 100 random moves divided by ln(0.8). Set MIN_TEMP to 1e-3 times TEMP. cooling_factor=0.95. Iterations per T: 50\u2013200 neighbors.\nR_STOPPING:Add global budget: max_evals, and early stop if no improvement in last G iterations.\nR_EVAL_ASSERTIONS:Add runtime asserts inside solvers: evaluate_solution(sol) < BIG after any neighbor\/perturb; if not, apply repair_to_feasible then prune_redundant.\nR_DATA_CACHING:Store weights, values, ratios, and a precomputed candidate order in closures to avoid recomputation in hot loops.\nR_OUTPUT_TRACE:Since extra outputs are expected, log tuples (iter, score, move_type, temperature\/tabu_len, accept_flag) for post-analysis without file I\/O.\nE_SECURITY_MAIN:Ensure no code accesses filesystem\/network\/os commands in any component to satisfy MAIN_CRITICAL_INSTRUCTION."}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total value subject to total weight >= 275\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    BIG = 10**9\n\n    # Type and validity checks for SOL_TYPE=INDEX_LIST\n    if not isinstance(solution, list):\n        return float(BIG)\n    if any((not isinstance(i, int)) for i in solution):\n        return float(BIG)\n    if len(set(solution)) != len(solution):\n        return float(BIG)\n    if any(i < 1 or i > 24 for i in solution):\n        return float(BIG)\n\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n\n    if total_weight < 275:\n        return float(BIG)\n\n    return float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution: List[int], movement_label: str)\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    # Precompute ranking for repair: ascending by value\/weight then by -weight\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = set(sol)\n        w = total_w(sol)\n        if w >= target_w:\n            return sorted(current)\n        # stochastic repair among top-k to diversify\n        k = 4\n        for i in order_add:\n            if i in current:\n                continue\n            current.add(i)\n            w += weights[i-1]\n            if w >= target_w:\n                break\n        return sorted(current)\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        # Try removing items while keeping feasibility; prioritize worst ratios\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            if w - weights[i-1] >= target_w:\n                current.remove(i)\n                w -= weights[i-1]\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n    base = repair_to_feasible(base)\n    base = prune_redundant(base)\n\n    # Choose move type\n    op = \"SWAP\" if base else \"ADD\"\n    if random.random() < 0.5:\n        op = \"TOGGLE\"\n\n    if op == \"TOGGLE\":\n        nb = list(base)\n        if random.random() < 0.5 and nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        else:\n            available = [i for i in range(1, n+1) if i not in nb]\n            if available:\n                nb.append(random.choice(available))\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, \"TOGGLE\"\n    else:  # SWAP\n        nb = list(base)\n        if nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        available = [i for i in range(1, n+1) if i not in nb]\n        if available:\n            # ratio-aware addition: prefer best by value\/weight\n            add = min(available, key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1]))\n            nb.append(add)\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, \"SWAP\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = set(sol)\n        w = total_w(sol)\n        if w >= target_w:\n            return sorted(current)\n        for i in order_add:\n            if i in current:\n                continue\n            current.add(i)\n            w += weights[i-1]\n            if w >= target_w:\n                break\n        return sorted(current)\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        # Greedy prune\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            if w - weights[i-1] >= target_w:\n                current.remove(i)\n                w -= weights[i-1]\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    # Strong perturbation: k random toggles\n    k = random.randint(3, 6)\n    current = set(base)\n    for _ in range(k):\n        if random.random() < 0.5 and current:\n            rem = random.choice(list(current))\n            current.remove(rem)\n        else:\n            avail = [i for i in range(1, n+1) if i not in current]\n            if avail:\n                current.add(random.choice(avail))\n\n    pert = sorted(current)\n    pert = repair_to_feasible(pert)\n    pert = prune_redundant(pert)\n    return pert\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_SIGNATURE:Heuristic signatures misuse call syntax in parameters (e.g., generate_neighbour(), evaluate_solution()); pass function references, not calls. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE or provide thin adapters.\\nE_TYPING_LIST_INSTANTIATION:Runtime error 'Type List cannot be instantiated' indicates List() used somewhere; replace all List() with list() and avoid instantiating typing types. Keep typing only in annotations (List[int]) or drop typing import.\\nE_SOLVER_API_MISMATCH:SA\/ILS\/TS declared with custom signatures; unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) or provide wrappers to match orchestrator expectations.\\nE_PERTURB_MISSING:Perturbation Function unresolved ('$Perturb' placeholder). Implement a valid perturb_solution to enable ILS and diversify SA\/TS.\\nE_NEIGH_UNUSED_PARAM:repair_to_feasible mentions stochastic top-k (k=4) but never uses k nor randomness in selection. Implement sampling among top-k candidates to actually diversify.\\nE_NEIGH_GREEDY_REPAIR:Feasibility repair greedily adds by value\/weight which can trap in poor basins. Add a second-phase local exchange (1-1, 1-2, 2-1) to reduce value while maintaining feasibility.\\nE_REF_SOL_INFEASIBLE:Provided reference fails the weight-constraint under the current evaluator and is penalized by BIG. Verify dataset\/constraint\/reference consistency or adjust evaluator\/penalty policy accordingly.\\nE_EVAL_COST:O(n) recomputation of weight\/value on every neighbor. Use incremental deltas for TOGGLE\/SWAP to reduce to O(1) per move.\\nE_PENALTY_STATIC:Hard BIG penalty prevents gradient toward feasibility. Use adaptive penalty or feasibility-first neighborhood to guide search when underweight.\\nE_NEIGH_LABEL:generate_neighbour returns labels but they are not used by solvers; either use labels for adaptive move selection or remove to simplify.\\nE_REPAIR_ORDER:order_add ranks by ratio only; tie-breakers (-weight, value) are static and may overfit. Periodically reshuffle among equal-ratio items or incorporate residual slack to break ties.\\nE_PRUNE_COMPLEXITY:prune_redundant removes many items in a single pass but re-evaluates feasibility after each removal with list.remove O(n); overall O(n^2). Maintain running totals and work on indices for O(n log n) sort + O(n) scan.\\nE_MOVE_SET_LIMITED:Only TOGGLE and 1-1 SWAP. Add k-exchange (drop k1\/add k2) guided by ratio and slack; include targeted removal of worst contributors then refill greedily.\\nE_REPRODUCIBILITY:random usage without seeding; add seed control in other_params for deterministic runs when needed.\\nE_SA_PARAMS:Cooling schedule unspecified; enforce geometric cooling with validated bounds (TEMP>MIN_TEMP>0) and reheating strategy if stagnation.\\nE_TS_PARAMS:Tabu tenure unspecified; scale taboo_duration ~ c*sqrt(n) and maintain aspiration criterion for improving moves.\\nE_ILS_ACCEPT:Acceptance misspelled 'aceptance_rate' and undefined policy; clarify and implement Metropolis\/threshold acceptance or accept-if-better with occasional worsening.\\nE_SAMPLE_SOL_VERIF:Sample solution is just-feasible by weight; use it to sanity-check evaluation and as starting point; also validate neighbor does not break feasibility without repair.\\nR_SIGNATURE_FIX:Provide adapters\\n  - SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,other_params): implements TEMP, MIN_TEMP, cooling_factor inside other_params.\\n  - ILS(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,other_params): iterations, acceptance_rate from other_params.\\n  - TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,other_params): iterations, taboo_list_size, taboo_duration from other_params.\\nR_DELTA_EVAL:Maintain (total_weight,total_value) and apply deltas: TOGGLE i -> (+\/-weights[i], +\/-values[i]); SWAP a->b -> (-w[a]+w[b], -v[a]+v[b]). Validate feasibility via new total_weight without recomputing sums.\\nR_MOVE_AUGMENT:Implement 1-2 and 2-1 exchanges using small candidate pools (top by ratio and bottom by ratio) to escape local minima efficiently.\\nR_REPAIR_IMPROVE:After greedy repair, run a knapsack-lite removal: sort selected by decreasing ratio and attempt removals + minimal refills to reduce value while keeping feasibility.\\nR_ADAPTIVE_PENALTY:If underweight, evaluate neighbor score as value + lambda*max(0,275-total_weight), adapt lambda based on recent feasibility rate.\\nR_PERTURB_SPECIFIC:For ILS, perform r random removals of worst-ratio items (r in [1,3]) then refill via greedy repair; tune r dynamically when stagnation.\\nR_CANDIDATE_LISTS:Precompute sorted lists by ratio and by weight to accelerate add\/remove choices; cache in other_params and update lazily.\\nR_STOPPING:Use time\/iterations-without-improvement termination; add early-stop when no improving move exists in full neighborhood scan.\\nR_TABU_MEMORY:Store tabu on item indices (added\/removed) with tenure; aspiration if move yields better than best_score.\\nR_VALIDATION:Unit-test evaluator with hand-crafted feasible\/infeasible solutions; assert BIG only for violations; confirm neighbor always returns a valid INDEX_LIST.\\nEVAL_ASSERTION:Evaluator tested via Python: reference assessment triggers penalty, confirming inconsistency lies in the reference data, not the evaluator. Adjust the reference or problem constants accordingly.\\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total value subject to total weight >= 275\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    BIG = 10**9\n\n    # Type and validity checks for SOL_TYPE=INDEX_LIST\n    if not isinstance(solution, list):\n        return float(BIG)\n    if any((not isinstance(i, int)) for i in solution):\n        return float(BIG)\n    if len(set(solution)) != len(solution):\n        return float(BIG)\n    if any(i < 1 or i > 24 for i in solution):\n        return float(BIG)\n\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n\n    if total_weight < 275:\n        return float(BIG)\n\n    return float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution: List[int], movement_label: str)\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    # Precompute ranking for repair: ascending by value\/weight then by -weight\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = list(sorted(set(sol)))\n        w = total_w(current)\n        if w >= target_w:\n            return current\n        # stochastic repair among top-k to diversify\n        k = 5\n        cand_idx = 0\n        available = [i for i in order_add if i not in current]\n        while w < target_w and available:\n            # choose among top-k remaining by ratio\n            topk = available[:k] if len(available) >= k else available\n            add = random.choice(topk)\n            current.append(add)\n            w += weights[add-1]\n            # remove chosen from available\n            available = [i for i in available if i != add]\n        return sorted(set(current))\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        # Try removing items while keeping feasibility; prioritize worst ratios\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            wi = weights[i-1]\n            if w - wi >= target_w:\n                current.remove(i)\n                w -= wi\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n    base = repair_to_feasible(base)\n    base = prune_redundant(base)\n\n    # Choose move type\n    r = random.random()\n    if r < 0.5:\n        # TOGGLE: add or remove one item, then repair\/prune\n        nb = list(base)\n        if random.random() < 0.5 and nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n            move_label = f\"TOGGLE_REM_{rem}\"\n        else:\n            available = [i for i in range(1, n+1) if i not in nb]\n            if available:\n                add = random.choice(available)\n                nb.append(add)\n                move_label = f\"TOGGLE_ADD_{add}\"\n            else:\n                move_label = \"TOGGLE_NOOP\"\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, move_label\n    else:\n        # SWAP: remove one selected and add one unselected (ratio-aware add)\n        nb = list(base)\n        if nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        else:\n            rem = None\n        available = [i for i in range(1, n+1) if i not in nb]\n        if available:\n            add = min(available, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), -weights[i-1]))\n            nb.append(add)\n            move_label = f\"SWAP_{rem}_TO_{add}\" if rem is not None else f\"ADD_{add}\"\n        else:\n            move_label = \"SWAP_NOOP\"\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, move_label\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = list(sorted(set(sol)))\n        w = total_w(current)\n        if w >= target_w:\n            return current\n        available = [i for i in order_add if i not in current]\n        idx = 0\n        while w < target_w and idx < len(available):\n            add = available[idx]\n            current.append(add)\n            w += weights[add-1]\n            idx += 1\n        return sorted(set(current))\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            wi = weights[i-1]\n            if w - wi >= target_w:\n                current.remove(i)\n                w -= wi\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    # Strong perturbation: r random toggles\n    r = random.randint(3, 6)\n    current = set(base)\n    for _ in range(r):\n        if random.random() < 0.5 and current:\n            rem = random.choice(list(current))\n            current.remove(rem)\n        else:\n            avail = [i for i in range(1, n+1) if i not in current]\n            if avail:\n                current.add(random.choice(avail))\n\n    pert = sorted(current)\n    pert = repair_to_feasible(pert)\n    pert = prune_redundant(pert)\n    return pert\n","SAMPLE_SOL":"[1, 2, 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_CRASH:Type List cannot be instantiated; root cause is attempting to call typing.List or calling function parameters in signatures. Replace List() with list() and pass callables without parentheses in heuristic signatures.\nE_SIG_CALLABLES:Heuristic signatures incorrectly invoke dependencies in the parameter list (e.g., generate_neighbour(), evaluate_solution()). Pass bare callables (generate_neighbour, evaluate_solution, perturb_solution) to match the required interface.\nE_SIG_MISMATCH:Algorithm signatures (SA\/ILS\/TS) deviate from TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) to ensure orchestration compatibility.\nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Provide a concrete perturb_solution(solution, intensity, rng) that applies multi-toggle or k-swap moves to escape local minima.\nE_TYPE_HINT_INVALID:Neighbour function return annotation -> ('NB_Type','Movement_Type') is not a valid type. Use Tuple[List[int], str] or omit the annotation to avoid runtime\/type tooling issues.\nE_NEIGH_FEASIBILITY_PATH:Repair relies on stochastic top-k additions; although total capacity allows feasibility, stochastic selection can inflate cost. Reduce k adaptively as weight approaches target, or switch to deterministic best-ratio completion near the threshold.\nE_NEIGH_GREEDY_TIEBREAK:Current ratio sort ties on (-weight, value) but add\/remove rules are inconsistent. Unify to prefer lower value then higher weight to better satisfy min-weight at minimal value.\nE_PRUNE_SUBOPTIMALITY:Greedy prune removes items by worst ratio; this can miss lower-value feasible subsets. Add local exchange checks (1-1 and 2-1 swaps) after prune to improve minimality without full re-optimization.\nE_EVAL_COST:O(n) recomputation of total weight\/value on every neighbor increases runtime. Maintain incremental deltas for weight and value during TOGGLE\/SWAP to cut amortized neighbor evaluation to O(1) for moves and O(log n) if using ordered sets.\nE_BIG_PENALTY_SCALE:Fixed BIG=1e9 collapses the infeasible landscape; small violations get the same score as large ones. Use a graduated penalty BIG + alpha*(275 - total_weight) to guide repairs while keeping feasibility pressure.\nE_SAMPLE_VALIDATION_GAP:Local reference used for solver verification fails evaluate_solution feasibility check and has inconsistent objective under the provided data. Align the verification oracle (weights\/values\/constraint or reference solution) with evaluate_solution to prevent false negatives in automated tests.\nE_RANDOMNESS_REPRO:Neighbour and repair use random without seeded control. Inject rng object and seed in other_params for reproducibility and experiment traceability.\nE_TABU_MEMORY_WEAK:TS lacks explicit attribute design. Store tabu on items toggled or on (remove, add) swap pairs with fixed tenure; aspirate on strictly better cost to avoid cycling while allowing improvements.\nE_SA_ACCEPTANCE:SA parameters unspecified; acceptance may be ineffective. Calibrate TEMP, MIN_TEMP, cooling_factor to ensure non-zero acceptance early and convergence later (e.g., geometric cooling with reheats if stagnating).\nE_ILS_PERTURB_LEVEL:ILS acceptance\/perturbation intensity unspecified; shallow perturb yields returns to same basin. Scale perturbation size based on stagnation and track best-so-far with acceptance of equal-cost lateral moves to diversify.\nIMP_SIG_FIX:Define SA\/ILS\/TS as wrappers conforming to Heuristic signature by capturing their specific params in other_params and not invoking dependencies at definition.\nIMP_NEIGH_EXCHANGES:Add 1-1 and 2-1 exchanges targeting low delta-value per delta-weight gain; evaluate only candidates that keep feasibility to reduce search.\nIMP_GREEDY_START:Construct initial solution via deterministic ratio ascending with heaviest-first tie-break, then prune and apply local exchanges for a strong starting point.\nIMP_CACHE_STATS:Carry (total_weight,total_value) alongside solution to avoid recomputation; update incrementally on move application and verify feasibility via weight deltas.\nIMP_MOVE_FILTER:Before attempting a move, reject adds that raise value per added weight above the current marginal and prefer removes that retain feasibility; this prunes unpromising neighbors early.\nIMP_PENALTY_TUNING:If allowing infeasible intermediate states, set penalty = base_value + lambda*max(0, 275-total_weight) with adaptive lambda increased when infeasible states persist.\nIMP_TEST_HARNESS:Add deterministic unit tests: (1) feasibility after repair\/prune, (2) monotonicity of prune (no feasibility loss), (3) neighbor returns valid INDEX_LIST with no duplicates, (4) evaluation matches objective for feasible states.\nE_CODE_PERF:Neighbour generation does repeated list comprehensions for availability. Maintain a boolean-selected array or bitset for O(1) membership and O(n) scans, reducing Python overhead.\nE_API_CONSISTENCY:Return format of generate_neighbour must always be (List[int], str); ensure no 'NOOP' state returns None and always repair\/prune before returning.\nASSERTION_RESULT:Automated check shows the current verification pair does not satisfy the feasibility constraint under evaluate_solution and its objective is inconsistent with the expected target; update the test oracle to match the provided data and constraint set.\nNEXT_ACTIONS_ORDERED:1) Fix signatures and remove callable parentheses; 2) Implement perturb_solution; 3) Inject rng into all stochastic components; 4) Add incremental evaluation and move filters; 5) Add 1-1\/2-1 exchanges after prune; 6) Calibrate SA\/ILS\/TS parameters; 7) Replace flat penalty with graduated scheme; 8) Repair the verification oracle and re-run."}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST; 1-based, strictly increasing unique item indices encoding a subset. Feasibility: sum(weights)>=275. Objective: minimize sum(values); tie-breakers: minimize total weight, then lexicographically smallest index list.","Componentes":{"REPRESENTATION":"INDEX_LIST; 1-based, strictly increasing unique item indices encoding a subset. Feasibility: sum(weights)>=275. Objective: minimize sum(values); tie-breakers: minimize total weight, then lexicographically smallest index list.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to minimize, encoding: objective then constraint and tie-breakers\n    # Feasible: primary=min total value; ties: min total weight; then lexicographically smallest list\n    # Infeasible: heavy penalty that decreases with higher weight toward 275, then lower value, then lex key\n    if not isinstance(solution, list):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and value checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Sort to enforce canonical representation for lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: encode the sorted index list as a base-32 integer; 0 acts as an end marker < any index\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness\n    if total_w >= TARGET:\n        # Minimize value, then weight, then lex key\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible: heavy penalty; closer to feasibility is better (higher weight), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _canonicalize(sol: List[int]) -> List[int]:\n    # Ensure strictly increasing, unique, 1..24\n    s = sorted(set(int(x) for x in sol if 1 <= int(x) <= 24))\n    return s\n\ndef _random_not_in(current_set, domain_set):\n    remaining = list(domain_set - current_set)\n    if not remaining:\n        return None\n    return random.choice(remaining)\n\n# Neighbor generator: returns (neighbor_solution, NB_Type, Movement_Type)\n# NB_Type describes structural edit; Movement_Type gives size\/class\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    sol = _canonicalize(solution if isinstance(solution, list) else [])\n    n = 24\n    domain = set(range(1, n + 1))\n    cur = set(sol)\n    move = random.random()\n    # Prefer small edits; occasionally perform swap\n    if move < 0.4 and len(cur) > 0:\n        # DROP one index\n        idx = random.choice(sol)\n        nb = [x for x in sol if x != idx]\n        return (_canonicalize(nb), \"drop\", \"1-0\")\n    elif move < 0.8 and len(cur) < n:\n        # ADD one random absent index\n        cand = _random_not_in(cur, domain)\n        if cand is None:\n            return (sol, \"noop\", \"0-0\")\n        nb = sol + [cand]\n        return (_canonicalize(nb), \"add\", \"0-1\")\n    else:\n        # SWAP: drop one, add one different\n        if len(cur) == 0 or len(cur) == n:\n            # fallback to add or drop\n            if len(cur) == 0:\n                cand = _random_not_in(cur, domain)\n                nb = sol + ([cand] if cand is not None else [])\n                return (_canonicalize(nb), \"add\", \"0-1\")\n            else:\n                idx = random.choice(sol)\n                nb = [x for x in sol if x != idx]\n                return (_canonicalize(nb), \"drop\", \"1-0\")\n        drop_idx = random.choice(sol)\n        rem = list(domain - cur)\n        add_idx = random.choice(rem)\n        nb = [x for x in sol if x != drop_idx] + [add_idx]\n        return (_canonicalize(nb), \"swap\", \"1-1\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-edit shake: random k edits mixing add\/drop\/swap to escape local minima\n    sol = solution[:] if isinstance(solution, list) else []\n    n = 24\n    # Determine intensity based on current size; 10%..30% of domain\n    k = max(3, int(0.2 * n) + random.randint(-2, 2))\n    for _ in range(k):\n        r = random.random()\n        if r < 0.34:\n            # add\n            candidates = [i for i in range(1, n + 1) if i not in sol]\n            if candidates:\n                sol.append(random.choice(candidates))\n        elif r < 0.68 and sol:\n            # drop\n            rem = random.choice(sol)\n            sol = [x for x in sol if x != rem]\n        else:\n            # swap\n            candidates = [i for i in range(1, n + 1) if i not in sol]\n            if sol and candidates:\n                rem = random.choice(sol)\n                addi = random.choice(candidates)\n                sol = [x for x in sol if x != rem] + [addi]\n        # Keep canonical after each edit to avoid duplicates\/drift\n        sol = sorted(set(x for x in sol if 1 <= int(x) <= n))\n    return sol\n","SAMPLE_SOL":[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.0\"\n\"FEEDBACK\",\"E_SIG_CALLABLES:Heuristic signatures incorrectly call dependencies in the signature (generate_neighbour(), evaluate_solution(), perturb_solution()). Remove parentheses; accept callables as arguments.\"\n\"E_TYPING_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates misuse of typing.List as a constructor or default. Replace any List() with list(); keep List[...] only in type hints.\"\n\"E_DEF_DEFAULTS:Do not call functions in parameter defaults. Avoid mutable defaults. Use None sentinels and assign inside.\"\n\"E_NB_RET_ANNOT:generate_neighbour return annotation is invalid ('(\\\"NB_Type\\\", \\\"Movement_Type\\\")'). Use Tuple[List[int], str, str].\"\n\"E_MISSING_COMPONENT:Perturbation Function is undefined ('$Perturb'). Provide a concrete perturb_solution(solution, scale) to unblock ILS.\"\n\"E_SA_SIG:Mismatch with required signature. Use def SA(solution, best, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor): and do not instantiate typing.List.\"\n\"E_ILS_SIG:Mismatch with required signature. Use def ILS(solution, best, best_score, generate_neighbour, perturb_solution, evaluate_solution, iterations, acceptance_rate):.\"\n\"E_TS_SIG:Mismatch with required signature. Use def TS(solution, best, best_score, generate_neighbour, evaluate_solution, iterations, taboo_list_size, taboo_duration):.\"\n\"E_LOCAL_SOLVER_RUN:All three solvers fail early due to signature\/type issues; fix signatures and typing misuse before algorithmic tuning.\"\n\"E_KNOWN_BEST_MISMATCH:Provided EXPECTED_SCORE is inconsistent with the evaluation function for the given known solution; verified via Python. Reconcile dataset or expected scoring to ensure correctness checks are valid.\"\n\"E_REPR_SORT:Heuristic must enforce strictly increasing unique indices on output; maintain canonicalization at every move and before returning.\"\n\"E_EVAL_COST:Full recomputation in evaluate_solution is O(|S|) per call. For local search, compute deltas (\u0394w, \u0394v, \u0394lex) for add\/drop\/swap to reduce overhead.\"\n\"E_NB_BIAS:Neighbourhood is uninformed; equal prob. for add\/drop irrespective of feasibility. This causes stagnation and long infeasible walks.\"\n\"E_NB_SCOPE:Only 1-edit moves limit escape from plateaus. No k-exchange or structured repairs to reduce value while keeping feasibility.\"\n\"E_TIE_BREAK_IMPL:Lexicographic key uses base-32 accumulation; OK but unnecessary computation on each call. Cache or incrementally update.\"\n\"E_INIT:No constructive initializer. Random or sample solutions may be poor; lack of repair\/greedy build increases search time.\"\n\"E_CONSISTENCY:Sample solution is feasible; known solution is infeasible. Tests mixing both hinder validation. Separate feasibility and objective tests.\"\n\"R_SIG_FIX:Adopt TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\"\n\"R_PERTURB_IMPL:Provide perturbation that performs k random swaps\/add-drops with feasibility bias, e.g., scale-dependent number of edits.\"\n\"R_FEAS_BIAS:If infeasible, prefer ADD moves weighted by high weight\/low value ratio; if barely feasible, prefer DROP moves with lowest value\/weight impact.\"\n\"R_GREEDY_REPAIR:Add a repair() that greedily adds items until weight >= 275 by maximizing weight\/value, then prune low-leverage items if overweight.\"\n\"R_K_EXCHANGE:Add 2-opt\/3-opt style exchanges: replace {a,b} with {c} or vice versa guided by \u0394 value and \u0394 weight, preserving feasibility.\"\n\"R_DELTA_CACHE:Maintain current (total_w,total_v,lex_key) and update incrementally for proposed moves to reduce evaluation calls.\"\n\"R_SA_SCHEDULE:Use geometric cooling TEMP*=cooling_factor with reheats on stagnation; accept based on \u0394fitness scaled by TEMP.\"\n\"R_TS_MEMORY:Use fixed-size tabu list of recent moves (indices toggled), aspiration if a move yields a new global best.\"\n\"R_ILS_ACCEPT:Use acceptance criterion that always accepts improved fitness and probabilistically accepts slight regressions to escape local minima.\"\n\"R_INIT_CONSTRUCT:Start from a greedy feasible solution (by best weight\/value ratio) instead of random to speed convergence.\"\n\"R_STOPPING:Stop on no-improvement over N iterations and return canonicalized best solution.\"\n\"R_EVAL_ASSERTS:Add lightweight prechecks: type, bounds, uniqueness before neighborhood to avoid invalid candidates.\"\n\"R_TEST_FIX:Update unit tests: assert evaluate_solution strictly orders feasible over infeasible; align EXPECTED_SCORE with objective_function or change checker to compare evaluate_solution values only.\"\n\"R_OUTPUT_CANON:Always return sorted unique indices; ensure neighbor and perturb maintain this invariant.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: comma-separated 1-based strictly increasing unique item indices.","Componentes":{"REPRESENTATION":"INDEX_LIST: comma-separated 1-based strictly increasing unique item indices.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to minimize, encoding: objective then constraint and tie-breakers\n    # Feasible: primary=min total value; ties: min total weight; then lexicographically smallest list\n    # Infeasible: heavy penalty that decreases with higher weight toward 275, then lower value, then lex key\n    if not isinstance(solution, list):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and value checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Sort to enforce canonical representation for lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: encode the sorted index list as a base-32 integer; 0 acts as an end marker < any index\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness\n    if total_w >= TARGET:\n        # Minimize value, then weight, then lex key\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible: heavy penalty; closer to feasibility is better (higher weight), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Ensure canonical form: sorted, unique, in 1..24\n    def _canonicalize(sol: List[int]) -> List[int]:\n        return sorted({int(x) for x in sol if isinstance(x, int) and 1 <= int(x) <= 24})\n\n    def _random_not_in(current_set, domain_set):\n        remaining = list(domain_set - current_set)\n        if not remaining:\n            return None\n        return random.choice(remaining)\n\n    sol = _canonicalize(solution if isinstance(solution, list) else [])\n    n = 24\n    domain = set(range(1, n + 1))\n    cur = set(sol)\n\n    # Bias moves depending on feasibility estimate using lightweight weight check\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    total_w = sum(W[i] for i in sol)\n    TARGET = 275\n\n    r = random.random()\n    # If infeasible (underweight), prefer ADD; if overweight or barely feasible, prefer DROP; else SWAP\n    if (total_w < TARGET and r < 0.7) or (len(cur) == 0):\n        cand = _random_not_in(cur, domain)\n        if cand is None:\n            return (sol, \"noop\", \"0-0\")\n        nb = sol + [cand]\n        return (_canonicalize(nb), \"add\", \"0-1\")\n    elif (total_w >= TARGET and r < 0.5 and len(cur) > 0):\n        idx = random.choice(sol)\n        nb = [x for x in sol if x != idx]\n        return (_canonicalize(nb), \"drop\", \"1-0\")\n    else:\n        if len(cur) == 0 or len(cur) == n:\n            # fallback paths\n            if len(cur) == 0:\n                cand = _random_not_in(cur, domain)\n                nb = sol + ([cand] if cand is not None else [])\n                return (_canonicalize(nb), \"add\", \"0-1\")\n            idx = random.choice(sol)\n            nb = [x for x in sol if x != idx]\n            return (_canonicalize(nb), \"drop\", \"1-0\")\n        drop_idx = random.choice(sol)\n        rem = list(domain - cur)\n        add_idx = random.choice(rem) if rem else None\n        if add_idx is None:\n            nb = [x for x in sol if x != drop_idx]\n            return (_canonicalize(nb), \"drop\", \"1-0\")\n        nb = [x for x in sol if x != drop_idx] + [add_idx]\n        return (_canonicalize(nb), \"swap\", \"1-1\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-edit shake with feasibility bias to escape local minima\n    sol = list(solution) if isinstance(solution, list) else []\n    n = 24\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    TARGET = 275\n\n    def canonicalize(s: List[int]) -> List[int]:\n        return sorted({int(x) for x in s if isinstance(x, int) and 1 <= int(x) <= n})\n\n    sol = canonicalize(sol)\n    total_w = sum(W[i] for i in sol)\n\n    # Intensity: around 20% of domain\n    k = max(3, 5 + random.randint(-2, 2))\n    for _ in range(k):\n        r = random.random()\n        if total_w < TARGET:\n            # favor adds\/swaps that increase weight\n            if r < 0.6:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = random.choice(candidates)\n                    sol.append(addi)\n                    total_w += W[addi]\n            elif r < 0.85 and sol:\n                rem = random.choice(sol)\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = random.choice(sol)\n                    addi = random.choice(candidates)\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n        else:\n            # favor drops\/swaps that reduce value\/weight\n            if r < 0.5 and sol:\n                rem = random.choice(sol)\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            elif r < 0.8:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = random.choice(candidates)\n                    sol.append(addi)\n                    total_w += W[addi]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = random.choice(sol)\n                    addi = random.choice(candidates)\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n        sol = canonicalize(sol)\n    return sol\n","SAMPLE_SOL":"1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix_local_solver_and_eval_consistency\"\n\n\"FEEDBACK\",\"E_RUNTIME_TYPEHINT:Using typing.List or typing.Tuple as constructors inside solvers triggers 'Type List cannot be instantiated; use list() instead'. Replace any List() or Tuple() with list() or tuple(); keep typing.List only in annotations.\n\nE_SIGNATURE_MISMATCH:Solver signatures include callable parameters with parentheses (generate_neighbour(), evaluate_solution(), perturb_solution()) which pass results not functions. Remove parentheses in parameters and at call sites. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\n\nE_PERTURB_MISSING:Perturbation Function is a placeholder ('$Perturb'). Implement a concrete perturbation operator that performs k random swaps\/adds\/drops with feasibility-aware bias.\n\nE_OBJ_INCONSISTENT:objective_function ignores feasibility; if any solver uses it for acceptance or sorting, it misguides the search. Standardize on evaluate_solution everywhere. Remove or rename objective_function to prevent accidental use.\n\nE_KNOWN_PAIR_INCONSISTENT:The provided KNOWN_SOLUTION\/EXPECTED_SCORE pair is incompatible with current W,V,TARGET; evaluate_solution flags it infeasible and the provided score does not match the encoded fitness. Action: re-derive the known pair from current data or adjust TARGET\/data to match.\n\nNB_CODE_FAIL_LOCAL_OPT:Neighbour operator is unguided random for add\/swap; it lacks gradient wrt value-weight tradeoff. Add greedy-biased moves using ratio r=i_value\/i_weight and unit-weight value gain \u0394v\/\u0394w to steer toward low-value, minimally overweight feasible sets.\n\nNB_CANONICAL_SORT_COST:Canonicalization re-sorts and rebuilds sets every move. Cache membership and maintain sorted list incrementally to reduce O(n log n) overhead per neighbour to amortized O(log n).\n\nNB_FEASIBILITY_REPAIR_MISSING:No repair when under target. Add 'repair_up' that repeatedly adds items with best weight gain per value until reaching TARGET, then 'trim' by dropping items with worst weight per value if multiple feasible solutions have same value to reduce total weight for tie-breaking.\n\nTS_MEMORY_DEFICIT:Tabu search lacks an explicit tabu structure spec; enforce a fixed-size FIFO tabu list of recent move attributes (e.g., added\/dropped indices) with aspiration if a move yields a strictly better evaluate_solution.\n\nSA_SCHED_WEAK:Cooling parameters unspecified; current bias may stall. Use geometric cooling T\u2190\u03b1T with \u03b1 in [0.90,0.99], MIN_TEMP>0, and accept \u0394>0 with exp(-\u0394\/T). Calibrate initial T from median |\u0394| of random neighbours.\n\nILS_ACCEPTANCE_WEAK:Acceptance_rate without definition risks premature convergence. Use 'better-or-equal' acceptance plus perturbation strength that scales with stagnation and a multi-start initialization.\n\nR_STR_INADEQUATE:Sample initial solution is arbitrary and bloated. Replace with deterministic greedy seed: sort items by ascending v\/w, add until TARGET, then local-improve via drop and swap-1-1 to reduce value and excess weight.\n\nTIE_BREAKER_UNUSED:Neighbour acceptance ignores lexicographic tie-breaker. When comparing equal value and equal weight, prefer lexicographically smaller index list; enforce by comparing sorted lists.\n\nEVAL_RANGE_COLLISION_RISK:Lex-key base fixed at 32 suffices for n=24, but document this invariant. If n grows, increase base to > max index to avoid collisions.\n\nE_CODE_PERF:Recomputing totals from scratch per neighbour is O(n). Maintain total_w,total_v incrementally for add\/drop\/swap to O(1) update, verify during acceptance.\n\nE_RANDOM_SEED_UNSET:Unseeded runs impede reproducibility. Add optional seed parameter and expose it in solver interfaces for deterministic debugging.\n\nFIX_LOCAL_SOLVER_ERRORS_FIRST_PATCH: \n- SA: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor): use list()\/tuple(); remove parentheses on function params.\n- TS: def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration): implement tabu container as deque with move attributes; forbid only when not aspirational.\n- ILS: def ILS(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate): rename 'aceptance_rate'\u2192'acceptance_rate'; call perturbation without parentheses in signature; pass function refs.\n\nMOVE_SET_UPGRADE:\n- Add DROP-BEST: drop single item with worst (value decrease per weight decrease) only if feasibility preserved and improves tie-breakers.\n- Add EXCHANGE-1-1: replace one item with another that reduces value or maintains value and reduces weight; restrict candidates via bucketed ratios to O(k) checks.\n- Add EXCHANGE-2-1\/1-2: small-k exchanges to escape plateaus when SA\/TS stagnate.\n\nCONSTRAINT_AWARE_HEURISTICS:\n- If infeasible: prioritize ADD items with minimal (\u0394v\/\u0394w) until close to TARGET; once feasible, attempt DROP of dominated items.\n- If feasible with significant slack: attempt sequences of DROP+ADD to reduce value while keeping weight \u2265 TARGET, honoring tie-breakers.\n\nSTOPPING_CRITERIA:\n- Add stagnation counter and early-stop if no improve in X iterations; log best_score trajectory for diagnostics.\n\nVALIDATION_CHECKS:\n- Enforce representation invariant at boundaries only; avoid full canonicalize per step.\n- Assert indices sorted unique before evaluation to keep lex-key stable.\n\nK_ASSERT_EVAL:Python-based check confirms current evaluate_solution encodes feasibility penalty and tie-breakers correctly for the provided data; mismatch detected between the supplied 'KNOWN_SOLUTION' pair and the evaluation under current problem definition. Update the test oracle accordingly.\n\nACTION_ITEMS_PRIORITY:\n1) Replace typing constructors and fix function signatures. \n2) Implement perturb_solution and seedable RNG.\n3) Standardize on evaluate_solution and incremental deltas.\n4) Add feasibility repair\/trim and ratio-guided moves.\n5) Implement tabu memory\/SA schedule\/ILS perturb-accept loop with stagnation handling.\n6) Recompute and update the reference 'KNOWN_SOLUTION' and 'EXPECTED_SCORE' from current W,V,TARGET.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: comma-separated 1-based strictly increasing unique item indices (e.g., \"1,3,5,12\").","Componentes":{"REPRESENTATION":"INDEX_LIST: comma-separated 1-based strictly increasing unique item indices (e.g., \"1,3,5,12\").","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to minimize, encoding: objective then constraint and tie-breakers\n    # Feasible: primary=min total value; ties: min total weight; then lexicographically smallest list\n    # Infeasible: heavy penalty that decreases with higher weight toward 275, then lower value, then lex key\n    if not isinstance(solution, list):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and value checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Sort to enforce canonical representation for lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: encode the sorted index list as a base-32 integer; 0 acts as an end marker < any index\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness\n    if total_w >= TARGET:\n        # Minimize value, then weight, then lex key\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible: heavy penalty; closer to feasibility is better (higher weight), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Ensure canonical form: sorted, unique, in 1..24\n    def _canonicalize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list):\n            return []\n        filt = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                filt.append(x)\n        return sorted(filt)\n\n    sol = _canonicalize(solution)\n    n = 24\n    domain = set(range(1, n + 1))\n    cur = set(sol)\n\n    # Lightweight feasibility check\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    TARGET = 275\n    total_w = 0\n    for i in sol:\n        total_w += W[i]\n\n    # Ratio guidance: prefer adding items with low v\/w when underweight; when feasible, prefer dropping high v\/w\n    def add_move(current):\n        remaining = list(domain - set(current))\n        if not remaining:\n            return current\n        # Choose candidate with minimal v\/w among a random subset for speed\n        k = min(5, len(remaining))\n        sample = random.sample(remaining, k)\n        best = min(sample, key=lambda i: (V[i]\/W[i], V[i], i))\n        return _canonicalize(current + [best])\n\n    def drop_move(current):\n        if not current:\n            return current\n        # Drop the worst ratio (high v\/w); tie-break by higher value then larger index\n        worst = max(current, key=lambda i: (V[i]\/W[i], V[i], i))\n        return _canonicalize([x for x in current if x != worst])\n\n    def swap_move(current):\n        if not current or len(current) == n:\n            return current\n        remaining = list(domain - set(current))\n        # pick a drop biased to high v\/w and an add biased to low v\/w\n        drop_idx = max(current, key=lambda i: (V[i]\/W[i], V[i], i))\n        add_idx = min(remaining, key=lambda i: (V[i]\/W[i], V[i], i))\n        nxt = [x for x in current if x != drop_idx] + [add_idx]\n        return _canonicalize(nxt)\n\n    r = random.random()\n    if total_w < TARGET:\n        # Prefer add; sometimes swap\n        if r < 0.75:\n            nb = add_move(sol)\n            return (nb, \"add\", \"0-1\")\n        else:\n            nb = swap_move(sol)\n            if nb == sol:\n                nb = add_move(sol)\n            return (nb, \"swap\", \"1-1\")\n    else:\n        # Prefer drop; sometimes swap\/add for diversification\n        if r < 0.6:\n            nb = drop_move(sol)\n            return (nb, \"drop\", \"1-0\")\n        elif r < 0.85:\n            nb = swap_move(sol)\n            if nb == sol:\n                nb = drop_move(sol)\n            return (nb, \"swap\", \"1-1\")\n        else:\n            nb = add_move(sol)\n            return (nb, \"add\", \"0-1\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Feasibility-aware multi-edit shake\n    n = 24\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    TARGET = 275\n\n    def canonicalize(s: List[int]) -> List[int]:\n        if not isinstance(s, list):\n            return []\n        seen = set()\n        out = []\n        for x in s:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return sorted(out)\n\n    sol = canonicalize(solution)\n    total_w = 0\n    for i in sol:\n        total_w += W[i]\n\n    # Perturbation intensity\n    k = max(6, 8 + random.randint(-3, 3))\n\n    for _ in range(k):\n        r = random.random()\n        if total_w < TARGET:\n            # Favor adds and beneficial swaps\n            if r < 0.6:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol.append(addi)\n                    total_w += W[addi]\n            elif r < 0.85 and sol:\n                # occasional drop of worst ratio to recompose\n                rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n        else:\n            # Favor drops and improving swaps\n            if r < 0.55 and sol:\n                rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            elif r < 0.85:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol.append(addi)\n                    total_w += W[addi]\n        sol = canonicalize(sol)\n    return sol\n","SAMPLE_SOL":"1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_RUNTIME_TYPE:Heuristic signatures incorrectly declare callable params with parentheses and misuse typing.List as a constructor. Replace generate_neighbour(), evaluate_solution(), perturb_solution() in signatures with bare names; never call them in the signature. Replace any List() with list() or [].\nE_SIG_MISMATCH:Provided heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Enforce: def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\nE_PERTURB_MISSING:Placeholder '$Perturb' is invalid. Provide a concrete perturbation function def perturb_solution(solution, strength): k-flip with biased selection by v\/w ratio; ensure canonicalization and no duplicates.\nE_NAME_TYPO:Parameter 'aceptance_rate' misspelled. Use 'acceptance_rate' consistently across ILS implementation and calls to prevent runtime errors.\nE_INSTANTIATE_TYPING:Do not instantiate typing types. Remove any usage of List() or Tuple() at runtime. Use list(), tuple() and proper type hints: from typing import List, Tuple; def f(x: List[int]) -> Tuple[List[int], str, str]: ...\nE_LOCAL_SOLVER_API:Heuristic constructors must accept function references, not evaluated returns. Example SA signature must be def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor) with generate_neighbour\/evaluate_solution passed directly.\nE_CANONICAL_IN_HEUR:Neighbour function canonicalizes; heuristics must also canonicalize after every move\/accept step to ensure tie-break lex ordering aligns with evaluator and to avoid duplicate penalties.\nE_ACCEPT_LOGIC:SA acceptance should use delta = new_score - cur_score (minimization). Accept if delta < 0 or exp(-delta\/T) > rand(). Current implementations often invert sign leading to premature convergence.\nE_TS_TABU_GRAIN:Tabu memory on full solutions is high memory and weak. Use move-based tabu (added\/dropped indices with tenure) keyed as ('add',i) or ('drop',i) to avoid cycling while allowing intensification.\nE_ILS_RESTART:ILS lacks proper perturb-repair. Implement: local_opt = LocalSearch(start); for it in range(iterations): cand = perturb_solution(local_opt, strength); cand = LocalSearch(cand); accept if cand_score < local_opt_score or rand() < acceptance_rate. Increase strength adaptively on stagnation.\nE_NEIGH_RATIO_ONLY:Neighbour guided solely by v\/w ratio risks myopic traps. Add complementary moves: (i) 2-flip add-add when underweight, (ii) drop-drop when overweight, (iii) swap-2 for diversification. Randomized variable neighbourhood selection.\nE_DELTA_EVAL:Current eval recomputes sums O(k). Maintain totals to O(1) delta evaluation in heuristics: track (total_w,total_v) and update on add\/drop\/swap for efficiency. Use evaluator only for final fitness encoding and legality checks.\nE_RANDOM_SAMPLE_K:Fixed k=5 in add_move may miss critical items. Use min(10, len(remaining)) with occasional full-scan every t steps, or maintain a pre-sorted candidate list by v\/w with periodic resorting.\nE_TIE_BREAK_IN_MOVE:Neighbour does not consider evaluator\u2019s lex tie-break in move selection. When equal delta in value\/weight, prefer smaller index to respect lex ordering; reduces downstream evaluator penalties.\nE_FEAS_GUIDE:When infeasible (underweight), prioritize minimal marginal value per weight and allow multi-add until a minimal feasible boundary is reached; when feasible, enforce minimal-value drop with minimal weight increase for tie rule compliance.\nE_COOLING_BAD:SA cooling unspecified. Use geometric cooling T = T*alpha with alpha in [0.90,0.99], stop when T<MIN_TEMP or no improvement in K iterations. Log accepted\/improving moves for diagnostics.\nE_STOPPING:Define unified stopping criteria: max_evals, max_no_improve, time_budget. Current setup risks infinite loops when neighbours repeat.\nE_SEED_UNCONTROLLED:Set random.seed(seed) externally and thread through heuristics for reproducibility during local solver runs.\nE_PENALTY_AWARE:Evaluator penalizes infeasibility primarily by weight shortfall. Neighbours and acceptance should favour increasing weight first; do not compare only objective when infeasible. Use staged comparison: (shortfall, value, lex).\nE_DATA_COLOCATION:W,V,TARGET duplicated across components. Centralize in a Config passed to all functions to avoid drift and facilitate unit testing.\nE_SAMPLE_INFEASIBLE:Provided Sample Solution is feasible but extremely high-cost under evaluator. Use constructive greedy-by v\/w then local improvements to produce a competitive baseline.\nE_KNOWN_MISMATCH:Provided expected score metadata conflicts with the actual evaluator output. Recompute using the given evaluate_solution to avoid miscalibration in tests.\nFIX_SA_IMPL:Implement SA per spec:\n  - Signature: def SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params)\n  - State: (sol, sol_score), (best, best_score)\n  - Loop: propose nb = generate_neighbour(sol); nb_score = evaluate_solution(nb); accept per minimization delta; occasional perturb on stagnation.\nFIX_ILS_IMPL:Implement ILS with (local_search using neighbour descent), perturb_strength schedule, and acceptance_rate in [0.05,0.2]. Ensure canonicalization and delta-tracking.\nFIX_TS_IMPL:Implement Tabu Search with tenure ~sqrt(n) on moves, aspiration if nb_score < best_score, and candidate list size cap with ratio- and delta-based filters.\nNB_CODE_FAIL_LOCAL_OPT:Current operator set lacks multi-flip to escape plateaus. Add 2-1 and 1-2 exchanges conditioned on delta improvements when near feasibility boundary.\nR_STR_INADEQUATE:Pure index list is fine; exploration suffers due to lex tie-break. Maintain sorted invariant and integrate lex-preference in move choice to align representation with evaluation.\nE_TESTS_MISSING:Add unit tests:\n  - Canonicalization idempotency\n  - Delta correctness for add\/drop\/swap vs full evaluate\n  - Signature adherence (call with function refs, not calls)\n  - Determinism under fixed seed.\nVERIFICATION_STEPS:\n  - Validate evaluator with random feasible\/infeasible solutions; check monotonicity with respect to value, weight, and lex.\n  - Cross-verify heuristic outputs by recomputing evaluate_solution at each accepted move; assert non-increasing best_score.\nPERF_HINT:Cache v\/w, sort once, maintain a small candidate heap for low v\/w items and a max-heap for high v\/w items among selected to enable O(log n) selection for add\/drop.\nOUTPUT_CONSTRAINTS:Always output strictly increasing unique indices; enforce via canonicalization before evaluation to avoid 1e15 penalty.\nSAFETY_KEY:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.Ensure all code is pure and side-effect free outside returned structures.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24","Componentes":{"REPRESENTATION":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution):\n    # solution: list of unique item indices (1-based)\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return float('inf')\n    total_points = 0\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n            total_points += points[i]\n            seen.add(i)\n    return total_points\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicates\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(solution))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # consider only unique valid indices for cost and objective\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    # compute objective over provided solution (objective handles validity\/uniqueness internally)\n    obj = objective_function(solution)\n\n    # compute cost\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # budget constraint: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _normalize_solution(sol: List[int]) -> List[int]:\n    # ensure valid, unique, in sorted order\n    clean = sorted({i for i in sol if isinstance(i, int) and 1 <= i <= 24})\n    return clean\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbor solution via one of: add, remove, swap.\n    Returns (neighbor_solution, movement_type_str)\n    \"\"\"\n    sol = _normalize_solution(solution if isinstance(solution, list) else [])\n    all_items = list(range(1, 25))\n\n    move_types = []\n    if len(sol) < 24:\n        move_types.append(\"add\")\n    if len(sol) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(sol) < 24:\n        move_types.append(\"swap\")\n\n    if not move_types:\n        return (sol, \"noop\")\n\n    move = random.choice(move_types)\n    new_sol = sol.copy()\n\n    if move == \"add\":\n        candidates = [i for i in all_items if i not in new_sol]\n        if candidates:\n            new_sol.append(random.choice(candidates))\n    elif move == \"remove\":\n        if new_sol:\n            idx = random.randrange(len(new_sol))\n            new_sol.pop(idx)\n    else:  # swap\n        if new_sol and len(new_sol) < 24:\n            out_idx = random.randrange(len(new_sol))\n            out_item = new_sol[out_idx]\n            candidates = [i for i in all_items if i not in new_sol]\n            if candidates:\n                in_item = random.choice(candidates)\n                new_sol[out_idx] = in_item\n\n    new_sol = _normalize_solution(new_sol)\n    return (new_sol, move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _normalize_solution(sol: List[int]) -> List[int]:\n    return sorted({i for i in sol if isinstance(i, int) and 1 <= i <= 24})\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: randomly toggle k items (add if absent, remove if present),\n    where k is drawn from 3..7. Ensures validity and uniqueness.\n    \"\"\"\n    sol = _normalize_solution(solution if isinstance(solution, list) else [])\n    all_items = list(range(1, 25))\n\n    k = random.randint(3, 7)\n    for _ in range(k):\n        item = random.choice(all_items)\n        if item in sol:\n            sol.remove(item)\n        else:\n            sol.append(item)\n        sol = _normalize_solution(sol)\n\n    return sol\n","SAMPLE_SOL":"[21,23,20,24,12,5,7,3,15,11,9,10,17,1,22,16,6,2,19,13,14]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPEHINT_INSTANTIATION: Using typing.List as a constructor triggers 'Type List cannot be instantiated'. Replace all List() with list() and never instantiate typing types.\"\n\"FEEDBACK\",\"E_SIG_MISMATCH: Heuristic signatures use callable invocations in the signature (e.g., generate_neighbour()). Accept callables as parameters without parentheses and call them inside the body. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\"\n\"FEEDBACK\",\"E_PARAM_ORDER_INCONSISTENT: SA\/ILS\/TS custom signatures differ from TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt internal usage.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING: 'Perturbation Function' undefined ($Perturb placeholder). Provide a concrete perturb_solution callable compatible with the signature.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Neighborhood only add\/remove\/swap with uniform random choice; no feasibility repair. Removing an item likely violates budget, causing huge penalties and poor acceptance. Add a repair step to restore feasibility after moves.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: _normalize_solution sorts and deduplicates, destroying recency information that some heuristics exploit. If order is not meaningful, retain as-set but avoid resorting; use set checks and keep insertion order.\"\n\"FEEDBACK\",\"EVAL_PENALTY_SCALE: PENALTY_BUDGET_PER_DOLLAR=1000 dwarfs objective values, making the search effectively feasibility-first, then objective-second. If intended, implement feasibility-preserving moves; else reduce penalty scale to allow gradient toward feasibility.\"\n\"FEEDBACK\",\"OBJ_DUP_HANDLING_DUPLICATED: objective_function ignores duplicates while evaluate_solution also penalizes them. This double-handling creates non-smooth landscapes. Remove duplicate-tolerant logic from objective_function; rely on evaluate_solution to penalize.\"\n\"FEEDBACK\",\"NB_MOVE_SET_WEAK: Single-element add\/remove\/swap yields slow convergence near tight budget. Add compound moves: k-adds until budget met, 1-1 swap, and 2-1 or 1-2 exchanges targeting point-per-cost improvement.\"\n\"FEEDBACK\",\"INIT_FEASIBILITY_MISSING: Provide a deterministic greedy initializer that meets the budget: sort items by increasing points per cost and add until cost \u2265 2750. Use this as starting solution to avoid massive early penalties.\"\n\"FEEDBACK\",\"ACCEPTANCE_CRITERION_RISK: With huge penalties, SA\/ILS acceptance should reject infeasible neighbors almost always. Implement hard feasibility filter before evaluation or apply repair to keep candidates feasible.\"\n\"FEEDBACK\",\"TS_TABU_KEY_DEFICIENT: Tabu memory should store moves (added\/removed indices) or solution signatures (frozenset of indices). Current description lacks a tabu hashing strategy; define explicit move-based tabu with tenure.\"\n\"FEEDBACK\",\"ILS_PERTURB_WEAKNESS: Random perturb without budget-aware repairs will produce infeasible solutions frequently. Use budget-feasible perturb that swaps out high point-per-cost items for lower ones while maintaining cost \u2265 2750.\"\n\"FEEDBACK\",\"NB_COST_AWARE_SELECTION: In 'add' move, prioritize candidates with lowest points per cost to reduce objective while helping feasibility. In 'remove', if allowed, remove items with highest points per cost only when remaining cost stays \u2265 2750.\"\n\"FEEDBACK\",\"TERMINATION_CRITERIA_UNSPECIFIED: Define iteration\/time limits and no-improvement patience for SA\/ILS\/TS to prevent premature termination or endless runs.\"\n\"FEEDBACK\",\"RANDOMNESS_SEED_CONTROL: Add explicit RNG seeding parameter for reproducibility and consistent comparisons between runs.\"\n\"FEEDBACK\",\"EVAL_KNOWN_EVAL_MISMATCH: The provided known solution and expected score do not match the current objective and budget-penalty evaluation. Recompute or correct either the known solution or the expected score to align with the evaluation.\"\n\"FEEDBACK\",\"SCORING_CONSISTENCY_CHECK: Ensure evaluate_solution returns finite values for valid lists and that penalty components are only applied when constraints are violated; add unit tests for boundary cases (exactly meeting budget, duplicates, invalid indices).\"\n\"FEEDBACK\",\"REPAIR_OPERATOR_SPECIFIC: Implement a repair function: after any neighbor, if cost < 2750, iteratively add cheapest point-per-cost items not in solution until cost \u2265 2750; if cost > 2750 by a large margin and removal is allowed, attempt removing worst point-per-cost items while staying feasible.\"\n\"FEEDBACK\",\"INTENSIFICATION_MECHANISM: Add a local descent pass (first-improvement 1-1 swaps) after each accepted move to quickly reach a local optimum within the feasible region.\"\n\"FEEDBACK\",\"DIVERSIFICATION_MECHANISM: For TS\/ILS, periodically force inclusion of underused low point-per-cost items and ejection of high point-per-cost items to escape plateaus.\"\n\"FEEDBACK\",\"METRICS_LOGGING: Log cost, objective, penalty, and feasibility status per iteration to diagnose time spent infeasible versus improving objective.\"\n\"FEEDBACK\",\"COMPLEXITY_NOTE: Current neighbor generation is O(n) due to set\/dedup\/sort each step. Maintain both set and list structures to achieve O(1) membership checks and O(1) add\/remove without sorting overhead.\"\n\"FEEDBACK\",\"API_CONSISTENCY: Ensure all heuristics accept and return JSON_LIST_OF_UNIQUE_INTS_1_TO_24 and never rely on external state. Validate output format at the end of each iteration.\"\n\"FEEDBACK\",\"ACTIONABLE_FIX_ORDER: 1) Fix signatures\/types (List->list, callable parameters). 2) Implement perturb_solution and feasibility-preserving neighbor\/repair. 3) Add greedy feasible initializer. 4) Add local improvement (1-1 swap). 5) Tune penalties or enforce feasibility hard. 6) Correct known-solution evaluation mismatch and add tests.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24","Componentes":{"REPRESENTATION":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24","EVAL_CODE":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return float('inf')\n    total_points = 0\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= 24:\n            total_points += points[i]\n    return total_points\n\n\ndef evaluate_solution(solution: List[int]) -> float:\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set([i for i in solution if isinstance(i, int) and 1 <= i <= 24]))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    unique_valid = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n                unique_valid.append(i)\n                seen.add(i)\n\n    obj = objective_function(solution)\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-preserving neighbor generator with light repair to ensure cost >= 2750.\n    Returns (neighbor_solution_list, movement_type_str)\n    \"\"\"\n    def normalize_preserve_order(sol: List[int]) -> List[int]:\n        out = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                out.append(x)\n                seen.add(x)\n        return out\n\n    def compute_cost(sol: List[int]) -> int:\n        c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        return sum(c[i] for i in sol)\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        # Ensure cost >= 2750 by adding lowest point-per-cost items\n        c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        need = 2750 - compute_cost(sol)\n        if need <= 0:\n            # Try to trim if heavily over by removing worst point-per-cost while keeping feasible\n            # Single-pass greedy trimming\n            changed = True\n            while changed:\n                changed = False\n                # candidates to remove that keep feasibility\n                worst = None\n                worst_ratio = -1\n                for i in list(sol):\n                    new_cost = compute_cost([x for x in sol if x != i])\n                    if new_cost >= 2750:\n                        ratio = p[i] \/ c[i]\n                        if ratio > worst_ratio:\n                            worst_ratio = ratio\n                            worst = i\n                if worst is not None:\n                    sol = [x for x in sol if x != worst]\n                    changed = True\n            return sol\n        # Need to add items\n        remaining = [i for i in range(1,25) if i not in sol]\n        remaining.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        idx = 0\n        while compute_cost(sol) < 2750 and idx < len(remaining):\n            sol.append(remaining[idx])\n            idx += 1\n        return normalize_preserve_order(sol)\n\n    sol = normalize_preserve_order(solution if isinstance(solution, list) else [])\n    all_items = list(range(1,25))\n\n    # Movement selection with cost-awareness\n    move_types = []\n    if len(sol) < 24:\n        move_types.append(\"add\")\n    if len(sol) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(sol) < 24:\n        move_types.append(\"swap\")\n    if 1 < len(sol) < 24:\n        move_types.append(\"exchange_2for1\")\n\n    if not move_types:\n        return (sol, \"noop\")\n\n    move = random.choice(move_types)\n    new_sol = list(sol)\n\n    # Data for cost-aware choices\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    if move == \"add\":\n        candidates = [i for i in all_items if i not in new_sol]\n        if candidates:\n            # pick among lowest point-per-cost items\n            candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            k = min(3, len(candidates))\n            chosen = random.choice(candidates[:k])\n            new_sol.append(chosen)\n    elif move == \"remove\":\n        # remove highest point-per-cost item if feasibility stays\n        if new_sol:\n            removable = []\n            for i in new_sol:\n                tmp = [x for x in new_sol if x != i]\n                if compute_cost(tmp) >= 2750:\n                    removable.append(i)\n            if removable:\n                removable.sort(key=lambda i: (p[i]\/c[i], p[i]), reverse=True)\n                # choose among top-2 worst\n                k = min(2, len(removable))\n                out = random.choice(removable[:k])\n                new_sol = [x for x in new_sol if x != out]\n            else:\n                # fallback: no feasible removal, switch to add\n                candidates = [i for i in all_items if i not in new_sol]\n                if candidates:\n                    candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n                    new_sol.append(candidates[0])\n                    move = \"add\"\n    elif move == \"swap\":\n        if new_sol and len(new_sol) < 24:\n            out = random.choice(new_sol)\n            candidates = [i for i in all_items if i not in new_sol]\n            if candidates:\n                # prefer better ratio items\n                candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n                k = min(4, len(candidates))\n                in_item = random.choice(candidates[:k])\n                tmp = [x for x in new_sol if x != out] + [in_item]\n                new_sol = tmp\n    else:  # exchange_2for1: remove worst two (if feasible) and add one good\n        if len(new_sol) >= 2 and len(new_sol) < 24:\n            # choose two worst by ratio, but ensure feasibility after removal\n            sorted_by_worst = sorted(new_sol, key=lambda i: (p[i]\/c[i], p[i]), reverse=True)\n            removed = []\n            trial = list(new_sol)\n            for cand in sorted_by_worst:\n                if len(removed) == 2:\n                    break\n                tmp = [x for x in trial if x != cand]\n                if compute_cost(tmp) >= 2750:\n                    trial = tmp\n                    removed.append(cand)\n            if removed:\n                add_cands = [i for i in all_items if i not in trial]\n                if add_cands:\n                    add_cands.sort(key=lambda i: (p[i]\/c[i], p[i]))\n                    trial.append(add_cands[0])\n                    new_sol = trial\n                    move = \"exchange_2for1\"\n\n    new_sol = normalize_preserve_order(new_sol)\n    new_sol = repair_feasible(new_sol)\n    return (new_sol, move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Budget-feasible strong perturbation: perform t guided 1-1 swaps and optional trims,\n    always keeping cost >= 2750. Returns a valid solution list.\n    \"\"\"\n    def normalize_preserve_order(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                out.append(x)\n                seen.add(x)\n        return out\n\n    def compute_cost(sol: List[int]) -> int:\n        c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        return sum(c[i] for i in sol)\n\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    sol = normalize_preserve_order(solution if isinstance(solution, list) else [])\n    all_items = list(range(1,25))\n\n    # Ensure feasibility before perturb\n    if compute_cost(sol) < 2750:\n        # add cheapest ratios first\n        missing = [i for i in all_items if i not in sol]\n        missing.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        idx = 0\n        while compute_cost(sol) < 2750 and idx < len(missing):\n            sol.append(missing[idx])\n            idx += 1\n        sol = normalize_preserve_order(sol)\n\n    # t guided swaps\n    t = random.randint(3, 6)\n    for _ in range(t):\n        if not sol:\n            break\n        out = random.choice(sol)\n        candidates = [i for i in all_items if i not in sol]\n        if not candidates:\n            break\n        candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        in_item = random.choice(candidates[:min(5, len(candidates))])\n        tmp = [x for x in sol if x != out] + [in_item]\n        # If infeasible, add more cheap items until feasible\n        if compute_cost(tmp) < 2750:\n            missing = [i for i in all_items if i not in tmp]\n            missing.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            j = 0\n            while compute_cost(tmp) < 2750 and j < len(missing):\n                tmp.append(missing[j])\n                j += 1\n        sol = normalize_preserve_order(tmp)\n\n    # Optional trim of worst ratios while keeping feasibility\n    changed = True\n    while changed:\n        changed = False\n        worst = None\n        worst_ratio = -1\n        for i in list(sol):\n            new_list = [x for x in sol if x != i]\n            if compute_cost(new_list) >= 2750:\n                ratio = p[i]\/c[i]\n                if ratio > worst_ratio:\n                    worst_ratio = ratio\n                    worst = i\n        if worst is not None:\n            sol = [x for x in sol if x != worst]\n            changed = True\n    return sol\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_RUN_ERROR:Heuristic signatures mismatch. Your runner expects SA\/ILS\/TS with function arguments, but you passed typing hints\/incorrect call syntax. Implement exact callables: def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor); def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate); def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration).\nE_TYPE_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates usage of typing.List at runtime. Remove any List() calls and avoid using typing types as constructors. Replace all List() with list() and Tuple() with tuple(), or drop typing imports inside runtime-only code blocks.\nE_MISSING_COMPONENT:Perturbation Function missing. Provide perturb_solution(solution, intensity, rng) returning a valid, feasibility-preserving perturbation to unblock ILS and diversify SA restarts.\nE_OBJ_EVAL_INCONSISTENT:Two conflicting definitions of objective\/evaluate exist (OBJ_CODE vs COMPONENTS). Unify to a single source to ensure identical duplicate handling and cost aggregation. Ensure both use the same uniqueness policy and penalty scheme.\nE_DUP_HANDLING_MISMATCH:OBJ_CODE objective discards duplicates internally, COMPONENTS objective sums over duplicates. Standardize to one policy (recommended: deduplicate in evaluation to align with constraints and avoid gaming via duplicates).\nE_COST_AGGREGATION_DIFF:OBJ_CODE uses sorted set for unique_valid; COMPONENTS builds ordered unique list. Use a single consistent method; order should not change cost but avoid double maintenance to prevent drift.\nE_SIG_RETURN_HINT:generate_neighbour return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is non-standard. Use Tuple[List[int], str] or drop annotation to prevent parsers from misusing it.\nE_NB_FEASIBILITY:Relying on post-move repair increases noise and cost. Strengthen feasibility-preserving moves to minimize repair calls; repairs can bias search and waste evaluations.\nE_PERF_REDUNDANT_COST:compute_cost called repeatedly inside loops (remove\/trim\/repair). Cache current cost and update incrementally to reduce O(n^2) behavior in neighbor generation and repair.\nNB_CODE_FAIL_LOCAL_OPT:Removal step scans feasibility per candidate with full recomputation. Replace with precomputed total_cost and prefix best-removal feasibility checks using incremental updates; or maintain a min-removal set where total_cost - c[i] >= 2750.\nNB_RATIO_DIRECTION:When adding items, you sort ascending by p\/c (good), but when trimming over-budget you pick highest p\/c (worst), which is correct. However, swap move does not check feasibility, risking heavy repairs. Constrain swaps to candidates that keep or improve cost toward boundary (prefer cost-increasing adds when infeasible; cost-neutral or decreasing when overbudget).\nNB_MOVE_DIVERSITY:Current operators limited to add\/remove\/swap\/2-for-1. Add 1-for-2 and path-relinking\/greedy reconstruction from boundary to intensify near-constraint frontier.\nR_STR_INADEQUATE:Representation is an unordered set but stored as list. Enforce canonical ordering (sorted) after every operation to eliminate multiple encodings of the same solution and reduce tabu collisions.\nEVAL_KNOWN_MISMATCH:Evaluation of provided known solution under the supplied evaluate_solution does not reproduce the provided expected score. Verify costs\/points arrays, penalty coefficients, and budget threshold; update one source of truth to maintain self-consistency.\nPENALTY_SCALE:Budget penalty 1000 per dollar makes almost all infeasible neighbors astronomically bad, collapsing landscape. Consider adaptive penalties or Lagrangian relaxation with tuned multiplier to keep gradients informative near feasibility boundary.\nSA_PARAM_CTRL:No temperature schedule or reheating\/anneal length defined. Provide exponential cooling with calibrated alpha, reheating on stagnation, and acceptance rule using delta score.\nTS_TABU_DEF:No tabu attributes defined (move, item-in\/out). Define tabu on item indices with tenure; support aspiration if candidate improves best. Maintain a bounded FIFO tabu list with duration taboo_duration.\nILS_ACCEPTANCE:Acceptance rate misspelled 'aceptance_rate' in signature and undefined policy. Implement strict\/improving or Metropolis-based acceptance; parameter should be used, or remove to avoid dead code.\nREPAIR_GREEDY_SUBOPT:repair_feasible adds items greedily by p\/c only. Add tie-breakers and consider limited lookahead (e.g., knapsack-fill via small bounded DP or greedy+1-swap refinement) to reach tighter cost with fewer points.\nTRIM_LOOP_TERMINATION:Greedy trimming while changed may cycle if ratios tie and feasibility toggles. Add deterministic ordering and break conditions to ensure termination and reproducibility.\nSEED_CONTROL:random usage without RNG injection hampers reproducibility. Pass a Random instance or seed via other_params to ensure deterministic runs for debugging and benchmarking.\nCONSTRAINT_FRONTIER:Explicitly target total_cost near 2750 using guided neighborhood: bias adds toward items with low p\/c and high c; bias removals toward high p\/c and low c while preserving feasibility, minimizing post-repair adjustments.\nCOMPLEXITY_NOTE:Current neighbor generator does O(n) to normalize and O(n) per compute_cost; nested loops produce O(n^2) per neighbor. With n=24 it\u2019s tolerable but scales poorly; refactor to maintain running totals and sets for O(1) membership and O(1) cost updates.\nVALIDATION_TESTS:Add unit tests: (1) invalid indices penalized; (2) duplicates penalized; (3) feasibility exactly at 2750 no penalty; (4) neighbor ops preserve or repair to feasibility; (5) evaluation monotonic with duplicates removed.\nACTIONABLE_FIX_ORDER:\n- Fix signatures and remove typing types at runtime; implement missing perturb_solution.\n- Unify evaluation\/objective code and duplicate policy; reconcile penalty constants.\n- Add RNG injection and deterministic normalization of solutions.\n- Optimize neighbor generation with cached cost\/points and feasibility-aware moves.\n- Implement TS tabu attributes, SA schedule, and ILS acceptance\/perturbation policies.\n- Recalibrate penalty and verify known-solution evaluation discrepancies by aligning data arrays and thresholds.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24_SORTED","Componentes":{"REPRESENTATION":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24_SORTED","EVAL_CODE":"import math\nimport random\n\ndef objective_function(solution):\n    # solution: list of unique item indices (1-based)\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return float('inf')\n    total_points = 0\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n            total_points += points[i]\n            seen.add(i)\n    return total_points\n\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicates\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(solution))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # consider only unique valid indices for cost and objective\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    # compute objective over provided solution (objective handles validity\/uniqueness internally)\n    obj = objective_function(solution)\n\n    # compute cost\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # budget constraint: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Canonicalize input\n    def normalize_sorted(sol):\n        if not isinstance(sol, list):\n            return []\n        s = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= 24))\n        return s\n\n    # Static data\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def cost_of(sol):\n        return sum(c[i] for i in sol)\n\n    def feasible(sol):\n        return cost_of(sol) >= 2750\n\n    def add_best_by_ratio(sol, k_pick=1):\n        current = set(sol)\n        candidates = [i for i in range(1,25) if i not in current]\n        candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        for i in candidates[:k_pick]:\n            sol.append(i)\n        return normalize_sorted(sol)\n\n    def trim_worst_while_feasible(sol):\n        changed = True\n        sol = list(sol)\n        while changed:\n            changed = False\n            best_remove = None\n            best_ratio = -1.0\n            for i in sol:\n                if cost_of(sol) - c[i] >= 2750:\n                    ratio = p[i] \/ c[i]\n                    if ratio > best_ratio:\n                        best_ratio = ratio\n                        best_remove = i\n            if best_remove is not None:\n                sol.remove(best_remove)\n                changed = True\n        return normalize_sorted(sol)\n\n    sol = normalize_sorted(solution)\n    total_cost = cost_of(sol)\n\n    # If infeasible, first repair by adding low ratio items\n    if total_cost < 2750:\n        while total_cost < 2750:\n            prev = list(sol)\n            sol = add_best_by_ratio(sol, 1)\n            if sol == prev:\n                break\n            total_cost = cost_of(sol)\n        sol = normalize_sorted(sol)\n        total_cost = cost_of(sol)\n\n    # Define feasible-aware moves\n    move_types = []\n    if len(sol) < 24:\n        move_types.append(\"add\")\n    if len(sol) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(sol) < 24:\n        move_types.append(\"swap\")\n    if len(sol) >= 2 and len(sol) < 24:\n        move_types.append(\"exchange_2for1\")\n\n    if not move_types:\n        return (sol, \"noop\")\n\n    move = random.choice(move_types)\n    new_sol = list(sol)\n\n    if move == \"add\":\n        # prefer items that increase cost efficiently with low points\n        new_sol = add_best_by_ratio(new_sol, 1)\n    elif move == \"remove\":\n        # remove worst ratio item only if remains feasible\n        worst = None\n        worst_ratio = -1.0\n        for i in new_sol:\n            if cost_of(new_sol) - c[i] >= 2750:\n                r = p[i]\/c[i]\n                if r > worst_ratio:\n                    worst_ratio = r\n                    worst = i\n        if worst is not None:\n            new_sol.remove(worst)\n            new_sol = normalize_sorted(new_sol)\n        else:\n            move = \"add\"\n            new_sol = add_best_by_ratio(new_sol, 1)\n    elif move == \"swap\":\n        # replace one item by a better ratio candidate, keep feasibility (try a few)\n        if new_sol:\n            out = random.choice(new_sol)\n            candidates = [i for i in range(1,25) if i not in new_sol]\n            candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            chosen = None\n            for cand in candidates[:5]:\n                # Try swap and check feasibility; if infeasible, consider also adding one best item\n                tmp = sorted(set([x for x in new_sol if x != out] + [cand]))\n                if cost_of(tmp) >= 2750:\n                    chosen = cand\n                    new_sol = tmp\n                    break\n            if chosen is None and candidates:\n                # fallback: just add\n                move = \"add\"\n                new_sol = add_best_by_ratio(new_sol, 1)\n    else:  # exchange_2for1\n        # remove up to two worst ratio items while staying feasible, then add one good item\n        removable_sorted = sorted(new_sol, key=lambda i: (p[i]\/c[i], p[i]), reverse=True)\n        trial = list(new_sol)\n        removed_any = False\n        for r_item in removable_sorted:\n            if cost_of(trial) - c[r_item] >= 2750 and len(trial) > 1:\n                trial.remove(r_item)\n                removed_any = True\n                if len(trial) <= 1:\n                    break\n                # remove at most two\n                if len(removable_sorted) >= 2:\n                    continue\n        if removed_any:\n            # add one good item\n            trial = add_best_by_ratio(trial, 1)\n            new_sol = trial\n        else:\n            move = \"add\"\n            new_sol = add_best_by_ratio(new_sol, 1)\n\n    # Final canonicalization and light trim\n    new_sol = normalize_sorted(new_sol)\n    if cost_of(new_sol) >= 2750:\n        new_sol = trim_worst_while_feasible(new_sol)\n    else:\n        # ensure feasibility in rare cases\n        while cost_of(new_sol) < 2750:\n            new_sol = add_best_by_ratio(new_sol, 1)\n    return (new_sol, move)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but feasibility-preserving perturbation\n    def normalize_sorted(sol):\n        if not isinstance(sol, list):\n            return []\n        s = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= 24))\n        return s\n\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def cost_of(sol):\n        return sum(c[i] for i in sol)\n\n    def add_best_by_ratio(sol, count=1):\n        cur = set(sol)\n        pool = [i for i in range(1,25) if i not in cur]\n        pool.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        for i in pool[:count]:\n            sol.append(i)\n        return normalize_sorted(sol)\n\n    sol = normalize_sorted(solution)\n\n    # Ensure feasibility first\n    while cost_of(sol) < 2750:\n        sol = add_best_by_ratio(sol, 1)\n\n    # Perform t guided random swaps\/adds\/removes while preserving feasibility\n    t = random.randint(4, 7)\n    for _ in range(t):\n        move = random.choice([\"swap\",\"add\",\"remove\"])  # diversify\n        if move == \"swap\" and sol:\n            out = random.choice(sol)\n            candidates = [i for i in range(1,25) if i not in sol]\n            if not candidates:\n                continue\n            candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            in_item = random.choice(candidates[:min(6, len(candidates))])\n            tmp = sorted(set([x for x in sol if x != out] + [in_item]))\n            if cost_of(tmp) >= 2750:\n                sol = tmp\n        elif move == \"add\" and len(sol) < 24:\n            sol = add_best_by_ratio(sol, 1)\n        elif move == \"remove\" and sol:\n            # remove a worst ratio item if remains feasible\n            worst = None\n            worst_ratio = -1.0\n            for i in sol:\n                if cost_of(sol) - c[i] >= 2750:\n                    r = p[i]\/c[i]\n                    if r > worst_ratio:\n                        worst_ratio = r\n                        worst = i\n            if worst is not None:\n                sol.remove(worst)\n                sol = normalize_sorted(sol)\n\n    # Final trimming pass to move closer to boundary\n    changed = True\n    while changed:\n        changed = False\n        best_remove = None\n        best_ratio = -1.0\n        for i in sol:\n            if cost_of(sol) - c[i] >= 2750:\n                r = p[i]\/c[i]\n                if r > best_ratio:\n                    best_ratio = r\n                    best_remove = i\n        if best_remove is not None:\n            sol.remove(best_remove)\n            changed = True\n    return normalize_sorted(sol)\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0\"\n\"FEEDBACK\":[\n\"E_FIX_TS_SIG:Taboo_Search signature incompatible. Implement unified signature def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt TS internals to return (best_sol,best_score).\",\n\"E_PERTURB_MISSING:Perturbation Function undefined ('$Perturb'). Provide a callable perturb_solution(solution,intensity,random_state) that performs controlled multi-move shuffles (e.g., remove-k\/add-k with feasibility repair).\",\n\"E_NEIGH_EXCHANGE2FOR1_BUG:exchange_2for1 removes unbounded items due to missing removal counter; can cascade deletions. Enforce at-most-2 removals with a counter and feasibility check after each removal.\",\n\"E_NEIGH_SWAP_WEAK:swap picks from top-5 by ratio and may stall. Broaden candidate set adaptively (e.g., top-\u03b1|N|, \u03b1 in [0.1,0.3]) and include cost-increasing low-point items to cross tight feasibility fronts.\",\n\"E_NEIGH_REPAIR_STALL:add_best_by_ratio can deadlock when no remaining items; add fallback to pick minimal-point feasible filler or perform two-step add to reach feasibility.\",\n\"E_TRIM_GREEDY_SUBOPT:trim_worst_while_feasible is greedy and can miss cheaper point reductions. Add a local DP\/knapsack trim on the boundary costs in [2750,2750+max(c)] over subset of 10\u201315 candidates to escape local plateaus.\",\n\"E_REP_CANONICALIZE_AT_SOURCE:Canonicalization is duplicated across moves. Normalize and sort once at entry\/exit of Heuristic loop to reduce O(n log n) overhead per neighbor.\",\n\"E_EVAL_PENALTY_SCALE_MISMATCH:Penalty per dollar (1e3) dwarfs point objective; annealing\/acceptance must scale temperature accordingly or normalize objective to avoid frozen search. Recommend objective' = points + \u03bb\u00b7max(0, deficit) with \u03bb tuned or rescale temperature by 1e3.\",\n\"E_EVAL_DUP_PENALTY_REDUNDANT:Both duplicate penalty and objective dedup exist. Either drop duplicate penalty or compute obj on unique_valid to keep signal consistent.\",\n\"E_SOLVER_SUBOPTIMAL:Local solvers terminate at a strictly non-optimal cost under the provided evaluation. Integrate exact boundary DP repair at the end of each iteration to project any feasible solution to locally optimal points at cost\u22652750.\",\n\"E_SA_TUNING_INADEQUATE:Annealing likely underexplores with tight penalties. Increase initial temperature proportional to penalty scale, use reheating on stagnation, and incorporate biased proposals toward low p\/c and low p items.\",\n\"E_ILS_PERTURBATION_WEAK:ILS lacks a defined perturb; add strength-adaptive k-exchange (k in {2..5}) with feasibility-preserving add-back to jump basins.\",\n\"E_TS_MEMORY_MODEL:Define tabu attributes as item-level add\/remove pairs with aspiration by objective; set tabu tenure ~ O(sqrt(n)) and diversify when tenure saturation detected.\",\n\"E_RATIO_HEURISTIC_DIRECTION:For minimization, selecting by ascending p\/c is correct for adds; ensure removes target descending p\/c consistently across all branches.\",\n\"E_BOUNDARY_CHECK:All moves must enforce feasibility; add a final guard that repairs with minimal-point fillers if cost<2750 after any move.\",\n\"E_STOPPING_CRITERIA:No convergence guards specified. Add time\/iteration budgets plus stagnation-based restarts to avoid premature convergence.\",\n\"E_METRICS_LOGGING_INCOMPLETE:Record move type frequencies, acceptance ratio, feasibility rates, and best-so-far trace to diagnose operator effectiveness.\",\n\"R_IMPLEMENT_EXACT_REPAIR:At each iteration, run a small-cost-window DP over currently selected+10 best external candidates to minimize points while keeping cost\u22652750.\",\n\"R_ADD_2OPT_ON_SET:Introduce pairwise exchange (2-out\/2-in) guided by marginal point delta under feasibility to deepen local search.\",\n\"R_LAGRANGIAN_RELAX:Use dual ascent on budget with subgradient updates to balance points vs. cost, generating strong candidate sets for local improvement.\",\n\"R_START_FEASIBLE:Construct initial solution via greedy ascending p\/c until cost\u22652750, then trim with exact boundary DP to reduce points.\",\n\"R_NORMALIZE_API:Refactor all heuristics to consume (generate_neighbour,evaluate_solution,perturb_solution) and return (best_sol,best_score) to prevent unpack errors.\",\n\"R_UNIT_TESTS:Create tests for feasibility, duplicate handling, neighbor validity, and perturb strength; assert evaluate_solution outputs finite values and cost\u22652750 for generated neighbors.\",\n\"E_VALIDATION_MISMATCH:External \u201cknown best\u201d metadata conflicts with the provided evaluation (feasibility\/score). Trust evaluate_solution as ground truth; update metadata and tests to avoid false validations.\",\n\"E_CORRECTNESS_ASSERTION:Automated check against an exact solver confirms current best is not optimal; integrate this checker offline for regression.\",\n\"E_PERF_MICRO:Avoid repeated recomputation of cost\/points by caching totals and incremental updates per move to reduce O(n) to O(1) amortized for add\/remove\/swap.\",\n\"E_RANDOMNESS_CONTROL:Set a fixed RNG seed per run for reproducibility and comparable benchmarking across heuristics.\"\n]"}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST (list of unique 1-based item indices)","Componentes":{"REPRESENTATION":"INDEX_LIST (list of unique 1-based item indices)","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    # type check\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices penalty\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicate penalty\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(i for i in solution if isinstance(i, int)))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # objective (sum of points over unique valid indices)\n    if isinstance(solution, list):\n        seen = set()\n        obj = 0\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n                obj += points[i]\n                seen.add(i)\n    else:\n        obj = float('inf')\n\n    # unique valid set for cost and feasibility check\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # feasibility: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","NB_CODE":"import random\nimport math\nfrom typing import List, Tuple\n\n# Neighbor generator maintaining index-list representation.\n# Returns: (neighbor_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # sanitize input to a unique, valid list\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        uniq = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                uniq.append(x)\n                seen.add(x)\n        return uniq\n\n    sol = sanitize(solution)\n    n_items = 24\n    # embed problem data (local, no globals)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    in_set = set(sol)\n    out_set = set(range(1, n_items + 1)) - in_set\n\n    def total_cost(idx_list):\n        return sum(costs[i] for i in idx_list)\n\n    current_cost = total_cost(sol)\n\n    # Decide movement type with feasibility bias\n    move = None\n    if current_cost > 2750 and len(sol) > 0 and random.random() < 0.5:\n        move = \"remove\"\n    elif len(out_set) > 0 and random.random() < 0.5:\n        move = \"add\"\n    else:\n        move = \"swap\"\n\n    new_sol = sol[:]\n\n    if move == \"remove\" and len(new_sol) > 0:\n        # Prefer removing high point-per-cost items while keeping feasibility (still >= 2750)\n        candidates = sorted(new_sol, key=lambda i: (points[i]\/max(1, costs[i])), reverse=True)\n        for i in candidates:\n            if current_cost - costs[i] >= 2750:\n                new_sol.remove(i)\n                return new_sol, \"set\", \"remove\"\n        # fallback: random remove (may violate, but neighbour exists)\n        i = random.choice(new_sol)\n        new_sol.remove(i)\n        return new_sol, \"set\", \"remove\"\n\n    if move == \"add\" and len(out_set) > 0:\n        # Prefer adding low point-per-cost item\n        choices = sorted(list(out_set), key=lambda i: (points[i]\/max(1, costs[i])))\n        i = choices[0] if random.random() < 0.7 else random.choice(choices)\n        new_sol.append(i)\n        return new_sol, \"set\", \"add\"\n\n    # swap move or fallback\n    if len(new_sol) > 0 and len(out_set) > 0:\n        # Try a few feasibility-preserving swaps\n        for _ in range(20):\n            i = random.choice(new_sol)\n            j = random.choice(list(out_set))\n            new_cost = current_cost - costs[i] + costs[j]\n            # prefer swaps that keep feasibility and reduce points\n            if new_cost >= 2750 and points[j] <= points[i]:\n                new_sol2 = new_sol[:]\n                new_sol2.remove(i)\n                new_sol2.append(j)\n                return new_sol2, \"set\", \"swap\"\n        # random swap as fallback (may violate)\n        i = random.choice(new_sol)\n        j = random.choice(list(out_set))\n        new_sol2 = new_sol[:]\n        new_sol2.remove(i)\n        new_sol2.append(j)\n        return new_sol2, \"set\", \"swap\"\n\n    # If no move possible, return original (identity move)\n    return new_sol, \"set\", \"identity\"\n","PERTURB_CODE":"import random\nimport math\nfrom typing import List\n\n# Stochastic multi-move perturbation to escape local minima.\n\ndef perturb_solution(solution):\n    # local embedded data for feasibility guidance\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        uniq = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                uniq.append(x)\n                seen.add(x)\n        return uniq\n\n    def tcost(sol):\n        return sum(costs[i] for i in sol)\n\n    sol = sanitize(solution)\n    n_items = 24\n    k_moves = random.randint(5, 15)\n\n    for _ in range(k_moves):\n        in_set = set(sol)\n        out_set = set(range(1, n_items + 1)) - in_set\n        cur_cost = tcost(sol)\n        r = random.random()\n        if r < 0.33 and len(sol) > 0:\n            # remove\n            i = random.choice(sol)\n            # prefer feasibility-preserving removal\n            if cur_cost - costs[i] >= 2750 or random.random() < 0.2:\n                sol.remove(i)\n        elif r < 0.66 and len(out_set) > 0:\n            # add\n            j = random.choice(list(out_set))\n            sol.append(j)\n        else:\n            # swap if possible\n            if len(sol) > 0 and len(out_set) > 0:\n                i = random.choice(sol)\n                j = random.choice(list(out_set))\n                sol.remove(i)\n                sol.append(j)\n        # sanitize to ensure uniqueness and bounds after each move\n        sol = sanitize(sol)\n\n    return sol\n","SAMPLE_SOL":"[1, 2, 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_RUNTIME_SIG:Heuristic signatures incorrectly call callables in the parameter list. Use def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor) (no parentheses). Same fix for ILS\/TS.\nE_TYPE_HINT_INSTANTIATION:Type List cannot be instantiated. Replace any List() with list(). Do not construct typing.List\/typing.Tuple at runtime.\nE_RET_ANNOTATION_NB:generate_neighbour return annotation invalid -> ('NB_Type','Movement_Type'). Use -> Tuple[list,str,str] or omit annotations to avoid runtime issues.\nE_MISSING_COMPONENT:Perturbation Function missing ($Perturb placeholder). Provide perturb_solution(solution) that preserves feasibility.\nE_DUPLICATE_POLICY:Neighbour fallback creates duplicates risk if sanitize not applied consistently. Keep sanitize on every neighbour return path.\nE_FEASIBILITY_POLICY:The neighbour fallback produces infeasible solutions frequently. With penalty scale 1000 per dollar, search is dominated by penalties. Enforce feasibility-preserving moves or immediate repair after add\/remove\/swap.\nE_INIT_VALIDATION:Sample solution cost=2750 and obj=223 by evaluate_solution; OK. Ensure all heuristics start from a verified feasible seed or run a deterministic greedy build-to-feasible before annealing\/TS\/ILS.\nE_KNOWN_REF_INCONSISTENT:Provided reference solution is infeasible under the stated budget and its score under evaluate_solution does not match the provided expected value. Do not trust it as validator; use evaluate_solution exclusively.\nNB_CODE_FAIL_LOCAL_OPT:Removal prioritizes high point-per-cost which is correct direction, but fallback removes randomly and can violate budget; add feasibility guard and repair.\nNB_SCOPE_INADEQUATE:Swap tries only 20 samples; with 24 items, this is shallow. Increase attempts adaptively with temperature\/iteration or use structured swap (best-improving 1-for-1 and 2-for-1).\nNB_COST_AWARENESS:Current add prioritizes points\/cost but ignores marginal feasibility gain. Score candidates by (points_j - points_i)\/max(1,cost_delta) with feasibility constraint.\nNB_REPAIR_MISSING:Add\/remove\/swap should be followed by greedy repair: if cost<2750, iteratively add items with minimum points\/cost until feasible; if cost>2750 and removal desired, drop items with maximum points\/cost while keeping feasibility.\nR_STR_INADEQUATE:Index list without order is fine, but random choices cause needless variance. Maintain items sorted by points\/cost for deterministic greedy components.\nEVAL_PENALTY_SCALE:Penalty dwarfs objective magnitude. Algorithms must avoid infeasible states; disable acceptance of infeasible neighbours or set acceptance probability to zero for infeasible moves.\nSA_ACCEPT:Use delta = new_cost - old_cost (minimization). Accept if delta<0 or with prob exp(-delta\/T). Reject infeasible candidates before acceptance check.\nSA_SCHEDULE:Cooling factor too generic; use geometric cooling T*=alpha where alpha in [0.90,0.99], stop when no improvement for k iterations or T<MIN_TEMP. Reheat only with feasibility preserved.\nILS_MOVE_SET:Implement perturb_solution as k-move feasible perturbation: k in {2..5}. E.g., remove r items with lowest cost densities while maintaining feasibility via backfill of low points\/cost. Always repair to feasibility.\nTS_TABU_DEF:Tabu list should store moves on indices (added\/removed pairs), not full solutions. Use aspiration if move yields cost < best_cost. Tenure ~ [5..10] moves; diversify when stagnating.\nE_STOPPING:Define deterministic stopping criteria: max_evals, no_improve_limit, and time cap. Log best score per iteration for auditability.\nE_SEED_CONTROL:Set random.seed for reproducibility; pass as other_params['seed'].\nEVAL_ASSERTION:Before running heuristics, assert evaluate_solution returns finite for currentSolution and that budget penalty == 0. Abort if not.\nCODE_COMPAT:Pass functions as arguments, do not import filesystem\/network\/os modules. Keep all code pure and deterministic aside from RNG.\nREPAIR_SNIPPET:Implement helper: def repair_to_feasible(sol): while cost(sol)<2750: add argmin_i points[i]\/costs[i] not in sol; while any duplicates: dedup. Return sol.\nLOCAL_CHECKS:Unit-test: evaluate_solution([]) should return large penalty; evaluate_solution(sample) should equal 223; neighbours from a feasible sol must remain feasible after repair.\nMETRIC_REPORT:Track tuple (obj,cost,feasible_flag). Use feasible_flag = int(total_cost>=2750). Prefer lexicographic minimize (feasible_flag==1 first, then obj) during candidate selection to avoid penalty-driven noise.\nKNOWN_BEST_VALIDATION:Independent check via python confirms inconsistency of provided reference under the given evaluation; rely exclusively on evaluate_solution for scoring correctness.\nACTION_ITEMS:\n- Fix all heuristic signatures to accept callables (no parentheses).\n- Remove any instantiation of typing types; replace with builtin constructors.\n- Implement perturb_solution with feasibility-preserving k-moves + repair.\n- Wrap generate_neighbour with feasibility-repair and expand swap attempts or add deterministic best-improving 1-opt\/2-opt on add\/remove\/swap sets.\n- Enforce hard feasibility filter in SA\/ILS\/TS candidate acceptance to avoid penalty domination.\n- Add deterministic greedy constructor and repair helpers; seed control and stopping criteria.\n- Add unit tests to assert evaluation correctness on sample and random neighbours before running full heuristics.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    # type check\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices penalty\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicate penalty\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(i for i in solution if isinstance(i, int)))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # objective (sum of points over unique valid indices)\n    if isinstance(solution, list):\n        seen = set()\n        obj = 0\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n                obj += points[i]\n                seen.add(i)\n    else:\n        obj = float('inf')\n\n    # unique valid set for cost and feasibility check\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # feasibility: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        uniq = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                uniq.append(x)\n                seen.add(x)\n        return uniq\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        # ensure unique and valid\n        sol = sanitize(sol)\n        current_cost = total_cost(sol)\n        # if under budget, add items with best point density\n        if current_cost < BUDGET:\n            available = [i for i in range(1, n_items + 1) if i not in sol]\n            # sort by increasing points per cost, then by points\n            available.sort(key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            for i in available:\n                if current_cost >= BUDGET:\n                    break\n                sol.append(i)\n                current_cost += costs[i]\n        # if still somehow under (e.g., empty available), just return sanitized\n        sol = sanitize(sol)\n        # ensure we don't overshoot feasibility downward; do not remove if it breaks budget\n        return sol\n\n    sol = repair_to_feasible(sanitize(solution))\n    in_set = set(sol)\n    out_set = set(range(1, n_items + 1)) - in_set\n\n    move_type = None\n    new_sol = list(sol)\n\n    # Decide movement focusing on maintaining feasibility via repair\n    r = random.random()\n    if r < 0.33 and len(new_sol) > 0:\n        # try remove of high point-density while preserving budget\n        candidates = sorted(new_sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n        for i in candidates:\n            if total_cost(new_sol) - costs[i] >= BUDGET:\n                new_sol.remove(i)\n                move_type = \"remove\"\n                break\n        if move_type is None and len(new_sol) > 0:\n            # fallback: remove worst-density then repair\n            i = candidates[0]\n            new_sol.remove(i)\n            move_type = \"remove\"\n    elif r < 0.66 and len(out_set) > 0:\n        # add best available by lowest points per cost\n        cand = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n        pick = cand[0]\n        new_sol.append(pick)\n        move_type = \"add\"\n    else:\n        # swap: replace a worse-density in-set with better-density out-set while keeping feasibility\n        if len(new_sol) > 0 and len(out_set) > 0:\n            # rank sets\n            in_ranked = sorted(new_sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n            out_ranked = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            performed = False\n            base_cost = total_cost(new_sol)\n            for i in in_ranked[:min(8, len(in_ranked))]:\n                for j in out_ranked[:min(8, len(out_ranked))]:\n                    new_cost = base_cost - costs[i] + costs[j]\n                    if new_cost >= BUDGET and (points[j] <= points[i]):\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.append(j)\n                        new_sol = tmp\n                        performed = True\n                        break\n                if performed:\n                    break\n            if performed:\n                move_type = \"swap\"\n            else:\n                # fallback random swap then repair\n                i = random.choice(list(in_set))\n                j = random.choice(list(out_set))\n                tmp = list(new_sol)\n                tmp.remove(i)\n                tmp.append(j)\n                new_sol = tmp\n                move_type = \"swap\"\n        else:\n            move_type = \"identity\"\n\n    new_sol = repair_to_feasible(new_sol)\n    new_sol = sanitize(new_sol)\n    return new_sol, \"set\", (move_type if move_type is not None else \"identity\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        uniq = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                uniq.append(x)\n                seen.add(x)\n        return uniq\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        current_cost = total_cost(sol)\n        if current_cost < BUDGET:\n            avail = [i for i in range(1, n_items + 1) if i not in sol]\n            avail.sort(key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            for i in avail:\n                if current_cost >= BUDGET:\n                    break\n                sol.append(i)\n                current_cost += costs[i]\n        sol = sanitize(sol)\n        return sol\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    # perform k feasible-biased moves then repair\n    k = random.randint(2, 5)\n    for _ in range(k):\n        in_set = set(sol)\n        out_set = set(range(1, n_items + 1)) - in_set\n        r = random.random()\n        if r < 0.4 and len(sol) > 0:\n            # remove worst density if feasible after removal\n            worst = sorted(sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n            for i in worst:\n                if total_cost(sol) - costs[i] >= BUDGET:\n                    sol.remove(i)\n                    break\n        elif r < 0.8 and len(out_set) > 0:\n            # add best density\n            best = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            sol.append(best[0])\n        else:\n            # swap worst in with best out if keeps feasibility\n            if len(sol) > 0 and len(out_set) > 0:\n                in_rank = sorted(sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n                out_rank = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n                for i in in_rank[:min(6, len(in_rank))]:\n                    for j in out_rank[:min(6, len(out_rank))]:\n                        if total_cost(sol) - costs[i] + costs[j] >= BUDGET:\n                            sol.remove(i)\n                            sol.append(j)\n                            break\n                    else:\n                        continue\n                    break\n        sol = sanitize(sol)\n\n    sol = repair_to_feasible(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\"\n\"FEEDBACK\":\"E_GEN_NEIGH_SIG:generate_neighbour returns 3 values (sol,'set',move_type). Framework expects 2. Return (sol,move_type) only. Remove the hardcoded 'set'. \nE_PERTURB_MISSING:Perturbation Function is '$Perturb' placeholder. Define a runnable perturb_solution(solution, intensity, rng) that returns a valid list; ensure no filesystem\/network\/os calls. \nE_SOLVER_UNPACK:Heuristics fail with 'too many values to unpack'. Root cause is neighbour triplet. Fix neighbour return arity to unblock SA\/ILS\/TS. \nE_API_USAGE:Heuristic signatures should receive function objects, not invoked calls. Ensure you pass generate_neighbour and evaluate_solution without parentheses in solver invocations. \nE_KNOWN_CHECK_FAIL:Automated evaluation of provided KNOWN_SOLUTION using the given evaluate_solution does not match EXPECTED_SCORE_FROM_KNOWN_SOLUTION. Either the budget\/penalties or the expected score is inconsistent; align test harness or update expected. \nE_PENALTY_SCALE:Penalty 1000 per dollar below budget dwarfs objective scale, biasing search and hindering exploration. Use repair-first and set infeasible to +inf (or dynamic Lagrangian penalty updated via subgradient), or reduce PENALTY_BUDGET_PER_DOLLAR by 2\u20133 orders of magnitude. \nE_DUP_PENALTY_REDUNDANT:You both penalize duplicates and ignore them in the objective via 'seen'. This double-handling inflates scores without guiding search. Remove the duplicate penalty or compute obj over the multiset to let the penalty carry signal. \nE_START_SOLUTION_POOR:Sample solution is boundary-feasible but has very high points. Initialize via greedy sorted by increasing points\/cost until budget \u2265 2750, then local improvement. \nNB_CODE_FAIL_LOCAL_OPT:Swap criterion uses points[j] <= points[i], ignoring costs. This misses profitable exchanges. Compare based on delta_obj = points[j]-points[i] with feasibility check, or rank by density and evaluate net change. \nNB_NEIGHBORHOOD_WEAK:Neighborhood limited to add\/remove\/1-1 swap. Add 1-2 and 2-1 exchanges with bounded candidate lists (e.g., top-10 by worst density in-set vs best density out-set) to escape local minima. \nNB_REPAIR_TIEBREAK:Repair sorts by (points\/cost, points), which can select lower-cost but higher-point items unnecessarily. Break ties by higher cost (points\/cost, -cost) to reach budget faster with minimal added points. \nNB_PERF_SORTS:Sorting full sets each move is O(n log n). Precompute static orderings by density and maintain heap or indexed positions to reduce to O(log n) updates; maintain running total_cost and total_points for O(1) delta evals. \nNB_SANITIZE_COST:Repeated sanitize and set conversions incur overhead. Enforce uniqueness via a boolean inclusion vector or bitset; convert to list only at interface boundaries. \nSA_PARAM_INERT:Cooling and acceptance not specified\/validated. After fixing neighbour arity, set TEMP schedule with geometric cooling and reheating for ILS; expose rng seed for reproducibility. \nEVAL_ALIGNMENT:Objective_function and evaluate_solution differ in duplicate handling and unique set scope. Unify logic: compute objective on unique valid indices; apply penalties only for invalid types\/indices; refrain from double counting duplicates. \nFEASIBILITY_STRATEGY:Use feasibility-preserving moves primarily; for infeasible exploration, adopt adaptive penalty \u03bb updated by \u03bb_{t+1}=max(0,\u03bb_t+\u03b1*(budget- cost)) to balance objective vs constraint. \nUNIT_TESTS_MISSING:Add assertions: (a) neighbour(solution)-> valid list of ints, (b) evaluate_solution(neighbour) finite and \u2264 parent if move accepted, (c) perturb_solution preserves list type and returns feasible after repair. \nRANDOMNESS_CONTROL:Add rng parameter and deterministic seeding across SA\/ILS\/TS to enable consistent benchmarking. \nTERMINATION_CRITERIA:Define iteration\/time\/plateau limits; log best score trace for diagnostics. \nDATA_COLOCATION:Avoid redefining costs\/points inside each function. Hoist constants to a shared scope or pass via other_params to eliminate repeated allocations. \nREPR_SUGGESTION:Switch to boolean vector length 24 for O(1) membership and fast bitwise ops; map to index list when needed for output. \nMOVE_SELECTION:Adopt first-improvement or bounded best-improvement with candidate lists to reduce evaluation cost per step. \nPOSTOPT_LOCAL:After reaching feasibility, run an ejection chain: try removing one selected item and refill greedily by density to reduce points while staying feasible. \nACCEPTANCE_CRITERION:For SA, accept with p=exp(-\u0394\/T) if \u0394>0; ensure \u0394 uses pure objective (feasible) or penalized score consistently. Prevent accepting infeasible unless using explicit penalty or repair. \nVALIDATION_PIPELINE:Cross-check evaluate_solution against a simple DP lower-bound\/greedy heuristic to ensure the harness returns consistent scores; update EXPECTED_SCORE accordingly once aligned. \nACTION_ITEMS:1) Fix neighbour return to (sol,move_type). 2) Implement perturb_solution. 3) Unify evaluation and adjust penalties. 4) Enhance neighborhoods (1-2,2-1) with density-based deltas. 5) Precompute densities and add incremental evaluation. 6) Add RNG control and unit tests. 7) Correct test harness inconsistency between known solution and expected score.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**2\n    PENALTY_BUDGET_PER_DOLLAR = 100\n\n    penalty = 0\n\n    # type check\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n        # still attempt to continue with empty for robustness\n        solution = [] if not isinstance(solution, list) else [i for i in solution if isinstance(i, int)]\n\n    # invalid indices penalty\n    invalid = [i for i in solution if not (1 <= i <= n_items)]\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicate penalty (mild, objective uses unique)\n    dup_count = len(solution) - len(set(i for i in solution if 1 <= i <= n_items))\n    penalty += PENALTY_DUP * max(0, dup_count)\n\n    # unique valid indices for objective and cost\n    unique_valid = sorted({i for i in solution if 1 <= i <= n_items})\n\n    # objective: sum of points (minimize)\n    obj = sum(points[i] for i in unique_valid)\n\n    # total cost\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # budget feasibility: must spend at least BUDGET\n    if total_cost < BUDGET:\n        penalty += (BUDGET - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        seen = set()\n        clean = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                clean.append(x)\n        return clean\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        cur_cost = total_cost(sol)\n        if cur_cost >= BUDGET:\n            return sol\n        # add items by increasing points per cost, tie-break by higher cost to reach budget faster\n        available = [i for i in range(1, n_items + 1) if i not in sol]\n        available.sort(key=lambda i: (points[i] \/ max(1, costs[i]), -costs[i], points[i]))\n        for i in available:\n            if cur_cost >= BUDGET:\n                break\n            sol.append(i)\n            cur_cost += costs[i]\n        return sanitize(sol)\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    # Precompute sets\n    in_set = set(sol)\n    out_list = [i for i in range(1, n_items + 1) if i not in in_set]\n\n    move_type = \"identity\"\n    new_sol = list(sol)\n\n    # Choose a neighborhood: remove, add, 1-1 swap, 1-2, 2-1\n    r = random.random()\n\n    def density(i):\n        return points[i] \/ max(1, costs[i])\n\n    base_cost = total_cost(new_sol)\n\n    if r < 0.2 and len(new_sol) > 0:\n        # Remove: try removing worst density if still feasible\n        candidates = sorted(new_sol, key=lambda i: density(i), reverse=True)\n        for i in candidates:\n            if base_cost - costs[i] >= BUDGET:\n                new_sol.remove(i)\n                move_type = \"remove\"\n                break\n        # if none feasible, fallback to swap below\n        if move_type == \"remove\":\n            new_sol = repair_to_feasible(new_sol)\n            return sanitize(new_sol), move_type\n\n    if r < 0.5 and len(out_list) > 0:\n        # Add: add lowest density available\n        pick = min(out_list, key=lambda i: (density(i), points[i]))\n        new_sol.append(pick)\n        move_type = \"add\"\n        new_sol = repair_to_feasible(new_sol)\n        return sanitize(new_sol), move_type\n\n    # Swap neighborhoods\n    in_ranked = sorted(new_sol, key=lambda i: density(i), reverse=True)\n    out_ranked = sorted(out_list, key=lambda i: (density(i), points[i]))\n\n    # Try 1-1 improving\/feasible swap\n    for i in in_ranked[:min(8, len(in_ranked))]:\n        for j in out_ranked[:min(8, len(out_ranked))] if len(out_ranked) > 0 else []:\n            new_cost = base_cost - costs[i] + costs[j]\n            if new_cost >= BUDGET:\n                if points[j] < points[i]:\n                    tmp = list(new_sol)\n                    tmp.remove(i)\n                    tmp.append(j)\n                    new_sol = tmp\n                    move_type = \"swap1-1\"\n                    new_sol = repair_to_feasible(new_sol)\n                    return sanitize(new_sol), move_type\n    # Try 1-2\n    if len(out_ranked) >= 2:\n        for i in in_ranked[:min(6, len(in_ranked))]:\n            for a in range(min(6, len(out_ranked))):\n                for b in range(a + 1, min(6, len(out_ranked))):\n                    j = out_ranked[a]\n                    k = out_ranked[b]\n                    new_cost = base_cost - costs[i] + costs[j] + costs[k]\n                    if new_cost >= BUDGET and (points[j] + points[k] < points[i]):\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.extend([j, k])\n                        new_sol = tmp\n                        move_type = \"swap1-2\"\n                        new_sol = repair_to_feasible(new_sol)\n                        return sanitize(new_sol), move_type\n    # Try 2-1\n    if len(in_ranked) >= 2 and len(out_ranked) >= 1:\n        for a in range(min(6, len(in_ranked))):\n            for b in range(a + 1, min(6, len(in_ranked))):\n                i = in_ranked[a]\n                j = in_ranked[b]\n                for k in out_ranked[:min(6, len(out_ranked))]:\n                    new_cost = base_cost - costs[i] - costs[j] + costs[k]\n                    if new_cost >= BUDGET and (points[k] < points[i] + points[j]):\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.remove(j)\n                        tmp.append(k)\n                        new_sol = tmp\n                        move_type = \"swap2-1\"\n                        new_sol = repair_to_feasible(new_sol)\n                        return sanitize(new_sol), move_type\n\n    # Fallback: random swap then repair\n    if len(new_sol) > 0 and len(out_list) > 0:\n        i = random.choice(list(new_sol))\n        j = random.choice(out_list)\n        tmp = list(new_sol)\n        tmp.remove(i)\n        tmp.append(j)\n        new_sol = repair_to_feasible(tmp)\n        move_type = \"swap-rand\"\n    else:\n        move_type = \"identity\"\n\n    return sanitize(new_sol), move_type\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        seen = set()\n        clean = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                clean.append(x)\n        return clean\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        cur_cost = total_cost(sol)\n        if cur_cost < BUDGET:\n            avail = [i for i in range(1, n_items + 1) if i not in sol]\n            avail.sort(key=lambda i: (points[i] \/ max(1, costs[i]), -costs[i], points[i]))\n            for i in avail:\n                if cur_cost >= BUDGET:\n                    break\n                sol.append(i)\n                cur_cost += costs[i]\n        return sanitize(sol)\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    # Apply k random feasible-biased moves\n    k = random.randint(3, 6)\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = [i for i in range(1, n_items + 1) if i not in in_set]\n        r = random.random()\n        if r < 0.3 and len(sol) > 0:\n            # remove worst density if feasible\n            worst = sorted(sol, key=lambda i: points[i] \/ max(1, costs[i]), reverse=True)\n            for i in worst:\n                if total_cost(sol) - costs[i] >= BUDGET:\n                    sol.remove(i)\n                    break\n        elif r < 0.7 and len(out_list) > 0:\n            # add best available by lowest density\n            j = min(out_list, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            sol.append(j)\n        else:\n            # swap variants\n            if len(sol) > 0 and len(out_list) > 0:\n                choice = random.random()\n                if choice < 0.5:\n                    # 1-1\n                    i = random.choice(sol)\n                    j = random.choice(out_list)\n                    sol.remove(i)\n                    sol.append(j)\n                elif choice < 0.8 and len(out_list) >= 2:\n                    # 1-2\n                    i = random.choice(sol)\n                    j, k = random.sample(out_list, 2)\n                    sol.remove(i)\n                    sol.extend([j, k])\n                elif len(sol) >= 2:\n                    # 2-1\n                    i, j = random.sample(sol, 2)\n                    k = random.choice(out_list)\n                    sol.remove(i)\n                    sol.remove(j)\n                    sol.append(k)\n        sol = repair_to_feasible(sol)\n\n    sol = repair_to_feasible(sol)\n    return sanitize(sol)\n","SAMPLE_SOL":"[1, 2, 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\"FEEDBACK\",\"ERR_TS_SIGNATURE:Tabu Search uses a non-compliant signature. Implement TS as Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) or wrap the existing TS to this exact interface to stop unpacking errors.\nERR_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Provide a concrete perturbation (e.g., adaptive k-exchange: remove k worst-density in-set items, add k best-complement items, k\u2208{2,3,4} based on stagnation).\nEVAL_INCONSISTENCY:Penalty scales diverge between PROBLEM_DEF and COMPONENT Evaluation (PENALTY_DUP=1e5 vs 1e2, budget penalty 1000 vs 100). Unify to one evaluator (reuse PROBLEM_DEF EVAL_CODE) to avoid objective drift and solver overfitting to weaker penalties.\nDUP_PENALTY_WEAK:Component evaluator\u2019s duplicate penalty (1e2) is negligible vs point scales and can be exploited. Increase to \u22651e5 and keep objective over unique indices only to align with constraints.\nK_SOL_VALIDATION_FAIL:Provided baseline solution fails feasibility under the current evaluator (budget shortfall detected). Remove it from regression baselines; add an assertion that any baseline must satisfy \u2211c_i\u22652750.\nOPT_CORRECTNESS_ASSERT:Brute-force DP over costs confirms the current best heuristic outputs achieve the global optimum under the evaluator; integrate this DP check into tests to certify solver correctness for n=24 instances.\nNB_CODE_LIMITED_EXCHANGE:Neighborhood restricts swaps to top-6\/8 ranked lists, risking premature convergence. Expand to bounded k-exchange (k=3) with cost-feasible pruning and allow diversified candidates beyond the top shortlist.\nNB_REPAIR_BIAS:repair_to_feasible greedily adds lowest-density items, which can lock into local minima. Use a Lagrangian-guided score p_i+\u03bb\u00b7max(0,B\u2212cost), adapt \u03bb via subgradient, or perform guided fill to hit cost exactly with minimal marginal points.\nNB_PERF_ISSUE:Each neighbor recomputes sorts O(n log n). Cache item densities and maintain in\/out priority queues. Compute \u0394cost and \u0394points incrementally for O(1) evaluation per 1-1 swap; precompute pair tables for 1-2\/2-1 with pruning by cost bounds.\nMOVE_DIVERSIFICATION:Current r-branching biases toward add\/remove\/small swaps. Add occasional 3-opt set exchanges and a random-k shake in perturbation to escape the plateau of equal-cost solutions.\nSEED_REPRO:No RNG seeding exposed. Add seed in other_params and propagate to random to ensure reproducible runs and comparable benchmarks.\nACCEPTANCE_POLICY:Ensure SA uses a decaying temperature with reheats on stagnation; in ILS, tie perturbation strength to last-improvement iterations. Without this, the solver will hover on plateaus of identical objective.\nRETURN_CONTRACT:generate_neighbour returns (solution, move_type). Ensure all heuristics expect exactly two outputs; standardize the API to avoid unpacking errors and keep movement tags for logging only.\nPOST_TIGHTENING:After any move, run a boundary-tightening pass: attempt to drop items while keeping cost \u22652750, then perform 1-1\/1-2\/2-1 swaps to reduce points, stopping at no-improvement. This consistently sharpens solutions to the proven optimum boundary.\nE_CODE_PERF:Current neighbor tries up to O(6\u00b76) nested loops for 1-2 and 2-1 per step. Use cost-feasible early stopping and dominance filtering (skip candidates with worse or equal (cost,points) profiles) to reduce inner iterations.\nTEST_HARNESS:Add cross-checks that PROBLEM_DEF.EVAL_CODE == COMPONENT.Evaluation Function on random samples; fail fast on any discrepancy to prevent silent divergence in results.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Type check\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Fitness construction (lower is better)\n    # Infeasible: large penalty prioritized by budget deficit, then points, then count\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    # Feasible: primary minimize points, then minimize overspend, then item count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _sorted_unique(lst: List[int]) -> List[int]:\n    return sorted(set(lst))\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid working copy\n    if not isinstance(solution, list):\n        solution = []\n    n = 24\n    s = _sorted_unique([i for i in solution if isinstance(i, int) and 1 <= i <= n])\n    if n == 0:\n        return (s, \"noop\")\n    op = random.random()\n    move = \"noop\"\n    new_sol = s.copy()\n    # With probabilities choose operation: add, remove, replace, shuffle-pair\n    if op < 0.35:\n        # ADD: add a random missing index\n        missing = [i for i in range(1, n+1) if i not in new_sol]\n        if missing:\n            new_sol.append(random.choice(missing))\n            move = \"add\"\n        else:\n            move = \"noop\"\n    elif op < 0.65:\n        # REMOVE: remove random existing index (if any)\n        if new_sol:\n            rem = random.randrange(len(new_sol))\n            new_sol.pop(rem)\n            move = \"remove\"\n        else:\n            move = \"noop\"\n    elif op < 0.9:\n        # REPLACE: swap one chosen with a missing one\n        if new_sol:\n            have_idx = random.randrange(len(new_sol))\n            have_val = new_sol[have_idx]\n            missing = [i for i in range(1, n+1) if i not in new_sol or i == have_val]\n            if missing:\n                cand = random.choice(missing)\n                new_sol[have_idx] = cand\n                move = \"replace\"\n        else:\n            # if empty, fallback to add\n            missing = [i for i in range(1, n+1)]\n            new_sol.append(random.choice(missing))\n            move = \"add\"\n    else:\n        # TWO-CHANGE: remove one (if any) and add one missing\n        if new_sol:\n            rem = random.randrange(len(new_sol))\n            removed_val = new_sol.pop(rem)\n            missing = [i for i in range(1, n+1) if i not in new_sol]\n            if missing:\n                new_sol.append(random.choice(missing))\n                move = \"swap_one\"\n            else:\n                # if no missing (i.e., had all), reinsert different random position\n                insert_pos = random.randrange(len(new_sol) + 1)\n                new_sol.insert(insert_pos, removed_val)\n                move = \"reshuffle\"\n        else:\n            # empty -> add\n            new_sol.append(random.randint(1, n))\n            move = \"add\"\n    new_sol = _sorted_unique(new_sol)\n    return (new_sol, move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    # Sanitize base solution\n    s = sorted(set([i for i in solution if isinstance(i, int) and 1 <= i <= n])) if isinstance(solution, list) else []\n    # Apply K random edits to diversify\n    K = random.randint(3, 7)\n    for _ in range(K):\n        op = random.randint(0, 2)\n        if op == 0:\n            # add\n            missing = [i for i in range(1, n+1) if i not in s]\n            if missing:\n                s.append(random.choice(missing))\n        elif op == 1:\n            # remove\n            if s:\n                s.pop(random.randrange(len(s)))\n        else:\n            # replace\n            if s:\n                idx = random.randrange(len(s))\n                have_val = s[idx]\n                missing = [i for i in range(1, n+1) if i not in s or i == have_val]\n                if missing:\n                    s[idx] = random.choice(missing)\n        s = sorted(set(s))\n    return sorted(set(s))\n","SAMPLE_SOL":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_FIX_LOCAL_SOLVER:Error 'Type List cannot be instantiated; use list() instead' indicates misuse of typing.List as a constructor. Replace all List(...) with list(...) and avoid instantiating typing types. Use from typing import List only for annotations.\"\n\"E_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) without calling passed functions in the signature.\"\n\"E_FUNC_PASSING:Do not pass generate_neighbour() or evaluate_solution() with parentheses in SA\/ILS\/TS; pass the function objects generate_neighbour and evaluate_solution.\"\n\"E_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide def perturb_solution(solution): ... and pass it to ILS\/Heuristic; otherwise ILS cannot run.\"\n\"E_SA_SIG:Your SA signature uses positional parameters inconsistent with the target. Refactor to Heuristic signature, or provide wrapper adapter that binds TEMP, MIN_TEMP, cooling_factor via other_params dict.\"\n\"E_TS_SIG:Tabu signature includes taboo_duration redundantly with taboo_list_size in many implementations. Ensure your TS matches the Heuristic signature and unpacks other_params for iterations, taboo_list_size, taboo_duration.\"\n\"E_EVAL_OBJ_MISMATCH:objective_function minimizes points only, ignoring feasibility and tie-breakers, while evaluate_solution encodes penalties and lexicographic ties. Ensure the solver optimizes evaluate_solution consistently; use objective_function only for reporting.\"\n\"E_KNOWN_MISMATCH:Provided expected score for the known solution does not match outputs from the supplied code. Reconcile data arrays or indexing to ensure consistency between objective_function\/evaluate_solution and any external expectations.\"\n\"E_NEIGH_TYPE_ANN:generate_neighbour return annotation ('NB_Type','Movement_Type') is not valid typing. Use Tuple[List[int], str] or omit annotation to avoid runtime\/type tooling issues.\"\n\"E_NEIGH_NOOP_RATE:REPLACE branch allows selecting the same value (have_val), producing frequent no-ops after deduplication. Constrain candidate set to missing excluding have_val to force actual change.\"\n\"E_NEIGH_SORT_LOSSES:_sorted_unique sorts the solution every move, destroying positional structure and shrinking the effective neighborhood. Preserve original order; only deduplicate when violating uniqueness.\"\n\"E_FEASIBILITY_DRIFT:Neighbour ops are cost-agnostic. Under budget, probability mass should favor ADD of low-point\/high-cost items to reach feasibility quickly; over budget, favor REMOVE\/REPLACE of high-point\/low-cost items.\"\n\"E_INIT_BAD_SEED:Sample solution [1..24] is a poor starting point for minimizing points (max points, large overspend). Seed with a greedy constructive: iteratively add items sorted by ascending points\/cost (with feasibility target cost >= B) to minimize points first.\"\n\"E_SCALING_TUNING:evaluate_solution returns values with magnitude ~1e12 for infeasible and ~1e6 scaling for feasible. SA temperature and acceptance must use score deltas of that scale; otherwise acceptance probability underflows. Normalize deltas (e.g., divide by 1e6) or set TEMP accordingly.\"\n\"E_TABU_ATTR:Tabu should track moves (added\/removed indices) not full solutions to reduce memory and avoid duplicate pruning. Use aspiration to allow improving solutions even if tabu.\"\n\"E_ILS_ACCEPT:Specify acceptance criterion using evaluate_solution (e.g., accept if improved or with small probability); without this, ILS risks stagnation. Ensure perturb_solution performs k random ADD\/REMOVE\/REPLACE biased by feasibility state.\"\n\"E_RANDOM_SEED:Set a fixed RNG seed for reproducibility during local testing; expose seed in other_params.\"\n\"E_STOP_CRIT:Define iteration\/time\/plateau stopping conditions; current reports show only failure to run, but solvers should guard against infinite loops with no improvement.\"\n\"E_CONSISTENCY_1BASED:All arrays use 1-based indexing with index 0 dummy. Maintain this consistently in neighbour operations and any greedy\/perturb routines to avoid off-by-one errors.\"\n\"E_TESTS_MIN:Set unit tests: (a) type errors return penalties, (b) duplicates penalized, (c) out-of-range penalized, (d) feasibility threshold handled, (e) lexicographic tie-breakers verified.\"\n\"R_FIX_SIG_CODE:Refactor solver entrypoint to the general signature; unpack hyperparameters via other_params. Example: def Heuristic(cur,best,bs,gen,evalf,pert,params): TEMP=params['TEMP']; ... return best,best_score\"\n\"R_PERTURB:Implement perturb_solution with feasibility-aware k-shake. Example: if under budget then add t items from sorted candidates by lowest points per added cost; if over budget then remove t highest points per removed cost; else 1\u20132 swaps.\"\n\"R_NEIGH_ENHANCE:Add 2-opt-like pair replacements: replace two items with two missing items chosen to reduce points and adjust cost toward B; also add targeted remove of highest point-per-cost item when overspend is small.\"\n\"R_GREEDY_INIT:Construct initial feasible solution by sorting items by ascending points then adding until cost >= B; break ties by lower cost. This respects the lexicographic objective and accelerates convergence.\"\n\"R_DELTA_EVAL:Cache totals (cost, points, count) and compute delta-score for neighbor moves to avoid full reevaluation O(k). This improves performance for SA\/TS inner loops.\"\n\"R_TEMPERATURE:Use geometric cooling TEMP*=cooling_factor with calibrated initial TEMP around median absolute delta-score; stop at MIN_TEMP or plateau_length.\"\n\"R_TABU_PARAMS:Set taboo_list_size \u2248 7\u201315 and taboo_duration accordingly; use aspiration if candidate improves best_score; diversify when no non-tabu improving moves exist.\"\n\"R_VALIDATE_EVAL:After implementing changes, validate solver by comparing evaluate_solution outputs against a small handcrafted set of feasible\/infeasible solutions to ensure penalties and tie-breakers apply as intended.\"\n\"EVAL_ASSERTION:Using the provided Python tool, the known reference was evaluated against evaluate_solution and objective_function, revealing inconsistency with the provided expected value. Correct the data or the claimed expectation to align with code behavior before relying on solver results.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Type check\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Fitness construction (lower is better)\n    # Infeasible: large penalty prioritized by budget deficit, then points, then count\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    # Feasible: primary minimize points, then minimize overspend, then item count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _sanitize(solution: List[int], n: int) -> List[int]:\n    if not isinstance(solution, list):\n        return []\n    seen = set()\n    cleaned = []\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            seen.add(x)\n            cleaned.append(x)\n    return cleaned\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embed problem data to enable feasibility-aware moves\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    cur = _sanitize(solution, n)\n    # Compute current totals\n    total_cost = sum(costs[i] for i in cur)\n    # Decide state: under, near, or over budget\n    state = \"feasible\" if total_cost >= B else \"under\"\n    # Movement probabilities tuned by state\n    p_add, p_remove, p_replace, p_swap2 = (0.55, 0.15, 0.20, 0.10) if state == \"under\" else (0.25, 0.45, 0.20, 0.10)\n    r = random.random()\n    new_sol = list(cur)\n    move = \"noop\"\n    # Helper sets\n    have = set(new_sol)\n    missing = [i for i in range(1, n+1) if i not in have]\n    # Biased candidate orderings\n    # Prefer adding low-point high-cost items when under budget\n    add_candidates = sorted(missing, key=lambda i: (points[i], -costs[i]))\n    # Prefer removing high point-per-cost items when over budget\n    remove_candidates = sorted(new_sol, key=lambda i: (-points[i]\/costs[i], -points[i]))\n    if r < p_add and add_candidates:\n        cand = random.choice(add_candidates[:max(1, min(5, len(add_candidates)))])\n        new_sol.append(cand)\n        move = \"add\"\n    elif r < p_add + p_remove and new_sol:\n        cand = random.choice(remove_candidates[:max(1, min(5, len(remove_candidates)))])\n        new_sol = [x for x in new_sol if x != cand]\n        move = \"remove\"\n    elif r < p_add + p_remove + p_replace:\n        if new_sol and missing:\n            # Replace worst in-set by best missing\n            out_idx = random.choice(remove_candidates[:max(1, min(5, len(remove_candidates)))])\n            in_idx = random.choice(add_candidates[:max(1, min(5, len(add_candidates)))])\n            if out_idx != in_idx:\n                new_sol = [x for x in new_sol if x != out_idx]\n                new_sol.append(in_idx)\n                move = \"replace\"\n            else:\n                move = \"noop\"\n        elif missing:\n            new_sol.append(random.choice(add_candidates))\n            move = \"add\"\n        else:\n            move = \"noop\"\n    else:\n        # Swap two: remove one and add one (or two small edits)\n        if new_sol:\n            out_idx = random.choice(remove_candidates[:max(1, min(5, len(remove_candidates)))])\n            new_sol = [x for x in new_sol if x != out_idx]\n            have2 = set(new_sol)\n            missing2 = [i for i in range(1, n+1) if i not in have2]\n            if missing2:\n                in_idx = random.choice(sorted(missing2, key=lambda i: (points[i], -costs[i]))[:max(1, min(5, len(missing2)))])\n                new_sol.append(in_idx)\n                move = \"swap_one\"\n            else:\n                move = \"remove\"\n        else:\n            if missing:\n                new_sol.append(random.choice(add_candidates))\n                move = \"add\"\n            else:\n                move = \"noop\"\n    # Preserve order of appearance, ensure uniqueness\n    seen = set()\n    ordered = []\n    for x in new_sol:\n        if x not in seen:\n            seen.add(x)\n            ordered.append(x)\n    return (ordered, move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    # sanitize\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    total_cost = sum(costs[i] for i in cur)\n    # Number of edits based on state\n    if total_cost < B:\n        K = random.randint(4, 7)\n    elif total_cost > B:\n        K = random.randint(3, 6)\n    else:\n        K = random.randint(2, 4)\n    s = list(cur)\n    for _ in range(K):\n        total_cost = sum(costs[i] for i in s)\n        have = set(s)\n        missing = [i for i in range(1, n+1) if i not in have]\n        if total_cost < B:\n            # add best low-point high-cost item\n            if missing:\n                cand = min(missing, key=lambda i: (points[i], -costs[i]))\n                s.append(cand)\n            else:\n                # replace worst item with better missing (if any)\n                worst = max(s, key=lambda i: (points[i], -costs[i]))\n                s.remove(worst)\n                s.append(worst)\n        elif total_cost > B:\n            # remove worst point-per-cost item\n            if s:\n                rem = max(s, key=lambda i: (points[i] \/ costs[i], points[i]))\n                s.remove(rem)\n        else:\n            # cost exactly at B: perform a swap aimed to reduce points if possible\n            if s and missing:\n                out = max(s, key=lambda i: (points[i] \/ costs[i], points[i]))\n                inn = min(missing, key=lambda i: (points[i], -costs[i]))\n                if inn != out:\n                    s.remove(out)\n                    s.append(inn)\n            else:\n                # fallback random tweak\n                if missing and (not s or random.random() < 0.5):\n                    s.append(random.choice(missing))\n                elif s:\n                    s.pop(random.randrange(len(s)))\n        # deduplicate while preserving order\n        seen2 = set()\n        s2 = []\n        for v in s:\n            if v not in seen2:\n                seen2.add(v)\n                s2.append(v)\n        s = s2\n    return s\n","SAMPLE_SOL":[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_INIT: Error 'Type List cannot be instantiated; use list() instead.' detected. Root cause: attempting to construct typing.List\/typing.Tuple at runtime. FIX: remove any List()\/Tuple() calls; use list()\/tuple() constructors only. Keep typing imports strictly for annotations.\n\nE_SOLVER_SIGNATURE: Signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. FIX: standardize to def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params). Do not call functions in the parameter list; pass function objects.\n\nE_PARAM_PASSING: Found usage like generate_neighbour() and evaluate_solution() in solver signatures\/logs. This invokes functions at definition time and passes return values instead of callables. FIX: pass generate_neighbour and evaluate_solution without parentheses.\n\nE_PERTURB_MISSING: Perturbation Function is undefined ('$Perturb'). This breaks ILS and any metaheuristics requiring diversification. FIX: implement perturb_solution as a k-move: remove r items with highest points\/cost, then greedily add low-point high-cost items until cost >= B; randomize k in [2,5] to escape local minima.\n\nE_OBJ_EVAL_MISMATCH: OBJ_CODE ignores feasibility and tie-breakers; EVAL_CODE enforces them. This inconsistency misguides solvers if OBJ_CODE is used anywhere (e.g., scoring logs). FIX: unify to a single evaluation oracle (reuse EVAL_CODE everywhere). If OBJ_CODE must exist, wrap EVAL_CODE and return only the lexicographic fitness scalar.\n\nE_REFERENCE_INFEASIBLE: Provided reference solution does not satisfy the evaluation\u2019s feasibility (cost >= B). FIX: verify data vectors and B, or update the reference so evaluate_solution returns a feasible-tier fitness. Do not rely on the objective-only scorer for validation.\n\nE_SA_ILS_TS_API: Reported solver signatures differ from required general signature and include extra positional params (TEMP, MIN_TEMP, etc.). FIX: pass such hyperparameters through other_params dict. Example mapping: other_params['SA'] = {'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}.\n\nE_ACCEPTANCE_FUNC: Lack of clear acceptance using the unified scalar fitness causes inconsistent moves. FIX: always compare evaluate_solution(new) < evaluate_solution(cur). For SA, accept if exp(-(f_new - f_cur)\/T) > rand.\n\nNB_CODE_FAIL_LOCAL_OPT: Neighborhood set is narrow and mostly single-edit; risks stagnation near feasibility boundary. FIX: add structured moves:\n- 2-swap: remove two, add two (focused on improving points then overspend).\n- Greedy-fill when under budget: loop-add lowest-point, highest-cost items until cost >= B instead of a single add.\n- Targeted drop when feasible: iterative removals minimizing \u0394fitness per removal.\n\nNB_MOVE_BIAS: remove_candidates uses -points\/cost; when feasible, this tends to drop high \u201cvalue\u201d items, which can inadvertently increase overspend if replacements are low cost. FIX: when feasible, prioritize removals by (\u0394fitness if removed), computed as a delta on the scalar fitness (points-major, then overspend, then count).\n\nR_STATE_DETECTION: State only distinguishes 'under' vs 'feasible'. There is no overspend-based granularity to drive removals aggressively when overspend is large. FIX: split feasible into 'near' (overspend <= 200) and 'far' (overspend > 200) and increase p_remove in 'far'.\n\nE_SANITIZE_DUPES: _sanitize is correct for bounds\/uniqueness, but silently drops invalids which can mask bugs. FIX: in solvers, validate before calling neighbour; log and reject any move that produces invalid indices or duplicates.\n\nE_COMPLEXITY_NOTE: Current neighbour computes a full sum(total_cost) each call O(k). In high-iteration loops this is a bottleneck. FIX: track total_cost and total_points in solver state; update incrementally for add\/remove\/replace\/swap in O(1), recomputing only on validation.\n\nE_TIEBREAKER_ALIGNMENT: Some moves optimize points\/cost ratios, not the scalar fitness ordering. FIX: use the exact evaluate_solution deltas for candidate ordering to align with lexicographic priorities.\n\nE_TABU_MECHANICS: Tabu search parameters not aligned with representation. FIX: tabu key should be a frozenset(solution) or last moved item(s). Use aspiration if new fitness < best_score despite tabu.\n\nE_INITIALIZATION: Sample solution is large; if it starts far from B, SA\/ILS may waste iterations. FIX: build initial solution by greedily adding items sorted by (points asc, cost desc) until cost >= B; then perform a few improving removals.\n\nE_STOPPING_CRITERIA: Missing time\/plateau caps risks overrun. FIX: add iteration cap, no-improvement cap, and temperature floor for SA.\n\nE_TESTHARNESS: Add deterministic test with fixed RNG seed to verify that evaluate_solution decreases monotonically under improving moves and that neighbour returns valid unique indices within [1,n].\n\nE_VALIDATION_WITH_REF: Cross-validated evaluate_solution using the same data\/penalties confirms consistent scalar fitness computation. No arithmetic errors found; issues are upstream (solver API\/perturb\/reference feasibility).\"\n\n"}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type check\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Fitness construction (lower is better)\n    # Infeasible: large penalty prioritized by budget deficit, then points, then count\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    # Feasible: primary minimize points, then minimize overspend, then item count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _sanitize_idx_list(solution: List[int], n: int) -> List[int]:\n    if not isinstance(solution, list):\n        return []\n    seen = set()\n    cleaned = []\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            seen.add(x)\n            cleaned.append(x)\n    return cleaned\n\ndef _fitness(sol: List[int]) -> int:\n    # Mirror of evaluate_solution (embedded, no external refs)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in sol):\n        return 10**15\n    if len(set(sol)) != len(sol):\n        return 10**15\n    total_cost = 0\n    total_points = 0\n    for idx in sol:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(sol)\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embed problem data\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    cur = _sanitize_idx_list(solution, n)\n    # Greedy fill if clearly under budget to diversify\n    total_cost = sum(costs[i] for i in cur)\n    if total_cost + 300 <= B:\n        have = set(cur)\n        missing = [i for i in range(1, n+1) if i not in have]\n        # Add items by (points asc, cost desc) until close to B\n        for i in sorted(missing, key=lambda i: (points[i], -costs[i])):\n            if total_cost >= B:\n                break\n            cur.append(i)\n            total_cost += costs[i]\n    # Recompute state\n    total_cost = sum(costs[i] for i in cur)\n    overspend = max(0, total_cost - B)\n    state = \"under\" if total_cost < B else (\"far\" if overspend > 200 else \"near\")\n    # Movement probabilities\n    if state == \"under\":\n        p_add, p_remove, p_replace, p_swap, p_2swap = 0.55, 0.10, 0.20, 0.10, 0.05\n    elif state == \"far\":\n        p_add, p_remove, p_replace, p_swap, p_2swap = 0.10, 0.55, 0.15, 0.15, 0.05\n    else:  # near\n        p_add, p_remove, p_replace, p_swap, p_2swap = 0.20, 0.35, 0.25, 0.15, 0.05\n    r = random.random()\n    new_sol = list(cur)\n    move = \"noop\"\n    have = set(new_sol)\n    missing = [i for i in range(1, n+1) if i not in have]\n    # Helper: delta-based removal ordering aligned with fitness\n    def removal_delta(idx: int) -> int:\n        s = [x for x in new_sol if x != idx]\n        return _fitness(s)\n    def addition_gain(idx: int) -> int:\n        s = list(new_sol) + [idx]\n        return _fitness(s)\n    if (r < p_add) and missing:\n        # choose among top-k low-point high-cost missing\n        cand_pool = sorted(missing, key=lambda i: (points[i], -costs[i]))[:min(6, len(missing))]\n        # pick the one with best resulting fitness\n        best_cand = None\n        best_fit = 10**18\n        for c in cand_pool:\n            f = addition_gain(c)\n            if f < best_fit:\n                best_fit = f\n                best_cand = c\n        if best_cand is not None:\n            new_sol.append(best_cand)\n            move = \"add\"\n    elif (r < p_add + p_remove) and new_sol:\n        # remove the item with smallest resulting fitness after removal\n        cand_pool = new_sol if len(new_sol) <= 8 else random.sample(new_sol, 8)\n        best_out = None\n        best_fit = 10**18\n        for idx in cand_pool:\n            f = removal_delta(idx)\n            if f < best_fit:\n                best_fit = f\n                best_out = idx\n        if best_out is not None:\n            new_sol = [x for x in new_sol if x != best_out]\n            move = \"remove\"\n    elif (r < p_add + p_remove + p_replace) and new_sol and missing:\n        # replace: try few candidates and pick best\n        out_pool = new_sol if len(new_sol) <= 6 else random.sample(new_sol, 6)\n        in_pool = sorted(missing, key=lambda i: (points[i], -costs[i]))[:min(6, len(missing))]\n        best_pair = None\n        best_fit = 10**18\n        for out_idx in out_pool:\n            for in_idx in in_pool:\n                if in_idx == out_idx:\n                    continue\n                s = [x for x in new_sol if x != out_idx]\n                s.append(in_idx)\n                f = _fitness(s)\n                if f < best_fit:\n                    best_fit = f\n                    best_pair = (out_idx, in_idx)\n        if best_pair is not None:\n            out_idx, in_idx = best_pair\n            new_sol = [x for x in new_sol if x != out_idx]\n            new_sol.append(in_idx)\n            move = \"replace\"\n    elif (r < p_add + p_remove + p_replace + p_swap) and new_sol:\n        # swap one out, one in\n        if missing:\n            out_idx = random.choice(new_sol)\n            in_cands = sorted(missing, key=lambda i: (points[i], -costs[i]))[:min(8, len(missing))]\n            best_in = None\n            best_fit = 10**18\n            base = [x for x in new_sol if x != out_idx]\n            for in_idx in in_cands:\n                s = list(base)\n                s.append(in_idx)\n                f = _fitness(s)\n                if f < best_fit:\n                    best_fit = f\n                    best_in = in_idx\n            if best_in is not None:\n                new_sol = base\n                new_sol.append(best_in)\n                move = \"swap_one\"\n    else:\n        # 2-swap: remove two, add up to two\n        if len(new_sol) >= 1:\n            out_pool = new_sol if len(new_sol) <= 6 else random.sample(new_sol, 6)\n            in_pool_all = sorted([i for i in range(1, n+1) if i not in set(new_sol)], key=lambda i: (points[i], -costs[i]))\n            best_variant = None\n            best_fit = 10**18\n            for out_idx in out_pool:\n                base = [x for x in new_sol if x != out_idx]\n                # Try add one\n                for in_idx in in_pool_all[:min(8, len(in_pool_all))]:\n                    s1 = list(base) + [in_idx]\n                    f1 = _fitness(s1)\n                    if f1 < best_fit:\n                        best_fit = f1\n                        best_variant = s1\n                # Try add two (if possible)\n                if len(in_pool_all) >= 2:\n                    for in_idx1 in in_pool_all[:min(6, len(in_pool_all))]:\n                        for in_idx2 in in_pool_all[:min(6, len(in_pool_all))]:\n                            if in_idx1 == in_idx2:\n                                continue\n                            s2 = list(base) + [in_idx1, in_idx2]\n                            f2 = _fitness(s2)\n                            if f2 < best_fit:\n                                best_fit = f2\n                                best_variant = s2\n            if best_variant is not None:\n                new_sol = _sanitize_idx_list(best_variant, n)\n                move = \"2swap\"\n    # Final sanitize preserving order\n    seen = set()\n    ordered = []\n    for x in new_sol:\n        if x not in seen:\n            seen.add(x)\n            ordered.append(x)\n    return (ordered, move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Embed problem data\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    # Sanitize\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    # Helper fitness (same as evaluator) for internal guidance\n    def fitness(sol: List[int]) -> int:\n        if any((i < 1) or (i > n) for i in sol):\n            return 10**15\n        if len(set(sol)) != len(sol):\n            return 10**15\n        total_cost = 0\n        total_points = 0\n        for idx in sol:\n            total_cost += costs[idx]\n            total_points += points[idx]\n        count = len(sol)\n        if total_cost < B:\n            deficit = B - total_cost\n            return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n        overspend = total_cost - B\n        return total_points * 10**6 + overspend * 10**3 + count\n    total_cost = sum(costs[i] for i in cur)\n    # Choose diversification strength\n    if total_cost < B:\n        k_remove = random.randint(2, 5)\n    elif total_cost > B:\n        k_remove = random.randint(3, 6)\n    else:\n        k_remove = random.randint(2, 4)\n    s = list(cur)\n    # Remove k items with highest points per cost (and points)\n    for _ in range(min(k_remove, len(s))):\n        if not s:\n            break\n        out = max(s, key=lambda i: (points[i]\/costs[i], points[i], -costs[i]))\n        s.remove(out)\n    # Greedily add low-point high-cost items until reaching feasibility\n    have = set(s)\n    missing = [i for i in range(1, n+1) if i not in have]\n    missing_sorted = sorted(missing, key=lambda i: (points[i], -costs[i]))\n    idx = 0\n    while True:\n        total_cost = sum(costs[i] for i in s)\n        if total_cost >= B or idx >= len(missing_sorted):\n            break\n        s.append(missing_sorted[idx])\n        idx += 1\n    # Local repair: if still under, add random low-point items\n    if sum(costs[i] for i in s) < B:\n        extra = [i for i in range(1, n+1) if i not in set(s)]\n        extra_sorted = sorted(extra, key=lambda i: (points[i], -costs[i]))\n        for i in extra_sorted:\n            if sum(costs[j] for j in s) >= B:\n                break\n            s.append(i)\n    # Deduplicate while preserving order\n    seen2 = set()\n    s2 = []\n    for v in s:\n        if v not in seen2 and 1 <= v <= n:\n            seen2.add(v)\n            s2.append(v)\n    # If perturbation worsened fitness drastically, keep better of original and perturbed\n    return s2 if fitness(s2) <= fitness(cur) else cur\n","SAMPLE_SOL":[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0.3\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_FAIL:Error 'Type List cannot be instantiated; use list() instead'. Replace any construction of 'List()' (from typing) with built-in 'list()'. Typing types are annotations only; never instantiate.\nE_HEUR_SIG_MISMATCH:Heuristic signatures include parentheses on function params (e.g., generate_neighbour(), evaluate_solution()). Pass function objects, not calls. Conform exactly to TARGET_HEURISTIC_GENERAL_SIGNATURE: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_SOLVER_SPECIFIC_SIGS:Provided SA\/ILS\/TS signatures deviate and misuse typing plus parentheses. Unify to generic signature and adapt wrappers. Example SA: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params): with params={'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}.\nE_PERTURB_MISSING:Perturbation Function undefined ($Perturb placeholder). Provide a deterministic, budget-aware perturbation, e.g., random k-exchange with feasibility repair targeting B via greedy add\/remove by fitness deltas.\nE_EVAL_DUPLICATION:_fitness duplicates evaluate_solution; risks divergence and doubles maintenance. Inject evaluate_solution into generate_neighbour and call it; remove _fitness copy to guarantee consistency.\nE_KNOWN_SOL_MISMATCH:KNOWN_SOLUTION and EXPECTED_SCORE_FROM_KNOWN_SOLUTION are inconsistent with provided data under both objective_function and evaluate_solution. Verified via Python: computed score does not match the stated expected. Align data or update the known reference to avoid false failure flags.\nE_OBJECTIVE_ALIGNMENT:objective_function returns only total_points, while evaluate_solution encodes feasibility and tie-breakers. Ensure any \u201cknown score\u201d references and acceptance criteria use evaluate_solution\u2019s fitness for solver correctness checks; use objective_function solely for reporting the primary metric.\nE_SAMPLE_FEASIBILITY_CHECK:Sample Solution evaluates feasible with large primary points; keep for smoke tests but add a minimal feasible baseline to validate improvements.\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood relies on small candidate pools and repeated full-fitness recomputation; exploration is shallow and costly. Add structured k-exchange (1-2-3 replace), and targeted remove-add based on marginal penalties aligned with fitness.\nE_DELTA_INEFFICIENCY:Each candidate evaluation recomputes full fitness O(k) repeatedly and sorts O(n log n) per call. Cache totals (cost, points, count) and compute deltas O(1). Precompute and reuse sorted index lists by (points asc, -cost) outside the hot loop.\nE_SORT_PER_CALL:missing and in_pool are repeatedly sorted. Maintain a static ordering array and filter via set membership to O(n); avoid re-sorting.\nE_GREEDY_PREFILL_RISK:Greedy prefill may overshoot budget and trigger \u201cfar\u201d removals, creating oscillation. Introduce budget-aware add heuristic that simulates addition until min(overspend<=0, margin<=M); or restrict by cost-threshold sampling.\nE_TIE_BREAK_IN_NEIGH_SELECT:Current selection minimizes full fitness which is correct; however, use structured lexicographic comparison (points, overspend, count) to avoid precision masking and to enable delta pruning.\nE_RNG_CONTROL:Randomness lacks seed control and temperature\/acceptance hooks. Add rng seed parameter and pass RNG object; avoid global random for reproducibility.\nE_SANITIZE_POLICY:_sanitize_idx_list silently drops invalids, potentially masking upstream bugs. Prefer explicit repair plus logging flag or return of (repaired, repaired_flag) to inform acceptance criteria.\nE_CONSTRAINT_CHECK_IN_NEIGH:Bounds and uniqueness enforced only at the end. Prevent duplicates during construction by set membership checks on all branches, not only final sanitize.\nR_REPRESENTATION_ORDER:Maintain solution as ordered by insertion; but evaluation is order-invariant. Normalize to sorted order to deduplicate states in tabu\/visited caches and reduce search space.\nTS_TABU_CONFIG:Tabu params unspecified; use attribute-based tabu (recent indices removed\/added) rather than full-solution tabu to reduce memory. Duration adaptive to state: longer when \u201cfar\u201d, shorter when \u201cnear\u201d.\nSA_ACCEPTANCE:Ensure Metropolis uses fitness difference with cooling schedule on the same minimization scale. Do not mix objective_function with evaluate_solution in acceptance.\nILS_ACCEPTANCE:Acceptance currently unspecified; use improved-else-accept-with-probability depending on perturb strength and delta fitness. Cap perturb size to avoid random restarts.\nE_STOPPING_CRITERIA:Add budget-aware stagnation detection (no lexicographic improvement over W iterations) and diversify via controlled ejection chains rather than random noise.\nCODE_COMPAT_NOTE:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS satisfied; keep code pure and local only.\nACTION_FIXES:\n- FIX_SIGS: Replace all SA\/ILS\/TS defs with the generic signature, remove parentheses on function params, remove typing instantiations. Example: def SA(cur,best,best_score,gen_nb,eval_fn,perturb,params): ...\n- PROVIDE_PERTURB:def perturb_solution(sol, rng, k=2): perform k exchanges with feasibility repair toward B, using eval_fn deltas.\n- REMOVE_DUP_EVAL:Delete _fitness; use eval_fn passed into generate_neighbour; pass eval_fn as a closure or parameter.\n- DELTA_CACHE:Compute base_cost, base_points once; for add i: delta = (points[i], max(0,(base_cost+cost[i])-B), +1); for remove i: delta = (-points[i], max(0,(base_cost-cost[i])-B), -1). Compare lexicographically to avoid 1e6 scaling.\n- PRECOMPUTE_ORDERINGS:At module init, build idx_by_points_cost = sorted(range(1,n+1), key=lambda i:(points[i],-costs[i])). Use it in all moves without re-sorting.\n- STATE-AWARE MOVES:When under: prioritized add with low points and high cost tight to B; when far: prioritized removal of highest (points,-cost) to get under; when near: replace two-for-one or one-for-two to reduce points while keeping cost \u2265 B with minimal overspend.\n- RNG_SEED:parametrize rng and expose seed in other_params to reproduce runs.\n- TESTS:Add unit checks: (a) evaluate_solution must be monotone in points primary and overspend secondary; (b) neighbour always returns unique 1..n; (c) perturb keeps feasibility or repairs within T attempts.\nVALIDATION_ASSERTIONS:\n- PY_EVAL_CHECK: Using the provided evaluate_solution, the stated EXPECTED_SCORE_FROM_KNOWN_SOLUTION does not match the computed value; rectify the reference or the data to unblock automated correctness checks.\n- FITNESS_TIEBREAK: Verify that for feasible neighbours with identical points, lower overspend is always selected; ensure equality handling uses count as third key.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Componentes":{"REPRESENTATION":"BIN_STR_LEN_24","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a 24-length binary string for the fuel offer selection problem.\n    Returns total price if gallons >= demand; otherwise adds a large penalty.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n\n    if total_gallons >= demand:\n        return float(total_price)\n\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\ndef _two_bit_flip(s: str, i: int, j: int) -> str:\n    if i == j:\n        return _flip_bit(s, i)\n    if i > j:\n        i, j = j, i\n    s = _flip_bit(s, i)\n    s = _flip_bit(s, j)\n    return s\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a local neighbour for a binary string solution.\n    Returns: (neighbour_solution, NB_Type, Movement_Type)\n    NB_Type: descriptor of neighbourhood (e.g., BIT_FLIP, TWO_BIT_FLIP)\n    Movement_Type: descriptor (e.g., LOCAL)\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) == 0:\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    move_kind = random.random()\n\n    if move_kind < 0.7:\n        # Single-bit flip (Hamming-1)\n        idx = random.randrange(n)\n        nb = _flip_bit(solution, idx)\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n    else:\n        # Two-bit flip (Hamming-2)\n        i, j = random.randrange(n), random.randrange(n)\n        nb = _two_bit_flip(solution, i, j)\n        return (nb, \"TWO_BIT_FLIP\", \"LOCAL\")\n","PERTURB_CODE":"import random\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits (k in [3,6]).\n    Returns a new perturbed solution string of same length.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(3, 6))\n    idxs = random.sample(range(n), k)\n    s = solution\n    for idx in idxs:\n        s = _flip_bit(s, idx)\n    return s\n","SAMPLE_SOL":"111011101111111110111111"},"Version":0,"Feedback":"COMPONENT_VERSION: v1.0.3\nFEEDBACK:\nE_LOCAL_SOLVER_ERROR:Type Tuple cannot be instantiated; replace any instantiation of typing.Tuple with built-in tuple and remove callable parentheses in signatures (pass generate_neighbour, evaluate_solution, perturb_solution as callables, not generate_neighbour()).\nE_SIGNATURE_MISMATCH:Heuristic signatures deviate from TARGET_HEURISTIC_GENERAL_SIGNATURE; enforce def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) for SA\/ILS\/TS routing.\nE_NEIGHBOUR_API_CONTRACT:generate_neighbour returns (nb, NB_Type, Movement_Type) but heuristics typically expect a solution only; either return only nb or wrap with adaptor that extracts first element consistently.\nE_PERTURB_MISSING:Perturbation Function unresolved ($Perturb placeholder); implement a k-bit flip or destroy-repair perturbation ensuring feasibility-oriented bias.\nE_EVAL_PENALTY_SCALE:Penalty 1e6 + 1e3*deficit likely blocks exploration in SA\/ILS; use adaptive penalty \u03bb scaled by cost magnitude or apply repair to meet demand before scoring to avoid prohibitive plateaus.\nE_DELTA_EVAL:Neighbour evaluation is O(n) per step; track (total_price,total_gallons) and compute O(1) deltas for single\/two-bit flips to reduce runtime.\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood limited to random bit flips; add 1-0 and 0-1 exchange with greedy completion, 2-opt-like pairwise exchanges, and biased flips by value-density (gallon\/price) to escape weak local minima.\nR_STR_INADEQUATE:Pure binary string hampers feasibility control; introduce auxiliary repair that flips cheapest items until demand met or use a permutation + greedy fill decoding for stronger structure.\nE_SA_PARAMS:SA lacks temperature policy; set T0 via cost stddev over initial neighbours, geometric cooling alpha\u22480.95, stop at MIN_TEMP or stagnation, optional reheating on no-improvement.\nE_ILS_ACCEPTANCE:ILS acceptance undefined; implement Better-or-Equal with occasional SA-style acceptance to diversify; set perturbation strength proportional to n (e.g., k\u2208[3,6]).\nE_TABU_CONFIG:Tabu tenure and aspiration missing; set tenure\u22487\u201310, track move-based tabu (bit indices), implement aspiration if candidate improves best_score.\nE_RANDOM_SEED:Non-deterministic results; expose rng seed parameter and thread-safe RNG instance for reproducibility.\nE_STOPPING_CRITERIA:No termination policy; add max_iterations, max_no_improve, and wall-clock budget hooks.\nE_VALIDATION_ORACLE:Provided reference solution fails current feasibility under evaluate_solution (verified via tool); update oracle or adjust demand\/penalty to align with test.\nE_SAMPLE_SOLUTION_CHECK:Sample is feasible but not guaranteed near-optimal; use greedy value-density seed and LNS to improve baseline before metaheuristics.\nR_CONSTRAINT_HANDLING:Add repair: if gallons<demand after a move, iteratively flip cheapest 0-bits until demand met; if gallons>demand with slack, attempt removing most expensive redundant 1-bits.\nR_MOVE_SCHEDULING:Use Variable Neighbourhood Descent: cycle BIT_FLIP, TWO_BIT_FLIP, and 1-1 exchanges; reset to simplest after improvement to intensify.\nR_LOGGING:Record (score, gallons, NB_Type, accept_type, T) per step to diagnose acceptance\/penalty effects; assert O(1) delta correctness with unit tests.\nR_API_SANITY:All components must avoid filesystem\/network\/os access per constraints; keep pure functions and pass state explicitly."}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Componentes":{"REPRESENTATION":"BIN_STR_LEN_24","EVAL_CODE":"import math\nfrom typing import Optional\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a 24-length binary string for the fuel offer selection problem.\n    Returns total price if gallons >= demand; otherwise adds an adaptive penalty.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n\n    if total_gallons >= demand:\n        return float(total_price)\n\n    # Adaptive penalty scaled by mean price per gallon and deficit\n    mean_ppg = sum(prices) \/ max(1, sum(gallons))\n    deficit = demand - total_gallons\n    # lambda factor scales to about two orders of magnitude larger than typical prices\n    lam = 50.0\n    penalty = lam * mean_ppg * deficit\n    return float(total_price + penalty)\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n\ndef _repair_feasible(s: str) -> str:\n    \"\"\"Greedy repair to meet demand with minimal added cost; then prune redundant costly ones.\"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    n = len(s)\n    sel = [1 if c == '1' else 0 for c in s]\n    total_g = sum(gallons[i] for i in range(n) if sel[i])\n    total_p = sum(prices[i] for i in range(n) if sel[i])\n\n    if total_g < demand:\n        # Add cheapest by price-per-gallon among zeros until feasible\n        candidates = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 0]\n        candidates.sort()\n        for _, i in candidates:\n            sel[i] = 1\n            total_g += gallons[i]\n            total_p += prices[i]\n            if total_g >= demand:\n                break\n\n    # Try pruning redundant 1s starting from worst price efficiency while staying feasible\n    ones = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 1]\n    ones.sort(reverse=True)\n    for _, i in ones:\n        if total_g - gallons[i] >= demand:\n            sel[i] = 0\n            total_g -= gallons[i]\n            total_p -= prices[i]\n\n    return ''.join('1' if b else '0' for b in sel)\n\n\ndef _biased_index_by_density(s: str) -> int:\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(s)\n    # Higher probability to flip items with poor value density if currently selected,\n    # or high value density if currently unselected (to encourage feasibility)\n    weights = []\n    for i in range(n):\n        dens = gallons[i] \/ prices[i]\n        if s[i] == '1':\n            w = 1.0 \/ max(1e-9, dens)\n        else:\n            w = dens\n        weights.append(max(1e-6, w))\n    total = sum(weights)\n    r = random.random() * total\n    acc = 0.0\n    for i, w in enumerate(weights):\n        acc += w\n        if acc >= r:\n            return i\n    return n - 1\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbour solution for a binary string.\n    Returns a tuple: (neighbour_solution, NB_Type, Movement_Type)\n    NB_Type in {BIT_FLIP, TWO_BIT_FLIP, EXCHANGE}\n    Movement_Type is 'LOCAL'\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) == 0:\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    move_kind = random.random()\n\n    if move_kind < 0.5:\n        # Single biased bit flip\n        idx = _biased_index_by_density(solution)\n        nb = _flip_bit(solution, idx)\n        nb = _repair_feasible(nb)\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n    elif move_kind < 0.85:\n        # Two-bit flip (distinct indices)\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i and n > 1:\n            j = random.randrange(n)\n        s = _flip_bit(solution, i)\n        s = _flip_bit(s, j)\n        nb = _repair_feasible(s)\n        return (nb, \"TWO_BIT_FLIP\", \"LOCAL\")\n    else:\n        # 1-1 exchange: turn off one 1, turn on one 0, then repair\n        ones = [i for i,c in enumerate(solution) if c == '1']\n        zeros = [i for i,c in enumerate(solution) if c == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s = solution\n            s = _flip_bit(s, i)\n            s = _flip_bit(s, j)\n            nb = _repair_feasible(s)\n            return (nb, \"EXCHANGE\", \"LOCAL\")\n        # Fallback to single flip\n        idx = random.randrange(n)\n        nb = _repair_feasible(_flip_bit(solution, idx))\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n","PERTURB_CODE":"import random\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n\ndef _repair_feasible(s: str) -> str:\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    n = len(s)\n    sel = [1 if c == '1' else 0 for c in s]\n    total_g = sum(gallons[i] for i in range(n) if sel[i])\n    total_p = sum(prices[i] for i in range(n) if sel[i])\n\n    if total_g < demand:\n        candidates = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 0]\n        candidates.sort()\n        for _, i in candidates:\n            sel[i] = 1\n            total_g += gallons[i]\n            total_p += prices[i]\n            if total_g >= demand:\n                break\n\n    ones = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 1]\n    ones.sort(reverse=True)\n    for _, i in ones:\n        if total_g - gallons[i] >= demand:\n            sel[i] = 0\n            total_g -= gallons[i]\n            total_p -= prices[i]\n\n    return ''.join('1' if b else '0' for b in sel)\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits (k in [3,6]), then repair.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(3, 6))\n    idxs = random.sample(range(n), k)\n    s = solution\n    for idx in idxs:\n        s = _flip_bit(s, idx)\n    s = _repair_feasible(s)\n    return s\n","SAMPLE_SOL":"111011101111111110111111"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix1\"\n\"FEEDBACK\",\"LS_SIGNATURE_ERROR:Heuristic signatures include typing.Optional instantiation and callable parameters written as generate_neighbour() instead of function objects. Remove Optional from runtime parameters and pass functions without calling them.\nLS_SIGNATURE_SPEC_FIX:Use def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor): and analogous for ILS\/TS; avoid Optional[...] in signatures and defaults.\nPERTURB_MISSING:Perturbation Function undefined ($Perturb placeholder). Provide a concrete perturb_solution(sol,rng,intensity) to unblock ILS and SA reheats.\nOBJ_EVAL_INCONSISTENCY:OBJ_CODE ignores feasibility; EVAL_CODE penalizes infeasibility with different scale than COMPONENTS evaluate_solution. Unify to a single evaluate with identical penalty to ensure coherent search pressure.\nPENALTY_SCALE_MISMATCH:EVAL_CODE uses +1_000_000+1_000*deficit; COMPONENT evaluate uses lam*mean_ppg*deficit (~O(10^2)). This creates divergent landscapes and misguides acceptance criteria. Standardize to one (recommend large, static penalty in early phases; adaptive only if tuned).\nNB_CONTRACT_VIOLATION:generate_neighbour docstring claims returns (neighbour,NB_Type,Movement_Type) but declared signature comment shows only neighbour expected by heuristics. Ensure heuristics consume (sol,nb_type,move_type) consistently or change neighbour to return only solution and emit telemetry elsewhere.\nNB_REPAIR_SIDE_EFFECT:Always-repair-to-feasible collapses landscape and masks constraint handling in acceptance logic. Allow occasional infeasible neighbours with graded penalties to improve exploration; gate by annealing temperature or probability.\nNB_DENSITY_HEURISTIC_BIAS:Index selection uses gallons\/prices heuristic that may overfit to local value density and miss complementary bundles. Add second operator set: random k-flip (k\u2208{2,3,5}) and targeted drop-add by marginal cost per covered gallon shortfall.\nNB_CODE_FAIL_LOCAL_OPT:No true exchange-improvement step evaluating delta-cost over feasible space. Add best-improving 1-1 and 2-1 exchanges with lazy delta evaluation to escape plateaus.\nINIT_SOLUTION_WEAK:Sample solution is feasible but no deterministic greedy baseline provided. Add greedy by ascending price-per-gallon with tie-break by price, then prune redundancies.\nE_CODE_PERF:Neighbour generation calls _repair_feasible (O(n log n) due to sorts) every move. Cache sorted lists by density and maintain incremental totals; switch to partial heaps for add\/prune to reach amortized O(log n).\nREPAIR_CORRECTNESS:Greedy prune may remove multiple items in reverse-density order without checking combined removals; ensure feasibility check handles cascading effects or use while-improvable loop with priority queue.\nAPI_CONTRACT:TARGET_HEURISTIC_GENERAL_SIGNATURE mandates parameter order; current SA\/ILS\/TS messages indicate mismatched ordering and extra args. Align exact order and names; avoid default argument misbinding.\nR_STR_INADEQUATE:Pure BINARY_STRING with heavy repair can cause premature convergence. Consider hybrid: keep binary, but add permutation of indices to define greedy fill order as a secondary solution space for perturbations.\nTABU_PARAMETERS:Tabu constructor failures indicate wrong arity. Provide TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration) and validate all ints; no Optional or complex types at call site.\nRANDOM_STATE_CONTROL:Lack of rng injection leads to non-reproducible failures. Accept rng seed or Random instance in other_params, thread through neighbour\/perturb.\nVALIDATION_GUARD:generate_neighbour returns INVALID\/NONE for bad input but heuristics likely do not handle this. Validate upfront and resample move if INVALID.\nEVAL_ASSERTIONS:Add asserts to reject non-binary strings and wrong lengths before search loop; early exit instead of propagating inf.\nKNOWN_REF_CHECK:FAIL_GIVEN_EVAL. Provided reference does not satisfy the stated constraint under the included evaluation. Update or remove to prevent misleading validation.\nSAMPLE_EVAL_CHECK:PASS_GIVEN_EVAL. The included sample solution evaluates correctly under the provided evaluate function.\nREPRO_STEPS:Create a single shared evaluate_solution (the strict-penalty one), adjust neighbour to optionally skip repair 30% of the time, add missing perturb_solution (e.g., flip 5\u201310 biased bits then repair), fix heuristic signatures as specified, and add deterministic greedy initializer followed by local improvement exchanges.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Componentes":{"REPRESENTATION":"BIN_STR_LEN_24","EVAL_CODE":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    \"\"\"\n    Evaluate a 24-length binary string for the offer selection problem.\n    Returns total price if gallons >= demand; otherwise returns price + large static penalty.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n\n    if total_gallons >= demand:\n        return float(total_price)\n\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Generate a neighbour for a 24-length binary string.\n    Returns a tuple: (neighbour_solution, NB_Type, Movement_Type)\n    NB_Type in {BIT_FLIP, TWO_BIT_FLIP, EXCHANGE}\n    Movement_Type is 'LOCAL'\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    def _valid(s: str) -> bool:\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n    def _totals(s: str) -> Tuple[int, int]:\n        tp = tg = 0\n        for i, c in enumerate(s):\n            if c == '1':\n                tp += prices[i]\n                tg += gallons[i]\n        return tp, tg\n\n    def _repair_feasible(s: str) -> str:\n        # Greedy add by best price-per-gallon, then prune worst while feasible\n        n = len(s)\n        sel = [1 if c == '1' else 0 for c in s]\n        total_g = sum(gallons[i] for i in range(n) if sel[i])\n        if total_g < demand:\n            candidates = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 0]\n            candidates.sort()\n            for _, i in candidates:\n                sel[i] = 1\n                total_g += gallons[i]\n                if total_g >= demand:\n                    break\n        # prune\n        changed = True\n        while changed:\n            changed = False\n            ones = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 1]\n            ones.sort(reverse=True)\n            for _, i in ones:\n                if total_g - gallons[i] >= demand:\n                    sel[i] = 0\n                    total_g -= gallons[i]\n                    changed = True\n                # break early to re-evaluate list after a successful removal\n                if changed:\n                    break\n        return ''.join('1' if b else '0' for b in sel)\n\n    def _biased_index_by_density(s: str) -> int:\n        n = len(s)\n        weights = []\n        for i in range(n):\n            dens = gallons[i] \/ prices[i]\n            w = (1.0 \/ max(1e-9, dens)) if s[i] == '1' else dens\n            weights.append(max(1e-6, w))\n        total = sum(weights)\n        r = random.random() * total\n        acc = 0.0\n        for i, w in enumerate(weights):\n            acc += w\n            if acc >= r:\n                return i\n        return n - 1\n\n    if not _valid(solution):\n        return (solution, \"INVALID\", \"NONE\")\n\n    n = len(solution)\n    move_kind = random.random()\n\n    if move_kind < 0.5:\n        # Single biased bit flip\n        idx = _biased_index_by_density(solution)\n        nb = _flip_bit(solution, idx)\n        # Repair with probability 0.7 to keep some infeasible exploration\n        if random.random() < 0.7:\n            nb = _repair_feasible(nb)\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n    elif move_kind < 0.85:\n        # Two-bit flip\n        if n == 1:\n            nb = _flip_bit(solution, 0)\n            if random.random() < 0.7:\n                nb = _repair_feasible(nb)\n            return (nb, \"TWO_BIT_FLIP\", \"LOCAL\")\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        s = _flip_bit(solution, i)\n        s = _flip_bit(s, j)\n        if random.random() < 0.7:\n            s = _repair_feasible(s)\n        return (s, \"TWO_BIT_FLIP\", \"LOCAL\")\n    else:\n        # Exchange: turn off one 1 and turn on one 0\n        ones = [i for i, c in enumerate(solution) if c == '1']\n        zeros = [i for i, c in enumerate(solution) if c == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s = _flip_bit(solution, i)\n            s = _flip_bit(s, j)\n            if random.random() < 0.7:\n                s = _repair_feasible(s)\n            return (s, \"EXCHANGE\", \"LOCAL\")\n        # Fallback: single random flip\n        idx = random.randrange(n)\n        nb = _flip_bit(solution, idx)\n        if random.random() < 0.7:\n            nb = _repair_feasible(nb)\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n","PERTURB_CODE":"import random\nfrom typing import Any\n\ndef perturb_solution(solution: Any):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits (k in [5,8]), then greedy repair to feasible.\n    Returns the perturbed solution string (same length as input) or the original if invalid.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    def _valid(s: str) -> bool:\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n    def _repair_feasible(s: str) -> str:\n        n = len(s)\n        sel = [1 if c == '1' else 0 for c in s]\n        total_g = sum(gallons[i] for i in range(n) if sel[i])\n        if total_g < demand:\n            candidates = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 0]\n            candidates.sort()\n            for _, i in candidates:\n                sel[i] = 1\n                total_g += gallons[i]\n                if total_g >= demand:\n                    break\n        changed = True\n        while changed:\n            changed = False\n            ones = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 1]\n            ones.sort(reverse=True)\n            for _, i in ones:\n                if total_g - gallons[i] >= demand:\n                    sel[i] = 0\n                    total_g -= gallons[i]\n                    changed = True\n                if changed:\n                    break\n        return ''.join('1' if b else '0' for b in sel)\n\n    if not _valid(solution):\n        return solution\n\n    n = len(solution)\n    k = min(n, random.randint(5, 8))\n    idxs = random.sample(range(n), k)\n    s = solution\n    for idx in idxs:\n        s = _flip_bit(s, idx)\n    s = _repair_feasible(s)\n    return s\n","SAMPLE_SOL":"111011101111101111111111"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses from callable parameters and use exactly: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\\nE_ANY_INSTANTIATION:Error 'Any cannot be instantiated' indicates misuse of typing.Any as a value (e.g., Any()). Replace with Optional[...] defaults (None) and use Any only as type annotation.\\nE_SA_SIGNATURE:Stop using def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor). Replace with def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and fetch annealing params from other_params.\\nE_ILS_SIGNATURE:Stop using def ILS(solution,best_sol,best_score,generate_neighbour(),perturb_solution(),evaluate_solution(),iterations,aceptance_rate). Replace with def ILS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Fix 'aceptance_rate' typo to 'acceptance_rate'.\\nE_TABU_SIGNATURE:Stop using def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration). Replace with def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove parentheses from callables; standardize naming 'tabu' not 'taboo'.\\nE_PERTURB_MISSING:'Perturbation Function' is undefined ($Perturb placeholder). Implement a concrete perturbation, e.g., k random biased flips followed by feasibility repair, and pass as perturb_solution.\\nE_OBJ_EVAL_INCONSISTENT:OBJ_CODE lacks feasibility penalty while EVAL_CODE includes it. Unify to a single evaluate function used everywhere to avoid solver\/best-tracking inconsistencies.\\nE_PENALTY_SCALE:Penalty 1_000_000 + 1_000*deficit dwarfs price signal and can freeze SA\/TS acceptance. Use adaptive penalty (e.g., lambda * deficit with lambda tuned to keep penalty within 1\u20132 orders of magnitude of objective) or enforce feasibility via mandatory repair before scoring.\\nNB_CODE_PERF:_repair_feasible sorts O(n log n) each call and may repeat in a while loop, yielding O(n^2 log n) worst-case per neighbor. Cache price\/gallon ratios and use a single-pass removal via marginal impact or maintain a binary heap to reduce to O(n log n).\\nNB_CODE_FAIL_LOCAL_OPT:Repair greedily adds by price-per-gallon then prunes by worst density; this can cycle near tight constraints. Add tie-breaking by absolute price and implement 1-removal\/1-add local re-optimization (swap) to escape local plateaus.\\nNB_FEASIBILITY_POLICY:Repair is probabilistic (p=0.7); remaining 30% infeasible neighbors incur massive penalty causing noisy gradients. Either always repair for SA\/TS evaluation or route infeasible neighbors to a soft-penalty with small lambda to preserve informative acceptance.\\nNB_EXCHANGE_EDGE:When ones or zeros are empty, fallback to single random flip may produce infeasibility. Couple fallback with mandatory repair to stabilize search dynamics.\\nNB_DENSITY_BIAS:biased index uses gallons\/prices to add and inverse to remove; this ignores covariance with feasibility margin. Weight by (gallons\/prices) normalized by current surplus (g_surplus = total_g - demand) to prefer dropping low-impact items when surplus is high.\\nNB_STATE_REUSE:Repeated recomputation of totals in _totals\/_repair_feasible increases cost. Thread current totals into neighbor generator and update incrementally per flip to achieve O(1) update plus O(log n) for repair operations.\\nE_VALIDATION_INTERFACE:generate_neighbour returns ('INVALID','INVALID','NONE') for bad inputs; downstream solvers likely assume Movement_Type in {'LOCAL'}. Return the original solution with a valid NB_Type flag and Movement_Type='LOCAL' to avoid crashes.\\nSEEDING:Randomized neighbor selection without fixed RNG seed impedes reproducibility. Accept seed via other_params and seed random at solver start.\\nDATA_DUPLICATION:prices\/gallons\/demand are duplicated across Evaluation and Neighbour functions. Centralize in evaluate_solution closure or pass via other_params to avoid drift.\\nBOUNDING:Add a cheap lower bound (LP-relaxation or greedy density bound) to prune obviously suboptimal states and guide acceptance thresholds.\\nSAMPLE_SOLUTION_GAP:The provided sample solution is feasible but plainly non-minimal under the given data. Use repair + 2-opt exchange to reduce redundant high-cost items.\\nKNOWN_SOL_MISMATCH:The provided KNOWN_SOLUTION\/EXPECTED_SCORE pair is inconsistent with the current evaluation function and data (fails feasibility under the stated demand). Update or remove to prevent false correctness signals during regression checks.\\nTEST_HARNESS:Create unit tests asserting: (a) all solvers accept the unified signature, (b) perturbation returns valid 24-bit strings, (c) evaluate_solution monotonicity w.r.t. added gallons under feasibility, and (d) reproducibility with fixed seed.\\nPARAM_PACKING:Use other_params as a dict: {'max_iter':..., 'temp_init':..., 'temp_min':..., 'cooling':..., 'tabu_tenure':..., 'tabu_size':..., 'acceptance_rate':..., 'seed':...}. Validate keys and provide defaults.\\nTERMINATION:Define consistent stopping criteria (iterations without improvement or time budget) across SA\/ILS\/TS to enable fair comparison.\\nSTATE_TRACKING:Always track (currentSolution,current_score) and (best,best_score) using evaluate_solution only; never mix with OBJ_CODE.\\nLOGGING:Return extra outputs explicitly: {'nb_type':..., 'move':..., 'score':..., 'gallons':..., 'price':..., 'feasible':...} to satisfy 'LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED' without polluting objective computation.\\nACTIONABLE_PATCHES:\\n- Replace all solver signatures with TARGET_HEURISTIC_GENERAL_SIGNATURE and remove Any() constructions.\\n- Implement perturb_solution as k=3 biased flips + mandatory repair.\\n- Enforce mandatory repair before scoring; reduce penalty to lambda=50 per deficit if infeasible neighbors must be kept.\\n- Optimize repair: precompute ratios, use heap for worst-removal, and stop after single successful removal per iteration.\\n- Centralize parameters and data; add seed control and unit tests to catch signature and feasibility regressions early.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BINARY_STRING","Componentes":{"REPRESENTATION":"BINARY_STRING","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: BINARY_STRING of length 24, characters in {'0','1'}\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n    if total_gallons >= demand:\n        return float(total_price)\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"NB_Invalid\", \"NoOp\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_Empty\", \"NoOp\")\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n\n    def total_gallons_and_cost(sol_list):\n        g = 0\n        c = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n                c += prices[i]\n        return g, c\n\n    move_r = random.random()\n\n    if move_r < 0.5:\n        # 1-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        return (''.join(s), \"NB_BitFlip\", \"Move_1bit\")\n    elif move_r < 0.8:\n        # 2-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        return (''.join(s), \"NB_BitFlip\", \"Move_2bit\")\n    else:\n        # Ratio-driven greedy adjustment toward feasibility\/cost-efficiency\n        g_now, _ = total_gallons_and_cost(s)\n        ratios = [prices[i] \/ gallons[i] for i in range(n)]\n        if g_now < demand:\n            # turn on the best (lowest price per gallon) among zeros\n            zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n            if zero_idxs:\n                best_i = min(zero_idxs, key=lambda i: ratios[i])\n                s[best_i] = '1'\n            return (''.join(s), \"NB_Greedy\", \"Move_AddBest\")\n        else:\n            # turn off the worst (highest price per gallon) among ones\n            one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n            if one_idxs:\n                worst_i = max(one_idxs, key=lambda i: ratios[i])\n                s[worst_i] = '0'\n            return (''.join(s), \"NB_Greedy\", \"Move_RemoveWorst\")\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Multi-flip stochastic perturbation with ratio guidance.\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n    k = random.randint(3, 6)\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n\n    for _ in range(k):\n        # With guidance: if under demand, prefer adding best; else random or remove worst\n        g_now = sum(gallons[i] for i, ch in enumerate(s) if ch == '1')\n        if g_now < demand and random.random() < 0.7:\n            zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n            if zero_idxs:\n                i = min(zero_idxs, key=lambda i: ratios[i])\n                s[i] = '1'\n                continue\n        if g_now >= demand and random.random() < 0.7:\n            one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n            if one_idxs:\n                i = max(one_idxs, key=lambda i: ratios[i])\n                s[i] = '0'\n                continue\n        # Fallback random flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n\n    return ''.join(s)\n","SAMPLE_SOL":"111011101111111110111111"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0.3\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST: Heuristic signatures incorrectly pass invoked functions and cause arity errors. Change to pass function references, not calls.\nSA_SIG_FIX: Use def SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor): and call nb_sol = generate_neighbour(currentSolution).\nILS_SIG_FIX: Use def ILS(currentSolution, best, best_score, generate_neighbour, perturb_solution, evaluate_solution, iterations, acceptance_rate): ensure perturb_solution is a callable reference.\nTS_SIG_FIX: Use def TS(currentSolution, best, best_score, generate_neighbour, evaluate_solution, iterations, taboo_list_size, taboo_duration): do not invoke functions in the signature list.\n\nNB_ARITY_MISMATCH: generate_neighbour returns (neighbor, NB_Type, Movement_Type) but heuristics likely unpack 1 or 2 values, triggering 'too many values to unpack'. Standardize to either return only neighbor or update heuristics to accept 3-tuple and ignore metadata.\nNB_API_PATCH: In SA\/ILS\/TS, use neighbor, _, _ = generate_neighbour(current) to avoid unpack errors, or wrap with def nb_wrap(s): return generate_neighbour(s)[0].\n\nPERTURB_MISSING: 'Perturbation Function' is undefined ('$Perturb'). Implement perturb_solution(solution) with a diversified multi-bit flip or segment-swap to satisfy ILS contract.\n\nOBJ_EVAL_INCONSISTENT: objective_function lacks feasibility penalty but evaluate_solution applies a large penalty. Using both interchangeably creates divergent rankings. Remove objective_function or align both to a single penalized evaluate_solution to ensure consistent selection pressure.\n\nEVAL_PENALTY_SCALING: Penalty 1_000_000 + 1_000*deficit dwarfs price differences and can mislead SA\/TS exploration. Prefer feasibility-repair over penalization, or use adaptive penalties that maintain gradient: e.g., penalty = alpha*deficit with alpha ~ mean(price\/gallon) and increase alpha only if prolonged infeasibility persists.\n\nFEASIBILITY_REPAIR: Add a deterministic repair step used by all heuristics:\n- If infeasible, iteratively turn on lowest price-per-gallon zeros until demand met.\n- If feasible, iteratively turn off highest price-per-gallon ones while maintaining feasibility.\nThis prevents penalized plateaus and accelerates convergence.\n\nINIT_SOLUTION_WEAK: No constructive initializer. Greedy by ratio prices[i]\/gallons[i] to reach the demand yields a strong baseline and reduces SA\/ILS runtime.\nINIT_PATCH: Build initial feasible solution by sorting offers by ratio ascending and picking until g\u00b7x \u2265 demand, then run a removal pass.\n\nNB_CODE_FAIL_LOCAL_OPT: Neighborhood restricted to 1- and 2-bit flips plus a unidirectional greedy toggle. This is too myopic; it cannot explore swap structures that keep feasibility while reducing cost.\nADD_SWAP_MOVES: Implement drop-add moves (1-for-1 swap: turn off a high-ratio '1' and turn on the best '0' to maintain feasibility), and 2-for-1 or 1-for-2 exchanges guided by ratios and gallons for larger steps.\n\nINCR_EVAL_MISSING: evaluate_solution recomputes O(n) each time. For SA\/TS iterative use, track total_price and total_gallons and update in O(1) per bit flip; for 2-bit\/swap, apply two O(1) deltas.\nINCR_EVAL_PATCH: Maintain state (price_sum, gallon_sum); on flipping bit i, do price_sum += \u00b1prices[i], gallon_sum += \u00b1gallons[i]; compute feasibility\/penalty from updated sums.\n\nKNOWN_SOLUTION_INCONSISTENT: Provided known solution format\/indices produce a heavily penalized evaluation under the current evaluate_solution and does not satisfy the demand constraint. This indicates a mismatch between the 'KNOWN_SOLUTION' and the active problem definition\/evaluator. Rectify the reference solution source or update the evaluator to match its originating instance.\n\nSAMPLE_SOLUTION_VALIDATION: Sample solution length is correct; ensure all solvers start from a validated, feasible seed to avoid immediate penalties. Verify evaluation compliance before running metaheuristics.\n\nR_STR_INADEQUATE: Pure bitstring with massive penalty impedes guided search near feasibility boundary. Consider hybrid representation with a separate feasibility tracker or maintain a sorted list of active items by ratio for fast best\/worst toggles.\n\nTS_MEMORY_POLICY: Define tabu attributes at move level (bit indices flipped or swap pairs). Given 1-\/2-bit flips, store indices as tabu with tenure tuned to ~sqrt(n). Also include aspiration criterion when a move yields a global best cost.\n\nSA_SCHEDULE_WEAK: Cooling must be geometric with calibrated initial TEMP matching the median positive delta of feasible-local moves. Estimate initial TEMP via short sampling to target ~0.8 acceptance of uphill moves, then cool by factor 0.95\u20130.99.\n\nILS_ACCEPTANCE_RULE: Use better-than-best or better-than-current with periodic worsening acceptance to escape local minima. Ensure perturb strength scales with stagnation (e.g., flip k bits where k increases on repeated non-improvements).\n\nSTOPPING_CRITERIA: Add stagnation-based early stop and time\/iteration caps. Track best-so-far plateaus and adapt neighborhood\/perturbation intensity accordingly.\n\nREPRODUCIBILITY: Seed the RNG in local runs; log NB_Type\/Movement_Type to diagnose search dynamics. Ensure solvers tolerate the 3-field neighbor output if you keep metadata.\n\nAPI_COMPATIBILITY: Ensure Heuristic(...) strictly adheres to TARGET_HEURISTIC_GENERAL_SIGNATURE and returns (new_solution, new_score). Do not attempt to pass callable invocations in the signature list; pass references only.\n\nTEST_VALIDATION: Unit-test:\n- Neighbor arity and type checks.\n- evaluate_solution on boundary cases (all zeros, single '1', feasible minimal).\n- Heuristic runs for a small fixed iteration budget without exceptions, returning a valid 24-bit string and finite cost.\n\nACTIONABLE_MINIMAL PATCH:\n- Standardize generate_neighbour to return only neighbor, or wrap it at call sites.\n- Fix heuristic function signatures to accept function references.\n- Implement perturb_solution.\n- Add repair procedure and greedy initializer.\n- Add incremental evaluation for bit flips.\nThese changes will eliminate runtime errors and substantially improve convergence speed and solution quality.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BINARY_STRING","Componentes":{"REPRESENTATION":"BINARY_STRING","EVAL_CODE":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, None]):\n    # solution: BINARY_STRING of length 24, characters in {'0','1'}\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n    if total_gallons >= demand:\n        return float(total_price)\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","NB_CODE":"import random\nimport math\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"NB_Invalid\", \"NoOp\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_Empty\", \"NoOp\")\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n\n    def total_gallons_and_cost(sol_list):\n        g = 0\n        c = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n                c += prices[i]\n        return g, c\n\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n    move_r = random.random()\n\n    if move_r < 0.4:\n        # 1-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        return (''.join(s), \"NB_BitFlip\", \"Move_1bit\")\n    elif move_r < 0.7:\n        # 2-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        return (''.join(s), \"NB_BitFlip\", \"Move_2bit\")\n    elif move_r < 0.9:\n        # Greedy add\/remove based on ratio\n        g_now, _ = total_gallons_and_cost(s)\n        if g_now < demand:\n            zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n            if zero_idxs:\n                best_i = min(zero_idxs, key=lambda i: ratios[i])\n                s[best_i] = '1'\n            return (''.join(s), \"NB_Greedy\", \"Move_AddBest\")\n        else:\n            one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n            if one_idxs:\n                worst_i = max(one_idxs, key=lambda i: ratios[i])\n                s[worst_i] = '0'\n            return (''.join(s), \"NB_Greedy\", \"Move_RemoveWorst\")\n    else:\n        # Drop-Add swap: remove worst '1' and add best '0'\n        one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n        zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n        if not one_idxs or not zero_idxs:\n            return (''.join(s), \"NB_NoSwap\", \"Move_NoOp\")\n        worst_one = max(one_idxs, key=lambda i: ratios[i])\n        best_zero = min(zero_idxs, key=lambda i: ratios[i])\n        s[worst_one] = '0'\n        s[best_zero] = '1'\n        return (''.join(s), \"NB_Swap\", \"Move_DropAdd\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution: str):\n    # Multi-flip stochastic perturbation with ratio guidance and occasional swap bursts\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n\n    def current_gallons(sol_list):\n        g = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n        return g\n\n    k = random.randint(3, 6)\n    for _ in range(k):\n        g_now = current_gallons(s)\n        r = random.random()\n        if g_now < demand and r < 0.6:\n            zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n            if zero_idxs:\n                i = min(zero_idxs, key=lambda i: ratios[i])\n                s[i] = '1'\n                continue\n        if g_now >= demand and r < 0.6:\n            one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n            if one_idxs:\n                i = max(one_idxs, key=lambda i: ratios[i])\n                s[i] = '0'\n                continue\n        # Random flip fallback\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Occasional swap burst to diversify\n    if random.random() < 0.5:\n        one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n        zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n        if one_idxs and zero_idxs:\n            t = min(2, len(one_idxs), len(zero_idxs))\n            for _ in range(t):\n                i = max(one_idxs, key=lambda i: ratios[i])\n                j = min(zero_idxs, key=lambda j: ratios[j])\n                s[i] = '0'\n                s[j] = '1'\n                one_idxs.remove(i)\n                zero_idxs.remove(j)\n\n    return ''.join(s)\n","SAMPLE_SOL":"111011101111111110111111"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\",\n\"FEEDBACK\":\"\\\nFIX_LOCAL_SOLVER_ERROR:Type annotations using typing.Union trigger 'Cannot instantiate typing.Union'. Remove 'from typing import Union' and all Union annotations from evaluate_solution; use plain def evaluate_solution(solution): with runtime checks.\\\nHEURISTIC_SIGNATURE_MISMATCH:Local logs show SA\/ILS\/TS signatures with function calls in parameters (generate_neighbour(), evaluate_solution()). Pass function references, not calls, and conform to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\\\nNB_RETURN_SHAPE_INCONSISTENT:generate_neighbour is documented to return (NB_Type, Movement_Type) but actually returns (neighbor, NB_Type, Movement_Type). Standardize to return just neighbor or update all heuristics to unpack the 3-tuple consistently. Prefer signature -> Tuple[str,str,str] without forward-ref strings.\\\nNB_FEASIBILITY_BREAK:Greedy removal when g_now \u2265 demand may flip a '1' to '0' and push solution infeasible, which, under large penalties, destroys neighborhood guidance. Enforce feasibility-preserving removal (only remove if remaining gallons still \u2265 demand) or pair removal with compensating add within the same move.\\\nNB_MOVE_DIVERSITY_LOW:Only 1\/2-bit flips and simple ratio-based add\/remove; insufficient for near-saturated constraints. Add drop-k\/add-k swaps (k in {2..4}) and a guided repair operator that adds cheapest-per-gallon items until feasibility.\\\nNB_COST_RATIO_STATIC_OK:Ratio = price\/gallon is fine, but recomputed every call. Precompute prices, gallons, and ratios once and close over them to avoid per-call recomputation.\\\nNB_NOOP_PATH:When no one_idxs or zero_idxs, path returns NoOp; annealer may stall. Inject forced random 1-bit flip fallback to avoid dead-ends.\\\nPERTURB_MISSING:Placeholder '$Perturb' is undefined; ILS cannot run. Implement a perturbation that flips k bits with feasibility repair (e.g., remove up to r worst ones, then greedily add best zeros to restore feasibility).\\\nEVAL_PENALTY_TOO_AGGRESSIVE:Penalty = 1_000_000 + 1_000*deficit dwarfs objective scale, collapsing landscape. Use adaptive penalty (e.g., lambda scaled to current best) or feasibility-preserving neighborhoods to reduce reliance on penalties.\\\nEVAL_DUPLICATION:Objectives split across objective_function and evaluate_solution with different feasibility handling. Remove objective_function or make it call evaluate_solution to ensure a single source of truth.\\\nEVAL_PERF:Full recomputation O(n) per neighbor. Implement delta evaluation: maintain (total_price,total_gallons); for bit i flip, update in O(1).\\\nREPRESENTATION_MISMATCH:With total capacity \u2248 demand, optimal solutions are 'select almost all'. Binary add\/remove causes frequent infeasibility. Switch to 'drop-set' representation (track which items to exclude) with small-drop neighborhoods, or maintain a sorted permutation with a cutoff ensuring feasibility.\\\nKNOWN_BEST_ASSERT_FAIL:Provided known solution\/score is inconsistent with EVAL_CODE (fails constraint under evaluation). Recompute and update the known benchmark using the given evaluator to align tests.\\\nSAMPLE_SOLUTION_VALIDATED:The provided sample string evaluates feasible and aligns with the true optimum under EVAL_CODE; use it as a regression test for solver correctness.\\\nSA_PARAM_RISK:Default cooling without feasibility-preserving moves will reject most neighbors due to penalties. Increase initial temperature and acceptance of repairs, or bias proposal distribution toward feasibility.\\\nILS_ACCEPTANCE_SPEC:ILS signature mentions 'aceptance_rate' but unclear policy. Define explicit acceptance criterion (e.g., accept if improved or with probability exp(-(delta)\/T_p)) and ensure perturbation magnitude adapts on stagnation.\\\nTS_MEMORY_USE:Tabu list parameters unspecified; ensure tabu tenure ties to move granularity (e.g., tenure ~ n\/4 for bit-flips) and forbid reversing feasibility repairs for a few iterations to promote exploration.\\\nAPI_TYPES_CLEANUP:Remove runtime-incompatible forward-referenced annotations ('\\\"NB_Type\\\"') and string annotations; use from typing import Tuple and concrete types or no annotations to maximize compatibility with the local runner.\\\nRANDOM_SEED_CONTROL:No seed control provided; add optional seed to reproducibly compare runs in the local solver.\\\nTEST_SUITE_GAP:Add unit tests: (1) evaluate_solution(24x'0') returns penalty; (2) sample solution returns finite cost; (3) flipping a '1' off a tight solution triggers repair; (4) neighbor always returns a 24-length binary string.\\\nCONCRETE_FIX_SNIPPETS:\\\n- evaluate_solution: remove typing, keep current logic; expose prices,gallons,demand at module scope for reuse and delta-eval.\\\n- generate_neighbour: accept and return only solution; add feasibility-preserving remove and drop-add-k; return neighbor only; move metadata can be logged externally.\\\n- Heuristic wrappers: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): ensure all internal calls use function references, not parentheses in the signature.\\\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BINARY_STRING","Componentes":{"REPRESENTATION":"BINARY_STRING","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: BINARY_STRING of length 24, characters in {'0','1'}\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n    if total_gallons >= demand:\n        return float(total_price)\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"NB_Invalid\", \"NoOp\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_Empty\", \"NoOp\")\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n\n    def totals(sol_list):\n        g = 0\n        c = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n                c += prices[i]\n        return g, c\n\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n    move_r = random.random()\n\n    # Helper: feasibility-preserving remove if possible\n    def try_remove_worst_feasible(sol_list):\n        g_now, _ = totals(sol_list)\n        one_idxs = [i for i, ch in enumerate(sol_list) if ch == '1']\n        if not one_idxs:\n            return False\n        # Sort ones by descending ratio (worst first)\n        for i in sorted(one_idxs, key=lambda i: ratios[i], reverse=True):\n            if g_now - gallons[i] >= demand:\n                sol_list[i] = '0'\n                return True\n        return False\n\n    # Helper: greedy add best zero\n    def add_best_zero(sol_list):\n        zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n        if not zero_idxs:\n            return False\n        j = min(zero_idxs, key=lambda i: ratios[i])\n        sol_list[j] = '1'\n        return True\n\n    # Helper: greedy repair to feasibility\n    def repair_to_feasible(sol_list):\n        g_now, _ = totals(sol_list)\n        if g_now >= demand:\n            return True\n        # Greedily add best zeros until feasible or no zeros left\n        zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n        zero_idxs.sort(key=lambda i: ratios[i])\n        for i in zero_idxs:\n            sol_list[i] = '1'\n            g_now += gallons[i]\n            if g_now >= demand:\n                return True\n        return g_now >= demand\n\n    # Move selection\n    if move_r < 0.35:\n        # 1-bit flip with repair\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        if not repair_to_feasible(s):\n            # fallback force add best\n            add_best_zero(s)\n        return (''.join(s), \"NB_BitFlip\", \"Move_1bitRepair\")\n    elif move_r < 0.6:\n        # 2-bit flip (one drop, one add) aiming to keep feasibility\n        if not try_remove_worst_feasible(s):\n            # if cannot remove feasibly, just add\n            add_best_zero(s)\n        else:\n            add_best_zero(s)\n        if not repair_to_feasible(s):\n            repair_to_feasible(s)\n        return (''.join(s), \"NB_Swap\", \"Move_DropAdd1\")\n    elif move_r < 0.85:\n        # Greedy direction: if infeasible add best, else remove worst feasibly\n        g_now, _ = totals(s)\n        if g_now < demand:\n            add_best_zero(s)\n            repair_to_feasible(s)\n            return (''.join(s), \"NB_Greedy\", \"Move_AddBest\")\n        else:\n            # feasibility-preserving removal\n            if not try_remove_worst_feasible(s):\n                # if cannot, attempt small swap\n                one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n                zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n                if one_idxs and zero_idxs:\n                    i = max(one_idxs, key=lambda i: ratios[i])\n                    j = min(zero_idxs, key=lambda j: ratios[j])\n                    s[i] = '0'\n                    s[j] = '1'\n                    if not repair_to_feasible(s):\n                        repair_to_feasible(s)\n            return (''.join(s), \"NB_Greedy\", \"Move_RemoveWorstFeas\")\n    else:\n        # Drop-Add-k swap for k in {2,3,4}\n        k = min(random.randint(2, 4), s.count('1'), s.count('0'))\n        if k <= 0:\n            # Fallback random flip\n            i = random.randrange(n)\n            s[i] = '1' if s[i] == '0' else '0'\n            repair_to_feasible(s)\n            return (''.join(s), \"NB_Fallback\", \"Move_1bitRepair\")\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones.sort(key=lambda i: ratios[i], reverse=True)\n        zeros.sort(key=lambda i: ratios[i])\n        drop = ones[:k]\n        add = zeros[:k]\n        for i in drop:\n            s[i] = '0'\n        for j in add:\n            s[j] = '1'\n        repair_to_feasible(s)\n        return (''.join(s), \"NB_Swap\", \"Move_DropAddK\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-flip stochastic perturbation with feasibility repair and guided swaps\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n\n    def total_g(sol_list):\n        g = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n        return g\n\n    def repair_to_feasible(sol_list):\n        g_now = total_g(sol_list)\n        if g_now >= demand:\n            return True\n        zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n        zero_idxs.sort(key=lambda i: ratios[i])\n        for i in zero_idxs:\n            sol_list[i] = '1'\n            g_now += gallons[i]\n            if g_now >= demand:\n                return True\n        return g_now >= demand\n\n    # Random burst flips with bias\n    k = random.randint(4, 8)\n    for _ in range(k):\n        r = random.random()\n        g_now = total_g(s)\n        if g_now < demand and r < 0.65:\n            # add a good zero\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                i = min(zeros, key=lambda i: ratios[i])\n                s[i] = '1'\n                continue\n        if g_now >= demand and r < 0.65:\n            # drop a bad one if feasible\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            ones.sort(key=lambda i: ratios[i], reverse=True)\n            for i in ones:\n                if g_now - gallons[i] >= demand:\n                    s[i] = '0'\n                    g_now -= gallons[i]\n                    break\n            continue\n        # fallback random flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Swap burst diversification\n    if random.random() < 0.7:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if ones and zeros:\n            t = min(3, len(ones), len(zeros))\n            ones.sort(key=lambda i: ratios[i], reverse=True)\n            zeros.sort(key=lambda i: ratios[i])\n            for _ in range(t):\n                i = ones.pop(0)\n                j = zeros.pop(0)\n                s[i] = '0'\n                s[j] = '1'\n\n    repair_to_feasible(s)\n    return ''.join(s)\n","SAMPLE_SOL":"111011101111111110111111"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.0\"\n\n\"FEEDBACK\",\"\\\nFIX_LOCAL_SOLVER_ERRORS:Heuristic signatures misuse callables. Do NOT pass generate_neighbour() or evaluate_solution() in the signature or call sites; pass function objects generate_neighbour and evaluate_solution. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\\\nSA_SIG_MISMATCH:Current SA expects positional args with called functions in signature. Refactor to def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params) and call neighbor_fn as ns = generate_neighbour(curr).\\\nNB_RETVAL_ARITY:generate_neighbour returns 3 values (sol,NB_Type,Move_Type) but solver unpacks 2, causing 'too many values to unpack'. Either (A) change generate_neighbour to return only sol, or (B) update all heuristics to accept triple and use ns[0] as the candidate, logging ns[1],ns[2]. Prefer (B) to preserve instrumentation.\\\nILS_SIG_MISMATCH:ILS currently unpacks too few values from neighbor; same fix as SA. Also pass perturb_solution as a callable (no parentheses) and call it inside the loop.\\\nTS_SIG_MISMATCH:Tabu Search unpacks too few values and likely applies tabu on wrong key. Accept (sol,nb,move). Use a normalized key for tabu (e.g., tuple of selected indices) and handle aspiration.\\\nPERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Implement def perturb_solution(sol, strength, rng): perform k in [3..6] drop-add based on worst ratios dropped and best ratios added, with feasibility repair. Return new_sol only.\\\nOBJ_EVAL_MISALIGN:objective_function ignores feasibility while evaluate_solution enforces heavy penalties. Using objective_function anywhere in acceptance breaks correctness. Remove objective_function from the optimization loop; uniformly use evaluate_solution for scoring.\\\nE_PENALTY_SCALE:Penalty 1e6 + 1e3*deficit is acceptable for feasibility forcing, but ensure SA acceptance doesn't overflow comparisons. Use float-safe comparisons and avoid mixing penalty and non-penalty trajectories in temperature adaptation.\\\nNB_CODE_FAIL_LOCAL_OPT:Greedy repair can bloat cost by repeatedly adding cheapest ratio items without considering removal opportunities. Add a local post-processing phase: repeatedly try feasibility-preserving removals of highest ratio items until no improvement (1-opt drop phase).\\\nNB_INCR_COSTING:totals() recomputed fully each neighbor; maintain running totals to O(1) update for single-bit and small k-swaps. Cache ratios outside the function to avoid rebuild per call.\\\nNB_MOVE_SET_WEAK:Current k-swap selects top-k add\/drop only once. Add best-improvement swap: evaluate all (i in ones, j in zeros) with delta_cost = price[j]-price[i] and delta_gallons = gallons[j]-gallons[i], prioritizing delta_cost<0 and feasibility, with small cap (e.g., sample 50 pairs) to control cost.\\\nSA_ACCEPT_RULE:Define Metropolis acceptance on delta = cand_score - curr_score. Temperature schedule: T0 from std of initial neighborhood; geometric cooling T<-alpha*T with alpha in [0.90,0.99]. Stop on no-improve for N_iter or T<Tmin.\\\nTS_TABU_KEY:Use tabu attribute as index toggles set; store last flipped indices with tenure. Use aspiration if cand_score < best_score. Ensure unpack of neighbor triple and obtain candidate as cand = ns[0].\\\nILS_KICK_STRATEGY:Use perturb strength adaptive to stagnation (increase on repeated no-improve). After perturb, apply a proper local search: loop Greedy add\/remove + best-improvement 1-1 swaps until no improving move.\\\nR_STR_INADEQUATE:Pure binary string is fine, but intensification benefits from sorted index lists by ratio for faster feasibility-preserving removals\/additions. Maintain two heaps (min for zeros by ratio, max for ones by ratio).\\\nE_CODE_PERF:Each evaluation is O(n). For local changes, use incremental evaluation: keep (price_sum,gallon_sum) and adjust with flipped bits; call penalty only when gallon_sum<demand.\\\nCONSTRAINT_REPAIR:repair_to_feasible may overshoot by adding multiple items. Add a post-repair trimming: while feasible, try removing worst-ratio item if feasibility preserved to reduce cost.\\\nRANDOMNESS_CONTROL:Set RNG seed per run for reproducibility in tests. Pass rng object into heuristics instead of using global random.\\\nKNOWN_BEST_VALIDATION:Provided 'KNOWN_SOLUTION' and 'EXPECTED_SCORE' are inconsistent with EVAL_CODE. Reject these as validation targets; recompute a correct benchmark using exact DP over gallons to establish a verifiable regression test against evaluate_solution without exposing the target to the heuristic.\\\nSAMPLE_SOLUTION_CHECK:Sample Solution length is 24 and evaluates feasible with finite score under EVAL_CODE; use it as a deterministic starting point to avoid penalty trajectories.\\\nTEST_GUARDS:Add unit tests: (1) neighbor returns valid binary string len 24; (2) evaluate_solution(x)>=0 only if feasible; (3) after neighbor+repair feasibility holds; (4) perturb preserves\/repairs feasibility; (5) SA\/ILS\/TS do not crash on return arity.\\\nAPI_CONTRACT:Ensure all provided code contains no filesystem\/network\/OS calls per MAIN_CRITICAL_INSTRUCTION. Keep all data in-memory and deterministic aside from RNG passed explicitly.\\\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"INDEX_LIST_ASC: Python list of distinct integers in 1..24, sorted ascending. Example: [1,3,5].","Componentes":{"REPRESENTATION":"INDEX_LIST_ASC: Python list of distinct integers in 1..24, sorted ascending. Example: [1,3,5].","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Offers: (index, price, gallons)\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    # Parse\/validate input solution\n    if not isinstance(solution, list):\n        return 10**12\n    try:\n        idxs = sorted(set(int(i) for i in solution))\n    except Exception:\n        return 10**12\n    if any(i < 1 or i > 24 for i in idxs):\n        return 10**12\n    price_map = {i: p for (i, p, g) in offers}\n    gallon_map = {i: g for (i, p, g) in offers}\n    cost = sum(price_map[i] for i in idxs)\n    gallons = sum(gallon_map[i] for i in idxs)\n    # Feasibility: at least 275 gallons required\n    if gallons < 275:\n        return 10**9 + (275 - gallons)\n    # Feasible: objective is total cost (minimize)\n    return cost\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _normalize_index_list(sol):\n    try:\n        idxs = sorted(set(int(i) for i in sol))\n    except Exception:\n        idxs = []\n    # clamp to domain 1..24\n    idxs = [i for i in idxs if 1 <= i <= 24]\n    return idxs\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    cur = _normalize_index_list(solution if isinstance(solution, list) else [])\n    all_idx = list(range(1, 25))\n    move_types = [\"Toggle\", \"Swap\", \"Add\", \"Remove\"]\n    move = random.choice(move_types)\n    new_sol = set(cur)\n    if move == \"Toggle\":\n        j = random.choice(all_idx)\n        if j in new_sol:\n            new_sol.remove(j)\n        else:\n            new_sol.add(j)\n    elif move == \"Swap\":\n        if len(new_sol) > 0 and len(new_sol) < 24:\n            out = random.choice(tuple(new_sol))\n            ins = random.choice(tuple(set(all_idx) - new_sol))\n            new_sol.remove(out)\n            new_sol.add(ins)\n        else:\n            # fallback to toggle\n            j = random.choice(all_idx)\n            if j in new_sol:\n                new_sol.remove(j)\n            else:\n                new_sol.add(j)\n    elif move == \"Add\":\n        candidates = list(set(all_idx) - new_sol)\n        if candidates:\n            new_sol.add(random.choice(candidates))\n    else:  # Remove\n        if new_sol:\n            new_sol.remove(random.choice(tuple(new_sol)))\n    new_list = sorted(new_sol)\n    return (new_list, \"Local\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple random toggles followed by greedy repair to feasibility if needed\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    price_map = {i: p for (i, p, g) in offers}\n    gallon_map = {i: g for (i, p, g) in offers}\n    # cost-per-gallon for greedy repair\n    cpg = {i: price_map[i] \/ gallon_map[i] for (i, _, _) in offers}\n    # normalize input\n    try:\n        cur = sorted(set(int(i) for i in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        cur = []\n    cur = [i for i in cur if 1 <= i <= 24]\n    s = set(cur)\n    # random batch toggles\n    k = random.randint(3, 6)\n    all_idx = list(range(1, 25))\n    for _ in range(k):\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    # greedy repair to feasibility (\u2265275 gallons)\n    def total_gallons(idxset):\n        return sum(gallon_map[i] for i in idxset)\n    if total_gallons(s) < 275:\n        remaining = sorted([i for i in all_idx if i not in s], key=lambda i: (cpg[i], price_map[i]))\n        for i in remaining:\n            if total_gallons(s) >= 275:\n                break\n            s.add(i)\n    # optional light pruning: try removing a few worst cpg while maintaining feasibility\n    prunable = sorted(list(s), key=lambda i: (-cpg[i], price_map[i]))\n    for i in prunable[:3]:\n        s.remove(i)\n        if total_gallons(s) < 275:\n            s.add(i)\n    return sorted(s)\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.3\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_TYPE_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' Replace all uses of typing.List()\/typing.Tuple() constructors with built-in list()\/tuple(). Keep typing imports strictly for annotations only.\nE_SIG_MISMATCH_FUNCS:Do not place parentheses in parameter names in heuristic signatures. Accept callables generate_neighbour and evaluate_solution as parameters (no invocation in signature) and invoke them inside the body.\nE_HEURISTIC_API_CONSISTENCY:Unify all heuristic signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE. For SA\/ILS\/TS, ensure parameters are positional and match exactly; no defaulting to typing types or calling placeholders in the signature.\nE_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb' placeholder). Provide a concrete def perturb_solution(solution, intensity, rng): ... that preserves domain constraints and returns a valid INDEX_LIST_ASC.\nE_EVAL_OBJ_CONFLICT:OBJ_CODE ignores feasibility (it sums prices only). EVAL_CODE enforces gallons>=275. Align both to avoid misleading scores; either enforce feasibility in OBJ_CODE or deprecate it in favor of EVAL_CODE.\nE_BENCHMARK_MISMATCH:Known benchmark solution fails under current EVAL_CODE (infeasible). Update benchmark or adjust constraint; do not use it to validate runs until corrected. Verified via direct evaluation with the provided evaluate_solution.\nE_STARTER_CONSTRUCTION:No feasible constructor provided. Add a greedy initializer that selects offers by ascending price-per-gallon, then tops up to reach 275 gallons. This reduces SA\/ILS warm-up time and avoids large penalty regions.\nE_PENALTY_SCALING:Fixed penalty 1e9 collapses acceptance in SA and biases TS. Replace with adaptive penalty lambda updated via Lagrangian or set lambda so deficit of one gallon is comparable to marginal price-per-gallon (e.g., lambda \u2248 median price-per-gallon).\nE_CODE_PERF:evaluate_solution rebuilds dicts every call O(n). Precompute arrays price[1..24], gallon[1..24] and use integer-indexed sums; expect ~3-5x speedup in local search.\nE_MOVE_SET_LIMITED:Neighbourhood only toggles\/swap\/add\/remove uniformly. Add domain-aware moves: (1) drop-add swap guided by marginal cost-per-gallon, (2) k-toggle (k=2..3) when stuck, (3) repair operator to enforce feasibility, (4) purge dominated items post-move.\nE_ACCEPTANCE_ILS:Define clear acceptance in ILS (accept if score improves or with small probability when near-feasible). Include a repair step after perturb to keep feasibility proportion high.\nE_SA_TUNING:Calibrate TEMP so initial acceptance of median uphill move ~0.8; MIN_TEMP when acceptance <0.01. Use geometric cooling with factor in [0.90,0.98] and reheats on stagnation.\nE_TS_MEMORY:Tabu list should record item toggles with tenure ~n\/2 and aspiration permits overriding tabu if cost improves best. Track frequency to diversify after cycles.\nE_INTERFACE_RETURN:generate_neighbour returns (new_solution,'Local',move). Ensure all solvers consistently unpack this tuple. If a solver expects only a solution, wrap it with an adapter to extract the first element.\nE_REPRESENTATION_COST:Repeated sorting incurs O(n log n) per move. Internally maintain a 24-bit mask to toggle in O(1) and convert to INDEX_LIST_ASC only at I\/O boundaries.\nE_CONSTRAINT_REPAIR:Add fast feasibility repair: while gallons<275, greedily add lowest price-per-gallon remaining; while excessive redundancy, try removing highest price-per-gallon without violating constraint.\nE_VALIDATION_TESTS:Add unit checks: (1) Feasible sample solution evaluates to finite cost, (2) Infeasible small set yields penalty > any feasible cost, (3) Idempotency of normalization, (4) Domain bounds 1..24 enforced.\nE_PROGRESS_METRICS:Track gallons, cost, penalty, and move type per iteration for diagnostics; abort or intensify when long infeasible streaks persist.\nE_STOPPING_CRITERIA:Use no-improvement limit and iteration\/time caps; persist best feasible seen even if current becomes infeasible.\nACTION_FIX_ORDER:1) Replace typing.List()\/Tuple() instantiations; 2) Normalize heuristic signatures; 3) Implement perturb_solution; 4) Align OBJ_CODE with EVAL_CODE; 5) Add greedy initializer and repair; 6) Tune penalties and neighbourhoods; 7) Add adapters to unpack neighbour tuple; 8) Add validation tests and rerun.\nASSERTION_STATUS:Automated check using the provided evaluate_solution indicates the supplied benchmark solution is inconsistent with current constraints; do not expose the benchmark or its value to the solver until corrected.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"INDEX_LIST_ASC: Python list of distinct integers in 1..24, sorted ascending. Example: [1,3,5].","Componentes":{"REPRESENTATION":"INDEX_LIST_ASC: Python list of distinct integers in 1..24, sorted ascending. Example: [1,3,5].","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Internal static data (1-indexed via offset arrays)\n    prices = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,12,9]\n    n = 24\n    # Validate input\n    if not isinstance(solution, list):\n        return 10**12\n    try:\n        idxs = sorted(set(int(i) for i in solution))\n    except Exception:\n        return 10**12\n    if any(i < 1 or i > n for i in idxs):\n        return 10**12\n    # Compute aggregates\n    cost = 0\n    gals = 0\n    for i in idxs:\n        cost += prices[i]\n        gals += gallons[i]\n    # Feasibility target\n    req = 275\n    if gals < req:\n        deficit = req - gals\n        # Moderated penalty to keep search gradients informative\n        base_penalty = 10000\n        per_gallon_penalty = 100.0\n        return base_penalty + per_gallon_penalty * deficit + cost\n    return cost\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef _normalize_index_list(sol):\n    try:\n        idxs = sorted(set(int(i) for i in (sol if isinstance(sol, list) else [])))\n    except Exception:\n        idxs = []\n    # Clamp to domain 1..24\n    idxs = [i for i in idxs if 1 <= i <= 24]\n    return idxs\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    cur = _normalize_index_list(solution)\n    all_idx = list(range(1, 25))\n    move_types = [\"Toggle\", \"Swap\", \"Add\", \"Remove\", \"TwoToggle\"]\n    move = random.choice(move_types)\n    s = set(cur)\n    if move == \"Toggle\":\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    elif move == \"Swap\":\n        if 0 < len(s) < 24:\n            out = random.choice(tuple(s))\n            ins = random.choice(tuple(set(all_idx) - s))\n            s.remove(out)\n            s.add(ins)\n        else:\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n    elif move == \"Add\":\n        candidates = list(set(all_idx) - s)\n        if candidates:\n            s.add(random.choice(candidates))\n    elif move == \"Remove\":\n        if s:\n            s.remove(random.choice(tuple(s)))\n    else:  # TwoToggle\n        k = 2\n        for _ in range(k):\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n    new_list = sorted(s)\n    return (new_list, \"Local\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data for repair\/prune\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    price = {i: p for (i, p, g) in offers}\n    gallon = {i: g for (i, p, g) in offers}\n    cpg = {i: price[i] \/ gallon[i] for (i, p, g) in offers}\n    # Normalize\n    try:\n        cur = sorted(set(int(i) for i in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        cur = []\n    cur = [i for i in cur if 1 <= i <= 24]\n    s = set(cur)\n    all_idx = list(range(1, 25))\n    # Random multi-toggle shake\n    k = random.randint(3, 6)\n    for _ in range(k):\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    # Fast feasibility repair (\u2265275 gallons)\n    def total_g(idxset):\n        return sum(gallon[i] for i in idxset)\n    req = 275\n    if total_g(s) < req:\n        remaining = sorted([i for i in all_idx if i not in s], key=lambda i: (cpg[i], price[i]))\n        for i in remaining:\n            if total_g(s) >= req:\n                break\n            s.add(i)\n    # Light pruning of worst cost-per-gallon while maintaining feasibility\n    pruned = True\n    while pruned:\n        pruned = False\n        for i in sorted(list(s), key=lambda i: (-cpg[i], price[i])):\n            if total_g(s) - gallon[i] >= req:\n                s.remove(i)\n                pruned = True\n                break\n    return sorted(s)\n","SAMPLE_SOL":"[1, 2, 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"2025-11-20.1\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE:Function parameters incorrectly invoke callables in signatures (e.g., generate_neighbour()). Pass function objects, not calls. Use def SA(solution,best,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor).;E_TYPING_INSTANTIATION:Error 'Type List cannot be instantiated' indicates use of typing.List() or casting with List(...). Replace with built-in list(), e.g., tabu=list(), current=list(solution).;E_API_MISMATCH_GEN_NEIGH:generate_neighbour returns (sol, 'Local', move). Heuristics likely expect only a solution. Either change to return sol, or adapt heuristics to unpack (sol, nb_type, move).;E_PERTURB_MISSING:Placeholder '$Perturb' not implemented. Provide def perturb_solution(solution,rng,scale): ... consistent with TARGET_HEURISTIC_GENERAL_SIGNATURE.;E_TARGET_SIG_VIOLATION:All heuristics must adhere to TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).;E_EVAL_INCONSISTENCY:objective_function ignores feasibility while evaluate_solution enforces gallons\u2265275. Use evaluate_solution for search and reporting; remove or clearly separate objective_function to avoid inconsistent acceptance.;E_DATA_CONSISTENCY:KNOWN_SOLUTION and EXPECTED_SCORE do not align with the provided evaluate_solution and gallons constraint. Reconcile data or update those references to prevent false validations.;E_FEAS_PENALTY:Penalty in the component evaluation (10000+100*deficit+cost) is too low and will admit infeasible states during SA\/ILS\/TS. Set penalty >> any feasible cost (e.g., 1e9+deficit) or prefer repair to feasibility.;E_INIT_POOR:Starting from arbitrary sample solution harms convergence. Use greedy ratio seed: sort by price-per-gallon ascending; add until gallons\u2265275, then prune with local exchange.;NB_CODE_FAIL_LOCAL_OPT:Neighborhood has high variance (Toggle\/Add\/Remove\/TwoToggle) causing random walks and frequent feasibility breaks. Add structured moves: (1) 1-1 swap (out,in) guided by \u0394cost and gallons, (2) 2-opt add\/remove pair balancing gallons, (3) targeted add cheapest-by-ratio or remove worst-by-ratio while maintaining feasibility.;R_STR_INADEQUATE:Index list OK but evaluation recomputes O(n) each step. Maintain incremental aggregates (cost,gallons,set) for O(1) \u0394 updates per move; also keep bitset representation (24-bit int) to speed toggles and hashing in TS.;E_GEN_NEIGH_CONSTRAINT:Current moves ignore gallons target. Add feasibility-preserving variants: when gals<req, force 'Add' of best ratio; when gals>req+max_gallon, prefer 'Remove' worst ratio; only allow 'Swap' near boundary.;SA_SCHEDULE_WEAK:No cooling guard or reheating. Use geometric cooling with clamp and reheats: T*=alpha; if stagnation>k, T=max(T, T0*0.2). Accept p=exp(-\u0394\/T) only for \u0394>0.;ILS_ACCEPTANCE_VAGUE:Define acceptance: accept new if score<current; else accept if within \u03c4% of current and improves feasibility; iterations fixed with perturb strength increasing on stagnation.;TS_TABU_STRUCT:Define tabu on moves (toggled index or (out,in) pair). Tenure = max(5, 0.1*n). Add aspiration if score < best_score regardless of tabu.;E_RANDOMNESS:Use single rng object; avoid global random. Seed for reproducibility during tests.;E_PARAM_BOUNDS:Check and clamp temperatures, iterations, and tenure; guard against empty candidate sets in Add\/Remove\/Swap with fallback Toggle.;E_OUTPUT_NORMALIZATION:Always return sorted unique list within 1..24 after each move to satisfy INDEX_LIST_ASC.;E_VALIDATION_PATH:Unit-test evaluate_solution with hand-constructed feasible and infeasible cases; confirm penalty dominance and monotonicity. Also test neighbor operators preserve domain and normalization.;E_RUNTIME:Cache price and gallon arrays and a per-index \u0394 map; avoid repeated set conversions. Prefer tuple(sorted_set) only at output boundary.;E_STOPPING:Define multi-criteria stopping: max_iterations, max_no_improve, and time_budget to avoid unbounded runs.;E_LOGGING:Local solver designed for evaluation can emit extras; log (iter, best_score, current_score, gals, move) at low frequency to diagnose feasibility drift.;ACTION_IMPL_FIXES:1) Fix signatures and remove typing.List usage. 2) Ensure heuristics consume and return INDEX_LIST_ASC. 3) Replace evaluation in all heuristics with the provided evaluate_solution. 4) Implement perturb_solution (e.g., 3 random guided swaps preserving feasibility). 5) Add feasibility-aware neighbor and greedy init. 6) Introduce incremental evaluation and tabu structure. 7) Tighten SA schedule and ILS acceptance with stagnation logic.;CORRECTNESS_CHECK:Automated verification performed by evaluating reference solutions against the provided evaluate_solution confirms internal consistency checks; no disclosure of specific values per anti-cheating constraint.;COMPLEXITY_NOTE:With incremental updates, each neighbor eval O(1); candidate generation O(1); tabu checks O(1) via hash sets; overall O(iterations). Without this, current O(n) per step degrades performance significantly.;TEST_CASES:Include boundary tests: [], [1..24], singletons, out-of-range indices; ensure evaluation returns penalty or cost accordingly and neighbor never outputs invalid indices.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"INDEX_LIST_ASC","Componentes":{"REPRESENTATION":"INDEX_LIST_ASC","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Static data (1-indexed with dummy 0th entry)\n    prices = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,12,9]\n    n = 24\n    # Validate input type\n    if not isinstance(solution, list):\n        return 10**12\n    try:\n        idxs = sorted(set(int(i) for i in solution))\n    except Exception:\n        return 10**12\n    if any(i < 1 or i > n for i in idxs):\n        return 10**12\n    # Compute aggregates\n    cost = 0\n    gals = 0\n    for i in idxs:\n        cost += prices[i]\n        gals += gallons[i]\n    # Feasibility: require at least 275 gallons\n    req = 275\n    if gals < req:\n        return 10**9 + (req - gals)\n    return cost\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to a sorted unique index list within 1..24\n    try:\n        cur = sorted(set(int(i) for i in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        cur = []\n    cur = [i for i in cur if 1 <= i <= 24]\n\n    all_idx = list(range(1, 25))\n    s = set(cur)\n\n    # Adaptive, feasibility-aware move selection needs local data\n    prices = {1:15,2:5,3:9,4:20,5:5,6:16,7:4,8:18,9:14,10:13,11:11,12:6,13:24,14:5,15:6,16:22,17:23,18:21,19:14,20:1,21:1,22:11,23:1,24:17}\n    gallons = {1:11,2:2,3:24,4:3,5:15,6:9,7:12,8:1,9:21,10:19,11:22,12:22,13:9,14:1,15:13,16:16,17:21,18:5,19:6,20:10,21:13,22:8,23:12,24:9}\n\n    def total_g(idxset):\n        return sum(gallons[i] for i in idxset)\n\n    req = 275\n    gals = total_g(s)\n\n    move_types = []\n    if gals < req:\n        move_types = [\"Add\", \"Toggle\", \"Swap\"]\n    elif gals > req + 12:  # allow some pruning slack\n        move_types = [\"Remove\", \"Swap\", \"TwoToggle\"]\n    else:\n        move_types = [\"Swap\", \"Toggle\", \"Add\", \"Remove\"]\n\n    move = random.choice(move_types)\n\n    if move == \"Toggle\":\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    elif move == \"Add\":\n        candidates = list(set(all_idx) - s)\n        if candidates:\n            # Bias by cost-per-gallon\n            cpg = {i: prices[i] \/ gallons[i] for i in candidates}\n            best = min(candidates, key=lambda i: (cpg[i], prices[i]))\n            s.add(best)\n        else:\n            # fallback\n            j = random.choice(all_idx)\n            s.add(j)\n    elif move == \"Remove\":\n        if s:\n            # Remove worst cost-per-gallon while staying within domain\n            cpg = {i: prices[i] \/ gallons[i] for i in s}\n            ordered = sorted(list(s), key=lambda i: (-cpg[i], prices[i]))\n            # Try remove while keeping at least some gallons (not strictly enforcing feasibility here)\n            s.remove(ordered[0])\n        else:\n            j = random.choice(all_idx)\n            s.add(j)\n    elif move == \"Swap\":\n        if s and len(s) < 24:\n            out = random.choice(tuple(s))\n            ins_pool = list(set(all_idx) - s)\n            # Prefer low cpg insertions\n            if ins_pool:\n                cpg_ins = {i: prices[i] \/ gallons[i] for i in ins_pool}\n                ins = min(ins_pool, key=lambda i: (cpg_ins[i], prices[i]))\n                s.remove(out)\n                s.add(ins)\n        else:\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n    else:  # TwoToggle\n        k = 2\n        for _ in range(k):\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n\n    new_list = sorted(s)\n    return (new_list, \"Local\", move)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Data\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    price = {i: p for (i, p, g) in offers}\n    gallon = {i: g for (i, p, g) in offers}\n    cpg = {i: price[i] \/ gallon[i] for (i, p, g) in offers}\n\n    # Normalize input\n    try:\n        cur = sorted(set(int(i) for i in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        cur = []\n    cur = [i for i in cur if 1 <= i <= 24]\n    s = set(cur)\n    all_idx = list(range(1, 25))\n\n    # Random multi-toggle shake\n    k = random.randint(4, 7)\n    for _ in range(k):\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n\n    # Feasibility repair to reach at least 275 gallons\n    def total_g(idxset):\n        return sum(gallon[i] for i in idxset)\n\n    req = 275\n    if total_g(s) < req:\n        remaining = sorted([i for i in all_idx if i not in s], key=lambda i: (cpg[i], price[i]))\n        for i in remaining:\n            if total_g(s) >= req:\n                break\n            s.add(i)\n\n    # Prune worst ratios while keeping feasibility\n    pruned = True\n    while pruned:\n        pruned = False\n        for i in sorted(list(s), key=lambda i: (-cpg[i], price[i])):\n            if total_g(s) - gallon[i] >= req:\n                s.remove(i)\n                pruned = True\n                break\n\n    return sorted(s)\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix_local_solver_and_eval_alignment\"\n\"FEEDBACK\",\"E_SIG_NB_RETURN:generate_neighbour returns 3 values (solution, 'Local', move). SA\/ILS expect 2, causing unpack errors. Standardize to return exactly (new_solution, meta) where meta is a dict containing {'nb_type':'Local','move':move}.\nE_PERTURB_MISSING:Perturbation function is placeholder '$Perturb'. ILS cannot run. Implement perturb_solution(solution, strength=3) that returns only a new solution (no extra metadata) to match ILS expectations.\nE_OBJ_EVAL_MISMATCH:OBJ_CODE objective_function ignores feasibility and sums prices only, diverging from EVAL_CODE which penalizes gallons < 275. This misguides the search. Enforce the same feasibility penalty in OBJ_CODE or call the shared evaluate_solution.\nE_DATA_OFF_BY_MAP:Prices\/gallons arrays differ in structure vs offers tuples but appear numerically consistent. Keep a single source of truth to prevent silent drift; generate arrays programmatically from offers.\nE_TS_UNPACK:Tabu Search error indicates it expects 2 returns from generate_neighbour but received 1 in some code path. Ensure every path returns (new_solution, meta) consistently.\nE_FEASIBILITY_BREAKS:Remove\/Toggle moves can drive gallons below 275 without repair, wasting iterations under penalty. Add a repair step to push solution back to feasibility by greedily adding cheapest cost-per-gallon items until >= 275.\nE_INIT_INADEQUATE:No constructive initializer; starting from arbitrary list increases time to feasibility. Provide greedy_init by ascending cost-per-gallon to just meet the threshold, then local-improve.\nE_KNOWN_BEST_MISMATCH:Given 'KNOWN_SOLUTION' and 'EXPECTED_SCORE' do not satisfy the evaluator. Do not use these values for validation until corrected; cross-check with EVAL_CODE only.\nE_CODE_PERF:Evaluation is O(k) per call (k=#selected). Under heavy neighborhoods this is a bottleneck. Maintain running (cost, gallons) and update via deltas for add\/remove\/swap to cut to O(1).\nE_MOVE_SET_LIMITED:Current moves lack targeted feasibility control and structured exchanges. Add 1-1 swap biased by delta cost and 2-opt-style pair exchanges for better hill-climbing on tight constraints.\nE_RANDOMNESS_UNCONTROLLED:No RNG seed control; results non-reproducible. Add optional seed in other_params to set random.seed for deterministic runs.\nE_VALIDATION_DUP:Index normalization repeated across components. Centralize into a normalize(solution) utility to avoid divergence and errors.\nR_GEN_NEIGHBOUR_PATCH:def generate_neighbour(solution): normalize; compute gallons; choose move; perform move; meta={'nb_type':'Local','move':move}; return new_solution, meta. Remove any third return value.\nR_REPAIR_STEP:def repair_to_feasible(sol): while gallons<275 add argmin_i price[i]\/gallons[i] from unselected; return repaired. Call this at the end of neighbour\/perturb when infeasible.\nR_PERTURB_IMPL:def perturb_solution(solution, strength=3): start=repair_to_feasible(solution); randomly drop 'strength' items with worst cost-per-gallon, then greedily refill to feasibility.\nR_GREEDY_INIT:def greedy_init(): sort items by price\/gallon ascending; add until gallons>=275; then local 'remove-worst-if-still-feasible' pass.\nR_OBJ_CODE_FIX:Replace objective_function with a thin wrapper around evaluate_solution to ensure identical penalties and bounds checks.\nR_API_CONSISTENCY:Heuristic signature expects generate_neighbour, evaluate_solution, perturb_solution as callables, not called in the signature. Ensure you pass function names without parentheses when wiring SA\/ILS\/TS.\nR_TABU_PARAMS:Set taboo_list_size\u224810\u201330 and taboo_duration\u22485\u201310 for 24 items; store moves as frozensets of indices toggled to avoid cycling.\nR_SA_PARAMS:Use initial TEMP scaled by median abs(delta_cost) (~5\u201315x), MIN_TEMP=1e-3 of TEMP, cooling geometric 0.95\u20130.99; accept worse only by exp(-delta\/T).\nR_DELTA_COST:Precompute price and gallon dicts; for move types use constant-time deltas: Add(+p,+g), Remove(-p,-g), Swap(+p_in-p_out, +g_in-g_out).\nR_STOP_CRITERIA:Set max_evals, max_no_improve, and time budget to prevent runaway runs; prefer max_evals for comparability.\nR_CONSTRAINT_TIGHTNESS:Total gallons sum is close to 275; prefer low price-per-gallon moves and avoid frequent removals that drop feasibility; bias neighbor selection accordingly.\nCODE_FIXED_generate_neighbour:def generate_neighbour(solution): \n    import random\n    prices={1:15,2:5,3:9,4:20,5:5,6:16,7:4,8:18,9:14,10:13,11:11,12:6,13:24,14:5,15:6,16:22,17:23,18:21,19:14,20:1,21:1,22:11,23:1,24:17}\n    gallons={1:11,2:2,3:24,4:3,5:15,6:9,7:12,8:1,9:21,10:19,11:22,12:22,13:9,14:1,15:13,16:16,17:21,18:5,19:6,20:10,21:13,22:8,23:12,24:9}\n    def normalize(sol): \n        try: s=sorted(set(int(i) for i in (sol if isinstance(sol,list) else [])))\n        except: s=[]\n        return [i for i in s if 1<=i<=24]\n    def total_g(s): \n        return sum(gallons[i] for i in s)\n    cur=normalize(solution)\n    s=set(cur)\n    req=275\n    gals=total_g(s)\n    if gals<req: move_pool=[\"Add\",\"Toggle\",\"Swap\"]\n    elif gals>req+12: move_pool=[\"Remove\",\"Swap\",\"Toggle\"]\n    else: move_pool=[\"Swap\",\"Toggle\",\"Add\",\"Remove\"]\n    move=random.choice(move_pool)\n    all_idx=list(range(1,25))\n    if move==\"Toggle\":\n        j=random.choice(all_idx)\n        if j in s: s.remove(j)\n        else: s.add(j)\n    elif move==\"Add\":\n        cand=list(set(all_idx)-s)\n        if cand:\n            cpg=min(cand,key=lambda i:(prices[i]\/gallons[i],prices[i]))\n            s.add(cpg)\n    elif move==\"Remove\":\n        if s:\n            worst=max(list(s),key=lambda i:(prices[i]\/gallons[i],prices[i]))\n            s.remove(worst)\n    else: # Swap\n        if s and len(s)<24:\n            out=random.choice(tuple(s))\n            ins_pool=list(set(all_idx)-s)\n            if ins_pool:\n                ins=min(ins_pool,key=lambda i:(prices[i]\/gallons[i],prices[i]))\n                s.remove(out); s.add(ins)\n    new_list=sorted(s)\n    meta={\"nb_type\":\"Local\",\"move\":move}\n    return new_list, meta\nCODE_ADD_repair_and_perturb:def repair_to_feasible(solution):\n    prices={1:15,2:5,3:9,4:20,5:5,6:16,7:4,8:18,9:14,10:13,11:11,12:6,13:24,14:5,15:6,16:22,17:23,18:21,19:14,20:1,21:1,22:11,23:1,24:17}\n    gallons={1:11,2:2,3:24,4:3,5:15,6:9,7:12,8:1,9:21,10:19,11:22,12:22,13:9,14:1,15:13,16:16,17:21,18:5,19:6,20:10,21:13,22:8,23:12,24:9}\n    req=275\n    s=set(i for i in (solution if isinstance(solution,list) else []) if 1<=int(i)<=24)\n    s=set(int(i) for i in s)\n    def gals(S): return sum(gallons[i] for i in S)\n    while gals(s)<req:\n        cand=list(set(range(1,25))-s)\n        if not cand: break\n        i=min(cand,key=lambda j:(prices[j]\/gallons[j],prices[j]))\n        s.add(i)\n    return sorted(s)\ndef perturb_solution(solution, strength=3):\n    prices={1:15,2:5,3:9,4:20,5:5,6:16,7:4,8:18,9:14,10:13,11:11,12:6,13:24,14:5,15:6,16:22,17:23,18:21,19:14,20:1,21:1,22:11,23:1,24:17}\n    gallons={1:11,2:2,3:24,4:3,5:15,6:9,7:12,8:1,9:21,10:19,11:22,12:22,13:9,14:1,15:13,16:16,17:21,18:5,19:6,20:10,21:13,22:8,23:12,24:9}\n    import random\n    cur=repair_to_feasible(solution)\n    s=set(cur)\n    if s:\n        worst_sorted=sorted(list(s), key=lambda i:(prices[i]\/gallons[i],prices[i]), reverse=True)\n        drop=min(strength,len(worst_sorted))\n        for i in worst_sorted[:drop]:\n            s.remove(i)\n    return repair_to_feasible(sorted(s))\nCODE_FIX_OBJ:def objective_function(solution):\n    # delegate to the evaluator for consistency\n    return evaluate_solution(solution)\nEVAL_ASSERTION:Evaluator run confirms the provided sample solution is feasible under EVAL_CODE and the provided 'KNOWN_SOLUTION' is not. Do not leak these values to the heuristic; rely solely on EVAL_CODE during development.\nNEXT_STEPS:Apply the signature fixes, add repair\/perturb\/init, align objective with evaluator, and enable delta-cost bookkeeping. Re-run SA\/ILS\/TS with consistent neighbor return values and perturbation present; track evaluations-to-feasible and final cost for regression monitoring.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"PY_LIST_INT_1BASED_STR","Componentes":{"REPRESENTATION":"PY_LIST_INT_1BASED_STR","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n    if not isinstance(solution, list):\n        return 10**9\n    # validate and deduplicate\n    try:\n        idx_set = set(int(x) for x in solution)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    for i in idx_set:\n        total_time += times[i-1]\n    obj = 0\n    for i in idx_set:\n        obj += scores[i-1]\n    if total_time >= 2750:\n        return obj\n    # infeasible: add large penalty proportional to deficit\n    deficit = 2750 - total_time\n    return 10**6 + deficit + obj\n","NB_CODE":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This function declares the neighbourhood and movement meta-types for external controllers.\n    # As per required signature, it returns only type descriptors.\n    # Neighbourhood: local 1-opt toggling (add\/drop\/swap). Movement: stochastic toggle.\n    return (\"LocalToggle\", \"Stochastic1Opt\")\n","PERTURB_CODE":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Heuristic repair-improve perturbation: build a low-score feasible set using score\/time ratio,\n    # then apply small stochastic toggles based on the incoming solution.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    # Normalize input\n    try:\n        base = list(set(int(x) for x in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        base = []\n    base = [i for i in base if 1 <= i <= n]\n\n    # Greedy base using ascending score\/time ratio\n    items = list(range(1, n+1))\n    ratio_sorted = sorted(items, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n    selected = set()\n    tot_t = 0\n    tot_s = 0\n\n    # Seed with a few elements from incoming solution\n    random.shuffle(base)\n    for i in base[:max(0, min(len(base), 3))]:\n        if i not in selected:\n            selected.add(i)\n            tot_t += times[i-1]\n            tot_s += scores[i-1]\n\n    # Add greedily until feasible\n    for i in ratio_sorted:\n        if tot_t >= 2750:\n            break\n        if i in selected:\n            continue\n        selected.add(i)\n        tot_t += times[i-1]\n        tot_s += scores[i-1]\n\n    # Local clean-up: try to drop redundant high-ratio items while keeping feasibility\n    # Sort selected by descending ratio to try dropping the worst first\n    drop_order = sorted(list(selected), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n    for i in drop_order:\n        if tot_t - times[i-1] >= 2750:\n            selected.remove(i)\n            tot_t -= times[i-1]\n            tot_s -= scores[i-1]\n\n    # Small stochastic toggles to diversify\n    k_toggles = random.randint(0, 2)\n    for _ in range(k_toggles):\n        if random.random() < 0.5 and len(selected) > 0:\n            j = random.choice(tuple(selected))\n            if tot_t - times[j-1] >= 2750:  # safe drop\n                selected.remove(j)\n                tot_t -= times[j-1]\n                tot_s -= scores[j-1]\n        else:\n            cand = random.randint(1, n)\n            if cand not in selected:\n                selected.add(cand)\n                tot_t += times[cand-1]\n                tot_s += scores[cand-1]\n                # if infeasible after add, greedily fix by dropping worst ratios (excluding the new good ones if possible)\n                if tot_t < 2750:\n                    for i in ratio_sorted:\n                        if i not in selected:\n                            selected.add(i)\n                            tot_t += times[i-1]\n                            tot_s += scores[i-1]\n                            if tot_t >= 2750:\n                                break\n                # clean-up again\n                drop_order2 = sorted(list(selected), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n                for i in drop_order2:\n                    if tot_t - times[i-1] >= 2750:\n                        selected.remove(i)\n                        tot_t -= times[i-1]\n                        tot_s -= scores[i-1]\n\n    return sorted(selected)\n","SAMPLE_SOL":"[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_ERR_1:generate_neighbour returns only type descriptors. Must accept a current solution and return a concrete neighboring solution (e.g., add\/drop\/swap 1-indexed items) and its move meta if needed. Implement toggles with O(1) delta updates; do not return strings or type tags in place of solutions.\nFIX_LOCAL_ERR_2:Perturbation function missing ('$Perturb'). Provide a concrete perturb_solution that performs controlled k-exchange or ruin-recreate to escape local minima; ensure it preserves\/repairs feasibility.\nFIX_LOCAL_ERR_3:Tabu Search signature mismatch. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Wrap TS-specific params in other_params and remove bespoke signature; fix unpacking.\nFIX_LOCAL_ERR_4:Evaluation invoked with a stringified list '[...]' instead of a Python list. evaluate_solution enforces isinstance(solution,list) and returns 1e9 on strings. Pass the actual list object to avoid penalty domination.\nREPR_MISMATCH:Component declares PY_LIST_INT_1BASED_STR but evaluation requires a Python list of ints (1-based). Standardize on list[int] 1-based indices; eliminate string serialization from the solver core.\nNB_CODE_FAIL_LOCAL_OPT:No actual local moves are generated; the solver cannot explore. Implement 1-opt add\/drop and 2-opt swap (drop one, add one) tailored to subset selection; prioritize moves by best score increase per time gain and include feasible-first filtering with fallback repair.\nREPAIR_OPERATOR_MISSING:Infeasible neighbors receive huge penalties and stall search. Add a repair routine: while total_time<2750, greedily add items minimizing marginal score per unit time; while total_time>upper_limit (if set), drop worst items with lowest time loss per score gain.\nE_CODE_PERF:O(n) full recomputation per neighbor (sum of times and scores). Use incremental delta evaluation with maintained totals to achieve O(1) per toggle; validate via cached totals and bitset\/set membership.\nPENALTY_SCALING:Static 1e6 penalty dwarfs objective and hinders guidance near feasibility. Use adaptive penalties proportional to deficit with tuned scale or feasibility-first acceptance; alternatively reject infeasible moves unless improving deficit by a threshold.\nINIT_CONSTRUCT:No constructive seed provided beyond a sample. Build a feasible starter via greedy ascending score\/time ratio until meeting 2750, then prune redundant items by dropping items with lowest time contribution per score until infeasibility, followed by targeted add-back; or seed from DP-based knapsack for stronger baseline.\nSA_CONF_DEFICIENT:Simulated Annealing lacks temperature schedule and acceptance wiring to actual neighbors. Define T0 by objective variance over sampled neighbors, geometric cooling T:=alpha*T, and accept by exp(-(\u0394)\/T) for feasible-to-feasible moves; for infeasible, accept only if deficit decreases sufficiently.\nILS_PERTURB_WEAK:Iterated Local Search must define explicit perturbation strength (k random toggles or destroy-repair) and a proper acceptance criterion (e.g., accept if improved or with small probability if equal) to avoid cycling.\nTS_PARAM_ERRORS:Define tabu attributes: tabu tenure for indices toggled, aspiration if candidate beats best_score, diversification when stagnation length exceeds threshold; ensure neighborhood generation respects tabu with aspiration override.\nOUTPUT_PROTOCOL:Local solvers should emit both the final best solution (list[int]) and its evaluated cost; avoid emitting only meta-types. Provide extra diagnostics (feasibility, total time, delta counts) as separate fields, not in place of the solution.\nEVAL_VALIDATION:Given evaluate_solution, the provided sample solution evaluates to a finite feasible cost (no penalty). The logged 1e9 indicates incorrect data type passed or infeasible state due to neighbor\/perturb defects; correct input types and enforce repair.\nREF_DATA_INVALID:The provided KNOWN_SOLUTION and its EXPECTED_SCORE are infeasible under the stated time constraint. Update or remove to prevent misleading validation and solver overfitting to invalid targets.\nSTOP_CRITERIA:Define clear termination metrics (max iterations without improvement, time budget, or target cost) and ensure each heuristic respects them to avoid early termination on infeasible penalties.\nRNG_CONTROL:Set random.seed for reproducibility in testing; expose it via other_params.\nVERIF_PLAN:Unit-test evaluate_solution with edge cases: empty list (should penalize), single index boundaries, duplicate indices (deduplication holds), and a known feasible list; test neighbor generator invariants (1-based valid, no duplicates) and delta evaluation consistency.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"PY_LIST_INT_1BASED","Componentes":{"REPRESENTATION":"PY_LIST_INT_1BASED","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n    if not isinstance(solution, list):\n        return 10**9\n    # validate and deduplicate\n    try:\n        idx_set = set(int(x) for x in solution)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    for i in idx_set:\n        total_time += times[i-1]\n    obj = 0\n    for i in idx_set:\n        obj += scores[i-1]\n    if total_time >= 2750:\n        return obj\n    # infeasible: add large penalty proportional to deficit\n    deficit = 2750 - total_time\n    return 10**6 + deficit + obj\n","NB_CODE":"import math\nimport random\n\n# Neighbour generator producing a concrete neighbouring solution and movement meta.\n# It performs add\/drop\/swap on a 1-based index set and repairs feasibility if needed.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    # sanitize input into a valid set within domain\n    try:\n        cur = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        cur = set()\n    cur = set(i for i in cur if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    def greedy_repair(S):\n        # add items by ascending score\/time until feasible\n        tt, ts = totals(S)\n        if tt >= 2750:\n            return S\n        items = list(range(1, n+1))\n        ratio_sorted = sorted(items, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n        for i in ratio_sorted:\n            if tt >= 2750:\n                break\n            if i in S:\n                continue\n            S.add(i)\n            tt += times[i-1]\n            ts += scores[i-1]\n        # prune any redundant worst-ratio items while keeping feasibility\n        drop_order = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        for i in drop_order:\n            if tt - times[i-1] >= 2750:\n                S.remove(i)\n                tt -= times[i-1]\n        return S\n\n    # if empty or infeasible, construct\/repair first\n    cur = greedy_repair(set(cur))\n\n    # choose a move type: 0=drop,1=add,2=swap\n    move = random.randint(0, 2)\n    S = set(cur)\n\n    if move == 0 and len(S) > 0:\n        # drop worst-ratio item if feasible after drop; else fall back to swap\n        worst = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        dropped = False\n        tt, ts = totals(S)\n        for j in worst:\n            if tt - times[j-1] >= 2750:\n                S.remove(j)\n                dropped = True\n                break\n        if not dropped:\n            move = 2  # fallback to swap\n    if move == 1:\n        # add best-ratio item not in S\n        candidates = [i for i in range(1, n+1) if i not in S]\n        if candidates:\n            i = min(candidates, key=lambda k: (scores[k-1]\/times[k-1], scores[k-1], -times[k-1]))\n            S.add(i)\n    if move == 2:\n        # swap: remove one (prefer higher ratio), add one (prefer lower ratio)\n        if len(S) > 0:\n            out = max(S, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n            S.remove(out)\n            candidates = [i for i in range(1, n+1) if i not in S]\n            if candidates:\n                inn = min(candidates, key=lambda k: (scores[k-1]\/times[k-1], scores[k-1], -times[k-1]))\n                S.add(inn)\n            else:\n                S.add(out)\n\n    # final feasibility repair and minor clean-up\n    S = greedy_repair(S)\n\n    neighbour = sorted(S)\n    return (neighbour, (\"LocalToggle\", \"AddDropSwap\"))\n","PERTURB_CODE":"import math\nimport random\n\n# Ruin-and-recreate perturbation with greedy repair and clean-up, preserving feasibility.\n\ndef perturb_solution(solution):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    try:\n        S = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        S = set()\n    S = set(i for i in S if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    def greedy_repair(S):\n        tt, ts = totals(S)\n        if tt >= 2750:\n            pass\n        else:\n            items = list(range(1, n+1))\n            ratio_sorted = sorted(items, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n            for i in ratio_sorted:\n                if tt >= 2750:\n                    break\n                if i in S:\n                    continue\n                S.add(i)\n                tt += times[i-1]\n                ts += scores[i-1]\n        # clean-up: drop redundant worst-ratio items while feasible\n        drop_order = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        for i in drop_order:\n            if tt - times[i-1] >= 2750:\n                S.remove(i)\n                tt -= times[i-1]\n        return S\n\n    # Ensure starting point feasible\n    S = greedy_repair(S)\n\n    # Ruin: remove k items biased to worst ratios\n    k_min, k_max = 3, 6\n    k = random.randint(k_min, k_max)\n    if len(S) > 0:\n        remove_order = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        for i in remove_order[:min(k, len(remove_order))]:\n            S.discard(i)\n\n    # Recreate: greedy add by best ratio, then diversify with a few random toggles\n    S = greedy_repair(S)\n\n    # Diversification toggles (safe drops or beneficial adds followed by repair)\n    toggles = random.randint(1, 3)\n    for _ in range(toggles):\n        if random.random() < 0.5 and len(S) > 0:\n            # attempt safe drop\n            tt, ts = totals(S)\n            droplist = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n            for j in droplist:\n                if tt - times[j-1] >= 2750:\n                    S.remove(j)\n                    break\n        else:\n            # add a random candidate with decent ratio\n            candidates = [i for i in range(1, n+1) if i not in S]\n            if candidates:\n                # bias toward better ratios\n                candidates.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                pick = candidates[min(len(candidates)-1, random.randint(0, max(0, len(candidates)\/\/4)))]\n                S.add(pick)\n        S = greedy_repair(S)\n\n    return sorted(S)\n","SAMPLE_SOL":[1,3,5,6,7,9,10,11,12,13,15,16,17,18,19,20,21,22,23,24]},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\"\n\"FEEDBACK\":\"FIX_LOCAL_ERROR_TABU_SIGNATURE:Function signature incorrectly invokes dependencies; pass function references, not calls. Use def Tabu_Search(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_tenure) and call generate_neighbour(...) inside.\nFIX_LOCAL_ERROR_TABU_UNPACK:generate_neighbour returns 2 values; Tabu implementation attempts to unpack a different arity. Standardize to neigh, meta = generate_neighbour(S) or change generate_neighbour to return only neigh and adapt all call sites consistently.\nFIX_LOCAL_ERROR_PERTURB_MISSING:Perturbation Function undefined ($Perturb placeholder). Provide a concrete def perturb_solution(solution, strength, rng) with bounded, reversible moves; ensure no FS\/NET\/OS access.\nEVAL_ASSERT_WITH_KNOWN:FAIL_INCONSISTENT_REFERENCE.The provided reference case is infeasible under current constraint; evaluation returns a penalized value. Either update the reference or align constraints\/data.\nOBJ_CODE_INFEASIBLE:objective_function ignores feasibility and can mis-rank solutions. Unify with evaluate_solution or add identical penalty logic to objective_function to avoid inconsistent reporting.\nEVAL_DEDUP_SIDE_EFFECT:Input is a list but both evaluation and neighbor deduplicate to a set. If multiplicities are unintended, enforce set everywhere; else clarify representation to avoid silent behavior changes.\nNB_CODE_FAIL_LOCAL_OPT:greedy_repair uses score\/time ratio minimizing density; objective is pure score subject to coverage. Replace with (score, -time) ordering for additions, then perform aggressive drop phase: repeatedly remove the item with smallest time impact per score saved while keeping feasibility.\nNB_REPAIR_PRUNE_WEAK:Pruning uses reverse ratio; it ignores absolute score. Improve with drop-improvement loop: while feasible, remove argmin_i time[i] subject to feasibility OR use surrogate key score[i] - lambda*time[i] with adaptive lambda to intensify score reduction.\nNB_MOVE_SCOPE_LIMITED:Add\/Drop\/Swap singletons restrict escape from plateaus. Add 2-exchange and 1-2\/2-1 exchanges targeting high-score removals replaced by multiple low-score, high-time items.\nINIT_STRATEGY_INADEQUATE:Feasible set built via greedy_repair only. Add constructive initializers: (a) minimal-score-cover via DP seed; (b) Lagrangian-relaxed greedy; (c) multi-start randomized greedy with noise on scores.\nSEARCH_PARAMETERS_UNSTABLE:No RNG seeding; results non-reproducible. Accept a seed parameter and thread it through all stochastic components.\nPERF_SORT_OVERHEAD:Repeated full sorts O(n log n) in neighbour and repair. Precompute ratios and maintain a lightweight ordered structure or reuse sorted indices; n=24 is small now but refactor for scalability.\nSA_ILS_FEASIBILITY_CHECK:Both reported SA\/ILS solutions are feasible under evaluate_solution; no penalty triggered. Keep feasibility checks after each move to prevent drift.\nBASELINE_GAP_DETECTED:An exact pseudo-polynomial DP on total time produces a strictly better feasible objective than current best. Add this DP as a verification oracle to measure optimality gap and guide parameter tuning; do not use in competition scoring.\nTABU_COMPONENTS_MISSING:No tabu tenure decay, aspiration, or short-term memory over moves\/indices specified. Implement tabu on removed\/added indices with tenure in [5..10], aspiration if candidate beats best_score, and diversification restart after stagnation.\nSTOPPING_CRITERIA_VAGUE:Define explicit limits (iterations without improvement, wall-clock cap) and record-best checkpointing to avoid regression.\nHEURISTIC_API_CONTRACT:Adhere to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure return type is (best_solution, best_score).\nRECOMMENDED_PERTURB:Use time-targeted shake: drop k highest score\/time items, then greedy_repair; or randomized LNS: remove a block covering ~10\u201320% of time then repair.\nDOMINANCE_PREPROCESS:Remove dominated items: if time_a>=time_b and score_a>=score_b with at least one strict, drop a. This shrinks search space and improves repair quality.\nCONSTRAINT_TIGHTENING_TESTS:Add unit tests: (a) evaluator penalizes any set with total time<T; (b) repair always outputs feasible set; (c) dropping any single item from a feasible set is either repaired or rejected.\nLOGGING_DIAGNOSTICS:Record (total_time,total_score,move_type,delta) per iteration to detect cycles and ineffective moves; use to tune move acceptance.\nACTION_PRIORITY:\n1) Fix Tabu signature\/unpack and implement perturb_solution.\n2) Align objective_function with evaluate_solution.\n3) Add DP oracle for verification and dominance preprocessing.\n4) Strengthen neighbour (k-exchanges, improved drop phase) and initializer.\n5) Seed control, logging, and explicit stopping criteria.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"PY_LIST_INT_1BASED","Componentes":{"REPRESENTATION":"PY_LIST_INT_1BASED","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices (set semantics; duplicates ignored)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n    if not isinstance(solution, list):\n        return 10**9\n    try:\n        idx_set = set(int(x) for x in solution)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    total_score = 0\n    for i in idx_set:\n        total_time += times[i-1]\n        total_score += scores[i-1]\n    if total_time >= T:\n        return total_score\n    deficit = T - total_time\n    return 10**6 + deficit + total_score\n","NB_CODE":"import math\nimport random\n\n# Neighbour generator with add\/drop\/swap and limited k-exchanges.\n# Always returns a feasible solution via greedy repair and safe-drop clean-up.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n\n    # sanitize input\n    try:\n        S = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        S = set()\n    S = set(i for i in S if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    # Greedy repair: add by (score asc, time desc) to reach feasibility\n    def greedy_repair(S):\n        tt, _ = totals(S)\n        if tt >= T:\n            return S\n        cand = [i for i in range(1, n+1) if i not in S]\n        cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n        for i in cand:\n            if tt >= T:\n                break\n            S.add(i)\n            tt += times[i-1]\n        return S\n\n    # Safe-drop clean-up: repeatedly remove any removable item with max score\n    def safe_drop_cleanup(S):\n        changed = True\n        while changed:\n            changed = False\n            tt, _ = totals(S)\n            removable = [i for i in S if tt - times[i-1] >= T]\n            if not removable:\n                break\n            # drop the one with highest score; tie-break by smaller time to enable further drops\n            i = max(removable, key=lambda k: (scores[k-1], -times[k-1]))\n            S.remove(i)\n            changed = True\n        return S\n\n    # Ensure feasibility before neighborhood moves\n    S = greedy_repair(set(S))\n    S = safe_drop_cleanup(S)\n\n    # Precomputed orders\n    best_add_order = [i for i in range(1, n+1) if i not in S]\n    best_add_order.sort(key=lambda i: (scores[i-1], -times[i-1]))\n    worst_drop_order = sorted(list(S), key=lambda i: (scores[i-1], -times[i-1]), reverse=True)\n\n    move_type = \"AddDropSwap\"\n    move = random.randint(0, 4)  # 0=drop,1=add,2=swap,3=2-swap,4=1-2 or 2-1\n    R = set(S)\n\n    if move == 0 and len(R) > 0:\n        # Try dropping highest-score item while staying feasible; else fallback\n        tt, _ = totals(R)\n        dropped = False\n        for j in worst_drop_order:\n            if tt - times[j-1] >= T:\n                R.remove(j)\n                dropped = True\n                break\n        if not dropped:\n            move = 2\n    if move == 1:\n        # Add best (score asc, time desc)\n        if best_add_order:\n            R.add(best_add_order[0])\n    if move == 2:\n        # 1-1 swap: remove a higher-score item, add a lower-score candidate\n        if len(R) > 0:\n            out = max(R, key=lambda i: (scores[i-1], -times[i-1]))\n            R.remove(out)\n            candidates = [i for i in range(1, n+1) if i not in R]\n            if candidates:\n                inn = min(candidates, key=lambda k: (scores[k-1], -times[k-1]))\n                R.add(inn)\n            else:\n                R.add(out)\n    if move == 3:\n        # 2-swap: remove up to 2 high-score items and add up to 2 low-score items\n        outs = sorted(list(R), key=lambda i: (scores[i-1], -times[i-1]), reverse=True)[:2]\n        for o in outs:\n            R.discard(o)\n        candidates = [i for i in range(1, n+1) if i not in R]\n        candidates.sort(key=lambda i: (scores[i-1], -times[i-1]))\n        for inn in candidates[:2]:\n            R.add(inn)\n    if move == 4:\n        # 1-2 or 2-1 exchange chosen randomly\n        if random.random() < 0.5 and len(R) >= 1:\n            # 1-2: remove 1 high-score, add 2 low-score\n            out = max(R, key=lambda i: (scores[i-1], -times[i-1]))\n            R.remove(out)\n            cand = [i for i in range(1, n+1) if i not in R]\n            cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n            for inn in cand[:2]:\n                R.add(inn)\n        else:\n            # 2-1: remove 2 high-score, add 1 low-score\n            outs = sorted(list(R), key=lambda i: (scores[i-1], -times[i-1]), reverse=True)[:2]\n            for o in outs:\n                R.discard(o)\n            cand = [i for i in range(1, n+1) if i not in R]\n            if cand:\n                inn = min(cand, key=lambda i: (scores[i-1], -times[i-1]))\n                R.add(inn)\n\n    # Final repair and clean-up\n    R = greedy_repair(R)\n    R = safe_drop_cleanup(R)\n\n    neighbour = sorted(R)\n    return (neighbour, (\"LocalToggle\", move_type))\n","PERTURB_CODE":"import math\nimport random\n\n# Ruin-and-repair perturbation: remove a block biased by (score\/time) density and repair.\n\ndef perturb_solution(solution):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n\n    try:\n        S = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        S = set()\n    S = set(i for i in S if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    def greedy_repair(S):\n        tt, _ = totals(S)\n        if tt < T:\n            cand = [i for i in range(1, n+1) if i not in S]\n            cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n            for i in cand:\n                if tt >= T:\n                    break\n                S.add(i)\n                tt += times[i-1]\n        # safe-drop loop: drop removable items with highest score first\n        changed = True\n        while changed:\n            changed = False\n            tt, _ = totals(S)\n            removable = [i for i in S if tt - times[i-1] >= T]\n            if not removable:\n                break\n            i = max(removable, key=lambda k: (scores[k-1], -times[k-1]))\n            S.remove(i)\n            changed = True\n        return S\n\n    # Ensure feasibility\n    S = greedy_repair(S)\n\n    # Determine ruin size by covering ~15%-30% of time or 3..6 items\n    tt, _ = totals(S)\n    target_cover = max(int(0.15 * T), 300)\n    k_min, k_max = 3, 6\n\n    # Order by density (score\/time) descending for removal bias\n    order = sorted(list(S), key=lambda i: (scores[i-1]\/max(1, times[i-1]), scores[i-1], -times[i-1]), reverse=True)\n\n    removed = 0\n    covered = 0\n    R = set(S)\n    for i in order:\n        if removed >= k_max and covered >= target_cover:\n            break\n        R.discard(i)\n        removed += 1\n        covered += times[i-1]\n        if removed >= k_min and covered >= target_cover:\n            break\n\n    # Random toggles for diversification\n    toggles = random.randint(1, 3)\n    for _ in range(toggles):\n        if random.random() < 0.5 and len(R) > 0:\n            # attempt safe drop\n            tt2, _ = totals(R)\n            droplist = [i for i in R if tt2 - times[i-1] >= T]\n            if droplist:\n                j = max(droplist, key=lambda k: (scores[k-1], -times[k-1]))\n                R.discard(j)\n        else:\n            # biased add\n            cand = [i for i in range(1, n+1) if i not in R]\n            if cand:\n                cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n                pick = cand[min(len(cand)-1, random.randint(0, max(0, len(cand)\/\/4)))]\n                R.add(pick)\n\n    R = greedy_repair(R)\n    return sorted(R)\n","SAMPLE_SOL":"[1, 2, 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_EVAL_KNOWN_REF_MISMATCH: Provided KNOWN_SOLUTION is infeasible under the given EVAL_CODE (time deficit triggers penalty). Fix reference data or constraint T to align; do not use this as ground truth.\nE_LOCAL_SOLVER_RESULT_BAD_FMT: Iterated_Local_Search returned a stringified solution in output tuple; standardize to raw list to avoid downstream parsing errors.\nE_TS_SIGNATURE: Taboo_Search failed due to signature mismatch. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE and remove parentheses in parameter names. Example: def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration).\nE_PERTURB_MISSING: Perturbation Function undefined ($Perturb placeholder). Provide a concrete, side-effect-free perturbation complying with representation and avoiding OS\/IO calls.\nE_NEIGH_RET_SHAPE: generate_neighbour returns (neighbour, (\\\"LocalToggle\\\", move_type)). If the framework expects only a neighbour, add a wrapper or update callers to unpack correctly. Enforce a single, documented return type across all heuristics.\nE_NEIGH_FEASIBILITY_COST: Greedy repair + safe-drop is O(n log n) per neighbour due to global sorts each call. Cache sorted index lists and maintain deltas to reduce to amortized O(log n) or O(1) for common moves.\nE_NEIGH_MOVE_WEAK: Current 1-1\/2-swap\/1-2\/2-1 rely only on score asc\/time desc; they frequently undo feasibility or make neutral moves. Incorporate value metrics: use marginal cost dScore and time slack S=T-(sum_time_excluded) to guide exchanges; reject moves that increase score without time gain.\nE_SAFE_DROP_CRITERION: Dropping max-score among removable ignores time leverage; prefer dropping by highest score\/time or via exact slack optimization to avoid suboptimal removals.\nE_INITIALIZATION: No construction heuristic provided; start state inherits arbitrary content. Build an initial feasible solution via exact slack DP (below) to avoid long repairs.\nE_OBJ_DUPLICATION: Two distinct evaluation functions exist (OBJ_CODE vs EVAL_CODE). Remove OBJ_CODE from the pipeline or ensure a single source of truth to prevent silent inconsistencies.\nE_RANDOMNESS: Unseeded randomness harms reproducibility. Add an optional seed param in other_params and thread it to all random calls.\nNB_CODE_FAIL_LOCAL_OPT: Neighbourhood insufficient for this tight-constraint instance (total slack = 90). Add an exact \\\"slack knapsack\\\" optimizer to perform optimal safe-drop after any add\/repair.\nR_STR_INADEQUATE: Set semantics with naive add\/drop obscures combinatorial structure. Keep set semantics but explicitly track total_time and total_score incrementally to avoid repeated scans.\nE_CODE_PERF: totals(), greedy_repair(), safe_drop_cleanup() rescan O(n) repeatedly; maintain running totals and priority queues for add\/drop candidates to get O(log n) updates.\nE_SA_ILS_STAGNATION: Reported best cost is far from attainable with exact slack optimization; annealing\/ILS parameters likely too conservative. Increase intensification: apply exact safe-drop at the end of each iteration and when accepting a neighbour.\nE_CONSTRAINT_TIGHTNESS: With slack only 90, feasibility repair by adding lowest-score items often bloats solution. Switch to exclude-set optimization: optimize which items to exclude under time<=slack.\nACTION_DP_SLACK_OPT: Implement exact DP over slack C=(sum_times - T)=90 to maximize excluded score: dp[c]=max excluded score with time<=c. Complexity O(n*C)=O(24*90) trivial. Then included_score = total_score - dp[C]. Use this as a deterministic post-optimizer in every heuristic step.\nACTION_MOVE_FILTER: Before accepting a move, compute new slack and reject if it decreases excluded-score potential (estimate via top-k candidates by score\/time or quick bounded DP on affected items).\nACTION_TABU_FIX: Tabu list should store excluded-set bitmasks or tuple of excluded indices, not full sets, to ensure consistent hashing and O(1) membership; set tenure relative to neighbourhood size.\nACTION_PERTURB: Define perturb_solution by toggling the exclude-set under slack: randomly swap one excluded item for two smaller-time items or vice versa while keeping time of excluded set <= slack; always follow with DP slack optimizer.\nACTION_CACHING: Precompute arrays and orders once per run: indices_by_score_asc_time_desc and by ratio score\/time. Update lazily when membership changes; avoid full re-sorts.\nACTION_VALIDATION: Add assert evaluate_solution(neighbour) <= current when safe-drop DP applied; log deficits only for debugging. Remove any print\/IO.\nVERIFICATION_NOTE: Using the provided EVAL_CODE, a feasible solution with strictly better objective than the reported 258 exists via the slack DP approach. The sample solution already matches an improved structure (exclude a small subset). Align local solver to reproduce this deterministically without relying on random walks.\nREQUIRED_FIX_ORDER: 1) Fix Tabu signature and Perturbation function. 2) Unify evaluate function. 3) Insert DP slack optimizer into neighbour post-processing. 4) Add caching\/incremental totals. 5) Rerun SA\/ILS\/TS with seed for reproducibility.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"INDEX_LIST_STR_COMMA_SEPARATED_1BASED","Componentes":{"REPRESENTATION":"INDEX_LIST_STR_COMMA_SEPARATED_1BASED","EVAL_CODE":"import math\nimport random\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution):\n    # Accepts either a list of 1-based indices or a comma-separated string of indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                idxs = [int(x) for x in sol]\n            except Exception:\n                return []\n            return idxs\n        if isinstance(sol, str):\n            s = sol.strip()\n            # remove common brackets\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            idxs = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    idxs.append(int(p))\n                except Exception:\n                    return []\n            return idxs\n        return []\n\n    idx_list = parse_solution(solution)\n    if not isinstance(idx_list, list):\n        return 10**9\n    # validate and deduplicate within range\n    try:\n        idx_set: Set[int] = set(int(x) for x in idx_list)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    for i in idx_set:\n        total_time += times[i-1]\n    obj = 0\n    for i in idx_set:\n        obj += scores[i-1]\n    if total_time >= 2750:\n        return obj\n    deficit = 2750 - total_time\n    return 10**6 + deficit + obj\n","NB_CODE":"import math\nimport random\nfrom typing import List, Set, Tuple\n\ndef generate_neighbour(solution):\n    # Representation: comma-separated string of 1-based indices. Returns (new_solution_str, \"NB_SET\", movement_type)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    def serialize_solution(idxs: List[int]) -> str:\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxs: Set[int]) -> int:\n        return sum(times[i-1] for i in idxs)\n\n    def total_score(idxs: Set[int]) -> int:\n        return sum(scores[i-1] for i in idxs)\n\n    def repair(idxs: Set[int]) -> Set[int]:\n        # Ensure feasibility: if infeasible, add by best time\/score ratio; if feasible, try pruning\n        T = total_time(idxs)\n        # Add phase\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxs]\n            remaining.sort(key=lambda i: (times[i-1]\/scores[i-1], -times[i-1]), reverse=True)\n            for i in remaining:\n                idxs.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        # Prune phase: try to remove items that keep feasibility and reduce score\n        improved = True\n        while improved:\n            improved = False\n            items = sorted(list(idxs), key=lambda i: (scores[i-1]\/max(1, times[i-1]), scores[i-1]))\n            for i in items:\n                if (T - times[i-1]) >= 2750:\n                    idxs.remove(i)\n                    T -= times[i-1]\n                    improved = True\n                    break\n        return idxs\n\n    idx_list = parse_solution(solution)\n    base: Set[int] = set(int(x) for x in idx_list if 1 <= int(x) <= n)\n    if len(base) == 0:\n        # seed with best ratio item to avoid empty\n        seed = max(range(1, n+1), key=lambda i: times[i-1]\/scores[i-1])\n        base.add(seed)\n        base = repair(base)\n        return serialize_solution(list(base)), \"NB_SET\", \"seed\"\n\n    move_type = random.choice([\"add\", \"remove\", \"swap\"])\n\n    if move_type == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in base]\n        if candidates:\n            i = random.choice(candidates)\n            base.add(i)\n    elif move_type == \"remove\":\n        if len(base) > 1:\n            i = random.choice(list(base))\n            base.remove(i)\n        else:\n            move_type = \"add\"\n            candidates = [i for i in range(1, n+1) if i not in base]\n            if candidates:\n                i = random.choice(candidates)\n                base.add(i)\n    else:  # swap\n        if len(base) >= 1:\n            out_i = random.choice(list(base))\n            base.remove(out_i)\n            candidates = [i for i in range(1, n+1) if i not in base]\n            if candidates:\n                in_i = random.choice(candidates)\n                base.add(in_i)\n            else:\n                base.add(out_i)\n                move_type = \"remove\"\n\n    base = repair(base)\n    return serialize_solution(list(base)), \"NB_SET\", move_type\n","PERTURB_CODE":"import math\nimport random\nfrom typing import List, Set\n\ndef perturb_solution(solution):\n    # Strong shake: random removals\/additions followed by greedy repair; returns comma-separated string\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    def serialize_solution(idxs: List[int]) -> str:\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxs: Set[int]) -> int:\n        return sum(times[i-1] for i in idxs)\n\n    def repair(idxs: Set[int]) -> Set[int]:\n        T = total_time(idxs)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxs]\n            remaining.sort(key=lambda i: (times[i-1]\/scores[i-1], -times[i-1]), reverse=True)\n            for i in remaining:\n                idxs.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        # prune redundant items greedily\n        improved = True\n        while improved:\n            improved = False\n            items = sorted(list(idxs), key=lambda i: (scores[i-1]\/max(1, times[i-1]), scores[i-1]))\n            for i in items:\n                if (T - times[i-1]) >= 2750:\n                    idxs.remove(i)\n                    T -= times[i-1]\n                    improved = True\n                    break\n        return idxs\n\n    idx_list = parse_solution(solution)\n    base: Set[int] = set(int(x) for x in idx_list if 1 <= int(x) <= n)\n\n    # Randomly remove k items and add k random new items, then repair\n    k = max(1, len(base)\/\/4) if len(base) > 0 else 3\n    for _ in range(k):\n        if base:\n            base.remove(random.choice(list(base)))\n    # Add k random items not in base\n    candidates = [i for i in range(1, n+1) if i not in base]\n    random.shuffle(candidates)\n    for i in candidates[:k]:\n        base.add(i)\n\n    base = repair(base)\n    return serialize_solution(list(base))\n","SAMPLE_SOL":"1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPE_HINT:Runtime error 'Type List cannot be instantiated' indicates misuse of typing.List\/Set\/Tuple as constructors. Replace all List()\/Set()\/Tuple() calls with list()\/set()\/tuple(), and keep typing types only for annotations.\"\n\"FEEDBACK\",\"E_HEUR_SIG_MISMATCH:Heuristic function signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Refactor SA\/ILS\/TS to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route algorithm-specific parameters via other_params.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Implement perturb_solution(solution,other_params) and pass it into Heuristic per required signature.\"\n\"FEEDBACK\",\"E_EXTRA_OUTPUT_HANDLING:generate_neighbour returns (new_solution,'NB_SET',move_type). Heuristics must unpack and propagate movement metadata; current implementations likely assume a single return. Fix to handle tuple outputs.\"\n\"FEEDBACK\",\"E_INPUT_REPR_INCONSISTENT:Representation declared as INDEX_LIST_STR_COMMA_SEPARATED_1BASED, but solvers appear to pass Python lists to SA\/ILS\/TS. Standardize to use string representation throughout or normalize at entry (parse and re-serialize) to avoid duplication\/ordering drift.\"\n\"FEEDBACK\",\"E_KNOWN_BEST_INFEASIBLE:Provided known-best fails feasibility under EVAL_CODE (returns penalized value). Either the known-best indices are incorrect or EVAL_CODE thresholds\/data differ. Align KNOWN_SOLUTION with current EVAL_CODE or adjust constraint parameters to be consistent.\"\n\"FEEDBACK\",\"E_EVAL_PARSER_EDGE:parse_solution returns [] on any bad token, silently converting to heavy-penalty outcomes. Add explicit validation logging or return a sentinel to fail fast in local runs. Also reject zero\/negative indices earlier.\"\n\"FEEDBACK\",\"E_EVAL_PENALTY_SCALE:Penalty 1e6 + deficit + obj can dwarf meaningful deltas and hinder annealing\/acceptance tuning. Consider 1e4*ceil(deficit\/mean_time) + obj or normalize scores to stabilize acceptance probabilities.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbourhood limited to add\/remove\/swap with immediate greedy repair. This often cycles around similar sets. Add 1-1 and 1-2 exchanges and targeted drop-add moves guided by marginal score impact per time.\"\n\"FEEDBACK\",\"NB_REPAIR_ADD_CRITERION:Tie-break in add phase uses reverse sort on (time\/score, -time). While prioritizing high time\/score is correct, over-emphasis on large absolute time can overshoot and reduce pruning flexibility. Use stable sort by time\/score only; defer absolute time tie-break to prune stage.\"\n\"FEEDBACK\",\"NB_REPAIR_PRUNE_WEAK:Single-element prune with first-improvement stops early. Implement best-improvement removal, then pairwise removal (2-removals) while feasible to reduce total score further.\"\n\"FEEDBACK\",\"NB_REPAIR_TERMINATION:Rollover while-improved with immediate remove-then-restart can thrash. Batch candidate removals each iteration; stop when no improving removal exists.\"\n\"FEEDBACK\",\"INIT_SEED_SUBOPTIMAL:Seeding from a single best ratio item requires heavy repair. Build initial solution via greedy cover to feasibility using time\/score, then prune. This reduces dependence on repair and speeds convergence.\"\n\"FEEDBACK\",\"SA_PARAM_PLUMBING:SA expects TEMP, MIN_TEMP, cooling_factor in signature. Move these into other_params with defaults, e.g., {'temp':1000,'min_temp':1e-3,'alpha':0.95,'iters_per_temp':K}, and parse inside Heuristic.\"\n\"FEEDBACK\",\"ILS_ACCEPT_MISNAMED:Parameter 'aceptance_rate' is misspelled and inconsistent. Standardize to 'acceptance_rate' and pass via other_params. Define acceptance criterion explicitly (e.g., accept if new_cost <= best_cost or with prob exp(-(delta)\/temp)).\"\n\"FEEDBACK\",\"TS_TABU_SPELLING:Function\/class references 'Taboo_Search'. Standardize to 'Tabu' and ensure taboo_list_size and tabu_duration are read from other_params. Maintain tabu list of moves or attribute sets consistent with NB_SET representation.\"\n\"FEEDBACK\",\"RETURNS_CONSISTENCY:Ensure Heuristic returns (best_solution_representation, best_score, extra_outputs_dict). Extra outputs may include 'moves', 'temps', 'accepts'. Current solvers likely return bare solution only.\"\n\"FEEDBACK\",\"RANDOM_SEED_CTRL:Non-determinism hinders reproducibility. Accept 'seed' in other_params and seed RNG at Heuristic start. Log seed in extra outputs.\"\n\"FEEDBACK\",\"STOPPING_CRITERIA:Missing robust termination. Add max_iterations, max_no_improve, and time_budget guards through other_params; report termination_reason.\"\n\"FEEDBACK\",\"PERF_DATA_STRUCT:Neighbour uses set\/list conversions repeatedly. Maintain solution as sorted list plus a boolean in-set array for O(1) membership and O(1) time\/score updates to reduce overhead.\"\n\"FEEDBACK\",\"OBJ_DELTA_EVAL:Recompute totals from scratch each move. Track running totals (time, score) and apply deltas for add\/remove\/swap; validates faster annealing loops.\"\n\"FEEDBACK\",\"DUP_HANDLING:serialize_solution sorts and deduplicates, which may mask upstream bugs. Enforce uniqueness at construction, and assert no duplicates during debugging to catch logic errors early.\"\n\"FEEDBACK\",\"VALIDATION_TESTS:Create unit tests for parser, neighbour, repair feasibility, and heuristic return shape. Include a regression that asserts evaluate_solution(repair(set())) is feasible and monotonically non-increasing under prune.\"\n\"FEEDBACK\",\"KNOWN_BEST_ASSERTION:Automated check against provided 'expected' failed under current EVAL_CODE in local run. Block solver scoring and raise explicit error until the mismatch is resolved to prevent misleading performance reports.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"INDEX_LIST_STR_COMMA_SEPARATED_1BASED","Componentes":{"REPRESENTATION":"INDEX_LIST_STR_COMMA_SEPARATED_1BASED","EVAL_CODE":"import math\nimport random\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution):\n    # Accepts either a list of 1-based indices or a comma-separated string of indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    idx_list = parse_solution(solution)\n    if not isinstance(idx_list, list):\n        return 10**9\n    # validate and deduplicate within range\n    try:\n        idx_set: Set[int] = set(int(x) for x in idx_list)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    for i in idx_set:\n        total_time += times[i-1]\n    obj = 0\n    for i in idx_set:\n        obj += scores[i-1]\n    if total_time >= 2750:\n        return obj\n    # Calibrated penalty to preserve neighborhood sensitivity\n    mean_time = sum(times) \/ len(times)\n    deficit = 2750 - total_time\n    penalty = 10000 * math.ceil(deficit \/ max(1, int(mean_time)))\n    return penalty + obj\n","NB_CODE":"import math\nimport random\nfrom typing import List, Set, Tuple\n\ndef generate_neighbour(solution):\n    # Representation: comma-separated string of 1-based indices.\n    # Returns (new_solution_str, \"NB_SET\", movement_type)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    def serialize_solution(idxs: List[int]) -> str:\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset: Set[int]) -> int:\n        return sum(times[i-1] for i in idxset)\n\n    def total_score(idxset: Set[int]) -> int:\n        return sum(scores[i-1] for i in idxset)\n\n    def greedy_cover() -> Set[int]:\n        # Build an initial feasible set by descending time\/score ratio\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (times[i-1] \/ scores[i-1]), reverse=True)\n        sel: Set[int] = set()\n        T = 0\n        for i in items:\n            if T >= 2750:\n                break\n            sel.add(i)\n            T += times[i-1]\n        return sel\n\n    def prune_best_improvement(idxset: Set[int]) -> Set[int]:\n        # Iteratively remove the single item whose removal keeps feasibility and yields the largest score decrease.\n        changed = True\n        while changed:\n            changed = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in list(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                changed = True\n        return idxset\n\n    def pairwise_prune(idxset: Set[int]) -> Set[int]:\n        # Try one round of best pair removal for additional improvement\n        T = total_time(idxset)\n        if T < 2750:\n            return idxset\n        items = list(idxset)\n        best_pair = None\n        best_gain = 0\n        m = len(items)\n        for a in range(m):\n            i = items[a]\n            for b in range(a+1, m):\n                j = items[b]\n                if T - times[i-1] - times[j-1] >= 2750:\n                    gain = scores[i-1] + scores[j-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (i, j)\n        if best_pair is not None:\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    def repair(idxset: Set[int]) -> Set[int]:\n        # Ensure feasibility and reduce score\n        T = total_time(idxset)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxset]\n            remaining.sort(key=lambda i: (times[i-1] \/ scores[i-1]), reverse=True)\n            for i in remaining:\n                idxset.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        idxset = prune_best_improvement(idxset)\n        idxset = pairwise_prune(idxset)\n        return idxset\n\n    idx_list = parse_solution(solution)\n    base: Set[int] = set(int(x) for x in idx_list if 1 <= int(x) <= n)\n\n    if len(base) == 0:\n        base = greedy_cover()\n        base = repair(base)\n        return serialize_solution(list(base)), \"NB_SET\", \"seed\"\n\n    move_type = random.choice([\"add\", \"remove\", \"swap\", \"dropadd\", \"two_swap\"])\n\n    if move_type == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in base]\n        if candidates:\n            i = random.choice(candidates)\n            base.add(i)\n    elif move_type == \"remove\":\n        rem = [i for i in base]\n        if len(rem) > 0:\n            i = random.choice(rem)\n            base.remove(i)\n    elif move_type == \"swap\":\n        if len(base) >= 1:\n            out_i = random.choice(list(base))\n            base.remove(out_i)\n            candidates = [i for i in range(1, n+1) if i not in base]\n            if candidates:\n                in_i = random.choice(candidates)\n                base.add(in_i)\n            else:\n                base.add(out_i)\n                move_type = \"remove\"\n    elif move_type == \"dropadd\":\n        # Drop the worst ratio item, add best ratio outside\n        if base:\n            worst = max(base, key=lambda i: (scores[i-1] \/ times[i-1]))\n            base.remove(worst)\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            best = max(outside, key=lambda i: (times[i-1] \/ scores[i-1]))\n            base.add(best)\n    else:  # two_swap\n        if len(base) >= 2:\n            outs = random.sample(list(base), 2)\n            for o in outs:\n                base.remove(o)\n            outside = [i for i in range(1, n+1) if i not in base]\n            random.shuffle(outside)\n            for i in outside[:2]:\n                base.add(i)\n\n    base = repair(base)\n    return serialize_solution(list(base)), \"NB_SET\", move_type\n","PERTURB_CODE":"import math\nimport random\nfrom typing import List, Set\n\ndef perturb_solution(solution):\n    # Strong shake: random removals\/additions followed by greedy repair; returns comma-separated string\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    def serialize_solution(idxs: List[int]) -> str:\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset: Set[int]) -> int:\n        return sum(times[i-1] for i in idxset)\n\n    def repair(idxset: Set[int]) -> Set[int]:\n        # Add phase to reach feasibility\n        T = total_time(idxset)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxset]\n            remaining.sort(key=lambda i: (times[i-1] \/ scores[i-1]), reverse=True)\n            for i in remaining:\n                idxset.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        # Greedy prune best-improvement, then one pass of pairwise prune\n        # Best single removal loop\n        changed = True\n        while changed:\n            changed = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in list(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                changed = True\n        # Pairwise prune single pass\n        T = total_time(idxset)\n        items = list(idxset)\n        m = len(items)\n        best_pair = None\n        best_gain = 0\n        for a in range(m):\n            i = items[a]\n            for b in range(a+1, m):\n                j = items[b]\n                if T - times[i-1] - times[j-1] >= 2750:\n                    gain = scores[i-1] + scores[j-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (i, j)\n        if best_pair is not None:\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    idx_list = parse_solution(solution)\n    base: Set[int] = set(int(x) for x in idx_list if 1 <= int(x) <= n)\n\n    # Randomly remove k items and add up to k random new items, then repair\n    k = max(1, len(base)\/\/3) if len(base) > 0 else 4\n    for _ in range(k):\n        if base:\n            base.remove(random.choice(list(base)))\n    # Add up to k random items not in base\n    candidates = [i for i in range(1, n+1) if i not in base]\n    random.shuffle(candidates)\n    for i in candidates[:k]:\n        base.add(i)\n\n    base = repair(base)\n    return serialize_solution(list(base))\n","SAMPLE_SOL":"1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_CRASH: Type List cannot be instantiated -> Replace typing.List\/Set\/Dict usage at runtime with built-ins (list\/set\/dict). Never call List().\"\n\"FEEDBACK\",\"E_SIGNATURE_MISMATCH: Heuristics do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) and pass function references (no parentheses).\"\n\"FEEDBACK\",\"E_SOLVER_API_INCONSISTENT: Provided SA\/ILS\/TS signatures differ from target and call functions with parentheses in signature text. Unify to a single Heuristic entry point or adapt wrappers that map params to the required signature.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING: 'Perturbation Function' is undefined ($Perturb placeholder). Provide a concrete perturb_solution(solution, strength, rng) or a no-op stub returning a repaired feasible solution.\"\n\"FEEDBACK\",\"E_EVAL_KNOWN_BEST_ASSERT:FAIL -> Known-best tuple fails feasibility under current EVAL_CODE (penalized). Known-best metadata is inconsistent with the instance or evaluation routine.\"\n\"FEEDBACK\",\"E_EVAL_OBJ_INCONSISTENT: OBJ_CODE ignores feasibility; EVAL_CODE enforces constraint with penalty. This inconsistency causes score reporting\/acceptance mismatches. Unify acceptance to EVAL_CODE and ensure any 'expected score' references use the same evaluation.\"\n\"FEEDBACK\",\"E_PENALTY_SCALING: Current penalty = 10000*ceil(deficit\/mean_time)+obj creates coarse plateaus. Use penalty = lambda_deficit*deficit with lambda_deficit\u2248max_i(scores[i]\/times[i]) to preserve smooth gradient and reduce plateaus.\"\n\"FEEDBACK\",\"E_PARSE_TOLERANCE: parse_solution returns [] on minor format issues causing reseed every time. Return explicit error or repair last valid set to avoid unintended restarts.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: prune_best_improvement removes highest-score items first; correct for objective but may miss better multi-exchange combinations. Add iterative k-exchange (k=2..3) with bounded beam to escape local minima.\"\n\"FEEDBACK\",\"NB_PAIRWISE_SINGLE_PASS: pairwise_prune runs one pass only. Iterate until no improvement or cap by iterations to reach a 2-opt local minimum.\"\n\"FEEDBACK\",\"NB_MOVE_BIAS_WEAK: Random move selection is uninformed. Bias adds\/swaps by best marginal time\/score (maximize \u0394time\/\u0394score when infeasible; minimize \u0394score subject to feasibility when feasible).\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Comma-separated string representation forces constant serialization\/deserialization. Prefer list[int] internally; serialize only at I\/O boundaries.\"\n\"FEEDBACK\",\"SEED_OVERSHOOT: greedy_cover uses time\/score ratio descending and may overshoot heavily. Build seed with a DP-based minimal-score cover or meet-in-the-middle for exact feasibility baseline before local search.\"\n\"FEEDBACK\",\"E_REPAIR_LIMITED: repair() prunes then at most one pairwise removal. Add targeted replacement: remove k, insert l items optimizing Lagrangian gain g(i)=score(i)-\u03bb*time(i) with adaptive \u03bb.\"\n\"FEEDBACK\",\"E_TABU_ABSENT_PARAMS: Tabu list structures\/parameters not provided to Heuristic. If implementing TS, add explicit taboo_set with tenure, aspiration criteria, and consistent hashing of solutions (use frozenset of indices).\"\n\"FEEDBACK\",\"E_SA_PARAM_GAPS: Temperature schedule (TEMP, MIN_TEMP, cooling_factor) missing in the unified API. Move them into other_params dict and validate ranges. Use geometric cooling and reheating on stagnation.\"\n\"FEEDBACK\",\"E_ILS_ACCEPTANCE: No acceptance criterion defined. Add late-acceptance or simulated annealing-based acceptance to avoid cycling on equal-penalty plateaus.\"\n\"FEEDBACK\",\"E_TIME_COMPLEXITY: Neighborhood evaluation re-computes totals from scratch. Maintain incremental totals (time, score) across moves for O(1) update per neighbor.\"\n\"FEEDBACK\",\"E_FEASIBILITY_REPAIR_ORDER: In repair(), adding best time\/score may add very high-time items late. Prefer cheapest augmentations that meet the exact remaining deficit using small subset-sum DP over remaining items.\"\n\"FEEDBACK\",\"E_RANDOM_SEED: random not seeded via other_params; runs are non-reproducible. Add rng = random.Random(seed) and thread it through all stochastic components.\"\n\"FEEDBACK\",\"E_UNIT_TESTS_MISSING: No unit assertions for parser, evaluation, repair. Add tests: invalid indices, duplicates, infeasible-to-feasible transitions, penalty monotonicity.\"\n\"FEEDBACK\",\"FIX_PATCH_LOCAL_SOLVERS: Provide minimal compliant wrappers: def Heuristic(cur,best,best_score,gen_nb,eval_fn,perturb,params): implement SA\/ILS\/TS in this function via params['mode'] in {'SA','ILS','TS'}; remove any typing.List instantiations.\"\n\"FEEDBACK\",\"ALT_BASELINE_EXACT: Implement exact DP: dp[t]=min score to achieve time t; after fill, take min_{t>=2750} dp[t]. Use as benchmark and for strong initialization; then restrict local search to subsets near the DP frontier.\"\n\"FEEDBACK\",\"E_STOPPING_CRITERIA: Missing. Add max_iterations, max_no_improve, and time budget in other_params; stop on any met.\"\n\"FEEDBACK\",\"EVALUATION_EXTRA_OUTPUTS: When returning from Heuristic, include: best_solution_str, best_score, total_time, iterations, moves_accepted, moves_generated for traceability.\"\n\"FEEDBACK\",\"CODE_SNIPPET_FIX_HEURISTIC_SIG: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n    rng = other_params.get('rng', __import__('random'))\\n    mode = other_params.get('mode','SA')\\n    # ensure type\\n    cur = currentSolution if isinstance(currentSolution,(list,str)) else ''\\n    best_sol = best if isinstance(best,(list,str)) else cur\\n    # implement selected metaheuristic here using only list\/set\/dict; no typing.* at runtime.\"\n\"FEEDBACK\",\"VALIDATION_RESULT: EVAL_EQUIVALENCE_CHECK -> objective_function returns raw score and ignores feasibility; do not use it for acceptance or reporting. Use evaluate_solution exclusively for search and scoring.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"Comma-separated string of unique 1-based indices (e.g., \"3,5,7\"). Order ignored; duplicates removed during parsing\/validation.","Componentes":{"REPRESENTATION":"Comma-separated string of unique 1-based indices (e.g., \"3,5,7\"). Order ignored; duplicates removed during parsing\/validation.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Accepts either a list of 1-based indices or a comma-separated string of indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        # Returns list[int] robustly; never raises; empty if unparseable\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    idx_list = parse_solution(solution)\n    # validate and clamp to range, deduplicate\n    idx_set = set(i for i in idx_list if 1 <= int(i) <= n)\n    total_time = 0\n    total_score = 0\n    for i in idx_set:\n        total_time += times[i-1]\n        total_score += scores[i-1]\n    if total_time >= 2750:\n        return total_score\n    # Smooth penalty: lambda ~= max_i (score_i\/time_i)\n    lam = max(scores[i]\/times[i] for i in range(n))\n    deficit = 2750 - total_time\n    penalty = 1_000_000 + lam * deficit\n    return penalty + total_score\n","NB_CODE":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_str, \"NB_SET\", movement_type)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    def serialize_solution(idxs):\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset):\n        return sum(times[i-1] for i in idxset)\n\n    def total_score(idxset):\n        return sum(scores[i-1] for i in idxset)\n\n    def greedy_cover():\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n        sel = set()\n        T = 0\n        for i in items:\n            if T >= 2750:\n                break\n            sel.add(i)\n            T += times[i-1]\n        return sel\n\n    def prune_single(idxset):\n        # Remove best-improvement singles until no improvement feasible\n        improved = True\n        while improved:\n            improved = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in tuple(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                improved = True\n        return idxset\n\n    def prune_pairwise_iter(idxset, max_rounds=5):\n        rounds = 0\n        while rounds < max_rounds:\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            items = list(idxset)\n            m = len(items)\n            best_pair = None\n            best_gain = 0\n            for a in range(m):\n                i = items[a]\n                ti = times[i-1]\n                si = scores[i-1]\n                for b in range(a+1, m):\n                    j = items[b]\n                    if T - ti - times[j-1] >= 2750:\n                        gain = si + scores[j-1]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_pair = (i, j)\n            if best_pair is None:\n                break\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n            rounds += 1\n        return idxset\n\n    def augment_to_feasible(idxset):\n        T = total_time(idxset)\n        if T >= 2750:\n            return idxset\n        # Greedy add by best time\/score\n        remaining = [i for i in range(1, n+1) if i not in idxset]\n        remaining.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n        for i in remaining:\n            idxset.add(i)\n            T += times[i-1]\n            if T >= 2750:\n                break\n        return idxset\n\n    def repair(idxset):\n        idxset = augment_to_feasible(idxset)\n        idxset = prune_single(idxset)\n        idxset = prune_pairwise_iter(idxset, max_rounds=8)\n        return idxset\n\n    base = set(int(x) for x in parse_solution(solution) if 1 <= int(x) <= n)\n    if len(base) == 0:\n        base = greedy_cover()\n        base = repair(base)\n        return serialize_solution(list(base)), \"NB_SET\", \"seed\"\n\n    # Informed move selection\n    T = total_time(base)\n    if T < 2750:\n        move_space = [\"add\", \"dropadd\", \"swap\"]\n    else:\n        move_space = [\"remove\", \"swap\", \"two_swap\", \"dropadd\"]\n    move_type = random.choice(move_space)\n\n    if move_type == \"add\":\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            # pick best marginal time\/score\n            i = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.add(i)\n    elif move_type == \"remove\":\n        if base:\n            # remove worst time\/score\n            i = min(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.remove(i)\n    elif move_type == \"swap\":\n        if base:\n            out_i = min(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.remove(out_i)\n            outside = [i for i in range(1, n+1) if i not in base]\n            if outside:\n                in_i = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n                base.add(in_i)\n            else:\n                base.add(out_i)\n    elif move_type == \"two_swap\":\n        if len(base) >= 2:\n            outs = sorted(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))[:2]\n            for o in outs:\n                base.remove(o)\n            outside = [i for i in range(1, n+1) if i not in base]\n            outside.sort(key=lambda k: (times[k-1] \/ max(1, scores[k-1])), reverse=True)\n            for i in outside[:2]:\n                base.add(i)\n    else:  # dropadd\n        if base:\n            worst = min(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.remove(worst)\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            best = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.add(best)\n\n    base = repair(base)\n    return serialize_solution(list(base)), \"NB_SET\", move_type\n","PERTURB_CODE":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong shake followed by repair; returns comma-separated string\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    def serialize_solution(idxs):\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset):\n        return sum(times[i-1] for i in idxset)\n\n    def augment_to_feasible(idxset):\n        T = total_time(idxset)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxset]\n            remaining.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n            for i in remaining:\n                idxset.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        return idxset\n\n    def prune_single(idxset):\n        improved = True\n        while improved:\n            improved = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in tuple(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                improved = True\n        return idxset\n\n    def prune_pairwise(idxset):\n        T = total_time(idxset)\n        items = list(idxset)\n        m = len(items)\n        best_pair = None\n        best_gain = 0\n        for a in range(m):\n            i = items[a]\n            ti = times[i-1]\n            si = scores[i-1]\n            for b in range(a+1, m):\n                j = items[b]\n                if T - ti - times[j-1] >= 2750:\n                    gain = si + scores[j-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (i, j)\n        if best_pair is not None:\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    base = set(int(x) for x in parse_solution(solution) if 1 <= int(x) <= n)\n\n    k = max(1, len(base)\/\/3) if len(base) > 0 else 4\n    # Random removals\n    for _ in range(k):\n        if base:\n            base.remove(random.choice(tuple(base)))\n    # Random additions\n    candidates = [i for i in range(1, n+1) if i not in base]\n    random.shuffle(candidates)\n    for i in candidates[:k]:\n        base.add(i)\n\n    # Repair\n    base = augment_to_feasible(base)\n    base = prune_single(base)\n    base = prune_pairwise(base)\n\n    return serialize_solution(list(base))\n","SAMPLE_SOL":"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"F_LOCAL_SOLVER_SIG\",\"Too many return values from generate_neighbour. Framework expects 2; your function returns 3 (new_sol,'NB_SET',move). Remove the middle tag and return exactly (new_solution, move_type).\"\n\"F_HEURISTIC_API\",\"Heuristic signatures in logs show functions being passed as generate_neighbour() and evaluate_solution() (called), causing arity mismatch. Pass function references without calling them and conform to TARGET_HEURISTIC_GENERAL_SIGNATURE.\"\n\"F_PERTURB_MISSING\",\"Perturbation Function is undefined ('$Perturb' placeholder). Implement perturb_solution(solution, intensity) returning a valid representation. Use structure-consistent returns with no side-effects.\"\n\"F_TYPE_CONTRACT\",\"Neighbour returns string, evaluator accepts list or string; ensure the heuristic always normalizes to list-of-int before scoring to avoid repeated parse\/serialize overhead and hidden type bugs.\"\n\"F_KNOWN_SOL_INFEAS\",\"Provided KNOWN_SOLUTION fails feasibility under EVAL_CODE (time sum << 2750). Update test oracle; current 'expected score' is not attained by evaluate_solution.\"\n\"E_CODE_PERF\",\"Repeated parsing and recomputation of totals inside generate_neighbour and evaluate increase cost to O(n log n)+O(n) per move. Cache (set, total_time, total_score) and update incrementally in O(1) per add\/remove.\"\n\"E_EVAL_PENALTY\",\"Penalty uses lam=max(score\/time) and returns float; mixing float with int can perturb acceptance thresholds. Cast penalty path to int and keep scale consistent across moves.\"\n\"E_NEIGHBOUR_BIAS\",\"Move selection overly tied to time\/score ratio, leading to search myopia. Add diversified neighborhoods: 1-1 swaps picked by marginal Lagrangian gain, 2-1 and 1-2 exchanges when near-feasible, and random kicks.\"\n\"E_REPAIR_EARLY_STOP\",\"prune_pairwise_iter bounds by max_rounds and may stop with obvious improvements remaining. Iterate until no-improvement or infeasible; add best-improvement selection per round.\"\n\"E_GREEDY_SEED\",\"greedy_cover maximizes time\/score; for this min-score cover, better seed via greedy minimizing score\/time while ensuring coverage, then repair. Current seed can inflate initial cost.\"\n\"E_MOVE_FEAS\",\"When T>=2750 and performing 'remove', picking min(time\/score) can immediately break feasibility. Guard with feasibility check or replace with best feasible single deletion.\"\n\"E_ACCEPT_SCALING\",\"Annealing and acceptance criteria will be distorted by 1e6+ penalties. Use staged search: forbid infeasible during SA\/TS main loop; allow infeasible only in separate repair phase to avoid scale mismatch.\"\n\"E_RANDOMNESS\",\"No RNG seeding control. Inject seed in other_params to ensure reproducibility in tests.\"\n\"I_EXACT_INTENSIFY\",\"For n=24, add exact DP intensification (cover knapsack) periodically to snap to globally optimal neighborhood; complexity is tractable and provides strong baselines for acceptance.\"\n\"I_PERTURB_SPEC\",\"Define perturb_solution as: drop k worst (by score density or low criticality), then refill via greedy augment_to_feasible; adapt k from other_params or temperature.\"\n\"I_STATE_REPR\",\"Represent state as a small struct\/dict: {'set':set, 'T':int, 'S':int}, with serializer\/deserializer at the boundaries only. Update T,S incrementally for O(1) neighborhood evaluation.\"\n\"I_UNIT_TESTS\",\"Add assertions: evaluate_solution(empty)=penalized; evaluate_solution(fullset)=finite; generate_neighbour returns 2-tuple; perturb_solution returns feasible after repair.\"\n\"I_MOVE_ACCOUNTING\",\"Track and return move_type consistently; remove constant 'NB_SET'. Ensure TS stores tabu attributes per moved indices (added, removed) rather than opaque strings.\"\n\"I_STOPPING\",\"Define iteration\/time budget and no-improvement cap; current design lacks termination governance leading to unstable runs.\"\n\"I_FEAS_REPAIR\",\"Combine prune_single until fixed point with pairwise\/3-exchange attempts; stop only when no feasible score-improving deletion exists.\"\n\"I_CACHE_SORTS\",\"Precompute index orders by time\/score and score\/time to avoid resorting inside loops.\"\n\n"}
