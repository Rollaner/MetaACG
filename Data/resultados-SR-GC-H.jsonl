{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS;c[i] is color in {1,...,k} for vertex i (1-indexed). Labels must be contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    # Graph definition (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n\n    # Base objective: minimize k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor with optional color-introduction, then normalize labels to be contiguous\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        # Relabel colors to contiguous 1..k preserving equality structure\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    idx = random.randrange(n)\n    k = max(cur)\n\n    # Allow trying an existing color or introduce a new color up to a small cap (<= n)\n    max_allow = min(n, max(k + (1 if random.random() < 0.25 else 0), 2))\n    # Ensure at least 2 colors to enable movement; draw a different color than current\n    choices = [c for c in range(1, max_allow + 1) if c != cur[idx]]\n    if not choices:\n        return cur\n    cur[idx] = random.choice(choices)\n\n    cur = normalize(cur)\n    return cur\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors plus random color relabel swap; then normalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    k = max(cur)\n\n    # Perform m random recolors\n    m = max(3, n \/\/ 2)\n    for _ in range(m):\n        i = random.randrange(n)\n        # allow expanding palette slightly during perturbation\n        max_allow = min(n, k + 1)\n        new_c = random.randrange(1, max_allow + 1)\n        if new_c == cur[i]:\n            new_c = (new_c % max_allow) + 1\n        cur[i] = new_c\n\n    # Randomly swap two color labels to escape symmetry\n    labels = list({c for c in cur})\n    if len(labels) >= 2:\n        a, b = random.sample(labels, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n\n    cur = normalize(cur)\n    return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000741588}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS;c[i] is color in {1,...,k} for vertex i (1-indexed). Labels must be contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    # Graph definition (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n\n    # Base objective: minimize k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor with optional color-introduction, then normalize labels to be contiguous\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        # Relabel colors to contiguous 1..k preserving equality structure\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    idx = random.randrange(n)\n    k = max(cur)\n\n    # Allow trying an existing color or introduce a new color up to a small cap (<= n)\n    max_allow = min(n, max(k + (1 if random.random() < 0.25 else 0), 2))\n    # Ensure at least 2 colors to enable movement; draw a different color than current\n    choices = [c for c in range(1, max_allow + 1) if c != cur[idx]]\n    if not choices:\n        return cur\n    cur[idx] = random.choice(choices)\n\n    cur = normalize(cur)\n    return cur\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors plus random color relabel swap; then normalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    k = max(cur)\n\n    # Perform m random recolors\n    m = max(3, n \/\/ 2)\n    for _ in range(m):\n        i = random.randrange(n)\n        # allow expanding palette slightly during perturbation\n        max_allow = min(n, k + 1)\n        new_c = random.randrange(1, max_allow + 1)\n        if new_c == cur[i]:\n            new_c = (new_c % max_allow) + 1\n        cur[i] = new_c\n\n    # Randomly swap two color labels to escape symmetry\n    labels = list({c for c in cur})\n    if len(labels) >= 2:\n        a, b = random.sample(labels, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n\n    cur = normalize(cur)\n    return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000555967}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS;c[i] is color in {1,...,k} for vertex i (1-indexed). Labels must be contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    # Graph definition (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n\n    # Base objective: minimize k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor with optional color-introduction, then normalize labels to be contiguous\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        # Relabel colors to contiguous 1..k preserving equality structure\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    idx = random.randrange(n)\n    k = max(cur)\n\n    # Allow trying an existing color or introduce a new color up to a small cap (<= n)\n    max_allow = min(n, max(k + (1 if random.random() < 0.25 else 0), 2))\n    # Ensure at least 2 colors to enable movement; draw a different color than current\n    choices = [c for c in range(1, max_allow + 1) if c != cur[idx]]\n    if not choices:\n        return cur\n    cur[idx] = random.choice(choices)\n\n    cur = normalize(cur)\n    return cur\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors plus random color relabel swap; then normalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    k = max(cur)\n\n    # Perform m random recolors\n    m = max(3, n \/\/ 2)\n    for _ in range(m):\n        i = random.randrange(n)\n        # allow expanding palette slightly during perturbation\n        max_allow = min(n, k + 1)\n        new_c = random.randrange(1, max_allow + 1)\n        if new_c == cur[i]:\n            new_c = (new_c % max_allow) + 1\n        cur[i] = new_c\n\n    # Randomly swap two color labels to escape symmetry\n    labels = list({c for c in cur})\n    if len(labels) >= 2:\n        a, b = random.sample(labels, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n\n    cur = normalize(cur)\n    return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000551336}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS;c[i] in {1,...,k} for vertex i (1-indexed). Labels contiguous {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Constants and graph definition (1-indexed vertices)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    HARD_PEN = 10**9\n    PEN_GAP = 2000.0\n    PEN_EDGE = 100.0\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        fitness += PEN_GAP\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local bind\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return float(fitness)\n","Vecindad":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _conflicts_of_vertex(sol, v):\n    c = sol[v-1]\n    cnt = 0\n    for nb in _adj[v]:\n        if sol[nb-1] == c:\n            cnt += 1\n    return cnt\n\ndef _total_conflicts(sol):\n    cnt = 0\n    for (u, v) in _EDGES:\n        if sol[u-1] == sol[v-1]:\n            cnt += 1\n    return cnt\n\ndef _kempe_swap(sol, color_a, color_b, start_v):\n    # BFS on subgraph induced by colors {a,b}, swap within the connected component containing start_v\n    n = len(sol)\n    if start_v < 1 or start_v > n:\n        return sol[:]\n    if sol[start_v-1] not in (color_a, color_b):\n        return sol[:]\n    target_set = {color_a, color_b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target_set:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        cv = out[v-1]\n        if cv == color_a:\n            out[v-1] = color_b\n        elif cv == color_b:\n            out[v-1] = color_a\n    return out\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _saturation(sol):\n    # returns list of (v, saturation_degree)\n    sat = []\n    for v in range(1, 10):\n        neigh_colors = set(sol[nb-1] for nb in _adj[v])\n        sat.append((v, len(neigh_colors)))\n    return sat\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input\")\n    sol = solution[:]\n    colors = list(sorted(set(sol)))\n    k = max(colors)\n\n    move_choices = [\"recolor_best\", \"kempe\", \"class_swap\", \"dsatur_recolor\"]\n    move = random.choices(move_choices, weights=[4, 3, 1, 2], k=1)[0]\n\n    if move == \"recolor_best\":\n        v = random.randrange(1, 10)\n        current = sol[v-1]\n        best_score = None\n        best_colors = []\n        for c in colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            score = _conflicts_of_vertex(tmp, v)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        return (sol, \"recolor_best\")\n\n    if move == \"kempe\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a start vertex that has color a or b\n            candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n            if candidates:\n                v0 = random.choice(candidates)\n                neigh = _kempe_swap(sol, a, b, v0)\n                return (neigh, f\"kempe({a},{b})\")\n        return (sol, \"kempe_noop\")\n\n    if move == \"class_swap\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            neigh = sol[:]\n            for i in range(9):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, f\"class_swap({a},{b})\")\n        return (sol, \"class_swap_noop\")\n\n    # dsatur_recolor\n    sat = _saturation(sol)\n    max_sat = max(s for _, s in sat)\n    candidates = [v for v, s in sat if s == max_sat]\n    v = random.choice(candidates)\n    current = sol[v-1]\n    neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n    # Prefer existing colors not in neighbor_colors\n    feasible = [c for c in colors if c != current and c not in neighbor_colors]\n    if feasible:\n        sol[v-1] = random.choice(feasible)\n    else:\n        # If none feasible, try any different existing color to mix\n        alt = [c for c in colors if c != current]\n        if alt:\n            sol[v-1] = random.choice(alt)\n    return (sol, \"dsatur_recolor\")\n","Perturbacion":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _vertex_conflicts(sol, v):\n    c = sol[v-1]\n    return sum(1 for nb in _adj[v] if sol[nb-1] == c)\n\ndef _total_conflicts(sol):\n    return sum(1 for (u, v) in _EDGES if sol[u-1] == sol[v-1])\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _kempe_component_swap(sol):\n    colors = list(sorted(set(sol)))\n    if len(colors) < 2:\n        return sol[:]\n    a, b = random.sample(colors, 2)\n    # choose a start vertex carrying color a or b\n    candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n    if not candidates:\n        return sol[:]\n    start_v = random.choice(candidates)\n    target = {a, b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        out[v-1] = a if out[v-1] == b else (b if out[v-1] == a else out[v-1])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n\n    # Identify high-conflict vertices\n    conflicts = [(v, _vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, c in conflicts[:m]]\n\n    colors = list(sorted(set(sol)))\n    max_colors = max(colors) + 1  # allow slight expansion during perturbation\n\n    # Greedy recolor targets using limited palette 1..max_colors\n    for v in targets:\n        neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n        # Prefer existing colors not used by neighbors\n        feasible = [c for c in range(1, max_colors+0) if c in colors and c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: choose color minimizing immediate conflicts (including possibly new color)\n            best_c = None\n            best_val = None\n            for c in range(1, max_colors+1):\n                val = sum(1 for nb in _adj[v] if (sol[nb-1] == c))\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            sol[v-1] = best_c if best_c is not None else sol[v-1]\n        # keep colors list updated\n        colors = list(sorted(set(sol)))\n\n    # Apply a Kempe swap to further diversify\n    sol = _kempe_component_swap(sol)\n\n    # Normalize labels to contiguous 1..k' to avoid gap penalties\n    sol = _relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: _conflicts_of_vertex() missing 1 required positional argument: 'v'.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002034623}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS;c[i] in {1,...,k} for vertex i (1-indexed). Labels contiguous {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Constants and graph definition (1-indexed vertices)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    HARD_PEN = 10**9\n    PEN_GAP = 2000.0\n    PEN_EDGE = 100.0\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        fitness += PEN_GAP\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local bind\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return float(fitness)\n","Vecindad":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _conflicts_of_vertex(sol, v):\n    c = sol[v-1]\n    cnt = 0\n    for nb in _adj[v]:\n        if sol[nb-1] == c:\n            cnt += 1\n    return cnt\n\ndef _total_conflicts(sol):\n    cnt = 0\n    for (u, v) in _EDGES:\n        if sol[u-1] == sol[v-1]:\n            cnt += 1\n    return cnt\n\ndef _kempe_swap(sol, color_a, color_b, start_v):\n    # BFS on subgraph induced by colors {a,b}, swap within the connected component containing start_v\n    n = len(sol)\n    if start_v < 1 or start_v > n:\n        return sol[:]\n    if sol[start_v-1] not in (color_a, color_b):\n        return sol[:]\n    target_set = {color_a, color_b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target_set:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        cv = out[v-1]\n        if cv == color_a:\n            out[v-1] = color_b\n        elif cv == color_b:\n            out[v-1] = color_a\n    return out\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _saturation(sol):\n    # returns list of (v, saturation_degree)\n    sat = []\n    for v in range(1, 10):\n        neigh_colors = set(sol[nb-1] for nb in _adj[v])\n        sat.append((v, len(neigh_colors)))\n    return sat\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input\")\n    sol = solution[:]\n    colors = list(sorted(set(sol)))\n    k = max(colors)\n\n    move_choices = [\"recolor_best\", \"kempe\", \"class_swap\", \"dsatur_recolor\"]\n    move = random.choices(move_choices, weights=[4, 3, 1, 2], k=1)[0]\n\n    if move == \"recolor_best\":\n        v = random.randrange(1, 10)\n        current = sol[v-1]\n        best_score = None\n        best_colors = []\n        for c in colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            score = _conflicts_of_vertex(tmp, v)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        return (sol, \"recolor_best\")\n\n    if move == \"kempe\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a start vertex that has color a or b\n            candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n            if candidates:\n                v0 = random.choice(candidates)\n                neigh = _kempe_swap(sol, a, b, v0)\n                return (neigh, f\"kempe({a},{b})\")\n        return (sol, \"kempe_noop\")\n\n    if move == \"class_swap\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            neigh = sol[:]\n            for i in range(9):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, f\"class_swap({a},{b})\")\n        return (sol, \"class_swap_noop\")\n\n    # dsatur_recolor\n    sat = _saturation(sol)\n    max_sat = max(s for _, s in sat)\n    candidates = [v for v, s in sat if s == max_sat]\n    v = random.choice(candidates)\n    current = sol[v-1]\n    neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n    # Prefer existing colors not in neighbor_colors\n    feasible = [c for c in colors if c != current and c not in neighbor_colors]\n    if feasible:\n        sol[v-1] = random.choice(feasible)\n    else:\n        # If none feasible, try any different existing color to mix\n        alt = [c for c in colors if c != current]\n        if alt:\n            sol[v-1] = random.choice(alt)\n    return (sol, \"dsatur_recolor\")\n","Perturbacion":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _vertex_conflicts(sol, v):\n    c = sol[v-1]\n    return sum(1 for nb in _adj[v] if sol[nb-1] == c)\n\ndef _total_conflicts(sol):\n    return sum(1 for (u, v) in _EDGES if sol[u-1] == sol[v-1])\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _kempe_component_swap(sol):\n    colors = list(sorted(set(sol)))\n    if len(colors) < 2:\n        return sol[:]\n    a, b = random.sample(colors, 2)\n    # choose a start vertex carrying color a or b\n    candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n    if not candidates:\n        return sol[:]\n    start_v = random.choice(candidates)\n    target = {a, b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        out[v-1] = a if out[v-1] == b else (b if out[v-1] == a else out[v-1])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n\n    # Identify high-conflict vertices\n    conflicts = [(v, _vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, c in conflicts[:m]]\n\n    colors = list(sorted(set(sol)))\n    max_colors = max(colors) + 1  # allow slight expansion during perturbation\n\n    # Greedy recolor targets using limited palette 1..max_colors\n    for v in targets:\n        neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n        # Prefer existing colors not used by neighbors\n        feasible = [c for c in range(1, max_colors+0) if c in colors and c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: choose color minimizing immediate conflicts (including possibly new color)\n            best_c = None\n            best_val = None\n            for c in range(1, max_colors+1):\n                val = sum(1 for nb in _adj[v] if (sol[nb-1] == c))\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            sol[v-1] = best_c if best_c is not None else sol[v-1]\n        # keep colors list updated\n        colors = list(sorted(set(sol)))\n\n    # Apply a Kempe swap to further diversify\n    sol = _kempe_component_swap(sol)\n\n    # Normalize labels to contiguous 1..k' to avoid gap penalties\n    sol = _relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: _conflicts_of_vertex() missing 1 required positional argument: 'v'.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001577448}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS;c[i] in {1,...,k} for vertex i (1-indexed). Labels contiguous {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Constants and graph definition (1-indexed vertices)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    HARD_PEN = 10**9\n    PEN_GAP = 2000.0\n    PEN_EDGE = 100.0\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        fitness += PEN_GAP\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local bind\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return float(fitness)\n","Vecindad":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _conflicts_of_vertex(sol, v):\n    c = sol[v-1]\n    cnt = 0\n    for nb in _adj[v]:\n        if sol[nb-1] == c:\n            cnt += 1\n    return cnt\n\ndef _total_conflicts(sol):\n    cnt = 0\n    for (u, v) in _EDGES:\n        if sol[u-1] == sol[v-1]:\n            cnt += 1\n    return cnt\n\ndef _kempe_swap(sol, color_a, color_b, start_v):\n    # BFS on subgraph induced by colors {a,b}, swap within the connected component containing start_v\n    n = len(sol)\n    if start_v < 1 or start_v > n:\n        return sol[:]\n    if sol[start_v-1] not in (color_a, color_b):\n        return sol[:]\n    target_set = {color_a, color_b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target_set:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        cv = out[v-1]\n        if cv == color_a:\n            out[v-1] = color_b\n        elif cv == color_b:\n            out[v-1] = color_a\n    return out\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _saturation(sol):\n    # returns list of (v, saturation_degree)\n    sat = []\n    for v in range(1, 10):\n        neigh_colors = set(sol[nb-1] for nb in _adj[v])\n        sat.append((v, len(neigh_colors)))\n    return sat\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input\")\n    sol = solution[:]\n    colors = list(sorted(set(sol)))\n    k = max(colors)\n\n    move_choices = [\"recolor_best\", \"kempe\", \"class_swap\", \"dsatur_recolor\"]\n    move = random.choices(move_choices, weights=[4, 3, 1, 2], k=1)[0]\n\n    if move == \"recolor_best\":\n        v = random.randrange(1, 10)\n        current = sol[v-1]\n        best_score = None\n        best_colors = []\n        for c in colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            score = _conflicts_of_vertex(tmp, v)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        return (sol, \"recolor_best\")\n\n    if move == \"kempe\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a start vertex that has color a or b\n            candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n            if candidates:\n                v0 = random.choice(candidates)\n                neigh = _kempe_swap(sol, a, b, v0)\n                return (neigh, f\"kempe({a},{b})\")\n        return (sol, \"kempe_noop\")\n\n    if move == \"class_swap\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            neigh = sol[:]\n            for i in range(9):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, f\"class_swap({a},{b})\")\n        return (sol, \"class_swap_noop\")\n\n    # dsatur_recolor\n    sat = _saturation(sol)\n    max_sat = max(s for _, s in sat)\n    candidates = [v for v, s in sat if s == max_sat]\n    v = random.choice(candidates)\n    current = sol[v-1]\n    neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n    # Prefer existing colors not in neighbor_colors\n    feasible = [c for c in colors if c != current and c not in neighbor_colors]\n    if feasible:\n        sol[v-1] = random.choice(feasible)\n    else:\n        # If none feasible, try any different existing color to mix\n        alt = [c for c in colors if c != current]\n        if alt:\n            sol[v-1] = random.choice(alt)\n    return (sol, \"dsatur_recolor\")\n","Perturbacion":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _vertex_conflicts(sol, v):\n    c = sol[v-1]\n    return sum(1 for nb in _adj[v] if sol[nb-1] == c)\n\ndef _total_conflicts(sol):\n    return sum(1 for (u, v) in _EDGES if sol[u-1] == sol[v-1])\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _kempe_component_swap(sol):\n    colors = list(sorted(set(sol)))\n    if len(colors) < 2:\n        return sol[:]\n    a, b = random.sample(colors, 2)\n    # choose a start vertex carrying color a or b\n    candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n    if not candidates:\n        return sol[:]\n    start_v = random.choice(candidates)\n    target = {a, b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        out[v-1] = a if out[v-1] == b else (b if out[v-1] == a else out[v-1])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n\n    # Identify high-conflict vertices\n    conflicts = [(v, _vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, c in conflicts[:m]]\n\n    colors = list(sorted(set(sol)))\n    max_colors = max(colors) + 1  # allow slight expansion during perturbation\n\n    # Greedy recolor targets using limited palette 1..max_colors\n    for v in targets:\n        neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n        # Prefer existing colors not used by neighbors\n        feasible = [c for c in range(1, max_colors+0) if c in colors and c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: choose color minimizing immediate conflicts (including possibly new color)\n            best_c = None\n            best_val = None\n            for c in range(1, max_colors+1):\n                val = sum(1 for nb in _adj[v] if (sol[nb-1] == c))\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            sol[v-1] = best_c if best_c is not None else sol[v-1]\n        # keep colors list updated\n        colors = list(sorted(set(sol)))\n\n    # Apply a Kempe swap to further diversify\n    sol = _kempe_component_swap(sol)\n\n    # Normalize labels to contiguous 1..k' to avoid gap penalties\n    sol = _relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: _conflicts_of_vertex() missing 1 required positional argument: 'v'.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001575198}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors first\n        try_colors = list(colors)\n        random.shuffle(try_colors)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = vertex_conflicts(tmp, v)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                # fallback: pick any other color if exists\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        # Prefer existing colors not in neighbor set\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: pick color minimizing immediate equal-neighbor count\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00265375}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors first\n        try_colors = list(colors)\n        random.shuffle(try_colors)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = vertex_conflicts(tmp, v)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                # fallback: pick any other color if exists\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        # Prefer existing colors not in neighbor set\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: pick color minimizing immediate equal-neighbor count\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Resultados":[[1,2,1,2,3,1,2,2,1],7000000000002.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003223266}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors first\n        try_colors = list(colors)\n        random.shuffle(try_colors)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = vertex_conflicts(tmp, v)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                # fallback: pick any other color if exists\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        # Prefer existing colors not in neighbor set\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: pick color minimizing immediate equal-neighbor count\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001477297}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\n# Required signature line (informational): def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize global delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors plus possible new color k+1 with small probability\n        k = max(sol)\n        try_colors = list(colors)\n        if random.random() < 0.15:\n            try_colors.append(k + 1)\n        random.shuffle(try_colors)\n        base_conf = total_conflicts(sol)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = total_conflicts(tmp)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice([u, v]) if random.random() < 0.7 else random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002628589}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\n# Required signature line (informational): def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize global delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors plus possible new color k+1 with small probability\n        k = max(sol)\n        try_colors = list(colors)\n        if random.random() < 0.15:\n            try_colors.append(k + 1)\n        random.shuffle(try_colors)\n        base_conf = total_conflicts(sol)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = total_conflicts(tmp)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice([u, v]) if random.random() < 0.7 else random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Resultados":[[1,2,3,4,2,3,2,4,3],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003206496}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\n# Required signature line (informational): def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize global delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors plus possible new color k+1 with small probability\n        k = max(sol)\n        try_colors = list(colors)\n        if random.random() < 0.15:\n            try_colors.append(k + 1)\n        random.shuffle(try_colors)\n        base_conf = total_conflicts(sol)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = total_conflicts(tmp)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice([u, v]) if random.random() < 0.7 else random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001456247}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    LARGE = 10**9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data (embedded locally)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty per conflict; lower is better\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        # Return a trivial safe neighbour\n        return ([1,2,3,1,2,3,2,1,3], \"recolor\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append(u)\n            conflicts.append(v)\n    # Choose a vertex to recolor (prefer conflicts)\n    if conflicts:\n        u = random.choice(conflicts)\n    else:\n        u = random.randint(1, 9)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    # Candidate colors: allow existing colors and with small prob a new color\n    candidates = set(range(1, max_color + 1))\n    if random.random() < 0.15:\n        candidates.add(max_color + 1)\n    # Remove current color to ensure movement, if possible\n    if s[u-1] in candidates and len(candidates) > 1:\n        candidates.discard(s[u-1])\n    # Heuristic: try to avoid neighbor colors\n    neighbor_colors = {s[v-1] for v in adj[u]}\n    feasible = [c for c in candidates if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        # If no feasible color among candidates, pick any candidate (may keep conflicts to allow SA to escape)\n        new_color = random.choice(list(candidates))\n    s[u-1] = new_color\n    return (s, \"recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        u = random.randint(1, 9)\n        neighbor_colors = {s[v-1] for v in adj[u]}\n        candidates = set(range(1, max_color + 1))\n        # With small probability introduce a new color to escape local minima\n        if random.random() < 0.2:\n            candidates.add(max_color + 1)\n        # Prefer colors not used by neighbors; if none, pick any\n        preferred = [c for c in candidates if c not in neighbor_colors]\n        if preferred:\n            new_color = random.choice(preferred)\n        else:\n            new_color = random.choice(list(candidates))\n        s[u-1] = new_color\n        max_color = max(max_color, new_color)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001085902}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    LARGE = 10**9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data (embedded locally)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty per conflict; lower is better\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        # Return a trivial safe neighbour\n        return ([1,2,3,1,2,3,2,1,3], \"recolor\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append(u)\n            conflicts.append(v)\n    # Choose a vertex to recolor (prefer conflicts)\n    if conflicts:\n        u = random.choice(conflicts)\n    else:\n        u = random.randint(1, 9)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    # Candidate colors: allow existing colors and with small prob a new color\n    candidates = set(range(1, max_color + 1))\n    if random.random() < 0.15:\n        candidates.add(max_color + 1)\n    # Remove current color to ensure movement, if possible\n    if s[u-1] in candidates and len(candidates) > 1:\n        candidates.discard(s[u-1])\n    # Heuristic: try to avoid neighbor colors\n    neighbor_colors = {s[v-1] for v in adj[u]}\n    feasible = [c for c in candidates if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        # If no feasible color among candidates, pick any candidate (may keep conflicts to allow SA to escape)\n        new_color = random.choice(list(candidates))\n    s[u-1] = new_color\n    return (s, \"recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        u = random.randint(1, 9)\n        neighbor_colors = {s[v-1] for v in adj[u]}\n        candidates = set(range(1, max_color + 1))\n        # With small probability introduce a new color to escape local minima\n        if random.random() < 0.2:\n            candidates.add(max_color + 1)\n        # Prefer colors not used by neighbors; if none, pick any\n        preferred = [c for c in candidates if c not in neighbor_colors]\n        if preferred:\n            new_color = random.choice(preferred)\n        else:\n            new_color = random.choice(list(candidates))\n        s[u-1] = new_color\n        max_color = max(max_color, new_color)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00086594}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    LARGE = 10**9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data (embedded locally)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty per conflict; lower is better\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        # Return a trivial safe neighbour\n        return ([1,2,3,1,2,3,2,1,3], \"recolor\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append(u)\n            conflicts.append(v)\n    # Choose a vertex to recolor (prefer conflicts)\n    if conflicts:\n        u = random.choice(conflicts)\n    else:\n        u = random.randint(1, 9)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    # Candidate colors: allow existing colors and with small prob a new color\n    candidates = set(range(1, max_color + 1))\n    if random.random() < 0.15:\n        candidates.add(max_color + 1)\n    # Remove current color to ensure movement, if possible\n    if s[u-1] in candidates and len(candidates) > 1:\n        candidates.discard(s[u-1])\n    # Heuristic: try to avoid neighbor colors\n    neighbor_colors = {s[v-1] for v in adj[u]}\n    feasible = [c for c in candidates if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        # If no feasible color among candidates, pick any candidate (may keep conflicts to allow SA to escape)\n        new_color = random.choice(list(candidates))\n    s[u-1] = new_color\n    return (s, \"recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        u = random.randint(1, 9)\n        neighbor_colors = {s[v-1] for v in adj[u]}\n        candidates = set(range(1, max_color + 1))\n        # With small probability introduce a new color to escape local minima\n        if random.random() < 0.2:\n            candidates.add(max_color + 1)\n        # Prefer colors not used by neighbors; if none, pick any\n        preferred = [c for c in candidates if c not in neighbor_colors]\n        if preferred:\n            new_color = random.choice(preferred)\n        else:\n            new_color = random.choice(list(candidates))\n        s[u-1] = new_color\n        max_color = max(max_color, new_color)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000791319}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return ([1,2,3,1,2,3,2,1,3], \"repair\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_incident_conflicts(sol, u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v-1] == color:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol, prefer_conflict=True):\n        # Choose vertex\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if prefer_conflict and conflicts_vertices:\n            u = random.choice(list(conflicts_vertices))\n        else:\n            u = random.randint(1, 9)\n        used = set(sol)\n        current = sol[u-1]\n        candidates = list(used)\n        # Try to stay within current colors; if impossible, allow new color\n        best_color = current\n        best_score = 10**9\n        for c in candidates:\n            if c == current:\n                continue\n            score = count_incident_conflicts(sol, u, c)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        if best_score == 0:\n            sol[u-1] = best_color\n            return sol, \"recolor-minconflict\"\n        # No conflict-free among existing colors; optionally introduce a new color\n        if random.random() < 0.5:\n            new_color = max(used) + 1\n            sol[u-1] = new_color\n            return sol, \"recolor-newcolor\"\n        else:\n            sol[u-1] = best_color\n            return sol, \"recolor-leastconflict\"\n\n    def kempe_chain_swap(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        # Choose a second color from neighbors or existing colors\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                # Nothing to swap\n                return recolor_min_conflict(sol, prefer_conflict=False)\n            cv = random.choice([c for c in used if c != cu])\n        # Build Kempe chain component of colors cu and cv containing u\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        component = []\n        while stack:\n            x = stack.pop()\n            component.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        # Swap colors cu <-> cv in the component\n        for x in component:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol, \"kempe-swap\"\n\n    def merge_move(sol):\n        # Attempt to reduce number of colors by moving a vertex from a rare color to another feasible color\n        used = list(set(sol))\n        if len(used) <= 1:\n            return recolor_min_conflict(sol, prefer_conflict=False)\n        color_counts = {c: 0 for c in used}\n        for c in sol:\n            color_counts[c] += 1\n        src = min(color_counts, key=lambda c: color_counts[c])\n        # Pick a vertex with color src\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        u = random.choice(verts)\n        # Try to assign a different existing color\n        dests = [c for c in used if c != src]\n        random.shuffle(dests)\n        for c in dests:\n            if all(sol[v-1] != c for v in adj[u]):\n                sol[u-1] = c\n                return sol, \"merge-move\"\n        # Fallback to min-conflict among dests\n        best_c = None\n        best_score = 10**9\n        for c in dests:\n            sc = count_incident_conflicts(sol, u, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c is not None and best_c != sol[u-1]:\n            sol[u-1] = best_c\n            return sol, \"merge-minconflict\"\n        return recolor_min_conflict(sol, prefer_conflict=False)\n\n    # Decide operator adaptively\n    # If conflicts exist, prioritize fixing them; else use structural moves\n    has_conflict = False\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            has_conflict = True\n            break\n\n    r = random.random()\n    if has_conflict:\n        if r < 0.7:\n            ns, mt = recolor_min_conflict(s[:], prefer_conflict=True)\n            return (ns, mt)\n        else:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n    else:\n        if r < 0.5:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n        else:\n            ns, mt = merge_move(s[:])\n            return (ns, mt)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap_once(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                return sol\n            cv = random.choice([c for c in used if c != cu])\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol\n\n    def random_recolor(sol):\n        u = random.randint(1, 9)\n        used = set(sol)\n        neighbor_colors = {sol[v-1] for v in adj[u]}\n        candidates = [c for c in used if c != sol[u-1] and c not in neighbor_colors]\n        if candidates:\n            sol[u-1] = random.choice(candidates)\n            return sol\n        # Allow introducing a new color with small probability to escape traps\n        if random.random() < 0.3:\n            sol[u-1] = max(used) + 1\n            return sol\n        # Else pick least-conflict among existing\n        best_c = sol[u-1]\n        best_score = 10**9\n        for c in used:\n            if c == sol[u-1]:\n                continue\n            score = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    score += 1\n            if score < best_score:\n                best_score = score\n                best_c = c\n        sol[u-1] = best_c\n        return sol\n\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.6:\n            s = kempe_swap_once(s)\n        else:\n            s = random_recolor(s)\n    return s\n","Resultados":[[1,3,2,1,3,2,3,1,2],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002288786}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return ([1,2,3,1,2,3,2,1,3], \"repair\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_incident_conflicts(sol, u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v-1] == color:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol, prefer_conflict=True):\n        # Choose vertex\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if prefer_conflict and conflicts_vertices:\n            u = random.choice(list(conflicts_vertices))\n        else:\n            u = random.randint(1, 9)\n        used = set(sol)\n        current = sol[u-1]\n        candidates = list(used)\n        # Try to stay within current colors; if impossible, allow new color\n        best_color = current\n        best_score = 10**9\n        for c in candidates:\n            if c == current:\n                continue\n            score = count_incident_conflicts(sol, u, c)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        if best_score == 0:\n            sol[u-1] = best_color\n            return sol, \"recolor-minconflict\"\n        # No conflict-free among existing colors; optionally introduce a new color\n        if random.random() < 0.5:\n            new_color = max(used) + 1\n            sol[u-1] = new_color\n            return sol, \"recolor-newcolor\"\n        else:\n            sol[u-1] = best_color\n            return sol, \"recolor-leastconflict\"\n\n    def kempe_chain_swap(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        # Choose a second color from neighbors or existing colors\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                # Nothing to swap\n                return recolor_min_conflict(sol, prefer_conflict=False)\n            cv = random.choice([c for c in used if c != cu])\n        # Build Kempe chain component of colors cu and cv containing u\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        component = []\n        while stack:\n            x = stack.pop()\n            component.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        # Swap colors cu <-> cv in the component\n        for x in component:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol, \"kempe-swap\"\n\n    def merge_move(sol):\n        # Attempt to reduce number of colors by moving a vertex from a rare color to another feasible color\n        used = list(set(sol))\n        if len(used) <= 1:\n            return recolor_min_conflict(sol, prefer_conflict=False)\n        color_counts = {c: 0 for c in used}\n        for c in sol:\n            color_counts[c] += 1\n        src = min(color_counts, key=lambda c: color_counts[c])\n        # Pick a vertex with color src\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        u = random.choice(verts)\n        # Try to assign a different existing color\n        dests = [c for c in used if c != src]\n        random.shuffle(dests)\n        for c in dests:\n            if all(sol[v-1] != c for v in adj[u]):\n                sol[u-1] = c\n                return sol, \"merge-move\"\n        # Fallback to min-conflict among dests\n        best_c = None\n        best_score = 10**9\n        for c in dests:\n            sc = count_incident_conflicts(sol, u, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c is not None and best_c != sol[u-1]:\n            sol[u-1] = best_c\n            return sol, \"merge-minconflict\"\n        return recolor_min_conflict(sol, prefer_conflict=False)\n\n    # Decide operator adaptively\n    # If conflicts exist, prioritize fixing them; else use structural moves\n    has_conflict = False\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            has_conflict = True\n            break\n\n    r = random.random()\n    if has_conflict:\n        if r < 0.7:\n            ns, mt = recolor_min_conflict(s[:], prefer_conflict=True)\n            return (ns, mt)\n        else:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n    else:\n        if r < 0.5:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n        else:\n            ns, mt = merge_move(s[:])\n            return (ns, mt)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap_once(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                return sol\n            cv = random.choice([c for c in used if c != cu])\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol\n\n    def random_recolor(sol):\n        u = random.randint(1, 9)\n        used = set(sol)\n        neighbor_colors = {sol[v-1] for v in adj[u]}\n        candidates = [c for c in used if c != sol[u-1] and c not in neighbor_colors]\n        if candidates:\n            sol[u-1] = random.choice(candidates)\n            return sol\n        # Allow introducing a new color with small probability to escape traps\n        if random.random() < 0.3:\n            sol[u-1] = max(used) + 1\n            return sol\n        # Else pick least-conflict among existing\n        best_c = sol[u-1]\n        best_score = 10**9\n        for c in used:\n            if c == sol[u-1]:\n                continue\n            score = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    score += 1\n            if score < best_score:\n                best_score = score\n                best_c = c\n        sol[u-1] = best_c\n        return sol\n\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.6:\n            s = kempe_swap_once(s)\n        else:\n            s = random_recolor(s)\n    return s\n","Resultados":[[11,12,12,10,13,11,14,14,10],100003,[8,9,10,8,9,10,9,8,10],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002513918}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return ([1,2,3,1,2,3,2,1,3], \"repair\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_incident_conflicts(sol, u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v-1] == color:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol, prefer_conflict=True):\n        # Choose vertex\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if prefer_conflict and conflicts_vertices:\n            u = random.choice(list(conflicts_vertices))\n        else:\n            u = random.randint(1, 9)\n        used = set(sol)\n        current = sol[u-1]\n        candidates = list(used)\n        # Try to stay within current colors; if impossible, allow new color\n        best_color = current\n        best_score = 10**9\n        for c in candidates:\n            if c == current:\n                continue\n            score = count_incident_conflicts(sol, u, c)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        if best_score == 0:\n            sol[u-1] = best_color\n            return sol, \"recolor-minconflict\"\n        # No conflict-free among existing colors; optionally introduce a new color\n        if random.random() < 0.5:\n            new_color = max(used) + 1\n            sol[u-1] = new_color\n            return sol, \"recolor-newcolor\"\n        else:\n            sol[u-1] = best_color\n            return sol, \"recolor-leastconflict\"\n\n    def kempe_chain_swap(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        # Choose a second color from neighbors or existing colors\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                # Nothing to swap\n                return recolor_min_conflict(sol, prefer_conflict=False)\n            cv = random.choice([c for c in used if c != cu])\n        # Build Kempe chain component of colors cu and cv containing u\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        component = []\n        while stack:\n            x = stack.pop()\n            component.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        # Swap colors cu <-> cv in the component\n        for x in component:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol, \"kempe-swap\"\n\n    def merge_move(sol):\n        # Attempt to reduce number of colors by moving a vertex from a rare color to another feasible color\n        used = list(set(sol))\n        if len(used) <= 1:\n            return recolor_min_conflict(sol, prefer_conflict=False)\n        color_counts = {c: 0 for c in used}\n        for c in sol:\n            color_counts[c] += 1\n        src = min(color_counts, key=lambda c: color_counts[c])\n        # Pick a vertex with color src\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        u = random.choice(verts)\n        # Try to assign a different existing color\n        dests = [c for c in used if c != src]\n        random.shuffle(dests)\n        for c in dests:\n            if all(sol[v-1] != c for v in adj[u]):\n                sol[u-1] = c\n                return sol, \"merge-move\"\n        # Fallback to min-conflict among dests\n        best_c = None\n        best_score = 10**9\n        for c in dests:\n            sc = count_incident_conflicts(sol, u, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c is not None and best_c != sol[u-1]:\n            sol[u-1] = best_c\n            return sol, \"merge-minconflict\"\n        return recolor_min_conflict(sol, prefer_conflict=False)\n\n    # Decide operator adaptively\n    # If conflicts exist, prioritize fixing them; else use structural moves\n    has_conflict = False\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            has_conflict = True\n            break\n\n    r = random.random()\n    if has_conflict:\n        if r < 0.7:\n            ns, mt = recolor_min_conflict(s[:], prefer_conflict=True)\n            return (ns, mt)\n        else:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n    else:\n        if r < 0.5:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n        else:\n            ns, mt = merge_move(s[:])\n            return (ns, mt)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap_once(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                return sol\n            cv = random.choice([c for c in used if c != cu])\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol\n\n    def random_recolor(sol):\n        u = random.randint(1, 9)\n        used = set(sol)\n        neighbor_colors = {sol[v-1] for v in adj[u]}\n        candidates = [c for c in used if c != sol[u-1] and c not in neighbor_colors]\n        if candidates:\n            sol[u-1] = random.choice(candidates)\n            return sol\n        # Allow introducing a new color with small probability to escape traps\n        if random.random() < 0.3:\n            sol[u-1] = max(used) + 1\n            return sol\n        # Else pick least-conflict among existing\n        best_c = sol[u-1]\n        best_score = 10**9\n        for c in used:\n            if c == sol[u-1]:\n                continue\n            score = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    score += 1\n            if score < best_score:\n                best_score = score\n                best_c = c\n        sol[u-1] = best_c\n        return sol\n\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.6:\n            s = kempe_swap_once(s)\n        else:\n            s = random_recolor(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001414926}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        # never happens, guard\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict(sol):\n        # Choose a conflicted vertex (lowest index for determinism)\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = bad[0]\n        current = sol[u-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_score = 10**9\n        # Try only existing colors; do not introduce new colors during repair\n        for c in used:\n            if c == current:\n                continue\n            # Count incident conflicts if u recolored to c\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        # No improvement possible with existing colors; pick least-conflict anyway (no new color)\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        # Find smallest color class\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        src = min(colors, key=lambda c: counts[c])\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        dest_colors = [c for c in colors if c != src]\n        # Try each vertex deterministically\n        for u in sorted(verts):\n            neighbor_colors = {sol[v-1] for v in adj[u]}\n            for dc in dest_colors:\n                if dc not in neighbor_colors:\n                    sol[u-1] = dc\n                    sol = compress_colors(sol)\n                    return sol, True\n        return sol, False\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors targeting smallest class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        c1 = min(colors, key=lambda c: counts[c])\n        # pick c2 as the color most adjacent to c1 vertices to encourage elimination\n        border_counts = {c: 0 for c in colors}\n        for i, c in enumerate(sol, start=1):\n            if c != c1:\n                continue\n            for v in adj[i]:\n                border_counts[sol[v-1]] += 1\n        candidate_c2 = [c for c in colors if c != c1]\n        if not candidate_c2:\n            return sol, False\n        c2 = max(candidate_c2, key=lambda c: border_counts.get(c, 0))\n        # choose start vertex within c1 deterministically (lowest index)\n        starts = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not starts:\n            return sol, False\n        u0 = starts[0]\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        # Swap colors in component; preserves feasibility if input feasible\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        sol = compress_colors(sol)\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        # Try to reduce k via merge; if not, do a kempe swap\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; preserves feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        # pick a random start vertex and a second color different from its color\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def minconflict_recolor_step(sol):\n        # choose a conflicted vertex and recolor to least-conflict existing color\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        if not bad:\n            return sol\n        u = min(bad)\n        current = sol[u-1]\n        used = list(set(sol))\n        best = current\n        best_sc = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_sc:\n                best_sc = sc\n                best = c\n        sol[u-1] = best\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        # Random color permutation to diversify (structure-preserving)\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            if conflict_count(s) == 0:\n                break\n            s = minconflict_recolor_step(s)\n        s = compress_colors(s)\n        return s\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00283602}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        # never happens, guard\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict(sol):\n        # Choose a conflicted vertex (lowest index for determinism)\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = bad[0]\n        current = sol[u-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_score = 10**9\n        # Try only existing colors; do not introduce new colors during repair\n        for c in used:\n            if c == current:\n                continue\n            # Count incident conflicts if u recolored to c\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        # No improvement possible with existing colors; pick least-conflict anyway (no new color)\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        # Find smallest color class\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        src = min(colors, key=lambda c: counts[c])\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        dest_colors = [c for c in colors if c != src]\n        # Try each vertex deterministically\n        for u in sorted(verts):\n            neighbor_colors = {sol[v-1] for v in adj[u]}\n            for dc in dest_colors:\n                if dc not in neighbor_colors:\n                    sol[u-1] = dc\n                    sol = compress_colors(sol)\n                    return sol, True\n        return sol, False\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors targeting smallest class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        c1 = min(colors, key=lambda c: counts[c])\n        # pick c2 as the color most adjacent to c1 vertices to encourage elimination\n        border_counts = {c: 0 for c in colors}\n        for i, c in enumerate(sol, start=1):\n            if c != c1:\n                continue\n            for v in adj[i]:\n                border_counts[sol[v-1]] += 1\n        candidate_c2 = [c for c in colors if c != c1]\n        if not candidate_c2:\n            return sol, False\n        c2 = max(candidate_c2, key=lambda c: border_counts.get(c, 0))\n        # choose start vertex within c1 deterministically (lowest index)\n        starts = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not starts:\n            return sol, False\n        u0 = starts[0]\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        # Swap colors in component; preserves feasibility if input feasible\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        sol = compress_colors(sol)\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        # Try to reduce k via merge; if not, do a kempe swap\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; preserves feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        # pick a random start vertex and a second color different from its color\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def minconflict_recolor_step(sol):\n        # choose a conflicted vertex and recolor to least-conflict existing color\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        if not bad:\n            return sol\n        u = min(bad)\n        current = sol[u-1]\n        used = list(set(sol))\n        best = current\n        best_sc = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_sc:\n                best_sc = sc\n                best = c\n        sol[u-1] = best\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        # Random color permutation to diversify (structure-preserving)\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            if conflict_count(s) == 0:\n                break\n            s = minconflict_recolor_step(s)\n        s = compress_colors(s)\n        return s\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003061681}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        # never happens, guard\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict(sol):\n        # Choose a conflicted vertex (lowest index for determinism)\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = bad[0]\n        current = sol[u-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_score = 10**9\n        # Try only existing colors; do not introduce new colors during repair\n        for c in used:\n            if c == current:\n                continue\n            # Count incident conflicts if u recolored to c\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        # No improvement possible with existing colors; pick least-conflict anyway (no new color)\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        # Find smallest color class\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        src = min(colors, key=lambda c: counts[c])\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        dest_colors = [c for c in colors if c != src]\n        # Try each vertex deterministically\n        for u in sorted(verts):\n            neighbor_colors = {sol[v-1] for v in adj[u]}\n            for dc in dest_colors:\n                if dc not in neighbor_colors:\n                    sol[u-1] = dc\n                    sol = compress_colors(sol)\n                    return sol, True\n        return sol, False\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors targeting smallest class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        c1 = min(colors, key=lambda c: counts[c])\n        # pick c2 as the color most adjacent to c1 vertices to encourage elimination\n        border_counts = {c: 0 for c in colors}\n        for i, c in enumerate(sol, start=1):\n            if c != c1:\n                continue\n            for v in adj[i]:\n                border_counts[sol[v-1]] += 1\n        candidate_c2 = [c for c in colors if c != c1]\n        if not candidate_c2:\n            return sol, False\n        c2 = max(candidate_c2, key=lambda c: border_counts.get(c, 0))\n        # choose start vertex within c1 deterministically (lowest index)\n        starts = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not starts:\n            return sol, False\n        u0 = starts[0]\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        # Swap colors in component; preserves feasibility if input feasible\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        sol = compress_colors(sol)\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        # Try to reduce k via merge; if not, do a kempe swap\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; preserves feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        # pick a random start vertex and a second color different from its color\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def minconflict_recolor_step(sol):\n        # choose a conflicted vertex and recolor to least-conflict existing color\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        if not bad:\n            return sol\n        u = min(bad)\n        current = sol[u-1]\n        used = list(set(sol))\n        best = current\n        best_sc = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_sc:\n                best_sc = sc\n                best = c\n        sol[u-1] = best\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        # Random color permutation to diversify (structure-preserving)\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            if conflict_count(s) == 0:\n                break\n            s = minconflict_recolor_step(s)\n        s = compress_colors(s)\n        return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001588697}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict_with_new(sol):\n        # Choose a conflicted vertex; break ties randomly\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = random.choice(bad)\n        current = sol[u-1]\n        used = sorted(set(sol))\n        # Evaluate existing colors\n        best_c = current\n        best_score = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_score > 0:\n            # Allow a temporary new color to break conflicts fast\n            new_color = max(used) + 1\n            # Check incident conflicts if using new color (always 0 by construction)\n            sol[u-1] = new_color\n            return sol, True\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class; iterate multiple moves\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        improved = False\n        changed = True\n        while changed:\n            changed = False\n            colors = sorted(set(sol))\n            if len(colors) <= 1:\n                break\n            # Find smallest color class\n            counts = {c: 0 for c in colors}\n            for c in sol:\n                counts[c] += 1\n            src = min(colors, key=lambda c: counts[c])\n            verts = [i+1 for i, c in enumerate(sol) if c == src]\n            dest_colors = [c for c in colors if c != src]\n            random.shuffle(verts)\n            # Try move each vertex to any compatible destination color\n            for u in verts:\n                neighbor_colors = {sol[v-1] for v in adj[u]}\n                # Order destination colors by minimal conflicts potential\n                dest_colors_sorted = sorted(dest_colors, key=lambda dc: sum(1 for v in adj[u] if sol[v-1] == dc))\n                moved = False\n                for dc in dest_colors_sorted:\n                    if dc not in neighbor_colors:\n                        sol[u-1] = dc\n                        changed = True\n                        improved = True\n                        moved = True\n                        break\n                if moved:\n                    continue\n            # If source color emptied, compress and continue\n            if all(c != src for c in sol):\n                sol = compress_colors(sol)\n        # Final attempt: if still same k, try a focused Kempe swap between src and best dest\n        return sol, improved\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors; randomized start to avoid cycling\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        c1 = random.choice(colors)\n        c2_choices = [c for c in colors if c != c1]\n        if not c2_choices:\n            return sol, False\n        c2 = random.choice(c2_choices)\n        # choose start vertex among those with color c1 maximizing boundary degree\n        c1_vertices = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not c1_vertices:\n            return sol, False\n        def boundary_deg(u):\n            return sum(1 for v in adj[u] if sol[v-1] == c2)\n        best_bd = max(boundary_deg(u) for u in c1_vertices)\n        candidates = [u for u in c1_vertices if boundary_deg(u) == best_bd]\n        u0 = random.choice(candidates)\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict_with_new(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            ns = compress_colors(ns)\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        if swapped:\n            ns = compress_colors(ns)\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; aims to preserve feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def random_recolor_break_sym(sol):\n        # Occasionally move a vertex to a new color to diversify\n        i = random.randint(1, 9)\n        used = set(sol)\n        new_c = max(used) + 1\n        sol[i-1] = new_c\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        # Perform a few Kempe swaps and optional random recolor, then compress\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        if random.random() < 0.25:\n            s = random_recolor_break_sym(s)\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation: min-conflict recolors and compression\n        for _ in range(6):\n            if conflict_count(s) == 0:\n                break\n            # pick conflicted vertex with random tie-breaking\n            bad = set()\n            for u, v in edges:\n                if s[u-1] == s[v-1]:\n                    bad.add(u)\n                    bad.add(v)\n            if not bad:\n                break\n            u = random.choice(list(bad))\n            current = s[u-1]\n            used = list(set(s))\n            # try existing colors first\n            best = current\n            best_sc = 10**9\n            for c in used:\n                if c == current:\n                    continue\n                sc = 0\n                for v in adj[u]:\n                    if s[v-1] == c:\n                        sc += 1\n                if sc < best_sc:\n                    best_sc = sc\n                    best = c\n            if best_sc > 0:\n                # allow new color to break conflicts\n                best = max(used) + 1\n            s[u-1] = best\n        s = compress_colors(s)\n        return s\n","Resultados":[[1,2,3,2,1,3,2,2,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002975172}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict_with_new(sol):\n        # Choose a conflicted vertex; break ties randomly\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = random.choice(bad)\n        current = sol[u-1]\n        used = sorted(set(sol))\n        # Evaluate existing colors\n        best_c = current\n        best_score = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_score > 0:\n            # Allow a temporary new color to break conflicts fast\n            new_color = max(used) + 1\n            # Check incident conflicts if using new color (always 0 by construction)\n            sol[u-1] = new_color\n            return sol, True\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class; iterate multiple moves\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        improved = False\n        changed = True\n        while changed:\n            changed = False\n            colors = sorted(set(sol))\n            if len(colors) <= 1:\n                break\n            # Find smallest color class\n            counts = {c: 0 for c in colors}\n            for c in sol:\n                counts[c] += 1\n            src = min(colors, key=lambda c: counts[c])\n            verts = [i+1 for i, c in enumerate(sol) if c == src]\n            dest_colors = [c for c in colors if c != src]\n            random.shuffle(verts)\n            # Try move each vertex to any compatible destination color\n            for u in verts:\n                neighbor_colors = {sol[v-1] for v in adj[u]}\n                # Order destination colors by minimal conflicts potential\n                dest_colors_sorted = sorted(dest_colors, key=lambda dc: sum(1 for v in adj[u] if sol[v-1] == dc))\n                moved = False\n                for dc in dest_colors_sorted:\n                    if dc not in neighbor_colors:\n                        sol[u-1] = dc\n                        changed = True\n                        improved = True\n                        moved = True\n                        break\n                if moved:\n                    continue\n            # If source color emptied, compress and continue\n            if all(c != src for c in sol):\n                sol = compress_colors(sol)\n        # Final attempt: if still same k, try a focused Kempe swap between src and best dest\n        return sol, improved\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors; randomized start to avoid cycling\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        c1 = random.choice(colors)\n        c2_choices = [c for c in colors if c != c1]\n        if not c2_choices:\n            return sol, False\n        c2 = random.choice(c2_choices)\n        # choose start vertex among those with color c1 maximizing boundary degree\n        c1_vertices = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not c1_vertices:\n            return sol, False\n        def boundary_deg(u):\n            return sum(1 for v in adj[u] if sol[v-1] == c2)\n        best_bd = max(boundary_deg(u) for u in c1_vertices)\n        candidates = [u for u in c1_vertices if boundary_deg(u) == best_bd]\n        u0 = random.choice(candidates)\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict_with_new(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            ns = compress_colors(ns)\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        if swapped:\n            ns = compress_colors(ns)\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; aims to preserve feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def random_recolor_break_sym(sol):\n        # Occasionally move a vertex to a new color to diversify\n        i = random.randint(1, 9)\n        used = set(sol)\n        new_c = max(used) + 1\n        sol[i-1] = new_c\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        # Perform a few Kempe swaps and optional random recolor, then compress\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        if random.random() < 0.25:\n            s = random_recolor_break_sym(s)\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation: min-conflict recolors and compression\n        for _ in range(6):\n            if conflict_count(s) == 0:\n                break\n            # pick conflicted vertex with random tie-breaking\n            bad = set()\n            for u, v in edges:\n                if s[u-1] == s[v-1]:\n                    bad.add(u)\n                    bad.add(v)\n            if not bad:\n                break\n            u = random.choice(list(bad))\n            current = s[u-1]\n            used = list(set(s))\n            # try existing colors first\n            best = current\n            best_sc = 10**9\n            for c in used:\n                if c == current:\n                    continue\n                sc = 0\n                for v in adj[u]:\n                    if s[v-1] == c:\n                        sc += 1\n                if sc < best_sc:\n                    best_sc = sc\n                    best = c\n            if best_sc > 0:\n                # allow new color to break conflicts\n                best = max(used) + 1\n            s[u-1] = best\n        s = compress_colors(s)\n        return s\n","Resultados":[[1,2,3,2,1,3,2,2,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003283195}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict_with_new(sol):\n        # Choose a conflicted vertex; break ties randomly\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = random.choice(bad)\n        current = sol[u-1]\n        used = sorted(set(sol))\n        # Evaluate existing colors\n        best_c = current\n        best_score = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_score > 0:\n            # Allow a temporary new color to break conflicts fast\n            new_color = max(used) + 1\n            # Check incident conflicts if using new color (always 0 by construction)\n            sol[u-1] = new_color\n            return sol, True\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class; iterate multiple moves\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        improved = False\n        changed = True\n        while changed:\n            changed = False\n            colors = sorted(set(sol))\n            if len(colors) <= 1:\n                break\n            # Find smallest color class\n            counts = {c: 0 for c in colors}\n            for c in sol:\n                counts[c] += 1\n            src = min(colors, key=lambda c: counts[c])\n            verts = [i+1 for i, c in enumerate(sol) if c == src]\n            dest_colors = [c for c in colors if c != src]\n            random.shuffle(verts)\n            # Try move each vertex to any compatible destination color\n            for u in verts:\n                neighbor_colors = {sol[v-1] for v in adj[u]}\n                # Order destination colors by minimal conflicts potential\n                dest_colors_sorted = sorted(dest_colors, key=lambda dc: sum(1 for v in adj[u] if sol[v-1] == dc))\n                moved = False\n                for dc in dest_colors_sorted:\n                    if dc not in neighbor_colors:\n                        sol[u-1] = dc\n                        changed = True\n                        improved = True\n                        moved = True\n                        break\n                if moved:\n                    continue\n            # If source color emptied, compress and continue\n            if all(c != src for c in sol):\n                sol = compress_colors(sol)\n        # Final attempt: if still same k, try a focused Kempe swap between src and best dest\n        return sol, improved\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors; randomized start to avoid cycling\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        c1 = random.choice(colors)\n        c2_choices = [c for c in colors if c != c1]\n        if not c2_choices:\n            return sol, False\n        c2 = random.choice(c2_choices)\n        # choose start vertex among those with color c1 maximizing boundary degree\n        c1_vertices = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not c1_vertices:\n            return sol, False\n        def boundary_deg(u):\n            return sum(1 for v in adj[u] if sol[v-1] == c2)\n        best_bd = max(boundary_deg(u) for u in c1_vertices)\n        candidates = [u for u in c1_vertices if boundary_deg(u) == best_bd]\n        u0 = random.choice(candidates)\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict_with_new(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            ns = compress_colors(ns)\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        if swapped:\n            ns = compress_colors(ns)\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; aims to preserve feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def random_recolor_break_sym(sol):\n        # Occasionally move a vertex to a new color to diversify\n        i = random.randint(1, 9)\n        used = set(sol)\n        new_c = max(used) + 1\n        sol[i-1] = new_c\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        # Perform a few Kempe swaps and optional random recolor, then compress\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        if random.random() < 0.25:\n            s = random_recolor_break_sym(s)\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation: min-conflict recolors and compression\n        for _ in range(6):\n            if conflict_count(s) == 0:\n                break\n            # pick conflicted vertex with random tie-breaking\n            bad = set()\n            for u, v in edges:\n                if s[u-1] == s[v-1]:\n                    bad.add(u)\n                    bad.add(v)\n            if not bad:\n                break\n            u = random.choice(list(bad))\n            current = s[u-1]\n            used = list(set(s))\n            # try existing colors first\n            best = current\n            best_sc = 10**9\n            for c in used:\n                if c == current:\n                    continue\n                sc = 0\n                for v in adj[u]:\n                    if s[v-1] == c:\n                        sc += 1\n                if sc < best_sc:\n                    best_sc = sc\n                    best = c\n            if best_sc > 0:\n                # allow new color to break conflicts\n                best = max(used) + 1\n            s[u-1] = best\n        s = compress_colors(s)\n        return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001543006}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; solution is a Python list of 9 positive integers (colors) where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Fitness = objective (minimize max color) + heavy penalties for conflicts\n    # Lower is better. Returns large value for invalid inputs.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution):\n    # Neighborhood: single-vertex recolor to a random color in [1, max_color+1], excluding current color\n    # Returns (neighbor_solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    if not isinstance(solution, list):\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    neigh = solution[:]  # shallow copy sufficient for flat list\n    idx = random.randrange(n)\n    current_color = neigh[idx] if isinstance(neigh[idx], int) and neigh[idx] >= 1 else 1\n    max_color = max([c for c in neigh if isinstance(c, int) and c >= 1] + [1])\n    # Allow exploring one extra color to escape local traps\n    candidate_colors = list(range(1, max_color + 2))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    if not candidate_colors:\n        candidate_colors = [1 if current_color != 1 else 2]\n    neigh[idx] = random.choice(candidate_colors)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolors + targeted attempt to lower max color on some vertices\n    if not isinstance(solution, list):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    s = solution[:]\n    # Parameters\n    steps = max(3, n \/\/ 3)\n    # Random recolors\n    for _ in range(steps):\n        i = random.randrange(n)\n        cur = s[i] if isinstance(s[i], int) and s[i] >= 1 else 1\n        max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n        cand = list(range(1, max_c + 2))\n        if cur in cand:\n            cand.remove(cur)\n        if not cand:\n            cand = [1 if cur != 1 else 2]\n        s[i] = random.choice(cand)\n    # Targeted reduction attempts for vertices with current max color\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency list\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n    vertices_max = [i for i, c in enumerate(s, start=1) if isinstance(c, int) and c == max_c]\n    random.shuffle(vertices_max)\n    for v in vertices_max:\n        # Try to reassign to the smallest feasible color\n        neighbor_colors = {s[u-1] for u in adj[v] if isinstance(s[u-1], int) and s[u-1] >= 1}\n        for col in range(1, max_c):\n            if col not in neighbor_colors:\n                s[v-1] = col\n                break\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000746}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; solution is a Python list of 9 positive integers (colors) where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Fitness = objective (minimize max color) + heavy penalties for conflicts\n    # Lower is better. Returns large value for invalid inputs.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution):\n    # Neighborhood: single-vertex recolor to a random color in [1, max_color+1], excluding current color\n    # Returns (neighbor_solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    if not isinstance(solution, list):\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    neigh = solution[:]  # shallow copy sufficient for flat list\n    idx = random.randrange(n)\n    current_color = neigh[idx] if isinstance(neigh[idx], int) and neigh[idx] >= 1 else 1\n    max_color = max([c for c in neigh if isinstance(c, int) and c >= 1] + [1])\n    # Allow exploring one extra color to escape local traps\n    candidate_colors = list(range(1, max_color + 2))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    if not candidate_colors:\n        candidate_colors = [1 if current_color != 1 else 2]\n    neigh[idx] = random.choice(candidate_colors)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolors + targeted attempt to lower max color on some vertices\n    if not isinstance(solution, list):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    s = solution[:]\n    # Parameters\n    steps = max(3, n \/\/ 3)\n    # Random recolors\n    for _ in range(steps):\n        i = random.randrange(n)\n        cur = s[i] if isinstance(s[i], int) and s[i] >= 1 else 1\n        max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n        cand = list(range(1, max_c + 2))\n        if cur in cand:\n            cand.remove(cur)\n        if not cand:\n            cand = [1 if cur != 1 else 2]\n        s[i] = random.choice(cand)\n    # Targeted reduction attempts for vertices with current max color\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency list\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n    vertices_max = [i for i, c in enumerate(s, start=1) if isinstance(c, int) and c == max_c]\n    random.shuffle(vertices_max)\n    for v in vertices_max:\n        # Try to reassign to the smallest feasible color\n        neighbor_colors = {s[u-1] for u in adj[v] if isinstance(s[u-1], int) and s[u-1] >= 1}\n        for col in range(1, max_c):\n            if col not in neighbor_colors:\n                s[v-1] = col\n                break\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000165}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; solution is a Python list of 9 positive integers (colors) where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Fitness = objective (minimize max color) + heavy penalties for conflicts\n    # Lower is better. Returns large value for invalid inputs.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution):\n    # Neighborhood: single-vertex recolor to a random color in [1, max_color+1], excluding current color\n    # Returns (neighbor_solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    if not isinstance(solution, list):\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    neigh = solution[:]  # shallow copy sufficient for flat list\n    idx = random.randrange(n)\n    current_color = neigh[idx] if isinstance(neigh[idx], int) and neigh[idx] >= 1 else 1\n    max_color = max([c for c in neigh if isinstance(c, int) and c >= 1] + [1])\n    # Allow exploring one extra color to escape local traps\n    candidate_colors = list(range(1, max_color + 2))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    if not candidate_colors:\n        candidate_colors = [1 if current_color != 1 else 2]\n    neigh[idx] = random.choice(candidate_colors)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolors + targeted attempt to lower max color on some vertices\n    if not isinstance(solution, list):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    s = solution[:]\n    # Parameters\n    steps = max(3, n \/\/ 3)\n    # Random recolors\n    for _ in range(steps):\n        i = random.randrange(n)\n        cur = s[i] if isinstance(s[i], int) and s[i] >= 1 else 1\n        max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n        cand = list(range(1, max_c + 2))\n        if cur in cand:\n            cand.remove(cur)\n        if not cand:\n            cand = [1 if cur != 1 else 2]\n        s[i] = random.choice(cand)\n    # Targeted reduction attempts for vertices with current max color\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency list\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n    vertices_max = [i for i, c in enumerate(s, start=1) if isinstance(c, int) and c == max_c]\n    random.shuffle(vertices_max)\n    for v in vertices_max:\n        # Try to reassign to the smallest feasible color\n        neighbor_colors = {s[u-1] for u in adj[v] if isinstance(s[u-1], int) and s[u-1] >= 1}\n        for col in range(1, max_c):\n            if col not in neighbor_colors:\n                s[v-1] = col\n                break\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000127}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where position i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Strategy: prioritize conflict resolution via best-improvement recolor; otherwise color-pair swap.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a trivial repaired solution if invalid\n        repaired = [1]*n\n        return (repaired, \"Repair\", \"ResetToOnes\")\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [max(1, int(c) if isinstance(c, int) else 1) for c in solution]\n            return (repaired, \"Repair\", \"Sanitize\")\n    K = max(solution)\n    # Build adjacency and conflict info\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    conflicts_vertices = []\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts_vertices.append(u)\n            conflicts_vertices.append(v)\n    conflicts_vertices = list(set(conflicts_vertices))\n    # Helper: evaluate delta conflicts for coloring vertex i with color col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n    # Attempt 1: if conflicts exist, best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        v = random.choice(conflicts_vertices)\n        current_col = solution[v-1]\n        best_col = current_col\n        best_delta = 0\n        # Restrict palette to 1..K (no drift)\n        for col in range(1, K+1):\n            if col == current_col:\n                continue\n            d = conflict_delta(solution, v, col)\n            if d < best_delta or (d == best_delta and random.random() < 0.5):\n                best_delta = d\n                best_col = col\n        neigh = solution[:]\n        if best_col != current_col:\n            neigh[v-1] = best_col\n            return (neigh, \"Single-Vertex-Recolor\", \"BestImprovement\")\n        # fallback: random recolor different color in [1..K]\n        candidate = [c for c in range(1, K+1) if c != current_col]\n        if not candidate:\n            candidate = [1 if current_col != 1 else 2]\n        neigh[v-1] = random.choice(candidate)\n        if neigh != solution:\n            return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    # Attempt 2: color swap between two colors (Kempe-like color class swap)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = solution[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != solution:\n            return (neigh, \"ColorClassSwap\", \"PairSwap\")\n    # Attempt 3: directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(solution, start=1) if col == K]\n    if verts_K:\n        v = random.choice(verts_K)\n        neigh = solution[:]\n        # Try smallest feasible color in [1..K-1]\n        forbidden = {solution[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh[v-1] = col\n                if neigh != solution:\n                    return (neigh, \"ReduceK\", \"GreedyFeasible\")\n    # Final fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    current_col = solution[idx]\n    cand = [c for c in range(1, K+1) if c != current_col]\n    if not cand:\n        cand = [1 if current_col != 1 else 2]\n    neigh = solution[:]\n    neigh[idx] = random.choice(cand)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomFallback\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor subset of vertices + attempt color compaction (reduce K without using K+1)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n    s = solution[:]\n    K = max(s)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    # Compute degrees and conflicts\n    deg = {i: len(adj[i]) for i in adj}\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u); conflicted.add(v)\n    # Kick parameters\n    steps = max(3, n \/\/ 3)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    # Bias toward higher degree vertices\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n    # Random recolors within [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n    # Targeted reduction: try to recolor vertices of color K into [1..K-1]\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n    # Color compaction: renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c:i+1 for i,c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001496066}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where position i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Strategy: prioritize conflict resolution via best-improvement recolor; otherwise color-pair swap.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a trivial repaired solution if invalid\n        repaired = [1]*n\n        return (repaired, \"Repair\", \"ResetToOnes\")\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [max(1, int(c) if isinstance(c, int) else 1) for c in solution]\n            return (repaired, \"Repair\", \"Sanitize\")\n    K = max(solution)\n    # Build adjacency and conflict info\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    conflicts_vertices = []\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts_vertices.append(u)\n            conflicts_vertices.append(v)\n    conflicts_vertices = list(set(conflicts_vertices))\n    # Helper: evaluate delta conflicts for coloring vertex i with color col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n    # Attempt 1: if conflicts exist, best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        v = random.choice(conflicts_vertices)\n        current_col = solution[v-1]\n        best_col = current_col\n        best_delta = 0\n        # Restrict palette to 1..K (no drift)\n        for col in range(1, K+1):\n            if col == current_col:\n                continue\n            d = conflict_delta(solution, v, col)\n            if d < best_delta or (d == best_delta and random.random() < 0.5):\n                best_delta = d\n                best_col = col\n        neigh = solution[:]\n        if best_col != current_col:\n            neigh[v-1] = best_col\n            return (neigh, \"Single-Vertex-Recolor\", \"BestImprovement\")\n        # fallback: random recolor different color in [1..K]\n        candidate = [c for c in range(1, K+1) if c != current_col]\n        if not candidate:\n            candidate = [1 if current_col != 1 else 2]\n        neigh[v-1] = random.choice(candidate)\n        if neigh != solution:\n            return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    # Attempt 2: color swap between two colors (Kempe-like color class swap)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = solution[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != solution:\n            return (neigh, \"ColorClassSwap\", \"PairSwap\")\n    # Attempt 3: directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(solution, start=1) if col == K]\n    if verts_K:\n        v = random.choice(verts_K)\n        neigh = solution[:]\n        # Try smallest feasible color in [1..K-1]\n        forbidden = {solution[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh[v-1] = col\n                if neigh != solution:\n                    return (neigh, \"ReduceK\", \"GreedyFeasible\")\n    # Final fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    current_col = solution[idx]\n    cand = [c for c in range(1, K+1) if c != current_col]\n    if not cand:\n        cand = [1 if current_col != 1 else 2]\n    neigh = solution[:]\n    neigh[idx] = random.choice(cand)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomFallback\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor subset of vertices + attempt color compaction (reduce K without using K+1)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n    s = solution[:]\n    K = max(s)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    # Compute degrees and conflicts\n    deg = {i: len(adj[i]) for i in adj}\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u); conflicted.add(v)\n    # Kick parameters\n    steps = max(3, n \/\/ 3)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    # Bias toward higher degree vertices\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n    # Random recolors within [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n    # Targeted reduction: try to recolor vertices of color K into [1..K-1]\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n    # Color compaction: renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c:i+1 for i,c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001202143}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where position i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Strategy: prioritize conflict resolution via best-improvement recolor; otherwise color-pair swap.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a trivial repaired solution if invalid\n        repaired = [1]*n\n        return (repaired, \"Repair\", \"ResetToOnes\")\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [max(1, int(c) if isinstance(c, int) else 1) for c in solution]\n            return (repaired, \"Repair\", \"Sanitize\")\n    K = max(solution)\n    # Build adjacency and conflict info\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    conflicts_vertices = []\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts_vertices.append(u)\n            conflicts_vertices.append(v)\n    conflicts_vertices = list(set(conflicts_vertices))\n    # Helper: evaluate delta conflicts for coloring vertex i with color col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n    # Attempt 1: if conflicts exist, best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        v = random.choice(conflicts_vertices)\n        current_col = solution[v-1]\n        best_col = current_col\n        best_delta = 0\n        # Restrict palette to 1..K (no drift)\n        for col in range(1, K+1):\n            if col == current_col:\n                continue\n            d = conflict_delta(solution, v, col)\n            if d < best_delta or (d == best_delta and random.random() < 0.5):\n                best_delta = d\n                best_col = col\n        neigh = solution[:]\n        if best_col != current_col:\n            neigh[v-1] = best_col\n            return (neigh, \"Single-Vertex-Recolor\", \"BestImprovement\")\n        # fallback: random recolor different color in [1..K]\n        candidate = [c for c in range(1, K+1) if c != current_col]\n        if not candidate:\n            candidate = [1 if current_col != 1 else 2]\n        neigh[v-1] = random.choice(candidate)\n        if neigh != solution:\n            return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    # Attempt 2: color swap between two colors (Kempe-like color class swap)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = solution[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != solution:\n            return (neigh, \"ColorClassSwap\", \"PairSwap\")\n    # Attempt 3: directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(solution, start=1) if col == K]\n    if verts_K:\n        v = random.choice(verts_K)\n        neigh = solution[:]\n        # Try smallest feasible color in [1..K-1]\n        forbidden = {solution[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh[v-1] = col\n                if neigh != solution:\n                    return (neigh, \"ReduceK\", \"GreedyFeasible\")\n    # Final fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    current_col = solution[idx]\n    cand = [c for c in range(1, K+1) if c != current_col]\n    if not cand:\n        cand = [1 if current_col != 1 else 2]\n    neigh = solution[:]\n    neigh[idx] = random.choice(cand)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomFallback\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor subset of vertices + attempt color compaction (reduce K without using K+1)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n    s = solution[:]\n    K = max(s)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    # Compute degrees and conflicts\n    deg = {i: len(adj[i]) for i in adj}\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u); conflicted.add(v)\n    # Kick parameters\n    steps = max(3, n \/\/ 3)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    # Bias toward higher degree vertices\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n    # Random recolors within [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n    # Targeted reduction: try to recolor vertices of color K into [1..K-1]\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n    # Color compaction: renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c:i+1 for i,c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001113282}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [1 if (not isinstance(c, int) or c < 1) else c for c in solution]\n            return (repaired, (\"Repair\", \"Sanitize\"))\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict list\n    conflicts_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n    conflicts_vertices = list(conflicts_vertices)\n\n    # Helper: conflict delta for recoloring vertex i to new_col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n\n    # 1) Best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        best_move = None\n        best_delta = math.inf\n        for v in conflicts_vertices:\n            cur = s[v-1]\n            for col in range(1, K+1):\n                if col == cur:\n                    continue\n                d = conflict_delta(s, v, col)\n                if d < best_delta or (d == best_delta and random.random() < 0.5):\n                    best_delta = d\n                    best_move = (v, col)\n        if best_move is not None and best_delta < 0:\n            v, col = best_move\n            neigh = s[:]\n            neigh[v-1] = col\n            return (neigh, (\"Single-Vertex-Recolor\", \"BestImprovement\"))\n        # fallback random recolor on a conflicted vertex\n        v = random.choice(conflicts_vertices)\n        cur = s[v-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(palette)\n        if neigh != s:\n            return (neigh, (\"Single-Vertex-Recolor\", \"RandomRecolorConflicted\"))\n\n    # 2) Color-class swap between two colors (Kempe-like)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"PairSwap\"))\n\n    # 3) Directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                if neigh != s:\n                    return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n\n    # 4) Fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    cur = s[idx]\n    palette = [c for c in range(1, K+1) if c != cur]\n    if not palette:\n        palette = [1 if cur != 1 else 2]\n    neigh = s[:]\n    neigh[idx] = random.choice(palette)\n    return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallback\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex recolors + targeted K-compaction\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency and degree\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    deg = {i: len(adj[i]) for i in adj}\n\n    # Conflicted set\n    conflicted = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    # Kick parameters (adaptive to conflicts)\n    base_steps = max(3, n \/\/ 3)\n    steps = base_steps + (len(conflicted) \/\/ 2)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n\n    # Random weighted recolors using existing palette [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0.0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n\n    # Targeted K-reduction and compaction\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        random.shuffle(verts_K)\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":[[3,1,2,3,1,2,1,3,2],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001781209}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [1 if (not isinstance(c, int) or c < 1) else c for c in solution]\n            return (repaired, (\"Repair\", \"Sanitize\"))\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict list\n    conflicts_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n    conflicts_vertices = list(conflicts_vertices)\n\n    # Helper: conflict delta for recoloring vertex i to new_col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n\n    # 1) Best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        best_move = None\n        best_delta = math.inf\n        for v in conflicts_vertices:\n            cur = s[v-1]\n            for col in range(1, K+1):\n                if col == cur:\n                    continue\n                d = conflict_delta(s, v, col)\n                if d < best_delta or (d == best_delta and random.random() < 0.5):\n                    best_delta = d\n                    best_move = (v, col)\n        if best_move is not None and best_delta < 0:\n            v, col = best_move\n            neigh = s[:]\n            neigh[v-1] = col\n            return (neigh, (\"Single-Vertex-Recolor\", \"BestImprovement\"))\n        # fallback random recolor on a conflicted vertex\n        v = random.choice(conflicts_vertices)\n        cur = s[v-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(palette)\n        if neigh != s:\n            return (neigh, (\"Single-Vertex-Recolor\", \"RandomRecolorConflicted\"))\n\n    # 2) Color-class swap between two colors (Kempe-like)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"PairSwap\"))\n\n    # 3) Directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                if neigh != s:\n                    return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n\n    # 4) Fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    cur = s[idx]\n    palette = [c for c in range(1, K+1) if c != cur]\n    if not palette:\n        palette = [1 if cur != 1 else 2]\n    neigh = s[:]\n    neigh[idx] = random.choice(palette)\n    return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallback\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex recolors + targeted K-compaction\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency and degree\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    deg = {i: len(adj[i]) for i in adj}\n\n    # Conflicted set\n    conflicted = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    # Kick parameters (adaptive to conflicts)\n    base_steps = max(3, n \/\/ 3)\n    steps = base_steps + (len(conflicted) \/\/ 2)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n\n    # Random weighted recolors using existing palette [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0.0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n\n    # Targeted K-reduction and compaction\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        random.shuffle(verts_K)\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":[[2,1,1,1,2,1,2,2,1],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002553317}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [1 if (not isinstance(c, int) or c < 1) else c for c in solution]\n            return (repaired, (\"Repair\", \"Sanitize\"))\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict list\n    conflicts_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n    conflicts_vertices = list(conflicts_vertices)\n\n    # Helper: conflict delta for recoloring vertex i to new_col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n\n    # 1) Best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        best_move = None\n        best_delta = math.inf\n        for v in conflicts_vertices:\n            cur = s[v-1]\n            for col in range(1, K+1):\n                if col == cur:\n                    continue\n                d = conflict_delta(s, v, col)\n                if d < best_delta or (d == best_delta and random.random() < 0.5):\n                    best_delta = d\n                    best_move = (v, col)\n        if best_move is not None and best_delta < 0:\n            v, col = best_move\n            neigh = s[:]\n            neigh[v-1] = col\n            return (neigh, (\"Single-Vertex-Recolor\", \"BestImprovement\"))\n        # fallback random recolor on a conflicted vertex\n        v = random.choice(conflicts_vertices)\n        cur = s[v-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(palette)\n        if neigh != s:\n            return (neigh, (\"Single-Vertex-Recolor\", \"RandomRecolorConflicted\"))\n\n    # 2) Color-class swap between two colors (Kempe-like)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"PairSwap\"))\n\n    # 3) Directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                if neigh != s:\n                    return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n\n    # 4) Fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    cur = s[idx]\n    palette = [c for c in range(1, K+1) if c != cur]\n    if not palette:\n        palette = [1 if cur != 1 else 2]\n    neigh = s[:]\n    neigh[idx] = random.choice(palette)\n    return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallback\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex recolors + targeted K-compaction\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency and degree\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    deg = {i: len(adj[i]) for i in adj}\n\n    # Conflicted set\n    conflicted = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    # Kick parameters (adaptive to conflicts)\n    base_steps = max(3, n \/\/ 3)\n    steps = base_steps + (len(conflicted) \/\/ 2)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n\n    # Random weighted recolors using existing palette [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0.0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n\n    # Targeted K-reduction and compaction\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        random.shuffle(verts_K)\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001315915}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n\n    # Cache graph structures on first call to avoid rebuild overhead\n    if not hasattr(generate_neighbour, \"_E\"):\n        E = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        generate_neighbour._E = tuple(E)\n        generate_neighbour._adj = {k: tuple(sorted(vs)) for k, vs in adj.items()}\n        generate_neighbour._deg = {k: len(vs) for k, vs in adj.items()}\n    E = generate_neighbour._E\n    adj = generate_neighbour._adj\n\n    s = solution[:]\n    K = max(s)\n\n    # Conflict bookkeeping\n    conflict_count = [0]*(n+1)\n    conflicted_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            conflicted_vertices.add(u)\n            conflicted_vertices.add(v)\n\n    # Helper: compute conflicts if vertex i is recolored to col\n    def conflicts_if(i, col):\n        cnt = 0\n        for nb in adj[i]:\n            if s[nb-1] == col:\n                cnt += 1\n        return cnt\n\n    # Helper: Kempe-chain swap of two colors c1,c2 restricted to the component containing start vertex v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        target = sol[v-1]\n        other = c2 if target == c1 else c1\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # If there are conflicts, apply min-conflicts or Kempe-chain guided move\n    if conflicted_vertices:\n        # Choose vertex with maximum conflict degree (tie-break by higher graph degree)\n        mx = -1\n        pick = None\n        for v in conflicted_vertices:\n            key = (conflict_count[v], len(adj[v]))\n            if key > (mx, -1) if pick is None else key > (conflict_count[pick], len(adj[pick])):\n                mx = conflict_count[v]\n                pick = v\n        v = pick\n        cur = s[v-1]\n        # Palette is existing colors 1..K\n        palette = list(range(1, K+1))\n        # Min-conflicts recolor with least-used tie-break to aid K reduction\n        usage = {c: 0 for c in palette}\n        for col in s:\n            usage[col] = usage.get(col, 0) + 1\n        best_cols = []\n        best_conf = math.inf\n        for col in palette:\n            if col == cur:\n                continue\n            cval = conflicts_if(v, col)\n            if cval < best_conf:\n                best_conf = cval\n                best_cols = [col]\n            elif cval == best_conf:\n                best_cols.append(col)\n        if best_cols and best_conf <= conflict_count[v]:\n            # choose least-used among best\n            best_cols.sort(key=lambda c: (usage.get(c, 0), c))\n            neigh = s[:]\n            neigh[v-1] = best_cols[0]\n            return (neigh, (\"Single-Vertex-Recolor\", \"MinConflicts\"))\n        # Try Kempe-chain between current color and a conflicting neighbor color\n        nb_colors = {s[nb-1] for nb in adj[v] if s[nb-1] == cur or nb in conflicted_vertices}\n        # If none, try any neighbor colors\n        if not nb_colors:\n            nb_colors = {s[nb-1] for nb in adj[v]}\n        for c2 in nb_colors:\n            if c2 == cur:\n                continue\n            neigh = kempe_swap_on_component(s, v, cur, c2)\n            # Accept if reduces conflicts\n            new_conf = 0\n            for (u, w) in E:\n                if neigh[u-1] == neigh[w-1]:\n                    new_conf += 1\n            old_conf = len(conflicted_vertices)\n            if new_conf < old_conf:\n                return (neigh, (\"KempeSwap\", \"ConflictReducing\"))\n        # Fallback random min-conflicts recolor\n        candidates = [c for c in palette if c != cur]\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(candidates)\n        return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallbackConflicted\"))\n\n    # If no conflicts, attempt K reduction\n    # 1) Greedy recolor vertices of max color into lower feasible colors\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n    # 2) Kempe-chain between color K and a lower color to free a K-vertex\n    if verts_K:\n        target_v = random.choice(verts_K)\n        for c2 in range(1, K):\n            neigh = kempe_swap_on_component(s, target_v, K, c2)\n            # If target_v changed color, we reduced K usage potentially\n            if neigh[target_v-1] != K:\n                return (neigh, (\"ReduceK\", \"KempeSwapK\"))\n    # 3) Color-class swap between K and a random lower color (may help compaction)\n    if K > 1:\n        c2 = random.randrange(1, K)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == K:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = K\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"KWithLower\"))\n    # 4) Plateau diversification: recolor vertex with largest degree to least-used lower color\n    usage = {c: 0 for c in range(1, K+1)}\n    for col in s:\n        usage[col] = usage.get(col, 0) + 1\n    idx = max(range(1, n+1), key=lambda i: len(adj[i]))\n    candidates = list(range(1, K+1))\n    candidates.sort(key=lambda c: (usage.get(c, 0), c))\n    if s[idx-1] == candidates[0] and len(candidates) > 1:\n        tgt = candidates[1]\n    else:\n        tgt = candidates[0]\n    neigh = s[:]\n    neigh[idx-1] = tgt\n    return (neigh, (\"Diversification\", \"LeastUsedColor\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex Kempe-chain kicks, class shuffle, and ejection chains targeting max color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [1]*n\n\n    # Static graph (embedded)\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    s = solution[:]\n    K = max(s)\n\n    # Helper: compute conflicts\n    def conflicts(sol):\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    # Kempe swap on component for colors c1,c2 starting at v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # 1) Multi-vertex Kempe-chain kicks\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(1, n+1)\n        if K == 1:\n            break\n        c1 = s[v-1]\n        c2 = random.randrange(1, K+1)\n        while c2 == c1 and K > 1:\n            c2 = random.randrange(1, K+1)\n        s = kempe_swap_on_component(s, v, c1, c2)\n\n    # 2) Color-class shuffle: pick a random color class and remap into [1..K-1] if possible\n    if K > 1:\n        cls = random.randrange(1, K+1)\n        tgt = random.randrange(1, K)\n        if tgt != cls:\n            for i, col in enumerate(s):\n                if col == cls:\n                    s[i] = tgt\n\n    # 3) Ejection chains (length 2\u20134) targeting max-color vertices\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    chain_len = random.randint(2, 4)\n    for _ in range(chain_len):\n        if not verts_K:\n            break\n        v = random.choice(verts_K)\n        forbidden = {s[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, K) if c not in forbidden] if K > 1 else [1]\n        if not candidates:\n            # if no feasible lower color, push a neighbor to another color to create room\n            nb = random.choice(list(adj[v]))\n            nb_forbidden = {s[u-1] for u in adj[nb]}\n            palette = [c for c in range(1, K+1) if c not in nb_forbidden]\n            if palette:\n                s[nb-1] = random.choice(palette)\n        else:\n            s[v-1] = random.choice(candidates)\n        K = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n\n    # Post-perturb compaction: greedily push down any remaining max colors\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: name 'generate_neighbour' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002213054}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n\n    # Cache graph structures on first call to avoid rebuild overhead\n    if not hasattr(generate_neighbour, \"_E\"):\n        E = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        generate_neighbour._E = tuple(E)\n        generate_neighbour._adj = {k: tuple(sorted(vs)) for k, vs in adj.items()}\n        generate_neighbour._deg = {k: len(vs) for k, vs in adj.items()}\n    E = generate_neighbour._E\n    adj = generate_neighbour._adj\n\n    s = solution[:]\n    K = max(s)\n\n    # Conflict bookkeeping\n    conflict_count = [0]*(n+1)\n    conflicted_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            conflicted_vertices.add(u)\n            conflicted_vertices.add(v)\n\n    # Helper: compute conflicts if vertex i is recolored to col\n    def conflicts_if(i, col):\n        cnt = 0\n        for nb in adj[i]:\n            if s[nb-1] == col:\n                cnt += 1\n        return cnt\n\n    # Helper: Kempe-chain swap of two colors c1,c2 restricted to the component containing start vertex v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        target = sol[v-1]\n        other = c2 if target == c1 else c1\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # If there are conflicts, apply min-conflicts or Kempe-chain guided move\n    if conflicted_vertices:\n        # Choose vertex with maximum conflict degree (tie-break by higher graph degree)\n        mx = -1\n        pick = None\n        for v in conflicted_vertices:\n            key = (conflict_count[v], len(adj[v]))\n            if key > (mx, -1) if pick is None else key > (conflict_count[pick], len(adj[pick])):\n                mx = conflict_count[v]\n                pick = v\n        v = pick\n        cur = s[v-1]\n        # Palette is existing colors 1..K\n        palette = list(range(1, K+1))\n        # Min-conflicts recolor with least-used tie-break to aid K reduction\n        usage = {c: 0 for c in palette}\n        for col in s:\n            usage[col] = usage.get(col, 0) + 1\n        best_cols = []\n        best_conf = math.inf\n        for col in palette:\n            if col == cur:\n                continue\n            cval = conflicts_if(v, col)\n            if cval < best_conf:\n                best_conf = cval\n                best_cols = [col]\n            elif cval == best_conf:\n                best_cols.append(col)\n        if best_cols and best_conf <= conflict_count[v]:\n            # choose least-used among best\n            best_cols.sort(key=lambda c: (usage.get(c, 0), c))\n            neigh = s[:]\n            neigh[v-1] = best_cols[0]\n            return (neigh, (\"Single-Vertex-Recolor\", \"MinConflicts\"))\n        # Try Kempe-chain between current color and a conflicting neighbor color\n        nb_colors = {s[nb-1] for nb in adj[v] if s[nb-1] == cur or nb in conflicted_vertices}\n        # If none, try any neighbor colors\n        if not nb_colors:\n            nb_colors = {s[nb-1] for nb in adj[v]}\n        for c2 in nb_colors:\n            if c2 == cur:\n                continue\n            neigh = kempe_swap_on_component(s, v, cur, c2)\n            # Accept if reduces conflicts\n            new_conf = 0\n            for (u, w) in E:\n                if neigh[u-1] == neigh[w-1]:\n                    new_conf += 1\n            old_conf = len(conflicted_vertices)\n            if new_conf < old_conf:\n                return (neigh, (\"KempeSwap\", \"ConflictReducing\"))\n        # Fallback random min-conflicts recolor\n        candidates = [c for c in palette if c != cur]\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(candidates)\n        return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallbackConflicted\"))\n\n    # If no conflicts, attempt K reduction\n    # 1) Greedy recolor vertices of max color into lower feasible colors\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n    # 2) Kempe-chain between color K and a lower color to free a K-vertex\n    if verts_K:\n        target_v = random.choice(verts_K)\n        for c2 in range(1, K):\n            neigh = kempe_swap_on_component(s, target_v, K, c2)\n            # If target_v changed color, we reduced K usage potentially\n            if neigh[target_v-1] != K:\n                return (neigh, (\"ReduceK\", \"KempeSwapK\"))\n    # 3) Color-class swap between K and a random lower color (may help compaction)\n    if K > 1:\n        c2 = random.randrange(1, K)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == K:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = K\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"KWithLower\"))\n    # 4) Plateau diversification: recolor vertex with largest degree to least-used lower color\n    usage = {c: 0 for c in range(1, K+1)}\n    for col in s:\n        usage[col] = usage.get(col, 0) + 1\n    idx = max(range(1, n+1), key=lambda i: len(adj[i]))\n    candidates = list(range(1, K+1))\n    candidates.sort(key=lambda c: (usage.get(c, 0), c))\n    if s[idx-1] == candidates[0] and len(candidates) > 1:\n        tgt = candidates[1]\n    else:\n        tgt = candidates[0]\n    neigh = s[:]\n    neigh[idx-1] = tgt\n    return (neigh, (\"Diversification\", \"LeastUsedColor\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex Kempe-chain kicks, class shuffle, and ejection chains targeting max color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [1]*n\n\n    # Static graph (embedded)\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    s = solution[:]\n    K = max(s)\n\n    # Helper: compute conflicts\n    def conflicts(sol):\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    # Kempe swap on component for colors c1,c2 starting at v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # 1) Multi-vertex Kempe-chain kicks\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(1, n+1)\n        if K == 1:\n            break\n        c1 = s[v-1]\n        c2 = random.randrange(1, K+1)\n        while c2 == c1 and K > 1:\n            c2 = random.randrange(1, K+1)\n        s = kempe_swap_on_component(s, v, c1, c2)\n\n    # 2) Color-class shuffle: pick a random color class and remap into [1..K-1] if possible\n    if K > 1:\n        cls = random.randrange(1, K+1)\n        tgt = random.randrange(1, K)\n        if tgt != cls:\n            for i, col in enumerate(s):\n                if col == cls:\n                    s[i] = tgt\n\n    # 3) Ejection chains (length 2\u20134) targeting max-color vertices\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    chain_len = random.randint(2, 4)\n    for _ in range(chain_len):\n        if not verts_K:\n            break\n        v = random.choice(verts_K)\n        forbidden = {s[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, K) if c not in forbidden] if K > 1 else [1]\n        if not candidates:\n            # if no feasible lower color, push a neighbor to another color to create room\n            nb = random.choice(list(adj[v]))\n            nb_forbidden = {s[u-1] for u in adj[nb]}\n            palette = [c for c in range(1, K+1) if c not in nb_forbidden]\n            if palette:\n                s[nb-1] = random.choice(palette)\n        else:\n            s[v-1] = random.choice(candidates)\n        K = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n\n    # Post-perturb compaction: greedily push down any remaining max colors\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: name 'generate_neighbour' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001679919}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n\n    # Cache graph structures on first call to avoid rebuild overhead\n    if not hasattr(generate_neighbour, \"_E\"):\n        E = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        generate_neighbour._E = tuple(E)\n        generate_neighbour._adj = {k: tuple(sorted(vs)) for k, vs in adj.items()}\n        generate_neighbour._deg = {k: len(vs) for k, vs in adj.items()}\n    E = generate_neighbour._E\n    adj = generate_neighbour._adj\n\n    s = solution[:]\n    K = max(s)\n\n    # Conflict bookkeeping\n    conflict_count = [0]*(n+1)\n    conflicted_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            conflicted_vertices.add(u)\n            conflicted_vertices.add(v)\n\n    # Helper: compute conflicts if vertex i is recolored to col\n    def conflicts_if(i, col):\n        cnt = 0\n        for nb in adj[i]:\n            if s[nb-1] == col:\n                cnt += 1\n        return cnt\n\n    # Helper: Kempe-chain swap of two colors c1,c2 restricted to the component containing start vertex v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        target = sol[v-1]\n        other = c2 if target == c1 else c1\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # If there are conflicts, apply min-conflicts or Kempe-chain guided move\n    if conflicted_vertices:\n        # Choose vertex with maximum conflict degree (tie-break by higher graph degree)\n        mx = -1\n        pick = None\n        for v in conflicted_vertices:\n            key = (conflict_count[v], len(adj[v]))\n            if key > (mx, -1) if pick is None else key > (conflict_count[pick], len(adj[pick])):\n                mx = conflict_count[v]\n                pick = v\n        v = pick\n        cur = s[v-1]\n        # Palette is existing colors 1..K\n        palette = list(range(1, K+1))\n        # Min-conflicts recolor with least-used tie-break to aid K reduction\n        usage = {c: 0 for c in palette}\n        for col in s:\n            usage[col] = usage.get(col, 0) + 1\n        best_cols = []\n        best_conf = math.inf\n        for col in palette:\n            if col == cur:\n                continue\n            cval = conflicts_if(v, col)\n            if cval < best_conf:\n                best_conf = cval\n                best_cols = [col]\n            elif cval == best_conf:\n                best_cols.append(col)\n        if best_cols and best_conf <= conflict_count[v]:\n            # choose least-used among best\n            best_cols.sort(key=lambda c: (usage.get(c, 0), c))\n            neigh = s[:]\n            neigh[v-1] = best_cols[0]\n            return (neigh, (\"Single-Vertex-Recolor\", \"MinConflicts\"))\n        # Try Kempe-chain between current color and a conflicting neighbor color\n        nb_colors = {s[nb-1] for nb in adj[v] if s[nb-1] == cur or nb in conflicted_vertices}\n        # If none, try any neighbor colors\n        if not nb_colors:\n            nb_colors = {s[nb-1] for nb in adj[v]}\n        for c2 in nb_colors:\n            if c2 == cur:\n                continue\n            neigh = kempe_swap_on_component(s, v, cur, c2)\n            # Accept if reduces conflicts\n            new_conf = 0\n            for (u, w) in E:\n                if neigh[u-1] == neigh[w-1]:\n                    new_conf += 1\n            old_conf = len(conflicted_vertices)\n            if new_conf < old_conf:\n                return (neigh, (\"KempeSwap\", \"ConflictReducing\"))\n        # Fallback random min-conflicts recolor\n        candidates = [c for c in palette if c != cur]\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(candidates)\n        return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallbackConflicted\"))\n\n    # If no conflicts, attempt K reduction\n    # 1) Greedy recolor vertices of max color into lower feasible colors\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n    # 2) Kempe-chain between color K and a lower color to free a K-vertex\n    if verts_K:\n        target_v = random.choice(verts_K)\n        for c2 in range(1, K):\n            neigh = kempe_swap_on_component(s, target_v, K, c2)\n            # If target_v changed color, we reduced K usage potentially\n            if neigh[target_v-1] != K:\n                return (neigh, (\"ReduceK\", \"KempeSwapK\"))\n    # 3) Color-class swap between K and a random lower color (may help compaction)\n    if K > 1:\n        c2 = random.randrange(1, K)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == K:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = K\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"KWithLower\"))\n    # 4) Plateau diversification: recolor vertex with largest degree to least-used lower color\n    usage = {c: 0 for c in range(1, K+1)}\n    for col in s:\n        usage[col] = usage.get(col, 0) + 1\n    idx = max(range(1, n+1), key=lambda i: len(adj[i]))\n    candidates = list(range(1, K+1))\n    candidates.sort(key=lambda c: (usage.get(c, 0), c))\n    if s[idx-1] == candidates[0] and len(candidates) > 1:\n        tgt = candidates[1]\n    else:\n        tgt = candidates[0]\n    neigh = s[:]\n    neigh[idx-1] = tgt\n    return (neigh, (\"Diversification\", \"LeastUsedColor\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex Kempe-chain kicks, class shuffle, and ejection chains targeting max color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [1]*n\n\n    # Static graph (embedded)\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    s = solution[:]\n    K = max(s)\n\n    # Helper: compute conflicts\n    def conflicts(sol):\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    # Kempe swap on component for colors c1,c2 starting at v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # 1) Multi-vertex Kempe-chain kicks\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(1, n+1)\n        if K == 1:\n            break\n        c1 = s[v-1]\n        c2 = random.randrange(1, K+1)\n        while c2 == c1 and K > 1:\n            c2 = random.randrange(1, K+1)\n        s = kempe_swap_on_component(s, v, c1, c2)\n\n    # 2) Color-class shuffle: pick a random color class and remap into [1..K-1] if possible\n    if K > 1:\n        cls = random.randrange(1, K+1)\n        tgt = random.randrange(1, K)\n        if tgt != cls:\n            for i, col in enumerate(s):\n                if col == cls:\n                    s[i] = tgt\n\n    # 3) Ejection chains (length 2\u20134) targeting max-color vertices\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    chain_len = random.randint(2, 4)\n    for _ in range(chain_len):\n        if not verts_K:\n            break\n        v = random.choice(verts_K)\n        forbidden = {s[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, K) if c not in forbidden] if K > 1 else [1]\n        if not candidates:\n            # if no feasible lower color, push a neighbor to another color to create room\n            nb = random.choice(list(adj[v]))\n            nb_forbidden = {s[u-1] for u in adj[nb]}\n            palette = [c for c in range(1, K+1) if c not in nb_forbidden]\n            if palette:\n                s[nb-1] = random.choice(palette)\n        else:\n            s[v-1] = random.choice(candidates)\n        K = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n\n    # Post-perturb compaction: greedily push down any remaining max colors\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: name 'generate_neighbour' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002317285}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED.c[i-1] is color of vertex i. Colors are positive integers starting at 1. Objective: minimize max(solution).","Evaluacion":"from typing import List\nimport math\n\ndef evaluate_solution(solution):\n    # Graph edges embedded\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Constraint check: proper coloring\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective: minimize number of colors used\n    return max(solution)\n","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback to a simple feasible-shaped vector (not guaranteed proper)\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Choose a random vertex to recolor\n    v = random.randrange(n)\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    candidate_colors = list(range(1, current_max + 1))\n    if len(candidate_colors) == 0:\n        candidate_colors = [1]\n\n    # Evaluate conflict count for each candidate color\n    scores = []\n    for c in candidate_colors:\n        scores.append((conflicts_of_color(v, c, sol), c))\n    # Prefer minimal conflicts; break ties randomly, avoid staying in same color if possible\n    min_conf = min(scores)[0]\n    best_colors = [c for (conf, c) in scores if conf == min_conf]\n    if sol[v] in best_colors and len(best_colors) > 1:\n        best_colors.remove(sol[v])\n    new_color = random.choice(best_colors) if best_colors else sol[v]\n\n    neighbor = sol[:]\n    neighbor[v] = new_color\n\n    # Small chance to perform a color relabel (symmetry breaking)\n    if random.random() < 0.1 and current_max > 1:\n        a, b = random.sample(range(1, current_max + 1), 2)\n        neighbor = [b if x == a else a if x == b else x for x in neighbor]\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    if current_max < 3:\n        current_max = 3\n\n    # 1) Random color relabeling (permute labels) to break symmetry\n    labels = list(range(1, current_max + 1))\n    random.shuffle(labels)\n    relabel = {old: new for new, old in enumerate(labels, start=1)}\n    sol = [relabel.get(x, x) for x in sol]\n\n    # 2) Multiple random vertex recolors guided by minimal local conflicts\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        v = random.randrange(n)\n        candidate_colors = list(range(1, current_max + 1))\n        scores = [(conflicts_of_color(v, c, sol), c) for c in candidate_colors]\n        scores.sort(key=lambda t: (t[0], random.random()))\n        # Pick among the top-2 least conflict colors randomly for diversification\n        pick_pool = [c for _, c in scores[:min(2, len(scores))]]\n        new_c = random.choice(pick_pool)\n        sol[v] = new_c\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0000046}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED.c[i-1] is color of vertex i. Colors are positive integers starting at 1. Objective: minimize max(solution).","Evaluacion":"from typing import List\nimport math\n\ndef evaluate_solution(solution):\n    # Graph edges embedded\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Constraint check: proper coloring\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective: minimize number of colors used\n    return max(solution)\n","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback to a simple feasible-shaped vector (not guaranteed proper)\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Choose a random vertex to recolor\n    v = random.randrange(n)\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    candidate_colors = list(range(1, current_max + 1))\n    if len(candidate_colors) == 0:\n        candidate_colors = [1]\n\n    # Evaluate conflict count for each candidate color\n    scores = []\n    for c in candidate_colors:\n        scores.append((conflicts_of_color(v, c, sol), c))\n    # Prefer minimal conflicts; break ties randomly, avoid staying in same color if possible\n    min_conf = min(scores)[0]\n    best_colors = [c for (conf, c) in scores if conf == min_conf]\n    if sol[v] in best_colors and len(best_colors) > 1:\n        best_colors.remove(sol[v])\n    new_color = random.choice(best_colors) if best_colors else sol[v]\n\n    neighbor = sol[:]\n    neighbor[v] = new_color\n\n    # Small chance to perform a color relabel (symmetry breaking)\n    if random.random() < 0.1 and current_max > 1:\n        a, b = random.sample(range(1, current_max + 1), 2)\n        neighbor = [b if x == a else a if x == b else x for x in neighbor]\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    if current_max < 3:\n        current_max = 3\n\n    # 1) Random color relabeling (permute labels) to break symmetry\n    labels = list(range(1, current_max + 1))\n    random.shuffle(labels)\n    relabel = {old: new for new, old in enumerate(labels, start=1)}\n    sol = [relabel.get(x, x) for x in sol]\n\n    # 2) Multiple random vertex recolors guided by minimal local conflicts\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        v = random.randrange(n)\n        candidate_colors = list(range(1, current_max + 1))\n        scores = [(conflicts_of_color(v, c, sol), c) for c in candidate_colors]\n        scores.sort(key=lambda t: (t[0], random.random()))\n        # Pick among the top-2 least conflict colors randomly for diversification\n        pick_pool = [c for _, c in scores[:min(2, len(scores))]]\n        new_c = random.choice(pick_pool)\n        sol[v] = new_c\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000154}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED.c[i-1] is color of vertex i. Colors are positive integers starting at 1. Objective: minimize max(solution).","Evaluacion":"from typing import List\nimport math\n\ndef evaluate_solution(solution):\n    # Graph edges embedded\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Constraint check: proper coloring\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective: minimize number of colors used\n    return max(solution)\n","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback to a simple feasible-shaped vector (not guaranteed proper)\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Choose a random vertex to recolor\n    v = random.randrange(n)\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    candidate_colors = list(range(1, current_max + 1))\n    if len(candidate_colors) == 0:\n        candidate_colors = [1]\n\n    # Evaluate conflict count for each candidate color\n    scores = []\n    for c in candidate_colors:\n        scores.append((conflicts_of_color(v, c, sol), c))\n    # Prefer minimal conflicts; break ties randomly, avoid staying in same color if possible\n    min_conf = min(scores)[0]\n    best_colors = [c for (conf, c) in scores if conf == min_conf]\n    if sol[v] in best_colors and len(best_colors) > 1:\n        best_colors.remove(sol[v])\n    new_color = random.choice(best_colors) if best_colors else sol[v]\n\n    neighbor = sol[:]\n    neighbor[v] = new_color\n\n    # Small chance to perform a color relabel (symmetry breaking)\n    if random.random() < 0.1 and current_max > 1:\n        a, b = random.sample(range(1, current_max + 1), 2)\n        neighbor = [b if x == a else a if x == b else x for x in neighbor]\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    if current_max < 3:\n        current_max = 3\n\n    # 1) Random color relabeling (permute labels) to break symmetry\n    labels = list(range(1, current_max + 1))\n    random.shuffle(labels)\n    relabel = {old: new for new, old in enumerate(labels, start=1)}\n    sol = [relabel.get(x, x) for x in sol]\n\n    # 2) Multiple random vertex recolors guided by minimal local conflicts\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        v = random.randrange(n)\n        candidate_colors = list(range(1, current_max + 1))\n        scores = [(conflicts_of_color(v, c, sol), c) for c in candidate_colors]\n        scores.sort(key=lambda t: (t[0], random.random()))\n        # Pick among the top-2 least conflict colors randomly for diversification\n        pick_pool = [c for _, c in scores[:min(2, len(scores))]]\n        new_c = random.choice(pick_pool)\n        sol[v] = new_c\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000117}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED. solution is a list of 9 positive ints; however, I\/O is tolerant and also accepts a whitespace-separated string of 9 ints. Objective: minimize max color used (k).","Evaluacion":"from typing import List, Tuple\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # soft penalty weight per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    # validate entries\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = compact(arr)\n\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        # simple fallback shape\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list for efficiency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # identify conflicting vertices\n    conflicting = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicting.add(u-1)\n            conflicting.add(v-1)\n\n    # pick a vertex: prioritize conflicts\n    if conflicting:\n        v = random.choice(list(conflicting))\n    else:\n        v = random.randrange(n)\n\n    # candidate colors: colors used in neighborhood plus ones present, maybe exploratory new color\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n    candidates = sorted(present_colors.union(neigh_colors))\n\n    # allow exploratory new color only if currently conflicting\n    if conflicting and random.random() < 0.2:\n        candidates.append(current_max + 1)\n\n    # scoring: number of conflicts if v is colored with c\n    def conflicts_if(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = [(conflicts_if(v, c, sol), c) for c in candidates]\n    scored.sort(key=lambda t: (t[0], random.random()))\n\n    # choose among top-min conflict colors\n    best_conf = scored[0][0]\n    pool = [c for (conf, c) in scored if conf == best_conf]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n    neighbor = compact(neighbor)\n\n    return neighbor, \"Recolor\", \"SingleVertex\"","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # random relabeling to break symmetry\n    labels = sorted(set(sol))\n    if labels:\n        shuf = labels[:]\n        random.shuffle(shuf)\n        relabel = {old: new for new, old in enumerate(shuf, start=1)}\n        sol = [relabel.get(x, x) for x in sol]\n\n    # compute conflict degree per vertex\n    def v_conflicts(idx: int, arr: List[int]) -> int:\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # choose a set of vertices with highest conflicts (or random if no conflicts)\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = random.randint(3, 5)\n    targets = [i for (sc, i) in conf_scores[:q]]\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n\n    # greedy randomized recolor for targets\n    present_colors = sorted(set(sol))\n    for v in targets:\n        # candidate colors among present plus one exploratory\n        candidates = present_colors[:]\n        candidates.append(max(present_colors) + 1 if present_colors else 1)\n        # score by local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], random.random()))\n        pick_pool = [c for conf, c in scored[:min(2, len(scored))]]\n        sol[v] = random.choice(pick_pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001548107}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED. solution is a list of 9 positive ints; however, I\/O is tolerant and also accepts a whitespace-separated string of 9 ints. Objective: minimize max color used (k).","Evaluacion":"from typing import List, Tuple\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # soft penalty weight per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    # validate entries\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = compact(arr)\n\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        # simple fallback shape\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list for efficiency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # identify conflicting vertices\n    conflicting = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicting.add(u-1)\n            conflicting.add(v-1)\n\n    # pick a vertex: prioritize conflicts\n    if conflicting:\n        v = random.choice(list(conflicting))\n    else:\n        v = random.randrange(n)\n\n    # candidate colors: colors used in neighborhood plus ones present, maybe exploratory new color\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n    candidates = sorted(present_colors.union(neigh_colors))\n\n    # allow exploratory new color only if currently conflicting\n    if conflicting and random.random() < 0.2:\n        candidates.append(current_max + 1)\n\n    # scoring: number of conflicts if v is colored with c\n    def conflicts_if(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = [(conflicts_if(v, c, sol), c) for c in candidates]\n    scored.sort(key=lambda t: (t[0], random.random()))\n\n    # choose among top-min conflict colors\n    best_conf = scored[0][0]\n    pool = [c for (conf, c) in scored if conf == best_conf]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n    neighbor = compact(neighbor)\n\n    return neighbor, \"Recolor\", \"SingleVertex\"","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # random relabeling to break symmetry\n    labels = sorted(set(sol))\n    if labels:\n        shuf = labels[:]\n        random.shuffle(shuf)\n        relabel = {old: new for new, old in enumerate(shuf, start=1)}\n        sol = [relabel.get(x, x) for x in sol]\n\n    # compute conflict degree per vertex\n    def v_conflicts(idx: int, arr: List[int]) -> int:\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # choose a set of vertices with highest conflicts (or random if no conflicts)\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = random.randint(3, 5)\n    targets = [i for (sc, i) in conf_scores[:q]]\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n\n    # greedy randomized recolor for targets\n    present_colors = sorted(set(sol))\n    for v in targets:\n        # candidate colors among present plus one exploratory\n        candidates = present_colors[:]\n        candidates.append(max(present_colors) + 1 if present_colors else 1)\n        # score by local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], random.random()))\n        pick_pool = [c for conf, c in scored[:min(2, len(scored))]]\n        sol[v] = random.choice(pick_pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001367955}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED. solution is a list of 9 positive ints; however, I\/O is tolerant and also accepts a whitespace-separated string of 9 ints. Objective: minimize max color used (k).","Evaluacion":"from typing import List, Tuple\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # soft penalty weight per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    # validate entries\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = compact(arr)\n\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        # simple fallback shape\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list for efficiency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # identify conflicting vertices\n    conflicting = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicting.add(u-1)\n            conflicting.add(v-1)\n\n    # pick a vertex: prioritize conflicts\n    if conflicting:\n        v = random.choice(list(conflicting))\n    else:\n        v = random.randrange(n)\n\n    # candidate colors: colors used in neighborhood plus ones present, maybe exploratory new color\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n    candidates = sorted(present_colors.union(neigh_colors))\n\n    # allow exploratory new color only if currently conflicting\n    if conflicting and random.random() < 0.2:\n        candidates.append(current_max + 1)\n\n    # scoring: number of conflicts if v is colored with c\n    def conflicts_if(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = [(conflicts_if(v, c, sol), c) for c in candidates]\n    scored.sort(key=lambda t: (t[0], random.random()))\n\n    # choose among top-min conflict colors\n    best_conf = scored[0][0]\n    pool = [c for (conf, c) in scored if conf == best_conf]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n    neighbor = compact(neighbor)\n\n    return neighbor, \"Recolor\", \"SingleVertex\"","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # random relabeling to break symmetry\n    labels = sorted(set(sol))\n    if labels:\n        shuf = labels[:]\n        random.shuffle(shuf)\n        relabel = {old: new for new, old in enumerate(shuf, start=1)}\n        sol = [relabel.get(x, x) for x in sol]\n\n    # compute conflict degree per vertex\n    def v_conflicts(idx: int, arr: List[int]) -> int:\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # choose a set of vertices with highest conflicts (or random if no conflicts)\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = random.randint(3, 5)\n    targets = [i for (sc, i) in conf_scores[:q]]\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n\n    # greedy randomized recolor for targets\n    present_colors = sorted(set(sol))\n    for v in targets:\n        # candidate colors among present plus one exploratory\n        candidates = present_colors[:]\n        candidates.append(max(present_colors) + 1 if present_colors else 1)\n        # score by local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], random.random()))\n        pick_pool = [c for conf, c in scored[:min(2, len(scored))]]\n        sol[v] = random.choice(pick_pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001270784}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    arr = compact(arr)\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\n\nrandom.random  # reference to ensure import is used\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # compute conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    # choose vertex: bias towards higher conflict; if none, random vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates)\n    else:\n        v = random.randrange(n)\n\n    # allowed candidate colors: existing colors 1..current_max; allow current_max+1 only if v is conflicting\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    candidates = sorted(present_colors)\n    if conflict_counts[v] > 0:\n        # exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(current_max + 1)\n    # always consider any neighbor colors (already subset of present, but keep for completeness)\n    for c in neigh_colors:\n        if c not in candidates:\n            candidates.append(c)\n\n    # scoring for each candidate color\n    def conflicts_if(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        local_conf = conflicts_if(v, c, sol)\n        # secondary criterion: prefer smaller resulting max color\n        new_max = max(current_max if c <= current_max else c, max(sol))\n        scored.append((local_conf, new_max, random.random(), c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_local = scored[0][0]\n    pool = [t[3] for t in scored if t[0] == best_local]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\n\nrandom.randrange  # reference to ensure import is used\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # conflict score per vertex\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol))\n    if not present_colors:\n        present_colors = [1]\n\n    for v in targets:\n        candidates = present_colors[:]\n        # allow exploratory new color\n        candidates.append(max(present_colors) + 1)\n        # evaluate local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            # prefer smaller color numbers to aid compaction\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1], random.random()))\n        best_conf = scored[0][0]\n        pool = [c for (conf, c) in scored if conf == best_conf][:2]\n        sol[v] = random.choice(pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001516947}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    arr = compact(arr)\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\n\nrandom.random  # reference to ensure import is used\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # compute conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    # choose vertex: bias towards higher conflict; if none, random vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates)\n    else:\n        v = random.randrange(n)\n\n    # allowed candidate colors: existing colors 1..current_max; allow current_max+1 only if v is conflicting\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    candidates = sorted(present_colors)\n    if conflict_counts[v] > 0:\n        # exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(current_max + 1)\n    # always consider any neighbor colors (already subset of present, but keep for completeness)\n    for c in neigh_colors:\n        if c not in candidates:\n            candidates.append(c)\n\n    # scoring for each candidate color\n    def conflicts_if(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        local_conf = conflicts_if(v, c, sol)\n        # secondary criterion: prefer smaller resulting max color\n        new_max = max(current_max if c <= current_max else c, max(sol))\n        scored.append((local_conf, new_max, random.random(), c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_local = scored[0][0]\n    pool = [t[3] for t in scored if t[0] == best_local]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\n\nrandom.randrange  # reference to ensure import is used\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # conflict score per vertex\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol))\n    if not present_colors:\n        present_colors = [1]\n\n    for v in targets:\n        candidates = present_colors[:]\n        # allow exploratory new color\n        candidates.append(max(present_colors) + 1)\n        # evaluate local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            # prefer smaller color numbers to aid compaction\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1], random.random()))\n        best_conf = scored[0][0]\n        pool = [c for (conf, c) in scored if conf == best_conf][:2]\n        sol[v] = random.choice(pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001326944}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    arr = compact(arr)\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\n\nrandom.random  # reference to ensure import is used\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # compute conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    # choose vertex: bias towards higher conflict; if none, random vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates)\n    else:\n        v = random.randrange(n)\n\n    # allowed candidate colors: existing colors 1..current_max; allow current_max+1 only if v is conflicting\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    candidates = sorted(present_colors)\n    if conflict_counts[v] > 0:\n        # exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(current_max + 1)\n    # always consider any neighbor colors (already subset of present, but keep for completeness)\n    for c in neigh_colors:\n        if c not in candidates:\n            candidates.append(c)\n\n    # scoring for each candidate color\n    def conflicts_if(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        local_conf = conflicts_if(v, c, sol)\n        # secondary criterion: prefer smaller resulting max color\n        new_max = max(current_max if c <= current_max else c, max(sol))\n        scored.append((local_conf, new_max, random.random(), c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_local = scored[0][0]\n    pool = [t[3] for t in scored if t[0] == best_local]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\n\nrandom.randrange  # reference to ensure import is used\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # conflict score per vertex\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol))\n    if not present_colors:\n        present_colors = [1]\n\n    for v in targets:\n        candidates = present_colors[:]\n        # allow exploratory new color\n        candidates.append(max(present_colors) + 1)\n        # evaluate local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            # prefer smaller color numbers to aid compaction\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1], random.random()))\n        best_conf = scored[0][0]\n        pool = [c for (conf, c) in scored if conf == best_conf][:2]\n        sol[v] = random.choice(pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001230294}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n\n    arr = compact(arr)\n    if arr is None:\n        return 10**12\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\nimport math\n\nrandom.random  # keep import referenced\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    present_colors = set(sol)\n    current_max = max(present_colors) if present_colors else 1\n\n    # choose vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates_v = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates_v)\n    else:\n        # conflict-free: try to reduce k by targeting max-color vertices first\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n        else:\n            v = random.randrange(n)\n\n    # candidate colors: 1..current_max plus possibly current_max+1 with small probability\n    candidates = list(range(1, current_max + 1))\n    if conflict_counts[v] > 0 and random.random() < 0.15:\n        candidates.append(current_max + 1)\n\n    # local scoring: (conflicts_after, new_max_color)\n    def local_conflicts(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        lc = local_conflicts(v, c, sol)\n        new_max = max(c if c > current_max else current_max, max(sol))\n        # prefer fewer conflicts, then smaller max color, then smaller color index\n        scored.append((lc, new_max, c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_conf = scored[0][0]\n    pool = [t for t in scored if t[0] == best_conf]\n    # light randomness among equally best\n    choice = random.choice(pool)\n    new_c = choice[2]\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    # compact to align with evaluation behavior\n    neighbor = compact(neighbor)\n    if neighbor is None:\n        neighbor = sol[:]\n\n    return neighbor, \"Recolor_SingleVertex\"\n","Perturbacion":"import random\nimport math\n\nrandom.randrange  # keep import referenced\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # helper to count vertex conflicts\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # select a small set of targets: prefer conflicting or max-color vertices\n    current_max = max(sol) if sol else 1\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        # no conflicts: target vertices using the maximum color to encourage k reduction\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if len(max_color_vertices) >= q:\n            targets = random.sample(max_color_vertices, k=q)\n        else:\n            others = [i for i in range(n) if i not in max_color_vertices]\n            extra = random.sample(others, k=max(0, q - len(max_color_vertices))) if others else []\n            targets = max_color_vertices + extra\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol)) if sol else [1]\n\n    # perturb by recoloring targets to low-conflict colors with slight randomness\n    for v in targets:\n        candidates = list(range(1, max(present_colors) + 1))\n        # allow exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(max(present_colors) + 1)\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1]))\n        # choose among the two best options to diversify\n        topk = [c for (cnt, c) in scored if cnt == scored[0][0]][:2]\n        sol[v] = random.choice(topk)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n    return sol\n","Resultados":[[1,2,3,2,1,3,2,2,3],3,[1,2,3,2,1,3,2,2,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002429458}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n\n    arr = compact(arr)\n    if arr is None:\n        return 10**12\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\nimport math\n\nrandom.random  # keep import referenced\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    present_colors = set(sol)\n    current_max = max(present_colors) if present_colors else 1\n\n    # choose vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates_v = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates_v)\n    else:\n        # conflict-free: try to reduce k by targeting max-color vertices first\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n        else:\n            v = random.randrange(n)\n\n    # candidate colors: 1..current_max plus possibly current_max+1 with small probability\n    candidates = list(range(1, current_max + 1))\n    if conflict_counts[v] > 0 and random.random() < 0.15:\n        candidates.append(current_max + 1)\n\n    # local scoring: (conflicts_after, new_max_color)\n    def local_conflicts(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        lc = local_conflicts(v, c, sol)\n        new_max = max(c if c > current_max else current_max, max(sol))\n        # prefer fewer conflicts, then smaller max color, then smaller color index\n        scored.append((lc, new_max, c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_conf = scored[0][0]\n    pool = [t for t in scored if t[0] == best_conf]\n    # light randomness among equally best\n    choice = random.choice(pool)\n    new_c = choice[2]\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    # compact to align with evaluation behavior\n    neighbor = compact(neighbor)\n    if neighbor is None:\n        neighbor = sol[:]\n\n    return neighbor, \"Recolor_SingleVertex\"\n","Perturbacion":"import random\nimport math\n\nrandom.randrange  # keep import referenced\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # helper to count vertex conflicts\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # select a small set of targets: prefer conflicting or max-color vertices\n    current_max = max(sol) if sol else 1\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        # no conflicts: target vertices using the maximum color to encourage k reduction\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if len(max_color_vertices) >= q:\n            targets = random.sample(max_color_vertices, k=q)\n        else:\n            others = [i for i in range(n) if i not in max_color_vertices]\n            extra = random.sample(others, k=max(0, q - len(max_color_vertices))) if others else []\n            targets = max_color_vertices + extra\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol)) if sol else [1]\n\n    # perturb by recoloring targets to low-conflict colors with slight randomness\n    for v in targets:\n        candidates = list(range(1, max(present_colors) + 1))\n        # allow exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(max(present_colors) + 1)\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1]))\n        # choose among the two best options to diversify\n        topk = [c for (cnt, c) in scored if cnt == scored[0][0]][:2]\n        sol[v] = random.choice(topk)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n    return sol\n","Resultados":[[1,2,3,1,4,3,2,1,4],2003,[1,2,3,1,2,3,2,1,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00279994}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n\n    arr = compact(arr)\n    if arr is None:\n        return 10**12\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\nimport math\n\nrandom.random  # keep import referenced\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    present_colors = set(sol)\n    current_max = max(present_colors) if present_colors else 1\n\n    # choose vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates_v = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates_v)\n    else:\n        # conflict-free: try to reduce k by targeting max-color vertices first\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n        else:\n            v = random.randrange(n)\n\n    # candidate colors: 1..current_max plus possibly current_max+1 with small probability\n    candidates = list(range(1, current_max + 1))\n    if conflict_counts[v] > 0 and random.random() < 0.15:\n        candidates.append(current_max + 1)\n\n    # local scoring: (conflicts_after, new_max_color)\n    def local_conflicts(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        lc = local_conflicts(v, c, sol)\n        new_max = max(c if c > current_max else current_max, max(sol))\n        # prefer fewer conflicts, then smaller max color, then smaller color index\n        scored.append((lc, new_max, c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_conf = scored[0][0]\n    pool = [t for t in scored if t[0] == best_conf]\n    # light randomness among equally best\n    choice = random.choice(pool)\n    new_c = choice[2]\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    # compact to align with evaluation behavior\n    neighbor = compact(neighbor)\n    if neighbor is None:\n        neighbor = sol[:]\n\n    return neighbor, \"Recolor_SingleVertex\"\n","Perturbacion":"import random\nimport math\n\nrandom.randrange  # keep import referenced\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # helper to count vertex conflicts\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # select a small set of targets: prefer conflicting or max-color vertices\n    current_max = max(sol) if sol else 1\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        # no conflicts: target vertices using the maximum color to encourage k reduction\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if len(max_color_vertices) >= q:\n            targets = random.sample(max_color_vertices, k=q)\n        else:\n            others = [i for i in range(n) if i not in max_color_vertices]\n            extra = random.sample(others, k=max(0, q - len(max_color_vertices))) if others else []\n            targets = max_color_vertices + extra\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol)) if sol else [1]\n\n    # perturb by recoloring targets to low-conflict colors with slight randomness\n    for v in targets:\n        candidates = list(range(1, max(present_colors) + 1))\n        # allow exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(max(present_colors) + 1)\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1]))\n        # choose among the two best options to diversify\n        topk = [c for (cnt, c) in scored if cnt == scored[0][0]][:2]\n        sol[v] = random.choice(topk)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001503087}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9: solution is a length-9 list [c1,c2,...,c9] with positive integers as color IDs for vertices 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph coloring evaluation: lower is better (fitness = number of colors if feasible; otherwise penalties dominate)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic pseudo-random neighbor generation based on input solution\n    # Encodes the neighbor solution into the NB_Type string to comply with the required return signature\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Seed with a stable hash of the tuple(solution)\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val ^= (int(x) if isinstance(x, int) else 0) & 0xFFFFFFFF\n        seed_val *= 1099511628211\n        seed_val &= (1<<64)-1\n    random.seed(seed_val)\n\n    # Helper: adjacency list\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Current max color\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges0:\n        if current_colors[u] == current_colors[v]:\n            conflicts.append(u)\n            conflicts.append(v)\n    conflicts = list(sorted(set(conflicts)))\n\n    candidate_indices = conflicts if conflicts else list(range(n))\n    u = random.choice(candidate_indices)\n\n    # Try recoloring u to the smallest feasible color in [1..kmax] or kmax+1 if needed\n    used_by_neighbors = {current_colors[v] for v in adj[u]}\n    new_color = None\n    for color in range(1, kmax+1):\n        if color not in used_by_neighbors:\n            new_color = color\n            break\n    if new_color is None:\n        new_color = kmax + 1\n\n    new_sol = sol[:]\n    new_sol[u] = new_color\n\n    # Encode neighbor into NB_Type string\n    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_color})\n    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: random recolors on a subset of vertices to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Stable seed based on input to keep determinism within a run context\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + (int(x) if isinstance(x, int) else 0) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    # Adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Decide how many positions to perturb (1..3)\n    num_moves = 1 + (seed_val % 3)\n    indices = list(range(n))\n    random.shuffle(indices)\n    to_change = indices[:num_moves]\n\n    for u in to_change:\n        used = {current_colors[v] for v in adj[u]}\n        # Prefer colors within current palette; if none feasible, allow introducing one new color\n        candidate_colors = [c for c in range(1, kmax+1) if c not in used]\n        if candidate_colors:\n            new_color = random.choice(candidate_colors)\n        else:\n            new_color = kmax + 1\n            kmax = max(kmax, new_color)\n        sol[u] = new_color\n        current_colors[u] = new_color\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001194363}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9: solution is a length-9 list [c1,c2,...,c9] with positive integers as color IDs for vertices 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph coloring evaluation: lower is better (fitness = number of colors if feasible; otherwise penalties dominate)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic pseudo-random neighbor generation based on input solution\n    # Encodes the neighbor solution into the NB_Type string to comply with the required return signature\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Seed with a stable hash of the tuple(solution)\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val ^= (int(x) if isinstance(x, int) else 0) & 0xFFFFFFFF\n        seed_val *= 1099511628211\n        seed_val &= (1<<64)-1\n    random.seed(seed_val)\n\n    # Helper: adjacency list\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Current max color\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges0:\n        if current_colors[u] == current_colors[v]:\n            conflicts.append(u)\n            conflicts.append(v)\n    conflicts = list(sorted(set(conflicts)))\n\n    candidate_indices = conflicts if conflicts else list(range(n))\n    u = random.choice(candidate_indices)\n\n    # Try recoloring u to the smallest feasible color in [1..kmax] or kmax+1 if needed\n    used_by_neighbors = {current_colors[v] for v in adj[u]}\n    new_color = None\n    for color in range(1, kmax+1):\n        if color not in used_by_neighbors:\n            new_color = color\n            break\n    if new_color is None:\n        new_color = kmax + 1\n\n    new_sol = sol[:]\n    new_sol[u] = new_color\n\n    # Encode neighbor into NB_Type string\n    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_color})\n    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: random recolors on a subset of vertices to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Stable seed based on input to keep determinism within a run context\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + (int(x) if isinstance(x, int) else 0) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    # Adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Decide how many positions to perturb (1..3)\n    num_moves = 1 + (seed_val % 3)\n    indices = list(range(n))\n    random.shuffle(indices)\n    to_change = indices[:num_moves]\n\n    for u in to_change:\n        used = {current_colors[v] for v in adj[u]}\n        # Prefer colors within current palette; if none feasible, allow introducing one new color\n        candidate_colors = [c for c in range(1, kmax+1) if c not in used]\n        if candidate_colors:\n            new_color = random.choice(candidate_colors)\n        else:\n            new_color = kmax + 1\n            kmax = max(kmax, new_color)\n        sol[u] = new_color\n        current_colors[u] = new_color\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001154363}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9: solution is a length-9 list [c1,c2,...,c9] with positive integers as color IDs for vertices 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph coloring evaluation: lower is better (fitness = number of colors if feasible; otherwise penalties dominate)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic pseudo-random neighbor generation based on input solution\n    # Encodes the neighbor solution into the NB_Type string to comply with the required return signature\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Seed with a stable hash of the tuple(solution)\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val ^= (int(x) if isinstance(x, int) else 0) & 0xFFFFFFFF\n        seed_val *= 1099511628211\n        seed_val &= (1<<64)-1\n    random.seed(seed_val)\n\n    # Helper: adjacency list\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Current max color\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges0:\n        if current_colors[u] == current_colors[v]:\n            conflicts.append(u)\n            conflicts.append(v)\n    conflicts = list(sorted(set(conflicts)))\n\n    candidate_indices = conflicts if conflicts else list(range(n))\n    u = random.choice(candidate_indices)\n\n    # Try recoloring u to the smallest feasible color in [1..kmax] or kmax+1 if needed\n    used_by_neighbors = {current_colors[v] for v in adj[u]}\n    new_color = None\n    for color in range(1, kmax+1):\n        if color not in used_by_neighbors:\n            new_color = color\n            break\n    if new_color is None:\n        new_color = kmax + 1\n\n    new_sol = sol[:]\n    new_sol[u] = new_color\n\n    # Encode neighbor into NB_Type string\n    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_color})\n    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: random recolors on a subset of vertices to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Stable seed based on input to keep determinism within a run context\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + (int(x) if isinstance(x, int) else 0) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    # Adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Decide how many positions to perturb (1..3)\n    num_moves = 1 + (seed_val % 3)\n    indices = list(range(n))\n    random.shuffle(indices)\n    to_change = indices[:num_moves]\n\n    for u in to_change:\n        used = {current_colors[v] for v in adj[u]}\n        # Prefer colors within current palette; if none feasible, allow introducing one new color\n        candidate_colors = [c for c in range(1, kmax+1) if c not in used]\n        if candidate_colors:\n            new_color = random.choice(candidate_colors)\n        else:\n            new_color = kmax + 1\n            kmax = max(kmax, new_color)\n        sol[u] = new_color\n        current_colors[u] = new_color\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001118232}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Check element domain\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Normalize colors to 1..k contiguous\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current = sol[:]\n    kmax = max(current) if current else 1\n\n    # Conflict counts per vertex\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    has_conflict = any(x > 0 for x in conflict_deg)\n\n    if has_conflict:\n        # Pick vertex with maximum conflict degree (tie-break by lowest index)\n        u = max(range(n), key=lambda i: (conflict_deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n    else:\n        # Attempt to reduce number of colors by moving a vertex from the highest color class\n        kmax = max(current) if current else 1\n        # Gather vertices by color\n        by_color = {c: [] for c in range(1, kmax+1)}\n        for i, c in enumerate(current):\n            by_color[c].append(i)\n\n        target_color = kmax\n        # Greedy recolor attempt for any vertex in target_color to a lower color\n        for u in by_color.get(target_color, []):\n            used = {current[v] for v in adj[u]}\n            for c in range(1, target_color):\n                if c not in used:\n                    new_sol = current[:]\n                    new_sol[u] = c\n                    # If target color becomes empty, normalize eliminates it\n                    new_sol = normalize_colors(new_sol)\n                    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n                    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"ReduceAttempt\")\n        # If not directly possible, perform a Kempe-chain swap between target_color and some lower color\n        for a in range(1, kmax):\n            if not by_color.get(target_color):\n                break\n            u = by_color[target_color][0]\n            # BFS on subgraph induced by colors {a, target_color}\n            allowed = {a, target_color}\n            visited = set()\n            comp = []\n            stack = [u]\n            while stack:\n                x = stack.pop()\n                if x in visited:\n                    continue\n                if current[x] not in allowed:\n                    continue\n                visited.add(x)\n                comp.append(x)\n                for nb in adj[x]:\n                    if current[nb] in allowed and nb not in visited:\n                        stack.append(nb)\n            new_sol = current[:]\n            for x in comp:\n                new_sol[x] = a if current[x] == target_color else target_color\n            new_sol = normalize_colors(new_sol)\n            encoded_neighbor = json.dumps({\"solution\": new_sol, \"kempe_colors\": [a, target_color]})\n            return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"KempeSwap\")\n\n        # Fallback: recolor a random vertex to the smallest feasible color (deterministic seed)\n        seed_val = 1469598103934665603\n        for x in current:\n            seed_val ^= int(x) & 0xFFFFFFFF\n            seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n        random.seed(seed_val)\n        u = random.randrange(n)\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"RecolorFallback\")\n","Perturbacion":"import random\nimport json\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Normalize colors\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2-4 vertices biased towards the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))  # largest color first\n\n    num_moves = 2 + (seed_val % 3)  # 2..4 moves\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        # Prefer within current palette\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                # pick a random existing color (may create conflicts intentionally)\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n    out = normalize_colors(out)\n    return out\n","Resultados":[[1,1,3,2,4,2,4,3,3],4,[1,1,3,2,4,2,4,3,3],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003037814}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Check element domain\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Normalize colors to 1..k contiguous\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current = sol[:]\n    kmax = max(current) if current else 1\n\n    # Conflict counts per vertex\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    has_conflict = any(x > 0 for x in conflict_deg)\n\n    if has_conflict:\n        # Pick vertex with maximum conflict degree (tie-break by lowest index)\n        u = max(range(n), key=lambda i: (conflict_deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n    else:\n        # Attempt to reduce number of colors by moving a vertex from the highest color class\n        kmax = max(current) if current else 1\n        # Gather vertices by color\n        by_color = {c: [] for c in range(1, kmax+1)}\n        for i, c in enumerate(current):\n            by_color[c].append(i)\n\n        target_color = kmax\n        # Greedy recolor attempt for any vertex in target_color to a lower color\n        for u in by_color.get(target_color, []):\n            used = {current[v] for v in adj[u]}\n            for c in range(1, target_color):\n                if c not in used:\n                    new_sol = current[:]\n                    new_sol[u] = c\n                    # If target color becomes empty, normalize eliminates it\n                    new_sol = normalize_colors(new_sol)\n                    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n                    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"ReduceAttempt\")\n        # If not directly possible, perform a Kempe-chain swap between target_color and some lower color\n        for a in range(1, kmax):\n            if not by_color.get(target_color):\n                break\n            u = by_color[target_color][0]\n            # BFS on subgraph induced by colors {a, target_color}\n            allowed = {a, target_color}\n            visited = set()\n            comp = []\n            stack = [u]\n            while stack:\n                x = stack.pop()\n                if x in visited:\n                    continue\n                if current[x] not in allowed:\n                    continue\n                visited.add(x)\n                comp.append(x)\n                for nb in adj[x]:\n                    if current[nb] in allowed and nb not in visited:\n                        stack.append(nb)\n            new_sol = current[:]\n            for x in comp:\n                new_sol[x] = a if current[x] == target_color else target_color\n            new_sol = normalize_colors(new_sol)\n            encoded_neighbor = json.dumps({\"solution\": new_sol, \"kempe_colors\": [a, target_color]})\n            return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"KempeSwap\")\n\n        # Fallback: recolor a random vertex to the smallest feasible color (deterministic seed)\n        seed_val = 1469598103934665603\n        for x in current:\n            seed_val ^= int(x) & 0xFFFFFFFF\n            seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n        random.seed(seed_val)\n        u = random.randrange(n)\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"RecolorFallback\")\n","Perturbacion":"import random\nimport json\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Normalize colors\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2-4 vertices biased towards the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))  # largest color first\n\n    num_moves = 2 + (seed_val % 3)  # 2..4 moves\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        # Prefer within current palette\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                # pick a random existing color (may create conflicts intentionally)\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n    out = normalize_colors(out)\n    return out\n","Resultados":["ENCODED_SOLUTION:{\"solution\": [1, 2, 3, 4, 5, 6, 7, 8, 3], \"changed_index\": 8, \"new_color\": 3}",1000000000,[1,1,3,2,4,2,4,3,3],1000000000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002413037}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Check element domain\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Normalize colors to 1..k contiguous\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current = sol[:]\n    kmax = max(current) if current else 1\n\n    # Conflict counts per vertex\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    has_conflict = any(x > 0 for x in conflict_deg)\n\n    if has_conflict:\n        # Pick vertex with maximum conflict degree (tie-break by lowest index)\n        u = max(range(n), key=lambda i: (conflict_deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n    else:\n        # Attempt to reduce number of colors by moving a vertex from the highest color class\n        kmax = max(current) if current else 1\n        # Gather vertices by color\n        by_color = {c: [] for c in range(1, kmax+1)}\n        for i, c in enumerate(current):\n            by_color[c].append(i)\n\n        target_color = kmax\n        # Greedy recolor attempt for any vertex in target_color to a lower color\n        for u in by_color.get(target_color, []):\n            used = {current[v] for v in adj[u]}\n            for c in range(1, target_color):\n                if c not in used:\n                    new_sol = current[:]\n                    new_sol[u] = c\n                    # If target color becomes empty, normalize eliminates it\n                    new_sol = normalize_colors(new_sol)\n                    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n                    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"ReduceAttempt\")\n        # If not directly possible, perform a Kempe-chain swap between target_color and some lower color\n        for a in range(1, kmax):\n            if not by_color.get(target_color):\n                break\n            u = by_color[target_color][0]\n            # BFS on subgraph induced by colors {a, target_color}\n            allowed = {a, target_color}\n            visited = set()\n            comp = []\n            stack = [u]\n            while stack:\n                x = stack.pop()\n                if x in visited:\n                    continue\n                if current[x] not in allowed:\n                    continue\n                visited.add(x)\n                comp.append(x)\n                for nb in adj[x]:\n                    if current[nb] in allowed and nb not in visited:\n                        stack.append(nb)\n            new_sol = current[:]\n            for x in comp:\n                new_sol[x] = a if current[x] == target_color else target_color\n            new_sol = normalize_colors(new_sol)\n            encoded_neighbor = json.dumps({\"solution\": new_sol, \"kempe_colors\": [a, target_color]})\n            return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"KempeSwap\")\n\n        # Fallback: recolor a random vertex to the smallest feasible color (deterministic seed)\n        seed_val = 1469598103934665603\n        for x in current:\n            seed_val ^= int(x) & 0xFFFFFFFF\n            seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n        random.seed(seed_val)\n        u = random.randrange(n)\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"RecolorFallback\")\n","Perturbacion":"import random\nimport json\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Normalize colors\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2-4 vertices biased towards the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))  # largest color first\n\n    num_moves = 2 + (seed_val % 3)  # 2..4 moves\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        # Prefer within current palette\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                # pick a random existing color (may create conflicts intentionally)\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n    out = normalize_colors(out)\n    return out\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001685918}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    violations = 0\n    for i, x in enumerate(solution):\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: minimize violations first, then k_used\n    # Large margin W ensures feasibility prioritized\n    W = 100000\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k (applied upon return only)\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degree and saturation degree\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: pick vertex by (conflict_deg desc, saturation desc, degree desc, index asc)\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        # choose smallest feasible color or introduce new if needed\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: try to reduce k by reassigning a vertex from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor to lower color\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                # if target color emptied, normalization will remove it\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe-chain swap between target_color and partner color that yields best k reduction potential\n    best_payload = None\n    best_tag = None\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # pick vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        # normalize for return\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"kempe_colors\": [a, target_color]}\n        best_payload = payload\n        best_tag = \"KempeSwap\"\n        # return first improved candidate (simple heuristic)\n        break\n    if best_payload is not None:\n        return (\"ENCODED_SOLUTION:\" + json.dumps(best_payload), best_tag)\n\n    # Fallback: recolor a random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize for return\n    # (keeps palette compact for evaluators\/caching)\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"changed_index\": u, \"new_color\": out[u]}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optionally apply a Kempe swap across two random colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            # find a vertex with color a to start\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # Rebuild adjacency for safety (local scope)\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Resultados":[[2,2,2,1,3,1,3,4,4],4,[2,2,2,1,3,1,3,4,4],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003060585}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    violations = 0\n    for i, x in enumerate(solution):\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: minimize violations first, then k_used\n    # Large margin W ensures feasibility prioritized\n    W = 100000\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k (applied upon return only)\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degree and saturation degree\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: pick vertex by (conflict_deg desc, saturation desc, degree desc, index asc)\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        # choose smallest feasible color or introduce new if needed\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: try to reduce k by reassigning a vertex from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor to lower color\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                # if target color emptied, normalization will remove it\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe-chain swap between target_color and partner color that yields best k reduction potential\n    best_payload = None\n    best_tag = None\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # pick vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        # normalize for return\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"kempe_colors\": [a, target_color]}\n        best_payload = payload\n        best_tag = \"KempeSwap\"\n        # return first improved candidate (simple heuristic)\n        break\n    if best_payload is not None:\n        return (\"ENCODED_SOLUTION:\" + json.dumps(best_payload), best_tag)\n\n    # Fallback: recolor a random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize for return\n    # (keeps palette compact for evaluators\/caching)\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"changed_index\": u, \"new_color\": out[u]}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optionally apply a Kempe swap across two random colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            # find a vertex with color a to start\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # Rebuild adjacency for safety (local scope)\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Resultados":["ENCODED_SOLUTION:{\"solution\": [1, 2, 3, 4, 5, 6, 7, 8, 3], \"changed_index\": 8, \"new_color\": 3}",1000000000,[2,2,2,1,3,1,3,4,4],1000000000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002340545}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    violations = 0\n    for i, x in enumerate(solution):\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: minimize violations first, then k_used\n    # Large margin W ensures feasibility prioritized\n    W = 100000\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k (applied upon return only)\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degree and saturation degree\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: pick vertex by (conflict_deg desc, saturation desc, degree desc, index asc)\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        # choose smallest feasible color or introduce new if needed\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: try to reduce k by reassigning a vertex from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor to lower color\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                # if target color emptied, normalization will remove it\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe-chain swap between target_color and partner color that yields best k reduction potential\n    best_payload = None\n    best_tag = None\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # pick vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        # normalize for return\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"kempe_colors\": [a, target_color]}\n        best_payload = payload\n        best_tag = \"KempeSwap\"\n        # return first improved candidate (simple heuristic)\n        break\n    if best_payload is not None:\n        return (\"ENCODED_SOLUTION:\" + json.dumps(best_payload), best_tag)\n\n    # Fallback: recolor a random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize for return\n    # (keeps palette compact for evaluators\/caching)\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"changed_index\": u, \"new_color\": out[u]}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optionally apply a Kempe swap across two random colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            # find a vertex with color a to start\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # Rebuild adjacency for safety (local scope)\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001476757}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    for x in solution:\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    violations = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution)) if solution else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Strong lexicographic penalty to prioritize feasibility\n    W = 10**6\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1)), \"meta\": {\"reason\": \"InvalidInputFallback\"}})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degrees and neighbor colors\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: recolor most conflicting vertex to smallest feasible color\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        # tie-break: more conflicts, higher saturation, higher degree, lower index\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"RecolorConflict\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: attempt to reduce number of colors by moving from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor from target_color to lower colors\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"ReduceGreedy\"}}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe chain swap between target_color and a lower color (first viable)\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # choose a vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"meta\": {\"kempe_colors\": [a, target_color], \"tag\": \"KempeSwap\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"KempeSwap\")\n\n    # Fallback: recolor a pseudo-random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"meta\": {\"changed_index\": u, \"new_color\": out[u], \"tag\": \"RecolorFallback\"}}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optional Kempe swap across two colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # rebuild adjacency local scope\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Resultados":[[2,2,2,1,3,1,3,4,4],4,[2,2,2,1,3,1,3,4,4],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002827612}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    for x in solution:\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    violations = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution)) if solution else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Strong lexicographic penalty to prioritize feasibility\n    W = 10**6\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1)), \"meta\": {\"reason\": \"InvalidInputFallback\"}})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degrees and neighbor colors\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: recolor most conflicting vertex to smallest feasible color\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        # tie-break: more conflicts, higher saturation, higher degree, lower index\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"RecolorConflict\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: attempt to reduce number of colors by moving from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor from target_color to lower colors\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"ReduceGreedy\"}}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe chain swap between target_color and a lower color (first viable)\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # choose a vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"meta\": {\"kempe_colors\": [a, target_color], \"tag\": \"KempeSwap\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"KempeSwap\")\n\n    # Fallback: recolor a pseudo-random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"meta\": {\"changed_index\": u, \"new_color\": out[u], \"tag\": \"RecolorFallback\"}}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optional Kempe swap across two colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # rebuild adjacency local scope\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Resultados":["ENCODED_SOLUTION:{\"solution\": [1, 2, 3, 4, 5, 6, 7, 8, 3], \"meta\": {\"changed_index\": 8, \"new_color\": 3, \"tag\": \"ReduceGreedy\"}}",1000000000,[2,2,2,1,3,1,3,4,4],1000000000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002362076}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    for x in solution:\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    violations = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution)) if solution else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Strong lexicographic penalty to prioritize feasibility\n    W = 10**6\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1)), \"meta\": {\"reason\": \"InvalidInputFallback\"}})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degrees and neighbor colors\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: recolor most conflicting vertex to smallest feasible color\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        # tie-break: more conflicts, higher saturation, higher degree, lower index\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"RecolorConflict\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: attempt to reduce number of colors by moving from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor from target_color to lower colors\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"ReduceGreedy\"}}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe chain swap between target_color and a lower color (first viable)\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # choose a vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"meta\": {\"kempe_colors\": [a, target_color], \"tag\": \"KempeSwap\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"KempeSwap\")\n\n    # Fallback: recolor a pseudo-random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"meta\": {\"changed_index\": u, \"new_color\": out[u], \"tag\": \"RecolorFallback\"}}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optional Kempe swap across two colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # rebuild adjacency local scope\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001464556}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT. Encoding: a comma-separated string of 9 positive integers representing colors [c1,...,c9] for vertices 1..9. Example: '1,2,3,4,1,2,3,4,1'.","Evaluacion":"import math\nfrom typing import List, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> float:\n    # Lower is better. Feasible k-coloring scored by k; infeasible heavily penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedure to test k-colorability for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution: Union[str, List[int]]) -> tuple:\n    # Returns (neighbour_solution, Movement_Type) where Movement_Type is a string descriptor.\n    # Neighbour move: pick a random node and recolor it to the smallest feasible color; if none feasible within current max+1, add a new color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        # fallback to a simple feasible seed if parsing fails\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    idx = random.randrange(n)  # 0-based index\n    used_by_neighbors = set(colors[v-1] for v in adj[idx+1])\n    maxc = max(colors) if colors else 1\n    new_color = None\n    for c in range(1, maxc+1):\n        if c not in used_by_neighbors:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = maxc+1\n    new_sol = colors[:]\n    new_sol[idx] = new_color\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_sol)\n    else:\n        out = new_sol\n    return (out, 'node_recolor')\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Strong perturbation: randomly reassign colors for a random subset of nodes, then greedy repair to maintain\/restore feasibility.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    kmax = max(colors) if colors else 1\n    p = random.uniform(0.35, 0.6)\n    idxs = [i for i in range(n) if random.random() < p]\n    if not idxs:\n        idxs = [random.randrange(n)]\n\n    # random reassignment within 1..kmax+1\n    for i in idxs:\n        colors[i] = random.randint(1, kmax+1)\n\n    # greedy repair pass to remove conflicts and try to reduce colors\n    for u in range(1, n+1):\n        used = set(colors[v-1] for v in adj[u])\n        if colors[u-1] in used:\n            for c in range(1, max(colors)+1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = max(colors)+1\n\n    # attempt simple color compaction\n    remap = {}\n    nextc = 1\n    for c in sorted(set(colors)):\n        remap[c] = nextc\n        nextc += 1\n    colors = [remap[c] for c in colors]\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    else:\n        return colors\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001895951}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT. Encoding: a comma-separated string of 9 positive integers representing colors [c1,...,c9] for vertices 1..9. Example: '1,2,3,4,1,2,3,4,1'.","Evaluacion":"import math\nfrom typing import List, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> float:\n    # Lower is better. Feasible k-coloring scored by k; infeasible heavily penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedure to test k-colorability for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution: Union[str, List[int]]) -> tuple:\n    # Returns (neighbour_solution, Movement_Type) where Movement_Type is a string descriptor.\n    # Neighbour move: pick a random node and recolor it to the smallest feasible color; if none feasible within current max+1, add a new color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        # fallback to a simple feasible seed if parsing fails\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    idx = random.randrange(n)  # 0-based index\n    used_by_neighbors = set(colors[v-1] for v in adj[idx+1])\n    maxc = max(colors) if colors else 1\n    new_color = None\n    for c in range(1, maxc+1):\n        if c not in used_by_neighbors:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = maxc+1\n    new_sol = colors[:]\n    new_sol[idx] = new_color\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_sol)\n    else:\n        out = new_sol\n    return (out, 'node_recolor')\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Strong perturbation: randomly reassign colors for a random subset of nodes, then greedy repair to maintain\/restore feasibility.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    kmax = max(colors) if colors else 1\n    p = random.uniform(0.35, 0.6)\n    idxs = [i for i in range(n) if random.random() < p]\n    if not idxs:\n        idxs = [random.randrange(n)]\n\n    # random reassignment within 1..kmax+1\n    for i in idxs:\n        colors[i] = random.randint(1, kmax+1)\n\n    # greedy repair pass to remove conflicts and try to reduce colors\n    for u in range(1, n+1):\n        used = set(colors[v-1] for v in adj[u])\n        if colors[u-1] in used:\n            for c in range(1, max(colors)+1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = max(colors)+1\n\n    # attempt simple color compaction\n    remap = {}\n    nextc = 1\n    for c in sorted(set(colors)):\n        remap[c] = nextc\n        nextc += 1\n    colors = [remap[c] for c in colors]\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    else:\n        return colors\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001623399}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT. Encoding: a comma-separated string of 9 positive integers representing colors [c1,...,c9] for vertices 1..9. Example: '1,2,3,4,1,2,3,4,1'.","Evaluacion":"import math\nfrom typing import List, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> float:\n    # Lower is better. Feasible k-coloring scored by k; infeasible heavily penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedure to test k-colorability for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution: Union[str, List[int]]) -> tuple:\n    # Returns (neighbour_solution, Movement_Type) where Movement_Type is a string descriptor.\n    # Neighbour move: pick a random node and recolor it to the smallest feasible color; if none feasible within current max+1, add a new color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        # fallback to a simple feasible seed if parsing fails\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    idx = random.randrange(n)  # 0-based index\n    used_by_neighbors = set(colors[v-1] for v in adj[idx+1])\n    maxc = max(colors) if colors else 1\n    new_color = None\n    for c in range(1, maxc+1):\n        if c not in used_by_neighbors:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = maxc+1\n    new_sol = colors[:]\n    new_sol[idx] = new_color\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_sol)\n    else:\n        out = new_sol\n    return (out, 'node_recolor')\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Strong perturbation: randomly reassign colors for a random subset of nodes, then greedy repair to maintain\/restore feasibility.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    kmax = max(colors) if colors else 1\n    p = random.uniform(0.35, 0.6)\n    idxs = [i for i in range(n) if random.random() < p]\n    if not idxs:\n        idxs = [random.randrange(n)]\n\n    # random reassignment within 1..kmax+1\n    for i in idxs:\n        colors[i] = random.randint(1, kmax+1)\n\n    # greedy repair pass to remove conflicts and try to reduce colors\n    for u in range(1, n+1):\n        used = set(colors[v-1] for v in adj[u])\n        if colors[u-1] in used:\n            for c in range(1, max(colors)+1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = max(colors)+1\n\n    # attempt simple color compaction\n    remap = {}\n    nextc = 1\n    for c in sorted(set(colors)):\n        remap[c] = nextc\n        nextc += 1\n    colors = [remap[c] for c in colors]\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    else:\n        return colors\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001541767}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list]) -> float:\n    # Lower is better: feasible -> k (max color); infeasible -> large penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        # Relabel colors to 1..k in order of appearance for stability\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols, u, ca, cb):\n        # Perform A-B Kempe chain swap containing u; returns new cols\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        # Build alternating component\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        # Swap colors in the component\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # Fail fast: return input unchanged with parse_error tag\n        return (solution, 'parse_error')\n\n    colors = normalize_colors(colors)\n    kmax = max(colors)\n\n    # Identify conflicted vertices\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n\n    move_type = None\n    new_cols = colors[:]\n\n    # Move selection: prioritize conflict-driven recolor, else apply diversification moves\n    r = random.random()\n    if conf_vertices and r < 0.5:\n        # Conflict-driven recolor: pick high-degree conflicted node, recolor to smallest feasible\n        u = max(conf_vertices, key=lambda x: (len(adj[x]), random.random()))\n        used = {colors[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                new_cols[u-1] = c\n                break\n        else:\n            # Try Kempe with a random neighbor color before introducing a new color\n            if used:\n                cb = random.choice(list(used))\n                ca = colors[u-1]\n                trial = kempe_interchange(colors, u, ca, cb)\n                # If reduces conflicts or preserves k, accept\n                if len(conflicts(trial)) <= len(conf_edges):\n                    new_cols = trial\n                else:\n                    new_cols[u-1] = kmax + 1\n                    kmax = kmax + 1\n            else:\n                new_cols[u-1] = kmax + 1\n                kmax = kmax + 1\n        move_type = 'conflict_recolor'\n    elif r < 0.8:\n        # Kempe chain swap around a random vertex and random color pair\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh_colors = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh_colors:\n            # fallback to recolor smallest feasible\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols[u-1] = feas\n            move_type = 'node_recolor'\n        else:\n            cb = random.choice(neigh_colors)\n            new_cols = kempe_interchange(colors, u, ca, cb)\n            move_type = 'kempe_swap'\n    else:\n        # Pairwise color swap of two non-adjacent vertices to reduce conflicts \/ compact colors\n        attempts = 0\n        applied = False\n        while attempts < 15 and not applied:\n            i = random.randrange(1, n+1)\n            j = random.randrange(1, n+1)\n            attempts += 1\n            if i == j or j in adj[i]:\n                continue\n            ci, cj = colors[i-1], colors[j-1]\n            new_cols = colors[:]\n            new_cols[i-1], new_cols[j-1] = cj, ci\n            # Accept if conflicts do not increase\n            if len(conflicts(new_cols)) <= len(conf_edges):\n                applied = True\n                move_type = 'pair_swap'\n                break\n        if not applied:\n            # fallback: simple recolor random node to smallest feasible\n            u = random.randrange(1, n+1)\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols = colors[:]\n                new_cols[u-1] = feas\n            else:\n                new_cols = colors[:]\n                new_cols[u-1] = kmax + 1\n            move_type = 'node_recolor'\n\n    # Normalize color labels\n    new_cols = normalize_colors(new_cols)\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_cols)\n    else:\n        out = new_cols\n    return (out, move_type if move_type is not None else 'unknown')\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation using 1-2 Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # If invalid, return a simple 4-color seed known feasible for this graph\n        fallback = [1,1,1,2,3,2,3,4,4]\n        if isinstance(solution, str):\n            return ','.join(str(x) for x in fallback)\n        return fallback\n\n    colors = normalize_colors(colors)\n\n    # Apply 1-2 Kempe swaps on random vertices\/color pairs\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Recolor up to two most-conflicted vertices greedily\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n    if conf_vertices:\n        # score vertices by conflicts then degree\n        def v_score(u):\n            cdeg = sum(1 for (a, b) in conf_edges if a == u or b == u)\n            return (cdeg, len(adj[u]))\n        conf_vertices.sort(key=lambda x: v_score(x), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v-1] for v in adj[u]}\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = kmax + 1\n                kmax += 1\n\n    # Normalize \/ compact labels\n    colors = normalize_colors(colors)\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    return colors\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Cannot instantiate typing.Union","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00228168}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list]) -> float:\n    # Lower is better: feasible -> k (max color); infeasible -> large penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        # Relabel colors to 1..k in order of appearance for stability\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols, u, ca, cb):\n        # Perform A-B Kempe chain swap containing u; returns new cols\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        # Build alternating component\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        # Swap colors in the component\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # Fail fast: return input unchanged with parse_error tag\n        return (solution, 'parse_error')\n\n    colors = normalize_colors(colors)\n    kmax = max(colors)\n\n    # Identify conflicted vertices\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n\n    move_type = None\n    new_cols = colors[:]\n\n    # Move selection: prioritize conflict-driven recolor, else apply diversification moves\n    r = random.random()\n    if conf_vertices and r < 0.5:\n        # Conflict-driven recolor: pick high-degree conflicted node, recolor to smallest feasible\n        u = max(conf_vertices, key=lambda x: (len(adj[x]), random.random()))\n        used = {colors[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                new_cols[u-1] = c\n                break\n        else:\n            # Try Kempe with a random neighbor color before introducing a new color\n            if used:\n                cb = random.choice(list(used))\n                ca = colors[u-1]\n                trial = kempe_interchange(colors, u, ca, cb)\n                # If reduces conflicts or preserves k, accept\n                if len(conflicts(trial)) <= len(conf_edges):\n                    new_cols = trial\n                else:\n                    new_cols[u-1] = kmax + 1\n                    kmax = kmax + 1\n            else:\n                new_cols[u-1] = kmax + 1\n                kmax = kmax + 1\n        move_type = 'conflict_recolor'\n    elif r < 0.8:\n        # Kempe chain swap around a random vertex and random color pair\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh_colors = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh_colors:\n            # fallback to recolor smallest feasible\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols[u-1] = feas\n            move_type = 'node_recolor'\n        else:\n            cb = random.choice(neigh_colors)\n            new_cols = kempe_interchange(colors, u, ca, cb)\n            move_type = 'kempe_swap'\n    else:\n        # Pairwise color swap of two non-adjacent vertices to reduce conflicts \/ compact colors\n        attempts = 0\n        applied = False\n        while attempts < 15 and not applied:\n            i = random.randrange(1, n+1)\n            j = random.randrange(1, n+1)\n            attempts += 1\n            if i == j or j in adj[i]:\n                continue\n            ci, cj = colors[i-1], colors[j-1]\n            new_cols = colors[:]\n            new_cols[i-1], new_cols[j-1] = cj, ci\n            # Accept if conflicts do not increase\n            if len(conflicts(new_cols)) <= len(conf_edges):\n                applied = True\n                move_type = 'pair_swap'\n                break\n        if not applied:\n            # fallback: simple recolor random node to smallest feasible\n            u = random.randrange(1, n+1)\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols = colors[:]\n                new_cols[u-1] = feas\n            else:\n                new_cols = colors[:]\n                new_cols[u-1] = kmax + 1\n            move_type = 'node_recolor'\n\n    # Normalize color labels\n    new_cols = normalize_colors(new_cols)\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_cols)\n    else:\n        out = new_cols\n    return (out, move_type if move_type is not None else 'unknown')\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation using 1-2 Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # If invalid, return a simple 4-color seed known feasible for this graph\n        fallback = [1,1,1,2,3,2,3,4,4]\n        if isinstance(solution, str):\n            return ','.join(str(x) for x in fallback)\n        return fallback\n\n    colors = normalize_colors(colors)\n\n    # Apply 1-2 Kempe swaps on random vertices\/color pairs\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Recolor up to two most-conflicted vertices greedily\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n    if conf_vertices:\n        # score vertices by conflicts then degree\n        def v_score(u):\n            cdeg = sum(1 for (a, b) in conf_edges if a == u or b == u)\n            return (cdeg, len(adj[u]))\n        conf_vertices.sort(key=lambda x: v_score(x), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v-1] for v in adj[u]}\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = kmax + 1\n                kmax += 1\n\n    # Normalize \/ compact labels\n    colors = normalize_colors(colors)\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    return colors\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Cannot instantiate typing.Union","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001799433}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list]) -> float:\n    # Lower is better: feasible -> k (max color); infeasible -> large penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        # Relabel colors to 1..k in order of appearance for stability\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols, u, ca, cb):\n        # Perform A-B Kempe chain swap containing u; returns new cols\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        # Build alternating component\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        # Swap colors in the component\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # Fail fast: return input unchanged with parse_error tag\n        return (solution, 'parse_error')\n\n    colors = normalize_colors(colors)\n    kmax = max(colors)\n\n    # Identify conflicted vertices\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n\n    move_type = None\n    new_cols = colors[:]\n\n    # Move selection: prioritize conflict-driven recolor, else apply diversification moves\n    r = random.random()\n    if conf_vertices and r < 0.5:\n        # Conflict-driven recolor: pick high-degree conflicted node, recolor to smallest feasible\n        u = max(conf_vertices, key=lambda x: (len(adj[x]), random.random()))\n        used = {colors[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                new_cols[u-1] = c\n                break\n        else:\n            # Try Kempe with a random neighbor color before introducing a new color\n            if used:\n                cb = random.choice(list(used))\n                ca = colors[u-1]\n                trial = kempe_interchange(colors, u, ca, cb)\n                # If reduces conflicts or preserves k, accept\n                if len(conflicts(trial)) <= len(conf_edges):\n                    new_cols = trial\n                else:\n                    new_cols[u-1] = kmax + 1\n                    kmax = kmax + 1\n            else:\n                new_cols[u-1] = kmax + 1\n                kmax = kmax + 1\n        move_type = 'conflict_recolor'\n    elif r < 0.8:\n        # Kempe chain swap around a random vertex and random color pair\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh_colors = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh_colors:\n            # fallback to recolor smallest feasible\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols[u-1] = feas\n            move_type = 'node_recolor'\n        else:\n            cb = random.choice(neigh_colors)\n            new_cols = kempe_interchange(colors, u, ca, cb)\n            move_type = 'kempe_swap'\n    else:\n        # Pairwise color swap of two non-adjacent vertices to reduce conflicts \/ compact colors\n        attempts = 0\n        applied = False\n        while attempts < 15 and not applied:\n            i = random.randrange(1, n+1)\n            j = random.randrange(1, n+1)\n            attempts += 1\n            if i == j or j in adj[i]:\n                continue\n            ci, cj = colors[i-1], colors[j-1]\n            new_cols = colors[:]\n            new_cols[i-1], new_cols[j-1] = cj, ci\n            # Accept if conflicts do not increase\n            if len(conflicts(new_cols)) <= len(conf_edges):\n                applied = True\n                move_type = 'pair_swap'\n                break\n        if not applied:\n            # fallback: simple recolor random node to smallest feasible\n            u = random.randrange(1, n+1)\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols = colors[:]\n                new_cols[u-1] = feas\n            else:\n                new_cols = colors[:]\n                new_cols[u-1] = kmax + 1\n            move_type = 'node_recolor'\n\n    # Normalize color labels\n    new_cols = normalize_colors(new_cols)\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_cols)\n    else:\n        out = new_cols\n    return (out, move_type if move_type is not None else 'unknown')\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation using 1-2 Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # If invalid, return a simple 4-color seed known feasible for this graph\n        fallback = [1,1,1,2,3,2,3,4,4]\n        if isinstance(solution, str):\n            return ','.join(str(x) for x in fallback)\n        return fallback\n\n    colors = normalize_colors(colors)\n\n    # Apply 1-2 Kempe swaps on random vertices\/color pairs\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Recolor up to two most-conflicted vertices greedily\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n    if conf_vertices:\n        # score vertices by conflicts then degree\n        def v_score(u):\n            cdeg = sum(1 for (a, b) in conf_edges if a == u or b == u)\n            return (cdeg, len(adj[u]))\n        conf_vertices.sort(key=lambda x: v_score(x), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v-1] for v in adj[u]}\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = kmax + 1\n                kmax += 1\n\n    # Normalize \/ compact labels\n    colors = normalize_colors(colors)\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    return colors\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Cannot instantiate typing.Union","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001732902}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> k (max color); infeasible -> scaled penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 100000.0\n    if len(colors) != n:\n        return 90000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 80000.0\n        if x < 1:\n            return 70000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n    if violations > 0:\n        return 10000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def normalize_colors(cols):\n        # Compact to 1..k preserving relative order of first appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # On parse error, return input as CSV unchanged with tag\n        if isinstance(solution, str):\n            return (solution, 'parse_error')\n        if isinstance(solution, list):\n            return (to_csv(solution), 'parse_error')\n        return (\"1,1,1,2,3,2,3,4,4\", 'parse_error')\n\n    colors = normalize_colors(colors)\n\n    # Determine feasibility and current k\n    conf_edges = conflicts(colors)\n    kmax = max(colors)\n\n    move_type = 'unknown'\n    new_cols = colors[:]\n\n    if conf_edges:\n        # Conflict repair priority\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        # Pick vertex with highest conflict degree, tie-break by random\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, colors, kmax)\n        if feas is not None:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            # Try Kempe swaps over all neighbor colors, pick best (min conflicts)\n            ca = colors[u - 1]\n            neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(colors, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: introduce a new color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible: attempt color elimination from max color class\n        max_class = [i for i, c in enumerate(colors, start=1) if c == kmax]\n        random.shuffle(max_class)\n        eliminated = False\n        for u in max_class:\n            feas = smallest_feasible_color(u, colors, kmax - 1)\n            if feas is not None:\n                new_cols[u - 1] = feas\n                eliminated = True\n                move_type = 'k_reduce_recolor'\n                break\n        if not eliminated:\n            # Try Kempe-based attempt to free a color for a max-class vertex\n            if max_class:\n                u = random.choice(max_class)\n                ca = colors[u - 1]\n                neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                applied = False\n                for cb in neigh_colors:\n                    trial = kempe_interchange(colors, u, ca, cb)\n                    # After swap, try greedy recolor within 1..kmax-1\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        applied = True\n                        move_type = 'k_reduce_kempe'\n                        break\n                if not applied:\n                    # Compact: swap labels of two colors to diversify\n                    if kmax >= 2:\n                        a, b = random.sample(range(1, kmax + 1), 2)\n                        for i in range(n):\n                            if new_cols[i] == a:\n                                new_cols[i] = b\n                            elif new_cols[i] == b:\n                                new_cols[i] = a\n                        move_type = 'color_class_swap'\n\n    # Optional normalization to keep labels compact; preserve k\n    new_cols = normalize_colors(new_cols)\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n    else:\n        colors = normalize_colors(colors)\n\n    # 1-2 Kempe swaps\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n + 1)\n        ca = colors[u - 1]\n        neigh = [colors[v - 1] for v in adj[u] if colors[v - 1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Greedy repair of up to two most conflicted vertices\n    conf_edges = conflicts(colors)\n    if conf_edges:\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def v_score(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        conf_vertices.sort(key=lambda x: (v_score(x), len(adj[x])), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v - 1] for v in adj[u]}\n            placed = False\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                colors[u - 1] = kmax + 1\n                kmax += 1\n\n    colors = normalize_colors(colors)\n    return to_csv(colors)\n","Resultados":["1,1,2,3,4,3,4,2,2",4.0,"1,1,1,2,3,2,3,4,4",4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00323761}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> k (max color); infeasible -> scaled penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 100000.0\n    if len(colors) != n:\n        return 90000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 80000.0\n        if x < 1:\n            return 70000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n    if violations > 0:\n        return 10000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def normalize_colors(cols):\n        # Compact to 1..k preserving relative order of first appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # On parse error, return input as CSV unchanged with tag\n        if isinstance(solution, str):\n            return (solution, 'parse_error')\n        if isinstance(solution, list):\n            return (to_csv(solution), 'parse_error')\n        return (\"1,1,1,2,3,2,3,4,4\", 'parse_error')\n\n    colors = normalize_colors(colors)\n\n    # Determine feasibility and current k\n    conf_edges = conflicts(colors)\n    kmax = max(colors)\n\n    move_type = 'unknown'\n    new_cols = colors[:]\n\n    if conf_edges:\n        # Conflict repair priority\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        # Pick vertex with highest conflict degree, tie-break by random\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, colors, kmax)\n        if feas is not None:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            # Try Kempe swaps over all neighbor colors, pick best (min conflicts)\n            ca = colors[u - 1]\n            neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(colors, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: introduce a new color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible: attempt color elimination from max color class\n        max_class = [i for i, c in enumerate(colors, start=1) if c == kmax]\n        random.shuffle(max_class)\n        eliminated = False\n        for u in max_class:\n            feas = smallest_feasible_color(u, colors, kmax - 1)\n            if feas is not None:\n                new_cols[u - 1] = feas\n                eliminated = True\n                move_type = 'k_reduce_recolor'\n                break\n        if not eliminated:\n            # Try Kempe-based attempt to free a color for a max-class vertex\n            if max_class:\n                u = random.choice(max_class)\n                ca = colors[u - 1]\n                neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                applied = False\n                for cb in neigh_colors:\n                    trial = kempe_interchange(colors, u, ca, cb)\n                    # After swap, try greedy recolor within 1..kmax-1\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        applied = True\n                        move_type = 'k_reduce_kempe'\n                        break\n                if not applied:\n                    # Compact: swap labels of two colors to diversify\n                    if kmax >= 2:\n                        a, b = random.sample(range(1, kmax + 1), 2)\n                        for i in range(n):\n                            if new_cols[i] == a:\n                                new_cols[i] = b\n                            elif new_cols[i] == b:\n                                new_cols[i] = a\n                        move_type = 'color_class_swap'\n\n    # Optional normalization to keep labels compact; preserve k\n    new_cols = normalize_colors(new_cols)\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n    else:\n        colors = normalize_colors(colors)\n\n    # 1-2 Kempe swaps\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n + 1)\n        ca = colors[u - 1]\n        neigh = [colors[v - 1] for v in adj[u] if colors[v - 1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Greedy repair of up to two most conflicted vertices\n    conf_edges = conflicts(colors)\n    if conf_edges:\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def v_score(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        conf_vertices.sort(key=lambda x: (v_score(x), len(adj[x])), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v - 1] for v in adj[u]}\n            placed = False\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                colors[u - 1] = kmax + 1\n                kmax += 1\n\n    colors = normalize_colors(colors)\n    return to_csv(colors)\n","Resultados":["1,1,2,3,2,3,4,2,4",4.0,[1,1,1,2,3,2,3,4,4],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00317028}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> k (max color); infeasible -> scaled penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 100000.0\n    if len(colors) != n:\n        return 90000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 80000.0\n        if x < 1:\n            return 70000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n    if violations > 0:\n        return 10000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def normalize_colors(cols):\n        # Compact to 1..k preserving relative order of first appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # On parse error, return input as CSV unchanged with tag\n        if isinstance(solution, str):\n            return (solution, 'parse_error')\n        if isinstance(solution, list):\n            return (to_csv(solution), 'parse_error')\n        return (\"1,1,1,2,3,2,3,4,4\", 'parse_error')\n\n    colors = normalize_colors(colors)\n\n    # Determine feasibility and current k\n    conf_edges = conflicts(colors)\n    kmax = max(colors)\n\n    move_type = 'unknown'\n    new_cols = colors[:]\n\n    if conf_edges:\n        # Conflict repair priority\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        # Pick vertex with highest conflict degree, tie-break by random\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, colors, kmax)\n        if feas is not None:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            # Try Kempe swaps over all neighbor colors, pick best (min conflicts)\n            ca = colors[u - 1]\n            neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(colors, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: introduce a new color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible: attempt color elimination from max color class\n        max_class = [i for i, c in enumerate(colors, start=1) if c == kmax]\n        random.shuffle(max_class)\n        eliminated = False\n        for u in max_class:\n            feas = smallest_feasible_color(u, colors, kmax - 1)\n            if feas is not None:\n                new_cols[u - 1] = feas\n                eliminated = True\n                move_type = 'k_reduce_recolor'\n                break\n        if not eliminated:\n            # Try Kempe-based attempt to free a color for a max-class vertex\n            if max_class:\n                u = random.choice(max_class)\n                ca = colors[u - 1]\n                neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                applied = False\n                for cb in neigh_colors:\n                    trial = kempe_interchange(colors, u, ca, cb)\n                    # After swap, try greedy recolor within 1..kmax-1\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        applied = True\n                        move_type = 'k_reduce_kempe'\n                        break\n                if not applied:\n                    # Compact: swap labels of two colors to diversify\n                    if kmax >= 2:\n                        a, b = random.sample(range(1, kmax + 1), 2)\n                        for i in range(n):\n                            if new_cols[i] == a:\n                                new_cols[i] = b\n                            elif new_cols[i] == b:\n                                new_cols[i] = a\n                        move_type = 'color_class_swap'\n\n    # Optional normalization to keep labels compact; preserve k\n    new_cols = normalize_colors(new_cols)\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n    else:\n        colors = normalize_colors(colors)\n\n    # 1-2 Kempe swaps\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n + 1)\n        ca = colors[u - 1]\n        neigh = [colors[v - 1] for v in adj[u] if colors[v - 1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Greedy repair of up to two most conflicted vertices\n    conf_edges = conflicts(colors)\n    if conf_edges:\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def v_score(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        conf_vertices.sort(key=lambda x: (v_score(x), len(adj[x])), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v - 1] for v in adj[u]}\n            placed = False\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                colors[u - 1] = kmax + 1\n                kmax += 1\n\n    colors = normalize_colors(colors)\n    return to_csv(colors)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001844822}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: primary objective = minimize violations, secondary = minimize k\n    # Scalarization: score = violations*1_000_000 + k; malformed => >= 1e9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 1_000_000_000.0\n    if len(colors) != n:\n        return 1_000_000_000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 1_000_000_000.0\n        if x < 1:\n            return 1_000_000_000.0\n\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n\n    if violations > 0:\n        return float(violations * 1_000_000)\n\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def conflicts(cols: List[int]):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def saturation_degree(u: int, cols: List[int]) -> int:\n        return len({cols[v - 1] for v in adj[u]})\n\n    def smallest_feasible_color(u: int, cols: List[int], kmax: int):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # Safe fallback to a valid 4-coloring\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Neighbor generation strategy:\n    # - If infeasible: pick most critical vertex by (conflict-degree, saturation, degree) and repair\n    # - If feasible: attempt k reduction by recoloring max color class or Kempe swap\n    conf_edges = conflicts(cols)\n    kmax = max(cols)\n\n    move_type = 'unknown'\n    new_cols = cols[:]\n\n    if conf_edges:\n        # Conflict repair\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), saturation_degree(x, cols), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, cols, kmax)\n        if feas is not None and feas != cols[u - 1]:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            ca = cols[u - 1]\n            neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(cols, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: cautiously expand color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible phase: try to reduce k\n        max_class_vertices = [i for i, c in enumerate(cols, start=1) if c == kmax]\n        random.shuffle(max_class_vertices)\n        reduced = False\n        for u in max_class_vertices:\n            feas = smallest_feasible_color(u, cols, kmax - 1)\n            if feas is not None and feas != cols[u - 1]:\n                new_cols[u - 1] = feas\n                move_type = 'k_reduce_recolor'\n                reduced = True\n                break\n        if not reduced:\n            if max_class_vertices:\n                u = max(max_class_vertices, key=lambda x: (saturation_degree(x, cols), len(adj[x]), random.random()))\n                ca = cols[u - 1]\n                neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                for cb in neigh_colors:\n                    trial = kempe_interchange(cols, u, ca, cb)\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        move_type = 'k_reduce_kempe'\n                        reduced = True\n                        break\n        if not reduced:\n            # Targeted color-class swap between two colors most conflicting on boundary\n            if kmax >= 2:\n                # Score boundary conflicts for each color\n                boundary = [0]*(kmax+1)\n                for (u,v) in edges:\n                    cu, cv = cols[u-1], cols[v-1]\n                    if cu != cv:\n                        boundary[cu] += 1\n                        boundary[cv] += 1\n                a = max(range(1,kmax+1), key=lambda c: (boundary[c], random.random()))\n                b = max([c for c in range(1,kmax+1) if c!=a], key=lambda c: (boundary[c], random.random()))\n                for i in range(n):\n                    if new_cols[i] == a:\n                        new_cols[i] = b\n                    elif new_cols[i] == b:\n                        new_cols[i] = a\n                move_type = 'color_class_swap'\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed:\n    # - 2 Kempe interchanges driven by local RNG(seed=hash(colors))\n    # - Greedy recolor of up to 2 vertices from largest color class\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    def greedy_recolor(u: int, cols: List[int], max_color_cap: int) -> bool:\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, max_color_cap + 1):\n            if c not in used:\n                cols[u - 1] = c\n                return True\n        return False\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Seeded RNG from solution to keep determinism per input\n    seed = 1469598103934665603\n    for x in cols:\n        seed = (seed ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Perform up to 2 Kempe swaps\n    for _ in range(2):\n        u = rng.randrange(1, n + 1)\n        cu = cols[u - 1]\n        neigh_colors = [cols[v - 1] for v in adj[u] if cols[v - 1] != cu]\n        if not neigh_colors:\n            continue\n        cb = rng.choice(neigh_colors)\n        cols = kempe_interchange(cols, u, cu, cb)\n\n    # Recolor a small subset from the largest color class into existing colors only\n    kmax = max(cols)\n    sizes = {c: 0 for c in range(1, kmax + 1)}\n    for c in cols:\n        sizes[c] += 1\n    largest_color = max(range(1, kmax + 1), key=lambda c: (sizes.get(c,0), rng.random()))\n    candidates = [i for i, c in enumerate(cols, start=1) if c == largest_color]\n    rng.shuffle(candidates)\n    moved = 0\n    for u in candidates:\n        if greedy_recolor(u, cols, kmax):\n            moved += 1\n        if moved >= 2:\n            break\n\n    return to_csv(cols)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002326758}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: primary objective = minimize violations, secondary = minimize k\n    # Scalarization: score = violations*1_000_000 + k; malformed => >= 1e9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 1_000_000_000.0\n    if len(colors) != n:\n        return 1_000_000_000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 1_000_000_000.0\n        if x < 1:\n            return 1_000_000_000.0\n\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n\n    if violations > 0:\n        return float(violations * 1_000_000)\n\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def conflicts(cols: List[int]):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def saturation_degree(u: int, cols: List[int]) -> int:\n        return len({cols[v - 1] for v in adj[u]})\n\n    def smallest_feasible_color(u: int, cols: List[int], kmax: int):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # Safe fallback to a valid 4-coloring\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Neighbor generation strategy:\n    # - If infeasible: pick most critical vertex by (conflict-degree, saturation, degree) and repair\n    # - If feasible: attempt k reduction by recoloring max color class or Kempe swap\n    conf_edges = conflicts(cols)\n    kmax = max(cols)\n\n    move_type = 'unknown'\n    new_cols = cols[:]\n\n    if conf_edges:\n        # Conflict repair\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), saturation_degree(x, cols), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, cols, kmax)\n        if feas is not None and feas != cols[u - 1]:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            ca = cols[u - 1]\n            neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(cols, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: cautiously expand color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible phase: try to reduce k\n        max_class_vertices = [i for i, c in enumerate(cols, start=1) if c == kmax]\n        random.shuffle(max_class_vertices)\n        reduced = False\n        for u in max_class_vertices:\n            feas = smallest_feasible_color(u, cols, kmax - 1)\n            if feas is not None and feas != cols[u - 1]:\n                new_cols[u - 1] = feas\n                move_type = 'k_reduce_recolor'\n                reduced = True\n                break\n        if not reduced:\n            if max_class_vertices:\n                u = max(max_class_vertices, key=lambda x: (saturation_degree(x, cols), len(adj[x]), random.random()))\n                ca = cols[u - 1]\n                neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                for cb in neigh_colors:\n                    trial = kempe_interchange(cols, u, ca, cb)\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        move_type = 'k_reduce_kempe'\n                        reduced = True\n                        break\n        if not reduced:\n            # Targeted color-class swap between two colors most conflicting on boundary\n            if kmax >= 2:\n                # Score boundary conflicts for each color\n                boundary = [0]*(kmax+1)\n                for (u,v) in edges:\n                    cu, cv = cols[u-1], cols[v-1]\n                    if cu != cv:\n                        boundary[cu] += 1\n                        boundary[cv] += 1\n                a = max(range(1,kmax+1), key=lambda c: (boundary[c], random.random()))\n                b = max([c for c in range(1,kmax+1) if c!=a], key=lambda c: (boundary[c], random.random()))\n                for i in range(n):\n                    if new_cols[i] == a:\n                        new_cols[i] = b\n                    elif new_cols[i] == b:\n                        new_cols[i] = a\n                move_type = 'color_class_swap'\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed:\n    # - 2 Kempe interchanges driven by local RNG(seed=hash(colors))\n    # - Greedy recolor of up to 2 vertices from largest color class\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    def greedy_recolor(u: int, cols: List[int], max_color_cap: int) -> bool:\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, max_color_cap + 1):\n            if c not in used:\n                cols[u - 1] = c\n                return True\n        return False\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Seeded RNG from solution to keep determinism per input\n    seed = 1469598103934665603\n    for x in cols:\n        seed = (seed ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Perform up to 2 Kempe swaps\n    for _ in range(2):\n        u = rng.randrange(1, n + 1)\n        cu = cols[u - 1]\n        neigh_colors = [cols[v - 1] for v in adj[u] if cols[v - 1] != cu]\n        if not neigh_colors:\n            continue\n        cb = rng.choice(neigh_colors)\n        cols = kempe_interchange(cols, u, cu, cb)\n\n    # Recolor a small subset from the largest color class into existing colors only\n    kmax = max(cols)\n    sizes = {c: 0 for c in range(1, kmax + 1)}\n    for c in cols:\n        sizes[c] += 1\n    largest_color = max(range(1, kmax + 1), key=lambda c: (sizes.get(c,0), rng.random()))\n    candidates = [i for i, c in enumerate(cols, start=1) if c == largest_color]\n    rng.shuffle(candidates)\n    moved = 0\n    for u in candidates:\n        if greedy_recolor(u, cols, kmax):\n            moved += 1\n        if moved >= 2:\n            break\n\n    return to_csv(cols)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001979174}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: primary objective = minimize violations, secondary = minimize k\n    # Scalarization: score = violations*1_000_000 + k; malformed => >= 1e9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 1_000_000_000.0\n    if len(colors) != n:\n        return 1_000_000_000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 1_000_000_000.0\n        if x < 1:\n            return 1_000_000_000.0\n\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n\n    if violations > 0:\n        return float(violations * 1_000_000)\n\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def conflicts(cols: List[int]):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def saturation_degree(u: int, cols: List[int]) -> int:\n        return len({cols[v - 1] for v in adj[u]})\n\n    def smallest_feasible_color(u: int, cols: List[int], kmax: int):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # Safe fallback to a valid 4-coloring\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Neighbor generation strategy:\n    # - If infeasible: pick most critical vertex by (conflict-degree, saturation, degree) and repair\n    # - If feasible: attempt k reduction by recoloring max color class or Kempe swap\n    conf_edges = conflicts(cols)\n    kmax = max(cols)\n\n    move_type = 'unknown'\n    new_cols = cols[:]\n\n    if conf_edges:\n        # Conflict repair\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), saturation_degree(x, cols), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, cols, kmax)\n        if feas is not None and feas != cols[u - 1]:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            ca = cols[u - 1]\n            neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(cols, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: cautiously expand color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible phase: try to reduce k\n        max_class_vertices = [i for i, c in enumerate(cols, start=1) if c == kmax]\n        random.shuffle(max_class_vertices)\n        reduced = False\n        for u in max_class_vertices:\n            feas = smallest_feasible_color(u, cols, kmax - 1)\n            if feas is not None and feas != cols[u - 1]:\n                new_cols[u - 1] = feas\n                move_type = 'k_reduce_recolor'\n                reduced = True\n                break\n        if not reduced:\n            if max_class_vertices:\n                u = max(max_class_vertices, key=lambda x: (saturation_degree(x, cols), len(adj[x]), random.random()))\n                ca = cols[u - 1]\n                neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                for cb in neigh_colors:\n                    trial = kempe_interchange(cols, u, ca, cb)\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        move_type = 'k_reduce_kempe'\n                        reduced = True\n                        break\n        if not reduced:\n            # Targeted color-class swap between two colors most conflicting on boundary\n            if kmax >= 2:\n                # Score boundary conflicts for each color\n                boundary = [0]*(kmax+1)\n                for (u,v) in edges:\n                    cu, cv = cols[u-1], cols[v-1]\n                    if cu != cv:\n                        boundary[cu] += 1\n                        boundary[cv] += 1\n                a = max(range(1,kmax+1), key=lambda c: (boundary[c], random.random()))\n                b = max([c for c in range(1,kmax+1) if c!=a], key=lambda c: (boundary[c], random.random()))\n                for i in range(n):\n                    if new_cols[i] == a:\n                        new_cols[i] = b\n                    elif new_cols[i] == b:\n                        new_cols[i] = a\n                move_type = 'color_class_swap'\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed:\n    # - 2 Kempe interchanges driven by local RNG(seed=hash(colors))\n    # - Greedy recolor of up to 2 vertices from largest color class\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    def greedy_recolor(u: int, cols: List[int], max_color_cap: int) -> bool:\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, max_color_cap + 1):\n            if c not in used:\n                cols[u - 1] = c\n                return True\n        return False\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Seeded RNG from solution to keep determinism per input\n    seed = 1469598103934665603\n    for x in cols:\n        seed = (seed ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Perform up to 2 Kempe swaps\n    for _ in range(2):\n        u = rng.randrange(1, n + 1)\n        cu = cols[u - 1]\n        neigh_colors = [cols[v - 1] for v in adj[u] if cols[v - 1] != cu]\n        if not neigh_colors:\n            continue\n        cb = rng.choice(neigh_colors)\n        cols = kempe_interchange(cols, u, cu, cb)\n\n    # Recolor a small subset from the largest color class into existing colors only\n    kmax = max(cols)\n    sizes = {c: 0 for c in range(1, kmax + 1)}\n    for c in cols:\n        sizes[c] += 1\n    largest_color = max(range(1, kmax + 1), key=lambda c: (sizes.get(c,0), rng.random()))\n    candidates = [i for i, c in enumerate(cols, start=1) if c == largest_color]\n    rng.shuffle(candidates)\n    moved = 0\n    for u in candidates:\n        if greedy_recolor(u, cols, kmax):\n            moved += 1\n        if moved >= 2:\n            break\n\n    return to_csv(cols)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001906443}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV; solution is 9 comma-separated positive integers representing colors for vertices 1..9 (e.g., '1,1,1,2,3,2,3,4,4')","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Neighbor: recolor a single vertex to a random color within [1, max_color] or maybe introduce max_color+1 with low probability\n    max_c = max(cur) if cur else 1\n    idx = random.randrange(n)\n    new = cur[:]\n    # 10% chance introduce a new color to escape plateaus\n    if random.random() < 0.10:\n        new_color = max_c + 1\n    else:\n        # ensure different color if possible\n        choices = list(range(1, max_c + 1))\n        if len(choices) > 1:\n            choices.remove(cur[idx])\n        new_color = random.choice(choices)\n    new[idx] = new_color\n    return (new, \"ColorChange\", \"ReassignOne\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: apply multiple random recolors\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return cur\n    max_c = max(cur)\n    steps = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k=min(steps, n))\n    for idx in idxs:\n        # 25% chance to introduce new color in perturbation\n        if random.random() < 0.25:\n            new_color = max_c + 1\n            max_c = max(max_c, new_color)\n        else:\n            choices = list(range(1, max_c + 1))\n            if len(choices) > 1 and cur[idx] in choices:\n                choices.remove(cur[idx])\n            new_color = random.choice(choices)\n        cur[idx] = new_color\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001009232}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV; solution is 9 comma-separated positive integers representing colors for vertices 1..9 (e.g., '1,1,1,2,3,2,3,4,4')","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Neighbor: recolor a single vertex to a random color within [1, max_color] or maybe introduce max_color+1 with low probability\n    max_c = max(cur) if cur else 1\n    idx = random.randrange(n)\n    new = cur[:]\n    # 10% chance introduce a new color to escape plateaus\n    if random.random() < 0.10:\n        new_color = max_c + 1\n    else:\n        # ensure different color if possible\n        choices = list(range(1, max_c + 1))\n        if len(choices) > 1:\n            choices.remove(cur[idx])\n        new_color = random.choice(choices)\n    new[idx] = new_color\n    return (new, \"ColorChange\", \"ReassignOne\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: apply multiple random recolors\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return cur\n    max_c = max(cur)\n    steps = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k=min(steps, n))\n    for idx in idxs:\n        # 25% chance to introduce new color in perturbation\n        if random.random() < 0.25:\n            new_color = max_c + 1\n            max_c = max(max_c, new_color)\n        else:\n            choices = list(range(1, max_c + 1))\n            if len(choices) > 1 and cur[idx] in choices:\n                choices.remove(cur[idx])\n            new_color = random.choice(choices)\n        cur[idx] = new_color\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00082274}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV; solution is 9 comma-separated positive integers representing colors for vertices 1..9 (e.g., '1,1,1,2,3,2,3,4,4')","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Neighbor: recolor a single vertex to a random color within [1, max_color] or maybe introduce max_color+1 with low probability\n    max_c = max(cur) if cur else 1\n    idx = random.randrange(n)\n    new = cur[:]\n    # 10% chance introduce a new color to escape plateaus\n    if random.random() < 0.10:\n        new_color = max_c + 1\n    else:\n        # ensure different color if possible\n        choices = list(range(1, max_c + 1))\n        if len(choices) > 1:\n            choices.remove(cur[idx])\n        new_color = random.choice(choices)\n    new[idx] = new_color\n    return (new, \"ColorChange\", \"ReassignOne\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: apply multiple random recolors\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return cur\n    max_c = max(cur)\n    steps = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k=min(steps, n))\n    for idx in idxs:\n        # 25% chance to introduce new color in perturbation\n        if random.random() < 0.25:\n            new_color = max_c + 1\n            max_c = max(max_c, new_color)\n        else:\n            choices = list(range(1, max_c + 1))\n            if len(choices) > 1 and cur[idx] in choices:\n                choices.remove(cur[idx])\n            new_color = random.choice(choices)\n        cur[idx] = new_color\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00081848}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list[int] of length 9\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Compute conflicting vertices\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.append(u - 1)\n            conflicts.append(v - 1)\n    conflicts = list(set(conflicts))\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        if limit is None:\n            up = max_c\n        else:\n            up = limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    # Randomly choose move type: 70% recolor, 30% Kempe swap\n    if random.random() < 0.70:\n        # Conflict-driven recolor: prefer conflicting vertices\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n            nb_type = \"ConflictDriven\"\n        else:\n            i = random.randrange(n)\n            nb_type = \"RandomVertex\"\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            # choose smallest feasible to bias toward lower K\n            new[i] = min(feas)\n        else:\n            # introduce new color with small probability, else random old color different from current\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return (new, nb_type, \"ReassignOne\")\n    else:\n        # Kempe chain swap between two colors to escape local minima\n        if max_c < 2:\n            # fallback to recolor if only one color present\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else max(1, ((new[i]) % max_c) + 1)\n            return (new, \"Fallback\", \"ReassignOne\")\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return (cur[:], \"NoOp\", \"KempeNone\")\n        seed = random.choice(candidates)\n        # BFS over subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        # swap colors in this component\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return (new, \"Kempe\", f\"Swap_{c1}_{c2}\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: pick a smallest color class and greedily recolor its vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    # choose smallest non-empty class\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # number of moves: 2 to 5 depending on size\n    steps = max(2, min(5, len(vertices)))\n    random.shuffle(vertices)\n    vertices = vertices[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in vertices:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            new[v] = random.choice(feas)\n        else:\n            # with small probability introduce a new color to escape infeasibility\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # fallback: assign a random different existing color\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001809131}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list[int] of length 9\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Compute conflicting vertices\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.append(u - 1)\n            conflicts.append(v - 1)\n    conflicts = list(set(conflicts))\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        if limit is None:\n            up = max_c\n        else:\n            up = limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    # Randomly choose move type: 70% recolor, 30% Kempe swap\n    if random.random() < 0.70:\n        # Conflict-driven recolor: prefer conflicting vertices\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n            nb_type = \"ConflictDriven\"\n        else:\n            i = random.randrange(n)\n            nb_type = \"RandomVertex\"\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            # choose smallest feasible to bias toward lower K\n            new[i] = min(feas)\n        else:\n            # introduce new color with small probability, else random old color different from current\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return (new, nb_type, \"ReassignOne\")\n    else:\n        # Kempe chain swap between two colors to escape local minima\n        if max_c < 2:\n            # fallback to recolor if only one color present\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else max(1, ((new[i]) % max_c) + 1)\n            return (new, \"Fallback\", \"ReassignOne\")\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return (cur[:], \"NoOp\", \"KempeNone\")\n        seed = random.choice(candidates)\n        # BFS over subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        # swap colors in this component\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return (new, \"Kempe\", f\"Swap_{c1}_{c2}\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: pick a smallest color class and greedily recolor its vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    # choose smallest non-empty class\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # number of moves: 2 to 5 depending on size\n    steps = max(2, min(5, len(vertices)))\n    random.shuffle(vertices)\n    vertices = vertices[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in vertices:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            new[v] = random.choice(feas)\n        else:\n            # with small probability introduce a new color to escape infeasibility\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # fallback: assign a random different existing color\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001544068}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list[int] of length 9\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Compute conflicting vertices\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.append(u - 1)\n            conflicts.append(v - 1)\n    conflicts = list(set(conflicts))\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        if limit is None:\n            up = max_c\n        else:\n            up = limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    # Randomly choose move type: 70% recolor, 30% Kempe swap\n    if random.random() < 0.70:\n        # Conflict-driven recolor: prefer conflicting vertices\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n            nb_type = \"ConflictDriven\"\n        else:\n            i = random.randrange(n)\n            nb_type = \"RandomVertex\"\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            # choose smallest feasible to bias toward lower K\n            new[i] = min(feas)\n        else:\n            # introduce new color with small probability, else random old color different from current\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return (new, nb_type, \"ReassignOne\")\n    else:\n        # Kempe chain swap between two colors to escape local minima\n        if max_c < 2:\n            # fallback to recolor if only one color present\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else max(1, ((new[i]) % max_c) + 1)\n            return (new, \"Fallback\", \"ReassignOne\")\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return (cur[:], \"NoOp\", \"KempeNone\")\n        seed = random.choice(candidates)\n        # BFS over subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        # swap colors in this component\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return (new, \"Kempe\", f\"Swap_{c1}_{c2}\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: pick a smallest color class and greedily recolor its vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    # choose smallest non-empty class\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # number of moves: 2 to 5 depending on size\n    steps = max(2, min(5, len(vertices)))\n    random.shuffle(vertices)\n    vertices = vertices[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in vertices:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            new[v] = random.choice(feas)\n        else:\n            # with small probability introduce a new color to escape infeasibility\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # fallback: assign a random different existing color\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001542848}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        else:\n            try:\n                lst = [int(float(x)) for x in list(sol)]\n            except Exception:\n                return None\n        n = 9\n        if len(lst) != n:\n            return lst  # caller will handle size penalty below\n        return lst\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns neighbor solution only (list[int] of length 9)\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n    conflicts = list(conflicts)\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        up = max_c if limit is None else limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if random.random() < 0.70:\n        # Conflict-driven recolor (prefer conflicting vertices)\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(n)\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            new[i] = min(feas)  # bias to lower K\n        else:\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return new\n    else:\n        # Kempe chain swap between two colors\n        if max_c < 2:\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else 1\n            return new\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return cur[:]\n        seed = random.choice(candidates)\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return new\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: operate on small color classes and high-conflict vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n\n    # choose smallest non-empty class (deterministic tie by color id)\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # also collect high-conflict vertices\n    conflict_count = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    # number of moves: 2 to 5 depending on availability\n    base = vertices[:]\n    rand_extra = sorted(range(n), key=lambda i: -conflict_count[i])[:3]\n    pool = list(set(base + rand_extra))\n    random.shuffle(pool)\n    steps = max(2, min(5, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible to diversify\n            new[v] = random.choice(feas)\n        else:\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001771351}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        else:\n            try:\n                lst = [int(float(x)) for x in list(sol)]\n            except Exception:\n                return None\n        n = 9\n        if len(lst) != n:\n            return lst  # caller will handle size penalty below\n        return lst\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns neighbor solution only (list[int] of length 9)\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n    conflicts = list(conflicts)\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        up = max_c if limit is None else limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if random.random() < 0.70:\n        # Conflict-driven recolor (prefer conflicting vertices)\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(n)\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            new[i] = min(feas)  # bias to lower K\n        else:\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return new\n    else:\n        # Kempe chain swap between two colors\n        if max_c < 2:\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else 1\n            return new\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return cur[:]\n        seed = random.choice(candidates)\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return new\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: operate on small color classes and high-conflict vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n\n    # choose smallest non-empty class (deterministic tie by color id)\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # also collect high-conflict vertices\n    conflict_count = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    # number of moves: 2 to 5 depending on availability\n    base = vertices[:]\n    rand_extra = sorted(range(n), key=lambda i: -conflict_count[i])[:3]\n    pool = list(set(base + rand_extra))\n    random.shuffle(pool)\n    steps = max(2, min(5, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible to diversify\n            new[v] = random.choice(feas)\n        else:\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001547978}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        else:\n            try:\n                lst = [int(float(x)) for x in list(sol)]\n            except Exception:\n                return None\n        n = 9\n        if len(lst) != n:\n            return lst  # caller will handle size penalty below\n        return lst\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns neighbor solution only (list[int] of length 9)\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n    conflicts = list(conflicts)\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        up = max_c if limit is None else limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if random.random() < 0.70:\n        # Conflict-driven recolor (prefer conflicting vertices)\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(n)\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            new[i] = min(feas)  # bias to lower K\n        else:\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return new\n    else:\n        # Kempe chain swap between two colors\n        if max_c < 2:\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else 1\n            return new\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return cur[:]\n        seed = random.choice(candidates)\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return new\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: operate on small color classes and high-conflict vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n\n    # choose smallest non-empty class (deterministic tie by color id)\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # also collect high-conflict vertices\n    conflict_count = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    # number of moves: 2 to 5 depending on availability\n    base = vertices[:]\n    rand_extra = sorted(range(n), key=lambda i: -conflict_count[i])[:3]\n    pool = list(set(base + rand_extra))\n    random.shuffle(pool)\n    steps = max(2, min(5, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible to diversify\n            new[v] = random.choice(feas)\n        else:\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001446947}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9_POSITIVE (example: 1,2,3,1,2,3,1,2,3)","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Graph Coloring objective: minimize K=max(color) subject to edge constraints\n    # Lower is better. Uses soft penalties: f = K + lambda * violations + invalid_penalty\n    # No globals; all data embedded\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    LAMBDA = 10.0\n    BIG = 1_000_000.0\n\n    def _coerce_list(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple)):\n            try:\n                lst = [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n        # length normalization only for evaluation; invalid length penalized\n        return lst\n\n    lst = _coerce_list(solution)\n    if lst is None:\n        return BIG\n\n    invalid = 0\n    if len(lst) != n:\n        return BIG + 1000.0 * abs(len(lst) - n)\n\n    # sanitize values; count invalids\n    colors = []\n    max_c = 0\n    for v in lst:\n        if isinstance(v, bool):\n            invalid += 1\n            v = 1\n        try:\n            c = int(v)\n        except Exception:\n            c = 1\n            invalid += 1\n        if c < 1:\n            invalid += 1\n            c = 1\n        colors.append(c)\n        if c > max_c:\n            max_c = c\n\n    # violations\n    viol = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            viol += 1\n\n    if invalid > 0:\n        return BIG\/10.0 + invalid * 100.0 + viol * 1000.0 + float(max_c)\n\n    # soft objective while infeasible, exact K when feasible\n    if viol == 0:\n        return float(max_c)\n    else:\n        return float(max_c) + LAMBDA * float(viol)\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"Local\"}; Movement_Type in {\"Decrement\",\"Recolor\",\"Kempe\"}\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1]*n\n        # pad\/trim to n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def conflicts_of(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u - 1)\n                conf.add(v - 1)\n        return list(conf)\n\n    max_c = max(cur) if cur else 1\n\n    # Move 1: Global decrement attempt on highest color class\n    high = max_c\n    high_vertices = [i for i, c in enumerate(cur) if c == high]\n\n    def feasible_colors(sol, idx, up):\n        used = set(sol[j] for j in adj[idx])\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if high > 1 and high_vertices and random.random() < 0.5:\n        new = cur[:]\n        success_any = False\n        for v in high_vertices:\n            feas = [c for c in feasible_colors(new, v, high - 1)]\n            if feas:\n                new[v] = random.choice(feas)\n                success_any = True\n        if success_any and max(new) <= max_c - 1:\n            return new, \"Local\", \"Decrement\"\n        # fallthrough if unsuccessful\n\n    # Move 2: Conflict-driven recolor\n    conf = conflicts_of(cur)\n    new = cur[:]\n    if conf and random.random() < 0.6:\n        i = random.choice(conf)\n    else:\n        i = random.randrange(n)\n    feas = feasible_colors(new, i, max_c)\n    if feas:\n        new[i] = min(feas) if random.random() < 0.7 else random.choice(feas)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # If no feasible color within 1..max_c, allow temporary new color to force change\n    choices = list(range(1, max_c + 1))\n    if new[i] in choices and len(choices) > 1:\n        choices.remove(new[i])\n    if choices:\n        new[i] = random.choice(choices)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # last resort: introduce new color to guarantee change\n    new[i] = max_c + 1\n    if new != cur:\n        return new, \"Local\", \"Recolor\"\n\n    # Move 3: Kempe chain swap for diversification\n    if max_c >= 2:\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if candidates:\n            seed = random.choice(candidates)\n            q = deque([seed])\n            visited = [False] * n\n            visited[seed] = True\n            comp = [seed]\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        visited[v] = True\n                        q.append(v)\n                        comp.append(v)\n            new = cur[:]\n            for v in comp:\n                new[v] = c2 if new[v] == c1 else (c1 if new[v] == c2 else new[v])\n            if new != cur:\n                return new, \"Local\", \"Kempe\"\n\n    # Safety: always return a different solution\n    j = (i + 1) % n\n    new = cur[:]\n    new[j] = (cur[j] % (max_c + 1)) + 1\n    if new[j] == cur[j]:\n        new[j] = cur[j] + 1\n    return new, \"Local\", \"Recolor\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger diversification: reassign a subset prioritizing smallest color class and high-conflict vertices\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1] * n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    smallest_class_color = min(classes.keys(), key=lambda k: (len(classes[k]), k))\n\n    # conflict counts\n    conflict_count = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    pool = list(set(classes[smallest_class_color] + sorted(range(n), key=lambda i: -conflict_count[i])[:3]))\n    random.shuffle(pool)\n    steps = max(3, min(6, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]  # work copy\n\n    def feasible_colors(idx, up):\n        used = set(new[j] for j in adj[idx])\n        # allow up to current max color; occasionally allow new color to diversify\n        colors = [c for c in range(1, up + 1) if c not in used]\n        return colors\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible for diversification\n            nc = random.choice(feas)\n            new[v] = nc\n        else:\n            # introduce at most one extra color with small probability\n            if random.random() < 0.3:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # forced change within 1..max_c\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices) if choices else max_c\n\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001906022}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9_POSITIVE (example: 1,2,3,1,2,3,1,2,3)","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Graph Coloring objective: minimize K=max(color) subject to edge constraints\n    # Lower is better. Uses soft penalties: f = K + lambda * violations + invalid_penalty\n    # No globals; all data embedded\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    LAMBDA = 10.0\n    BIG = 1_000_000.0\n\n    def _coerce_list(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple)):\n            try:\n                lst = [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n        # length normalization only for evaluation; invalid length penalized\n        return lst\n\n    lst = _coerce_list(solution)\n    if lst is None:\n        return BIG\n\n    invalid = 0\n    if len(lst) != n:\n        return BIG + 1000.0 * abs(len(lst) - n)\n\n    # sanitize values; count invalids\n    colors = []\n    max_c = 0\n    for v in lst:\n        if isinstance(v, bool):\n            invalid += 1\n            v = 1\n        try:\n            c = int(v)\n        except Exception:\n            c = 1\n            invalid += 1\n        if c < 1:\n            invalid += 1\n            c = 1\n        colors.append(c)\n        if c > max_c:\n            max_c = c\n\n    # violations\n    viol = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            viol += 1\n\n    if invalid > 0:\n        return BIG\/10.0 + invalid * 100.0 + viol * 1000.0 + float(max_c)\n\n    # soft objective while infeasible, exact K when feasible\n    if viol == 0:\n        return float(max_c)\n    else:\n        return float(max_c) + LAMBDA * float(viol)\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"Local\"}; Movement_Type in {\"Decrement\",\"Recolor\",\"Kempe\"}\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1]*n\n        # pad\/trim to n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def conflicts_of(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u - 1)\n                conf.add(v - 1)\n        return list(conf)\n\n    max_c = max(cur) if cur else 1\n\n    # Move 1: Global decrement attempt on highest color class\n    high = max_c\n    high_vertices = [i for i, c in enumerate(cur) if c == high]\n\n    def feasible_colors(sol, idx, up):\n        used = set(sol[j] for j in adj[idx])\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if high > 1 and high_vertices and random.random() < 0.5:\n        new = cur[:]\n        success_any = False\n        for v in high_vertices:\n            feas = [c for c in feasible_colors(new, v, high - 1)]\n            if feas:\n                new[v] = random.choice(feas)\n                success_any = True\n        if success_any and max(new) <= max_c - 1:\n            return new, \"Local\", \"Decrement\"\n        # fallthrough if unsuccessful\n\n    # Move 2: Conflict-driven recolor\n    conf = conflicts_of(cur)\n    new = cur[:]\n    if conf and random.random() < 0.6:\n        i = random.choice(conf)\n    else:\n        i = random.randrange(n)\n    feas = feasible_colors(new, i, max_c)\n    if feas:\n        new[i] = min(feas) if random.random() < 0.7 else random.choice(feas)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # If no feasible color within 1..max_c, allow temporary new color to force change\n    choices = list(range(1, max_c + 1))\n    if new[i] in choices and len(choices) > 1:\n        choices.remove(new[i])\n    if choices:\n        new[i] = random.choice(choices)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # last resort: introduce new color to guarantee change\n    new[i] = max_c + 1\n    if new != cur:\n        return new, \"Local\", \"Recolor\"\n\n    # Move 3: Kempe chain swap for diversification\n    if max_c >= 2:\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if candidates:\n            seed = random.choice(candidates)\n            q = deque([seed])\n            visited = [False] * n\n            visited[seed] = True\n            comp = [seed]\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        visited[v] = True\n                        q.append(v)\n                        comp.append(v)\n            new = cur[:]\n            for v in comp:\n                new[v] = c2 if new[v] == c1 else (c1 if new[v] == c2 else new[v])\n            if new != cur:\n                return new, \"Local\", \"Kempe\"\n\n    # Safety: always return a different solution\n    j = (i + 1) % n\n    new = cur[:]\n    new[j] = (cur[j] % (max_c + 1)) + 1\n    if new[j] == cur[j]:\n        new[j] = cur[j] + 1\n    return new, \"Local\", \"Recolor\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger diversification: reassign a subset prioritizing smallest color class and high-conflict vertices\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1] * n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    smallest_class_color = min(classes.keys(), key=lambda k: (len(classes[k]), k))\n\n    # conflict counts\n    conflict_count = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    pool = list(set(classes[smallest_class_color] + sorted(range(n), key=lambda i: -conflict_count[i])[:3]))\n    random.shuffle(pool)\n    steps = max(3, min(6, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]  # work copy\n\n    def feasible_colors(idx, up):\n        used = set(new[j] for j in adj[idx])\n        # allow up to current max color; occasionally allow new color to diversify\n        colors = [c for c in range(1, up + 1) if c not in used]\n        return colors\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible for diversification\n            nc = random.choice(feas)\n            new[v] = nc\n        else:\n            # introduce at most one extra color with small probability\n            if random.random() < 0.3:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # forced change within 1..max_c\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices) if choices else max_c\n\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001565868}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9_POSITIVE (example: 1,2,3,1,2,3,1,2,3)","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Graph Coloring objective: minimize K=max(color) subject to edge constraints\n    # Lower is better. Uses soft penalties: f = K + lambda * violations + invalid_penalty\n    # No globals; all data embedded\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    LAMBDA = 10.0\n    BIG = 1_000_000.0\n\n    def _coerce_list(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple)):\n            try:\n                lst = [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n        # length normalization only for evaluation; invalid length penalized\n        return lst\n\n    lst = _coerce_list(solution)\n    if lst is None:\n        return BIG\n\n    invalid = 0\n    if len(lst) != n:\n        return BIG + 1000.0 * abs(len(lst) - n)\n\n    # sanitize values; count invalids\n    colors = []\n    max_c = 0\n    for v in lst:\n        if isinstance(v, bool):\n            invalid += 1\n            v = 1\n        try:\n            c = int(v)\n        except Exception:\n            c = 1\n            invalid += 1\n        if c < 1:\n            invalid += 1\n            c = 1\n        colors.append(c)\n        if c > max_c:\n            max_c = c\n\n    # violations\n    viol = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            viol += 1\n\n    if invalid > 0:\n        return BIG\/10.0 + invalid * 100.0 + viol * 1000.0 + float(max_c)\n\n    # soft objective while infeasible, exact K when feasible\n    if viol == 0:\n        return float(max_c)\n    else:\n        return float(max_c) + LAMBDA * float(viol)\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"Local\"}; Movement_Type in {\"Decrement\",\"Recolor\",\"Kempe\"}\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1]*n\n        # pad\/trim to n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def conflicts_of(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u - 1)\n                conf.add(v - 1)\n        return list(conf)\n\n    max_c = max(cur) if cur else 1\n\n    # Move 1: Global decrement attempt on highest color class\n    high = max_c\n    high_vertices = [i for i, c in enumerate(cur) if c == high]\n\n    def feasible_colors(sol, idx, up):\n        used = set(sol[j] for j in adj[idx])\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if high > 1 and high_vertices and random.random() < 0.5:\n        new = cur[:]\n        success_any = False\n        for v in high_vertices:\n            feas = [c for c in feasible_colors(new, v, high - 1)]\n            if feas:\n                new[v] = random.choice(feas)\n                success_any = True\n        if success_any and max(new) <= max_c - 1:\n            return new, \"Local\", \"Decrement\"\n        # fallthrough if unsuccessful\n\n    # Move 2: Conflict-driven recolor\n    conf = conflicts_of(cur)\n    new = cur[:]\n    if conf and random.random() < 0.6:\n        i = random.choice(conf)\n    else:\n        i = random.randrange(n)\n    feas = feasible_colors(new, i, max_c)\n    if feas:\n        new[i] = min(feas) if random.random() < 0.7 else random.choice(feas)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # If no feasible color within 1..max_c, allow temporary new color to force change\n    choices = list(range(1, max_c + 1))\n    if new[i] in choices and len(choices) > 1:\n        choices.remove(new[i])\n    if choices:\n        new[i] = random.choice(choices)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # last resort: introduce new color to guarantee change\n    new[i] = max_c + 1\n    if new != cur:\n        return new, \"Local\", \"Recolor\"\n\n    # Move 3: Kempe chain swap for diversification\n    if max_c >= 2:\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if candidates:\n            seed = random.choice(candidates)\n            q = deque([seed])\n            visited = [False] * n\n            visited[seed] = True\n            comp = [seed]\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        visited[v] = True\n                        q.append(v)\n                        comp.append(v)\n            new = cur[:]\n            for v in comp:\n                new[v] = c2 if new[v] == c1 else (c1 if new[v] == c2 else new[v])\n            if new != cur:\n                return new, \"Local\", \"Kempe\"\n\n    # Safety: always return a different solution\n    j = (i + 1) % n\n    new = cur[:]\n    new[j] = (cur[j] % (max_c + 1)) + 1\n    if new[j] == cur[j]:\n        new[j] = cur[j] + 1\n    return new, \"Local\", \"Recolor\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger diversification: reassign a subset prioritizing smallest color class and high-conflict vertices\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1] * n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    smallest_class_color = min(classes.keys(), key=lambda k: (len(classes[k]), k))\n\n    # conflict counts\n    conflict_count = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    pool = list(set(classes[smallest_class_color] + sorted(range(n), key=lambda i: -conflict_count[i])[:3]))\n    random.shuffle(pool)\n    steps = max(3, min(6, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]  # work copy\n\n    def feasible_colors(idx, up):\n        used = set(new[j] for j in adj[idx])\n        # allow up to current max color; occasionally allow new color to diversify\n        colors = [c for c in range(1, up + 1) if c not in used]\n        return colors\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible for diversification\n            nc = random.choice(feas)\n            new[v] = nc\n        else:\n            # introduce at most one extra color with small probability\n            if random.random() < 0.3:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # forced change within 1..max_c\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices) if choices else max_c\n\n    return new\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001485988}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS; solution is a list of length 9 with positive integer color labels for vertices 1..9. Labels should be normalized to {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution, NB_Type, Movement_Type)\n    NB_Type: string label of neighborhood (e.g., 'RECOLOR' or 'SWAP')\n    Movement_Type: string label of move subtype (e.g., 'single-vertex', 'pair-swap')\n    \"\"\"\n    # Internal helpers and data (no globals)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicts_of(sol: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return a minimal valid construct to allow recovery\n        base = list(range(1, n+1))\n        return (base, \"RECOLOR\", \"repair-init\")\n    new_sol = solution[:]\n    # Choose neighborhood type stochastically: recolor or swap\n    if random.random() < 0.7:\n        # RECOLOR: change color of one vertex to reduce conflicts or diversify\n        v = random.randrange(n)\n        current_color = new_sol[v]\n        # Candidate colors: 1..(max_color+1) to allow new color introduction\n        max_c = max(new_sol) if new_sol else 1\n        candidates = list(range(1, max_c + 2))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and abs(c - current_color) > abs(best[v] - current_color)):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP: swap colors of two vertices to potentially resolve conflicts while preserving palette\n        i, j = 0, 0\n        tries = 0\n        while i == j and tries < 10:\n            i = random.randrange(n)\n            j = random.randrange(n)\n            tries += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple random recolors to escape deep local minima\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        # Try a random color from 1..max_c+1 (allow temporary new colors)\n        new_c = random.randrange(1, max_c + 2)\n        sol[v] = new_c\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00086908}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS; solution is a list of length 9 with positive integer color labels for vertices 1..9. Labels should be normalized to {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution, NB_Type, Movement_Type)\n    NB_Type: string label of neighborhood (e.g., 'RECOLOR' or 'SWAP')\n    Movement_Type: string label of move subtype (e.g., 'single-vertex', 'pair-swap')\n    \"\"\"\n    # Internal helpers and data (no globals)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicts_of(sol: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return a minimal valid construct to allow recovery\n        base = list(range(1, n+1))\n        return (base, \"RECOLOR\", \"repair-init\")\n    new_sol = solution[:]\n    # Choose neighborhood type stochastically: recolor or swap\n    if random.random() < 0.7:\n        # RECOLOR: change color of one vertex to reduce conflicts or diversify\n        v = random.randrange(n)\n        current_color = new_sol[v]\n        # Candidate colors: 1..(max_color+1) to allow new color introduction\n        max_c = max(new_sol) if new_sol else 1\n        candidates = list(range(1, max_c + 2))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and abs(c - current_color) > abs(best[v] - current_color)):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP: swap colors of two vertices to potentially resolve conflicts while preserving palette\n        i, j = 0, 0\n        tries = 0\n        while i == j and tries < 10:\n            i = random.randrange(n)\n            j = random.randrange(n)\n            tries += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple random recolors to escape deep local minima\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        # Try a random color from 1..max_c+1 (allow temporary new colors)\n        new_c = random.randrange(1, max_c + 2)\n        sol[v] = new_c\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000715269}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS; solution is a list of length 9 with positive integer color labels for vertices 1..9. Labels should be normalized to {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution, NB_Type, Movement_Type)\n    NB_Type: string label of neighborhood (e.g., 'RECOLOR' or 'SWAP')\n    Movement_Type: string label of move subtype (e.g., 'single-vertex', 'pair-swap')\n    \"\"\"\n    # Internal helpers and data (no globals)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicts_of(sol: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return a minimal valid construct to allow recovery\n        base = list(range(1, n+1))\n        return (base, \"RECOLOR\", \"repair-init\")\n    new_sol = solution[:]\n    # Choose neighborhood type stochastically: recolor or swap\n    if random.random() < 0.7:\n        # RECOLOR: change color of one vertex to reduce conflicts or diversify\n        v = random.randrange(n)\n        current_color = new_sol[v]\n        # Candidate colors: 1..(max_color+1) to allow new color introduction\n        max_c = max(new_sol) if new_sol else 1\n        candidates = list(range(1, max_c + 2))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and abs(c - current_color) > abs(best[v] - current_color)):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP: swap colors of two vertices to potentially resolve conflicts while preserving palette\n        i, j = 0, 0\n        tries = 0\n        while i == j and tries < 10:\n            i = random.randrange(n)\n            j = random.randrange(n)\n            tries += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple random recolors to escape deep local minima\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        # Try a random color from 1..max_c+1 (allow temporary new colors)\n        new_c = random.randrange(1, max_c + 2)\n        sol[v] = new_c\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000694817}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    # Representation enforcement\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Distinct color count and normalization check\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type in {RECOLOR, SWAP}\n    Movement_Type in {single-vertex, pair-swap}\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Basic validation and repair-init\n    if not isinstance(solution, list) or len(solution) != n:\n        base = list(range(1, n + 1))\n        return (base, \"RECOLOR\", \"repair-init\")\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n\n    if random.random() < 0.8:\n        # RECOLOR neighborhood: focus on conflicted vertices if any\n        bad = conflicted_vertices(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(n)\n        current_color = new_sol[v]\n        max_c = max(new_sol) if new_sol else 1\n        # Prefer existing palette; occasionally allow +1 to escape\n        candidates = list(range(1, max_c + (1 if random.random() < 0.2 else 0) + 1))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and c < trial[v]):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        best = normalize_palette(best)\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP neighborhood: swap colors of two distinct vertices\n        i = random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        trial = normalize_palette(trial)\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor a subset (focused on conflicts if any)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n + 1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    bad = conflicted_vertices(sol)\n    pool = bad if bad else list(range(n))\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.choice(pool)\n        # recolor using existing palette plus occasional new color\n        new_c = random.randrange(1, max_c + (1 if random.random() < 0.3 else 0) + 1)\n        if new_c < 1:\n            new_c = 1\n        sol[v] = new_c\n    sol = normalize_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001095543}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    # Representation enforcement\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Distinct color count and normalization check\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type in {RECOLOR, SWAP}\n    Movement_Type in {single-vertex, pair-swap}\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Basic validation and repair-init\n    if not isinstance(solution, list) or len(solution) != n:\n        base = list(range(1, n + 1))\n        return (base, \"RECOLOR\", \"repair-init\")\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n\n    if random.random() < 0.8:\n        # RECOLOR neighborhood: focus on conflicted vertices if any\n        bad = conflicted_vertices(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(n)\n        current_color = new_sol[v]\n        max_c = max(new_sol) if new_sol else 1\n        # Prefer existing palette; occasionally allow +1 to escape\n        candidates = list(range(1, max_c + (1 if random.random() < 0.2 else 0) + 1))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and c < trial[v]):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        best = normalize_palette(best)\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP neighborhood: swap colors of two distinct vertices\n        i = random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        trial = normalize_palette(trial)\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor a subset (focused on conflicts if any)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n + 1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    bad = conflicted_vertices(sol)\n    pool = bad if bad else list(range(n))\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.choice(pool)\n        # recolor using existing palette plus occasional new color\n        new_c = random.randrange(1, max_c + (1 if random.random() < 0.3 else 0) + 1)\n        if new_c < 1:\n            new_c = 1\n        sol[v] = new_c\n    sol = normalize_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00091357}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    # Representation enforcement\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Distinct color count and normalization check\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type in {RECOLOR, SWAP}\n    Movement_Type in {single-vertex, pair-swap}\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Basic validation and repair-init\n    if not isinstance(solution, list) or len(solution) != n:\n        base = list(range(1, n + 1))\n        return (base, \"RECOLOR\", \"repair-init\")\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n\n    if random.random() < 0.8:\n        # RECOLOR neighborhood: focus on conflicted vertices if any\n        bad = conflicted_vertices(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(n)\n        current_color = new_sol[v]\n        max_c = max(new_sol) if new_sol else 1\n        # Prefer existing palette; occasionally allow +1 to escape\n        candidates = list(range(1, max_c + (1 if random.random() < 0.2 else 0) + 1))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and c < trial[v]):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        best = normalize_palette(best)\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP neighborhood: swap colors of two distinct vertices\n        i = random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        trial = normalize_palette(trial)\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor a subset (focused on conflicts if any)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n + 1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    bad = conflicted_vertices(sol)\n    pool = bad if bad else list(range(n))\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.choice(pool)\n        # recolor using existing palette plus occasional new color\n        new_c = random.randrange(1, max_c + (1 if random.random() < 0.3 else 0) + 1)\n        if new_c < 1:\n            new_c = 1\n        sol[v] = new_c\n    sol = normalize_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000892081}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used (with SMALL penalty if palette not normalized 1..k).\n    Infeasible: large base penalty plus conflict-gradient to preserve ordering.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED_BASE = 100_000_000\n    CONFLICT_SCALE = 1_000\n    SMALL = 10_000\n    # Representation checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED_BASE + conflicts * CONFLICT_SCALE\n    # Distinct colors and normalization\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"RECOLOR\",\"SWAP\"}; Movement_Type in {\"single-vertex\",\"pair-swap\"}.\n    Implementation focuses on conflict-driven recolor; occasional pair-swap.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Validate\/repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        # Greedy coloring seed to avoid excessive conflicts\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        for v in range(1, n+1):\n            forbidden = {sol[u-1] for u in adj[v] if sol[u-1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[v-1] = c\n        return (sol, (\"RECOLOR\", \"repair-init\"))\n    sol = solution[:]\n    # Build adjacency list and quick helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    # With high probability do recolor; else do swap\n    if random.random() < 0.85:\n        # Select target vertex (prefer conflicted)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            v = random.randrange(n)\n        v1 = v + 1\n        current_color = sol[v]\n        # Candidate colors from neighbor palette plus optional new color\n        neigh_colors = {sol[u-1] for u in adj[v1]}\n        max_c = max(sol) if sol else 1\n        candidates = sorted(neigh_colors | {current_color})\n        # Occasionally allow introducing a new color to escape traps\n        if random.random() < 0.1:\n            candidates.append(max_c + 1)\n        # Evaluate delta conflicts for each candidate color\n        best_c = current_color\n        best_delta = None\n        best_palette_growth = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            # Compute conflicts if v were color c using only neighbors\n            before = 0\n            after = 0\n            for u in adj[v1]:\n                if sol[u-1] == current_color:\n                    before += 1\n                if sol[u-1] == c:\n                    after += 1\n            delta = after - before  # aim to minimize conflicts\n            palette_growth = 1 if c > max_c else 0\n            if (best_delta is None or\n                delta < best_delta or\n                (delta == best_delta and palette_growth < best_palette_growth) or\n                (delta == best_delta and palette_growth == best_palette_growth and c < best_c)):\n                best_delta = delta\n                best_palette_growth = palette_growth\n                best_c = c\n                if best_delta < 0 and best_palette_growth == 0:\n                    pass\n        new_sol = sol[:]\n        new_sol[v] = best_c\n        return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n    else:\n        # Conflict-aware pair swap: pick one conflicted (or random) and swap with a neighbor index\n        i = random.choice(conflicted) if conflicted else random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        new_sol = sol[:]\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (new_sol, (\"SWAP\", \"pair-swap\"))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor a small set of vertices, biased to conflicts,\n    using existing palette with occasional +1 color to escape.\n    Returns a valid representation (list of 9 positive ints).\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Minimal repair if needed\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n    steps = max(3, n \/\/ 3)\n    max_c = max(sol) if sol else 1\n    for _ in range(steps):\n        v = random.choice(pool)\n        neigh = {sol[u-1] for u in adj[v+1]}\n        candidates = list(set(range(1, max_c + 1)) - neigh)\n        if not candidates or random.random() < 0.25:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001381486}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used (with SMALL penalty if palette not normalized 1..k).\n    Infeasible: large base penalty plus conflict-gradient to preserve ordering.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED_BASE = 100_000_000\n    CONFLICT_SCALE = 1_000\n    SMALL = 10_000\n    # Representation checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED_BASE + conflicts * CONFLICT_SCALE\n    # Distinct colors and normalization\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"RECOLOR\",\"SWAP\"}; Movement_Type in {\"single-vertex\",\"pair-swap\"}.\n    Implementation focuses on conflict-driven recolor; occasional pair-swap.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Validate\/repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        # Greedy coloring seed to avoid excessive conflicts\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        for v in range(1, n+1):\n            forbidden = {sol[u-1] for u in adj[v] if sol[u-1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[v-1] = c\n        return (sol, (\"RECOLOR\", \"repair-init\"))\n    sol = solution[:]\n    # Build adjacency list and quick helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    # With high probability do recolor; else do swap\n    if random.random() < 0.85:\n        # Select target vertex (prefer conflicted)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            v = random.randrange(n)\n        v1 = v + 1\n        current_color = sol[v]\n        # Candidate colors from neighbor palette plus optional new color\n        neigh_colors = {sol[u-1] for u in adj[v1]}\n        max_c = max(sol) if sol else 1\n        candidates = sorted(neigh_colors | {current_color})\n        # Occasionally allow introducing a new color to escape traps\n        if random.random() < 0.1:\n            candidates.append(max_c + 1)\n        # Evaluate delta conflicts for each candidate color\n        best_c = current_color\n        best_delta = None\n        best_palette_growth = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            # Compute conflicts if v were color c using only neighbors\n            before = 0\n            after = 0\n            for u in adj[v1]:\n                if sol[u-1] == current_color:\n                    before += 1\n                if sol[u-1] == c:\n                    after += 1\n            delta = after - before  # aim to minimize conflicts\n            palette_growth = 1 if c > max_c else 0\n            if (best_delta is None or\n                delta < best_delta or\n                (delta == best_delta and palette_growth < best_palette_growth) or\n                (delta == best_delta and palette_growth == best_palette_growth and c < best_c)):\n                best_delta = delta\n                best_palette_growth = palette_growth\n                best_c = c\n                if best_delta < 0 and best_palette_growth == 0:\n                    pass\n        new_sol = sol[:]\n        new_sol[v] = best_c\n        return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n    else:\n        # Conflict-aware pair swap: pick one conflicted (or random) and swap with a neighbor index\n        i = random.choice(conflicted) if conflicted else random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        new_sol = sol[:]\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (new_sol, (\"SWAP\", \"pair-swap\"))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor a small set of vertices, biased to conflicts,\n    using existing palette with occasional +1 color to escape.\n    Returns a valid representation (list of 9 positive ints).\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Minimal repair if needed\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n    steps = max(3, n \/\/ 3)\n    max_c = max(sol) if sol else 1\n    for _ in range(steps):\n        v = random.choice(pool)\n        neigh = {sol[u-1] for u in adj[v+1]}\n        candidates = list(set(range(1, max_c + 1)) - neigh)\n        if not candidates or random.random() < 0.25:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001172303}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used (with SMALL penalty if palette not normalized 1..k).\n    Infeasible: large base penalty plus conflict-gradient to preserve ordering.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED_BASE = 100_000_000\n    CONFLICT_SCALE = 1_000\n    SMALL = 10_000\n    # Representation checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED_BASE + conflicts * CONFLICT_SCALE\n    # Distinct colors and normalization\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"RECOLOR\",\"SWAP\"}; Movement_Type in {\"single-vertex\",\"pair-swap\"}.\n    Implementation focuses on conflict-driven recolor; occasional pair-swap.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Validate\/repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        # Greedy coloring seed to avoid excessive conflicts\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        for v in range(1, n+1):\n            forbidden = {sol[u-1] for u in adj[v] if sol[u-1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[v-1] = c\n        return (sol, (\"RECOLOR\", \"repair-init\"))\n    sol = solution[:]\n    # Build adjacency list and quick helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    # With high probability do recolor; else do swap\n    if random.random() < 0.85:\n        # Select target vertex (prefer conflicted)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            v = random.randrange(n)\n        v1 = v + 1\n        current_color = sol[v]\n        # Candidate colors from neighbor palette plus optional new color\n        neigh_colors = {sol[u-1] for u in adj[v1]}\n        max_c = max(sol) if sol else 1\n        candidates = sorted(neigh_colors | {current_color})\n        # Occasionally allow introducing a new color to escape traps\n        if random.random() < 0.1:\n            candidates.append(max_c + 1)\n        # Evaluate delta conflicts for each candidate color\n        best_c = current_color\n        best_delta = None\n        best_palette_growth = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            # Compute conflicts if v were color c using only neighbors\n            before = 0\n            after = 0\n            for u in adj[v1]:\n                if sol[u-1] == current_color:\n                    before += 1\n                if sol[u-1] == c:\n                    after += 1\n            delta = after - before  # aim to minimize conflicts\n            palette_growth = 1 if c > max_c else 0\n            if (best_delta is None or\n                delta < best_delta or\n                (delta == best_delta and palette_growth < best_palette_growth) or\n                (delta == best_delta and palette_growth == best_palette_growth and c < best_c)):\n                best_delta = delta\n                best_palette_growth = palette_growth\n                best_c = c\n                if best_delta < 0 and best_palette_growth == 0:\n                    pass\n        new_sol = sol[:]\n        new_sol[v] = best_c\n        return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n    else:\n        # Conflict-aware pair swap: pick one conflicted (or random) and swap with a neighbor index\n        i = random.choice(conflicted) if conflicted else random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        new_sol = sol[:]\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (new_sol, (\"SWAP\", \"pair-swap\"))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor a small set of vertices, biased to conflicts,\n    using existing palette with occasional +1 color to escape.\n    Returns a valid representation (list of 9 positive ints).\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Minimal repair if needed\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n    steps = max(3, n \/\/ 3)\n    max_c = max(sol) if sol else 1\n    for _ in range(steps):\n        v = random.choice(pool)\n        neigh = {sol[u-1] for u in adj[v+1]}\n        candidates = list(set(range(1, max_c + 1)) - neigh)\n        if not candidates or random.random() < 0.25:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001117113}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used.\n    Infeasible: strong penalty dominated by conflict count with small tie-break on distinct colors.\n    Representation must be a list of 9 positive integers.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**12\n    # Validate representation\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k_used = len(set(solution))\n    if conflicts > 0:\n        # Strong ordering in infeasible space\n        return 1_000_000 * conflicts + 1_000 * k_used\n    # Feasible: minimize number of colors\n    return k_used\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    Neighbourhoods:\n      - Conflict-driven recolor of a single vertex.\n      - Kempe-chain swap between two colors on a conflicted vertex component.\n    Always normalizes palette to 1..k.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Basic repair if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        # DSATUR seed\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # select vertex with max saturation degree then max degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                neighbor_colors[u].add(c)\n        return (normalize_palette(colors), (\"RECOLOR\", \"repair-init\"))\n\n    sol = solution[:]\n\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n\n    if conflicted and random.random() < 0.35:\n        # Kempe-chain swap around a conflicted vertex\n        v = random.choice(conflicted)\n        v1 = v + 1\n        # pick a conflicting neighbor to define two colors a,b\n        neigh_conf = [u for u in adj[v1] if sol[u-1] == sol[v]]\n        if not neigh_conf:\n            # fallback to recolor\n            pass\n        else:\n            u = random.choice(neigh_conf)\n            a = sol[v]\n            # choose a different color from neighbor palette or introduce new if palette small\n            palette = sorted(set(sol))\n            # prefer a neighbor's color different from a\n            neigh_cols = [sol[w-1] for w in adj[v1] if sol[w-1] != a]\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n            else:\n                b = (max(palette) + 1) if random.random() < 0.2 else random.choice(palette)\n                if b == a:\n                    b = max(palette) + 1\n            # BFS on Kempe component containing v in subgraph induced by colors {a,b}\n            comp = set()\n            dq = deque([v1])\n            allowed = {a, b}\n            while dq:\n                x = dq.popleft()\n                if x in comp:\n                    continue\n                if sol[x-1] not in allowed:\n                    continue\n                comp.add(x)\n                for y in adj[x]:\n                    if sol[y-1] in allowed and y not in comp:\n                        dq.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x-1] == a:\n                    new_sol[x-1] = b\n                elif new_sol[x-1] == b:\n                    new_sol[x-1] = a\n            new_sol = normalize_palette(new_sol)\n            return (new_sol, (\"KEMPE\", \"component-swap\"))\n\n    # Conflict-driven recolor\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vertex_conflicts(i, sol), len(adj[i+1])))\n    else:\n        v = random.randrange(n)\n    v1 = v + 1\n    curr_c = sol[v]\n    palette = set(sol)\n    max_c = max(palette) if palette else 1\n    # Candidate colors: all existing colors, plus maybe a new one\n    candidates = list(range(1, max_c + 1))\n    if random.random() < 0.1:\n        candidates.append(max_c + 1)\n    # Evaluate delta conflicts locally\n    best_c = curr_c\n    best_score = (10**9, 10**9)  # (after_conflicts, palette_growth)\n    for c in candidates:\n        if c == curr_c and random.random() < 0.5:\n            continue\n        before = 0\n        after = 0\n        for u in adj[v1]:\n            if sol[u-1] == curr_c:\n                before += 1\n            if sol[u-1] == c:\n                after += 1\n        palette_growth = 1 if c > max_c else 0\n        score = (after, palette_growth)\n        if score < best_score or (score == best_score and c < best_c):\n            best_score = score\n            best_c = c\n    new_sol = sol[:]\n    new_sol[v] = best_c\n    new_sol = normalize_palette(new_sol)\n    return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor multiple vertices (biased to conflicts)\n    using current palette with occasional expansion, followed by normalization.\n    Returns a valid list[int] of length 9.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Repair invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n\n    steps = max(3, n \/\/ 2)\n    palette = sorted(set(sol))\n    max_c = max(palette) if palette else 1\n\n    for _ in range(steps):\n        v = random.choice(pool)\n        v1 = v + 1\n        neigh_cols = {sol[u-1] for u in adj[v1]}\n        # Prefer lower colors not in neighbors\n        candidates = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n        if not candidates or random.random() < 0.2:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n        # Optionally do a quick local descent recolor to reduce immediate conflicts\n        if random.random() < 0.5:\n            neigh_cols2 = {sol[u-1] for u in adj[v1]}\n            best_c = sol[v]\n            best_conf = sum(1 for u in adj[v1] if sol[u-1] == best_c)\n            for c in range(1, max(sol)+1):\n                if c == sol[v]:\n                    continue\n                conf = sum(1 for u in adj[v1] if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            sol[v] = best_c\n\n    sol = normalize_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001797801}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used.\n    Infeasible: strong penalty dominated by conflict count with small tie-break on distinct colors.\n    Representation must be a list of 9 positive integers.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**12\n    # Validate representation\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k_used = len(set(solution))\n    if conflicts > 0:\n        # Strong ordering in infeasible space\n        return 1_000_000 * conflicts + 1_000 * k_used\n    # Feasible: minimize number of colors\n    return k_used\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    Neighbourhoods:\n      - Conflict-driven recolor of a single vertex.\n      - Kempe-chain swap between two colors on a conflicted vertex component.\n    Always normalizes palette to 1..k.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Basic repair if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        # DSATUR seed\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # select vertex with max saturation degree then max degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                neighbor_colors[u].add(c)\n        return (normalize_palette(colors), (\"RECOLOR\", \"repair-init\"))\n\n    sol = solution[:]\n\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n\n    if conflicted and random.random() < 0.35:\n        # Kempe-chain swap around a conflicted vertex\n        v = random.choice(conflicted)\n        v1 = v + 1\n        # pick a conflicting neighbor to define two colors a,b\n        neigh_conf = [u for u in adj[v1] if sol[u-1] == sol[v]]\n        if not neigh_conf:\n            # fallback to recolor\n            pass\n        else:\n            u = random.choice(neigh_conf)\n            a = sol[v]\n            # choose a different color from neighbor palette or introduce new if palette small\n            palette = sorted(set(sol))\n            # prefer a neighbor's color different from a\n            neigh_cols = [sol[w-1] for w in adj[v1] if sol[w-1] != a]\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n            else:\n                b = (max(palette) + 1) if random.random() < 0.2 else random.choice(palette)\n                if b == a:\n                    b = max(palette) + 1\n            # BFS on Kempe component containing v in subgraph induced by colors {a,b}\n            comp = set()\n            dq = deque([v1])\n            allowed = {a, b}\n            while dq:\n                x = dq.popleft()\n                if x in comp:\n                    continue\n                if sol[x-1] not in allowed:\n                    continue\n                comp.add(x)\n                for y in adj[x]:\n                    if sol[y-1] in allowed and y not in comp:\n                        dq.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x-1] == a:\n                    new_sol[x-1] = b\n                elif new_sol[x-1] == b:\n                    new_sol[x-1] = a\n            new_sol = normalize_palette(new_sol)\n            return (new_sol, (\"KEMPE\", \"component-swap\"))\n\n    # Conflict-driven recolor\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vertex_conflicts(i, sol), len(adj[i+1])))\n    else:\n        v = random.randrange(n)\n    v1 = v + 1\n    curr_c = sol[v]\n    palette = set(sol)\n    max_c = max(palette) if palette else 1\n    # Candidate colors: all existing colors, plus maybe a new one\n    candidates = list(range(1, max_c + 1))\n    if random.random() < 0.1:\n        candidates.append(max_c + 1)\n    # Evaluate delta conflicts locally\n    best_c = curr_c\n    best_score = (10**9, 10**9)  # (after_conflicts, palette_growth)\n    for c in candidates:\n        if c == curr_c and random.random() < 0.5:\n            continue\n        before = 0\n        after = 0\n        for u in adj[v1]:\n            if sol[u-1] == curr_c:\n                before += 1\n            if sol[u-1] == c:\n                after += 1\n        palette_growth = 1 if c > max_c else 0\n        score = (after, palette_growth)\n        if score < best_score or (score == best_score and c < best_c):\n            best_score = score\n            best_c = c\n    new_sol = sol[:]\n    new_sol[v] = best_c\n    new_sol = normalize_palette(new_sol)\n    return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor multiple vertices (biased to conflicts)\n    using current palette with occasional expansion, followed by normalization.\n    Returns a valid list[int] of length 9.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Repair invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n\n    steps = max(3, n \/\/ 2)\n    palette = sorted(set(sol))\n    max_c = max(palette) if palette else 1\n\n    for _ in range(steps):\n        v = random.choice(pool)\n        v1 = v + 1\n        neigh_cols = {sol[u-1] for u in adj[v1]}\n        # Prefer lower colors not in neighbors\n        candidates = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n        if not candidates or random.random() < 0.2:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n        # Optionally do a quick local descent recolor to reduce immediate conflicts\n        if random.random() < 0.5:\n            neigh_cols2 = {sol[u-1] for u in adj[v1]}\n            best_c = sol[v]\n            best_conf = sum(1 for u in adj[v1] if sol[u-1] == best_c)\n            for c in range(1, max(sol)+1):\n                if c == sol[v]:\n                    continue\n                conf = sum(1 for u in adj[v1] if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            sol[v] = best_c\n\n    sol = normalize_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001443596}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used.\n    Infeasible: strong penalty dominated by conflict count with small tie-break on distinct colors.\n    Representation must be a list of 9 positive integers.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**12\n    # Validate representation\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k_used = len(set(solution))\n    if conflicts > 0:\n        # Strong ordering in infeasible space\n        return 1_000_000 * conflicts + 1_000 * k_used\n    # Feasible: minimize number of colors\n    return k_used\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    Neighbourhoods:\n      - Conflict-driven recolor of a single vertex.\n      - Kempe-chain swap between two colors on a conflicted vertex component.\n    Always normalizes palette to 1..k.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Basic repair if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        # DSATUR seed\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # select vertex with max saturation degree then max degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                neighbor_colors[u].add(c)\n        return (normalize_palette(colors), (\"RECOLOR\", \"repair-init\"))\n\n    sol = solution[:]\n\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n\n    if conflicted and random.random() < 0.35:\n        # Kempe-chain swap around a conflicted vertex\n        v = random.choice(conflicted)\n        v1 = v + 1\n        # pick a conflicting neighbor to define two colors a,b\n        neigh_conf = [u for u in adj[v1] if sol[u-1] == sol[v]]\n        if not neigh_conf:\n            # fallback to recolor\n            pass\n        else:\n            u = random.choice(neigh_conf)\n            a = sol[v]\n            # choose a different color from neighbor palette or introduce new if palette small\n            palette = sorted(set(sol))\n            # prefer a neighbor's color different from a\n            neigh_cols = [sol[w-1] for w in adj[v1] if sol[w-1] != a]\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n            else:\n                b = (max(palette) + 1) if random.random() < 0.2 else random.choice(palette)\n                if b == a:\n                    b = max(palette) + 1\n            # BFS on Kempe component containing v in subgraph induced by colors {a,b}\n            comp = set()\n            dq = deque([v1])\n            allowed = {a, b}\n            while dq:\n                x = dq.popleft()\n                if x in comp:\n                    continue\n                if sol[x-1] not in allowed:\n                    continue\n                comp.add(x)\n                for y in adj[x]:\n                    if sol[y-1] in allowed and y not in comp:\n                        dq.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x-1] == a:\n                    new_sol[x-1] = b\n                elif new_sol[x-1] == b:\n                    new_sol[x-1] = a\n            new_sol = normalize_palette(new_sol)\n            return (new_sol, (\"KEMPE\", \"component-swap\"))\n\n    # Conflict-driven recolor\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vertex_conflicts(i, sol), len(adj[i+1])))\n    else:\n        v = random.randrange(n)\n    v1 = v + 1\n    curr_c = sol[v]\n    palette = set(sol)\n    max_c = max(palette) if palette else 1\n    # Candidate colors: all existing colors, plus maybe a new one\n    candidates = list(range(1, max_c + 1))\n    if random.random() < 0.1:\n        candidates.append(max_c + 1)\n    # Evaluate delta conflicts locally\n    best_c = curr_c\n    best_score = (10**9, 10**9)  # (after_conflicts, palette_growth)\n    for c in candidates:\n        if c == curr_c and random.random() < 0.5:\n            continue\n        before = 0\n        after = 0\n        for u in adj[v1]:\n            if sol[u-1] == curr_c:\n                before += 1\n            if sol[u-1] == c:\n                after += 1\n        palette_growth = 1 if c > max_c else 0\n        score = (after, palette_growth)\n        if score < best_score or (score == best_score and c < best_c):\n            best_score = score\n            best_c = c\n    new_sol = sol[:]\n    new_sol[v] = best_c\n    new_sol = normalize_palette(new_sol)\n    return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor multiple vertices (biased to conflicts)\n    using current palette with occasional expansion, followed by normalization.\n    Returns a valid list[int] of length 9.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Repair invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n\n    steps = max(3, n \/\/ 2)\n    palette = sorted(set(sol))\n    max_c = max(palette) if palette else 1\n\n    for _ in range(steps):\n        v = random.choice(pool)\n        v1 = v + 1\n        neigh_cols = {sol[u-1] for u in adj[v1]}\n        # Prefer lower colors not in neighbors\n        candidates = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n        if not candidates or random.random() < 0.2:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n        # Optionally do a quick local descent recolor to reduce immediate conflicts\n        if random.random() < 0.5:\n            neigh_cols2 = {sol[u-1] for u in adj[v1]}\n            best_c = sol[v]\n            best_conf = sum(1 for u in adj[v1] if sol[u-1] == best_c)\n            for c in range(1, max(sol)+1):\n                if c == sol[v]:\n                    continue\n                conf = sum(1 for u in adj[v1] if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            sol[v] = best_c\n\n    sol = normalize_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001371066}
