{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS; vertices 1..9 mapped to positive integer group indices; example: [1,2,3,1,3,3,4,4,2]","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != 9:\n        return float('inf')\n    # Penalty weights\n    penalty_conflict = 1000.0\n    penalty_invalid = 1e6\n    # Check integers and positivity\n    try:\n        for g in solution:\n            if not isinstance(g, int) or g <= 0:\n                return penalty_invalid\n    except Exception:\n        return penalty_invalid\n    # Friendship edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return float(groups_used + penalty_conflict * conflicts)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only (no side-effects). This function specifies the neighborhood used by local search.\n    # NB_Type: structure; Movement_Type: operation kind\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Deep copy to avoid in-place modification\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,3,3,4,4,2]\n    s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Identify conflicts\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append((u-1, v-1))\n    # Decide perturbation strength\n    k_moves = 3 if len(conflicts) == 0 else min(5, max(2, len(conflicts)))\n    # Helper to conflict-aware recolor\n    def recolor_vertex(i: int):\n        neighbor_colors = {s[j] for j in adj[i]}\n        # Try to reuse existing colors first\n        candidate_colors = [c for c in range(1, max(s)+1) if c not in neighbor_colors]\n        if candidate_colors:\n            s[i] = random.choice(candidate_colors)\n            return\n        # Otherwise introduce at most one new color\n        s[i] = max(s) + 1\n    # Apply k_moves random edits\n    for _ in range(k_moves):\n        if conflicts:\n            i, j = random.choice(conflicts)\n            v = random.choice([i, j])\n        else:\n            v = random.randrange(n)\n        if random.random() < 0.7:\n            recolor_vertex(v)\n        else:\n            # Random swap of colors between two vertices to encourage exploration\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        # Refresh conflicts list occasionally (cheap incremental update)\n        conflicts = []\n        for u2, v2 in edges:\n            if s[u2-1] == s[v2-1]:\n                conflicts.append((u2-1, v2-1))\n    # Post-process: relabel colors to compact 1..K to keep objective stable\n    mapping = {}\n    next_c = 1\n    for idx in range(n):\n        c = s[idx]\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        s[idx] = mapping[c]\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000802253}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS; vertices 1..9 mapped to positive integer group indices; example: [1,2,3,1,3,3,4,4,2]","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != 9:\n        return float('inf')\n    # Penalty weights\n    penalty_conflict = 1000.0\n    penalty_invalid = 1e6\n    # Check integers and positivity\n    try:\n        for g in solution:\n            if not isinstance(g, int) or g <= 0:\n                return penalty_invalid\n    except Exception:\n        return penalty_invalid\n    # Friendship edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return float(groups_used + penalty_conflict * conflicts)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only (no side-effects). This function specifies the neighborhood used by local search.\n    # NB_Type: structure; Movement_Type: operation kind\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Deep copy to avoid in-place modification\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,3,3,4,4,2]\n    s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Identify conflicts\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append((u-1, v-1))\n    # Decide perturbation strength\n    k_moves = 3 if len(conflicts) == 0 else min(5, max(2, len(conflicts)))\n    # Helper to conflict-aware recolor\n    def recolor_vertex(i: int):\n        neighbor_colors = {s[j] for j in adj[i]}\n        # Try to reuse existing colors first\n        candidate_colors = [c for c in range(1, max(s)+1) if c not in neighbor_colors]\n        if candidate_colors:\n            s[i] = random.choice(candidate_colors)\n            return\n        # Otherwise introduce at most one new color\n        s[i] = max(s) + 1\n    # Apply k_moves random edits\n    for _ in range(k_moves):\n        if conflicts:\n            i, j = random.choice(conflicts)\n            v = random.choice([i, j])\n        else:\n            v = random.randrange(n)\n        if random.random() < 0.7:\n            recolor_vertex(v)\n        else:\n            # Random swap of colors between two vertices to encourage exploration\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        # Refresh conflicts list occasionally (cheap incremental update)\n        conflicts = []\n        for u2, v2 in edges:\n            if s[u2-1] == s[v2-1]:\n                conflicts.append((u2-1, v2-1))\n    # Post-process: relabel colors to compact 1..K to keep objective stable\n    mapping = {}\n    next_c = 1\n    for idx in range(n):\n        c = s[idx]\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        s[idx] = mapping[c]\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000582889}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS; vertices 1..9 mapped to positive integer group indices; example: [1,2,3,1,3,3,4,4,2]","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != 9:\n        return float('inf')\n    # Penalty weights\n    penalty_conflict = 1000.0\n    penalty_invalid = 1e6\n    # Check integers and positivity\n    try:\n        for g in solution:\n            if not isinstance(g, int) or g <= 0:\n                return penalty_invalid\n    except Exception:\n        return penalty_invalid\n    # Friendship edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return float(groups_used + penalty_conflict * conflicts)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only (no side-effects). This function specifies the neighborhood used by local search.\n    # NB_Type: structure; Movement_Type: operation kind\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Deep copy to avoid in-place modification\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,3,3,4,4,2]\n    s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Identify conflicts\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append((u-1, v-1))\n    # Decide perturbation strength\n    k_moves = 3 if len(conflicts) == 0 else min(5, max(2, len(conflicts)))\n    # Helper to conflict-aware recolor\n    def recolor_vertex(i: int):\n        neighbor_colors = {s[j] for j in adj[i]}\n        # Try to reuse existing colors first\n        candidate_colors = [c for c in range(1, max(s)+1) if c not in neighbor_colors]\n        if candidate_colors:\n            s[i] = random.choice(candidate_colors)\n            return\n        # Otherwise introduce at most one new color\n        s[i] = max(s) + 1\n    # Apply k_moves random edits\n    for _ in range(k_moves):\n        if conflicts:\n            i, j = random.choice(conflicts)\n            v = random.choice([i, j])\n        else:\n            v = random.randrange(n)\n        if random.random() < 0.7:\n            recolor_vertex(v)\n        else:\n            # Random swap of colors between two vertices to encourage exploration\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        # Refresh conflicts list occasionally (cheap incremental update)\n        conflicts = []\n        for u2, v2 in edges:\n            if s[u2-1] == s[v2-1]:\n                conflicts.append((u2-1, v2-1))\n    # Post-process: relabel colors to compact 1..K to keep objective stable\n    mapping = {}\n    next_c = 1\n    for idx in range(n):\n        c = s[idx]\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        s[idx] = mapping[c]\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000566019}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS_NORMALIZED: solution is a list of 9 positive integers where index i maps to vertex i+1 and values are color IDs relabeled to contiguous 1..K in order of first appearance.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Fast validation and evaluation. Returns groups_used + 1000*conflicts.\n    # Embedded graph (1-indexed edges)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    s = solution\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only; actual move implemented by the metaheuristic using this specification.\n    # Neighborhood: pick one vertex uniformly at random and recolor it to a color not used by its neighbors if possible; otherwise allow introducing a new color.\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed copy using conflict-aware recolors, occasional swaps, and color normalization.\n    # Validate and construct a safe starting point if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n        s = base[:]  # valid 4-coloring\n    else:\n        # Coerce to positive ints; fallback to 1 for invalid entries\n        s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Helper: normalize colors to contiguous 1..K by order of first appearance\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            arr[i] = mapping[c]\n        return arr\n    # Compute initial conflicts list\n    def list_conflicts(arr):\n        conf = []\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    conflicts = list_conflicts(s)\n    # Decide perturbation strength adaptively\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    # Helper recolor for a vertex preferring reuse of existing colors\n    def recolor_vertex(i):\n        neighbor_colors = {s[j] for j in adj[i]}\n        maxc = max(s) if s else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            s[i] = random.choice(candidates)\n        else:\n            s[i] = maxc + 1\n    # Apply k_moves edits\n    for _ in range(k_moves):\n        # Choose a target vertex, prioritizing conflicts\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.7:\n            recolor_vertex(v)\n        elif r < 0.9:\n            # Swap colors with another vertex to escape local minima\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        else:\n            # Merge attempt: try to set v to a lower color if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        # Refresh conflicts after the move\n        conflicts = list_conflicts(s)\n    # Final normalization to reduce symmetry and keep objective stable\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000894403}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS_NORMALIZED: solution is a list of 9 positive integers where index i maps to vertex i+1 and values are color IDs relabeled to contiguous 1..K in order of first appearance.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Fast validation and evaluation. Returns groups_used + 1000*conflicts.\n    # Embedded graph (1-indexed edges)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    s = solution\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only; actual move implemented by the metaheuristic using this specification.\n    # Neighborhood: pick one vertex uniformly at random and recolor it to a color not used by its neighbors if possible; otherwise allow introducing a new color.\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed copy using conflict-aware recolors, occasional swaps, and color normalization.\n    # Validate and construct a safe starting point if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n        s = base[:]  # valid 4-coloring\n    else:\n        # Coerce to positive ints; fallback to 1 for invalid entries\n        s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Helper: normalize colors to contiguous 1..K by order of first appearance\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            arr[i] = mapping[c]\n        return arr\n    # Compute initial conflicts list\n    def list_conflicts(arr):\n        conf = []\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    conflicts = list_conflicts(s)\n    # Decide perturbation strength adaptively\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    # Helper recolor for a vertex preferring reuse of existing colors\n    def recolor_vertex(i):\n        neighbor_colors = {s[j] for j in adj[i]}\n        maxc = max(s) if s else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            s[i] = random.choice(candidates)\n        else:\n            s[i] = maxc + 1\n    # Apply k_moves edits\n    for _ in range(k_moves):\n        # Choose a target vertex, prioritizing conflicts\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.7:\n            recolor_vertex(v)\n        elif r < 0.9:\n            # Swap colors with another vertex to escape local minima\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        else:\n            # Merge attempt: try to set v to a lower color if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        # Refresh conflicts after the move\n        conflicts = list_conflicts(s)\n    # Final normalization to reduce symmetry and keep objective stable\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000722691}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS_NORMALIZED: solution is a list of 9 positive integers where index i maps to vertex i+1 and values are color IDs relabeled to contiguous 1..K in order of first appearance.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Fast validation and evaluation. Returns groups_used + 1000*conflicts.\n    # Embedded graph (1-indexed edges)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    s = solution\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only; actual move implemented by the metaheuristic using this specification.\n    # Neighborhood: pick one vertex uniformly at random and recolor it to a color not used by its neighbors if possible; otherwise allow introducing a new color.\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed copy using conflict-aware recolors, occasional swaps, and color normalization.\n    # Validate and construct a safe starting point if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n        s = base[:]  # valid 4-coloring\n    else:\n        # Coerce to positive ints; fallback to 1 for invalid entries\n        s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Helper: normalize colors to contiguous 1..K by order of first appearance\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            arr[i] = mapping[c]\n        return arr\n    # Compute initial conflicts list\n    def list_conflicts(arr):\n        conf = []\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    conflicts = list_conflicts(s)\n    # Decide perturbation strength adaptively\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    # Helper recolor for a vertex preferring reuse of existing colors\n    def recolor_vertex(i):\n        neighbor_colors = {s[j] for j in adj[i]}\n        maxc = max(s) if s else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            s[i] = random.choice(candidates)\n        else:\n            s[i] = maxc + 1\n    # Apply k_moves edits\n    for _ in range(k_moves):\n        # Choose a target vertex, prioritizing conflicts\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.7:\n            recolor_vertex(v)\n        elif r < 0.9:\n            # Swap colors with another vertex to escape local minima\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        else:\n            # Merge attempt: try to set v to a lower color if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        # Refresh conflicts after the move\n        conflicts = list_conflicts(s)\n    # Final normalization to reduce symmetry and keep objective stable\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00068894}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] of length 9, positive group IDs. Index i corresponds to vertex i+1. Colors must be normalized to contiguous labels 1..K in order of first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    s = solution\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    # Conflicts dominate objective via large penalty\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood descriptor for metaheuristics:\n    #   - Primary: conflict-aware single-vertex recolor using existing feasible colors when available\n    #   - Secondary: occasional whole color-class swap to escape plateaus\n    # The metaheuristic should enumerate candidate colors from neighbor colors + one spare and prefer minimal incremental conflicts.\n    return (\"LocalMove\", \"SingleVertexRecolor+ClassSwap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    # Helpers\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        if not arr:\n            return\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = s[:]\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            # Merge attempt: try to lower color of v if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Resultados":[[1,2,3,1,3,3,4,4,2],4.0,[1,2,3,1,3,3,4,4,2],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001169097}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] of length 9, positive group IDs. Index i corresponds to vertex i+1. Colors must be normalized to contiguous labels 1..K in order of first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    s = solution\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    # Conflicts dominate objective via large penalty\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood descriptor for metaheuristics:\n    #   - Primary: conflict-aware single-vertex recolor using existing feasible colors when available\n    #   - Secondary: occasional whole color-class swap to escape plateaus\n    # The metaheuristic should enumerate candidate colors from neighbor colors + one spare and prefer minimal incremental conflicts.\n    return (\"LocalMove\", \"SingleVertexRecolor+ClassSwap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    # Helpers\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        if not arr:\n            return\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = s[:]\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            # Merge attempt: try to lower color of v if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Resultados":["LocalMove",null,[1,2,3,1,3,3,4,4,2],null],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001532892}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] of length 9, positive group IDs. Index i corresponds to vertex i+1. Colors must be normalized to contiguous labels 1..K in order of first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    s = solution\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    # Conflicts dominate objective via large penalty\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood descriptor for metaheuristics:\n    #   - Primary: conflict-aware single-vertex recolor using existing feasible colors when available\n    #   - Secondary: occasional whole color-class swap to escape plateaus\n    # The metaheuristic should enumerate candidate colors from neighbor colors + one spare and prefer minimal incremental conflicts.\n    return (\"LocalMove\", \"SingleVertexRecolor+ClassSwap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    # Helpers\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        if not arr:\n            return\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = s[:]\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            # Merge attempt: try to lower color of v if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000822462}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] length 9. Index i corresponds to vertex i+1. Positive integers as color IDs, normalized to contiguous 1..K by first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1000000.0\n    s = normalize_labels(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns a single neighbour solution (list[int]) produced by conflict-aware recolor\n    # plus occasional color-class swap if no conflicts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph (1-indexed in data, convert to 0-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def conflicts_list(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    s = normalize_labels(s)\n    k = max(s) if s else 1\n    confs = conflicts_list(s)\n    t = s[:]\n    if confs:\n        # Focus on a conflicted vertex\n        a, b = random.choice(confs)\n        v = a if random.random() < 0.5 else b\n        neighbor_colors = {t[j] for j in adj[v]}\n        candidates = list(range(1, k + 1))\n        if (k + 1) not in candidates:\n            candidates.append(k + 1)\n        best_c = None\n        best_cnt = 10**9\n        ties = []\n        for c in candidates:\n            cnt = 0\n            for j in adj[v]:\n                if t[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                ties = [c]\n            elif cnt == best_cnt:\n                ties.append(c)\n        if ties:\n            best_c = random.choice(ties)\n        else:\n            best_c = k + 1\n        t[v] = best_c\n    else:\n        # No conflicts: attempt color-class swap or recolor a random vertex to reduce colors\n        if random.random() < 0.4 and len(set(t)) >= 2:\n            colors = list(set(t))\n            c1, c2 = random.sample(colors, 2)\n            for i in range(n):\n                if t[i] == c1:\n                    t[i] = c2\n                elif t[i] == c2:\n                    t[i] = c1\n        else:\n            v = random.randrange(n)\n            neighbor_colors = {t[j] for j in adj[v]}\n            candidates = [c for c in range(1, k + 1) if c not in neighbor_colors]\n            if not candidates:\n                candidates = [t[v]]\n            t[v] = random.choice(candidates)\n    t = normalize_labels(t)\n    return t\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = normalize(s)\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0014364}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] length 9. Index i corresponds to vertex i+1. Positive integers as color IDs, normalized to contiguous 1..K by first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1000000.0\n    s = normalize_labels(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns a single neighbour solution (list[int]) produced by conflict-aware recolor\n    # plus occasional color-class swap if no conflicts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph (1-indexed in data, convert to 0-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def conflicts_list(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    s = normalize_labels(s)\n    k = max(s) if s else 1\n    confs = conflicts_list(s)\n    t = s[:]\n    if confs:\n        # Focus on a conflicted vertex\n        a, b = random.choice(confs)\n        v = a if random.random() < 0.5 else b\n        neighbor_colors = {t[j] for j in adj[v]}\n        candidates = list(range(1, k + 1))\n        if (k + 1) not in candidates:\n            candidates.append(k + 1)\n        best_c = None\n        best_cnt = 10**9\n        ties = []\n        for c in candidates:\n            cnt = 0\n            for j in adj[v]:\n                if t[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                ties = [c]\n            elif cnt == best_cnt:\n                ties.append(c)\n        if ties:\n            best_c = random.choice(ties)\n        else:\n            best_c = k + 1\n        t[v] = best_c\n    else:\n        # No conflicts: attempt color-class swap or recolor a random vertex to reduce colors\n        if random.random() < 0.4 and len(set(t)) >= 2:\n            colors = list(set(t))\n            c1, c2 = random.sample(colors, 2)\n            for i in range(n):\n                if t[i] == c1:\n                    t[i] = c2\n                elif t[i] == c2:\n                    t[i] = c1\n        else:\n            v = random.randrange(n)\n            neighbor_colors = {t[j] for j in adj[v]}\n            candidates = [c for c in range(1, k + 1) if c not in neighbor_colors]\n            if not candidates:\n                candidates = [t[v]]\n            t[v] = random.choice(candidates)\n    t = normalize_labels(t)\n    return t\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = normalize(s)\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001185036}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] length 9. Index i corresponds to vertex i+1. Positive integers as color IDs, normalized to contiguous 1..K by first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1000000.0\n    s = normalize_labels(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns a single neighbour solution (list[int]) produced by conflict-aware recolor\n    # plus occasional color-class swap if no conflicts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph (1-indexed in data, convert to 0-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def conflicts_list(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    s = normalize_labels(s)\n    k = max(s) if s else 1\n    confs = conflicts_list(s)\n    t = s[:]\n    if confs:\n        # Focus on a conflicted vertex\n        a, b = random.choice(confs)\n        v = a if random.random() < 0.5 else b\n        neighbor_colors = {t[j] for j in adj[v]}\n        candidates = list(range(1, k + 1))\n        if (k + 1) not in candidates:\n            candidates.append(k + 1)\n        best_c = None\n        best_cnt = 10**9\n        ties = []\n        for c in candidates:\n            cnt = 0\n            for j in adj[v]:\n                if t[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                ties = [c]\n            elif cnt == best_cnt:\n                ties.append(c)\n        if ties:\n            best_c = random.choice(ties)\n        else:\n            best_c = k + 1\n        t[v] = best_c\n    else:\n        # No conflicts: attempt color-class swap or recolor a random vertex to reduce colors\n        if random.random() < 0.4 and len(set(t)) >= 2:\n            colors = list(set(t))\n            c1, c2 = random.sample(colors, 2)\n            for i in range(n):\n                if t[i] == c1:\n                    t[i] = c2\n                elif t[i] == c2:\n                    t[i] = c1\n        else:\n            v = random.randrange(n)\n            neighbor_colors = {t[j] for j in adj[v]}\n            candidates = [c for c in range(1, k + 1) if c not in neighbor_colors]\n            if not candidates:\n                candidates = [t[v]]\n            t[v] = random.choice(candidates)\n    t = normalize_labels(t)\n    return t\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = normalize(s)\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001125175}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a list of 9 positive integers [c1,...,c9], where ci is the color of node i. Lower unique color count is better; edges forbid equal colors on endpoints.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        # Penalize incorrect length heavily\n        length_penalty = 1e6 + abs(len(solution) - n) * 1e5\n        # Attempt to compute objective on whatever is present\n        try:\n            unique_rooms = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                unique_rooms.add(x)\n            obj = float(len(unique_rooms))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    # Validate values and compute objective\n    invalid_vals = 0\n    unique_rooms = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            unique_rooms.add(x)\n    if invalid_vals > 0:\n        return float(1e6 * invalid_vals)\n    obj = float(len(unique_rooms))\n    # Constraint violations: conflicts along edges\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    conflict_penalty_weight = 1000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: description of neighborhood; Movement_Type: description of move strategy\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Repair\/initialize if invalid\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 5) for _ in range(n)]\n        return new_sol, \"REINIT\", \"Random\"\n    sol = list(solution)\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # Choose a target vertex\n    if conflicted:\n        idx = random.choice(conflicted) - 1\n    else:\n        idx = random.randrange(n)\n    # Determine available colors (avoid neighbors' colors)\n    neighbor_colors = {sol[j-1] for j in adj[idx+1]}\n    max_color = max(sol) if sol else 1\n    # Candidate colors: prefer existing colors; allow occasional expansion for escape\n    candidates = [c for c in range(1, max_color+1) if c not in neighbor_colors]\n    if not candidates:\n        # If no conflict-free color among existing, try adding a new color with small prob\n        if random.random() < 0.2:\n            candidates = [max_color + 1]\n        else:\n            # fallback: any existing color different from current\n            candidates = [c for c in range(1, max_color+1) if c != sol[idx]] or [sol[idx]]\n    # Greedy tie-break: pick color minimizing induced conflicts at this vertex\n    best_c = None\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for j in adj[idx+1]:\n            if c == sol[j-1]:\n                conf += 1\n        if (best_conf is None) or (conf < best_conf):\n            best_conf = conf\n            best_c = c\n    new_sol = list(sol)\n    new_sol[idx] = best_c\n    return new_sol, \"RECOLOR\", \"GreedyLocal\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolorings and color compaction\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Initialize if invalid\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid(solution):\n        return [random.randint(1, 5) for _ in range(n)]\n    sol = list(solution)\n    max_color = max(sol)\n    # Number of perturbations proportional to size\n    k = max(3, n \/\/ 2)\n    for _ in range(k):\n        i = random.randrange(n)\n        # Choose a color different from current, within 1..max_color+1 (allow new color)\n        choices = list(range(1, max_color + 2))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            continue\n        sol[i] = random.choice(choices)\n        max_color = max(max_color, sol[i])\n    # Color compaction: relabel colors to 1..m in order of appearance\n    mapping = {}\n    nxt = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n    sol = [mapping[x] for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001126065}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a list of 9 positive integers [c1,...,c9], where ci is the color of node i. Lower unique color count is better; edges forbid equal colors on endpoints.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        # Penalize incorrect length heavily\n        length_penalty = 1e6 + abs(len(solution) - n) * 1e5\n        # Attempt to compute objective on whatever is present\n        try:\n            unique_rooms = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                unique_rooms.add(x)\n            obj = float(len(unique_rooms))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    # Validate values and compute objective\n    invalid_vals = 0\n    unique_rooms = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            unique_rooms.add(x)\n    if invalid_vals > 0:\n        return float(1e6 * invalid_vals)\n    obj = float(len(unique_rooms))\n    # Constraint violations: conflicts along edges\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    conflict_penalty_weight = 1000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: description of neighborhood; Movement_Type: description of move strategy\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Repair\/initialize if invalid\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 5) for _ in range(n)]\n        return new_sol, \"REINIT\", \"Random\"\n    sol = list(solution)\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # Choose a target vertex\n    if conflicted:\n        idx = random.choice(conflicted) - 1\n    else:\n        idx = random.randrange(n)\n    # Determine available colors (avoid neighbors' colors)\n    neighbor_colors = {sol[j-1] for j in adj[idx+1]}\n    max_color = max(sol) if sol else 1\n    # Candidate colors: prefer existing colors; allow occasional expansion for escape\n    candidates = [c for c in range(1, max_color+1) if c not in neighbor_colors]\n    if not candidates:\n        # If no conflict-free color among existing, try adding a new color with small prob\n        if random.random() < 0.2:\n            candidates = [max_color + 1]\n        else:\n            # fallback: any existing color different from current\n            candidates = [c for c in range(1, max_color+1) if c != sol[idx]] or [sol[idx]]\n    # Greedy tie-break: pick color minimizing induced conflicts at this vertex\n    best_c = None\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for j in adj[idx+1]:\n            if c == sol[j-1]:\n                conf += 1\n        if (best_conf is None) or (conf < best_conf):\n            best_conf = conf\n            best_c = c\n    new_sol = list(sol)\n    new_sol[idx] = best_c\n    return new_sol, \"RECOLOR\", \"GreedyLocal\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolorings and color compaction\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Initialize if invalid\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid(solution):\n        return [random.randint(1, 5) for _ in range(n)]\n    sol = list(solution)\n    max_color = max(sol)\n    # Number of perturbations proportional to size\n    k = max(3, n \/\/ 2)\n    for _ in range(k):\n        i = random.randrange(n)\n        # Choose a color different from current, within 1..max_color+1 (allow new color)\n        choices = list(range(1, max_color + 2))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            continue\n        sol[i] = random.choice(choices)\n        max_color = max(max_color, sol[i])\n    # Color compaction: relabel colors to 1..m in order of appearance\n    mapping = {}\n    nxt = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n    sol = [mapping[x] for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000974513}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a list of 9 positive integers [c1,...,c9], where ci is the color of node i. Lower unique color count is better; edges forbid equal colors on endpoints.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        # Penalize incorrect length heavily\n        length_penalty = 1e6 + abs(len(solution) - n) * 1e5\n        # Attempt to compute objective on whatever is present\n        try:\n            unique_rooms = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                unique_rooms.add(x)\n            obj = float(len(unique_rooms))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    # Validate values and compute objective\n    invalid_vals = 0\n    unique_rooms = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            unique_rooms.add(x)\n    if invalid_vals > 0:\n        return float(1e6 * invalid_vals)\n    obj = float(len(unique_rooms))\n    # Constraint violations: conflicts along edges\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    conflict_penalty_weight = 1000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: description of neighborhood; Movement_Type: description of move strategy\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Repair\/initialize if invalid\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 5) for _ in range(n)]\n        return new_sol, \"REINIT\", \"Random\"\n    sol = list(solution)\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # Choose a target vertex\n    if conflicted:\n        idx = random.choice(conflicted) - 1\n    else:\n        idx = random.randrange(n)\n    # Determine available colors (avoid neighbors' colors)\n    neighbor_colors = {sol[j-1] for j in adj[idx+1]}\n    max_color = max(sol) if sol else 1\n    # Candidate colors: prefer existing colors; allow occasional expansion for escape\n    candidates = [c for c in range(1, max_color+1) if c not in neighbor_colors]\n    if not candidates:\n        # If no conflict-free color among existing, try adding a new color with small prob\n        if random.random() < 0.2:\n            candidates = [max_color + 1]\n        else:\n            # fallback: any existing color different from current\n            candidates = [c for c in range(1, max_color+1) if c != sol[idx]] or [sol[idx]]\n    # Greedy tie-break: pick color minimizing induced conflicts at this vertex\n    best_c = None\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for j in adj[idx+1]:\n            if c == sol[j-1]:\n                conf += 1\n        if (best_conf is None) or (conf < best_conf):\n            best_conf = conf\n            best_c = c\n    new_sol = list(sol)\n    new_sol[idx] = best_c\n    return new_sol, \"RECOLOR\", \"GreedyLocal\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolorings and color compaction\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Initialize if invalid\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid(solution):\n        return [random.randint(1, 5) for _ in range(n)]\n    sol = list(solution)\n    max_color = max(sol)\n    # Number of perturbations proportional to size\n    k = max(3, n \/\/ 2)\n    for _ in range(k):\n        i = random.randrange(n)\n        # Choose a color different from current, within 1..max_color+1 (allow new color)\n        choices = list(range(1, max_color + 2))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            continue\n        sol[i] = random.choice(choices)\n        max_color = max(max_color, sol[i])\n    # Color compaction: relabel colors to 1..m in order of appearance\n    mapping = {}\n    nxt = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n    sol = [mapping[x] for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000953472}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a Python list of 9 positive integers [c1,...,c9], where ci is the color assigned to node i (i in {1..9}). Colors are labels; solutions are normalized to a compact palette 1..k after moves.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != n:\n        length_penalty = 1_000_000.0 + float(abs(len(solution) - n) * 100_000)\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                uniq.add(x)\n            obj = float(len(uniq))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return float(1_000_000.0 * invalid_vals)\n    # Objective: number of used colors\n    obj = float(len(uniq))\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_count_at(sol, v, adj):\n        c = sol[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if sol[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        # Build induced subgraph of colors {a,b} and get the component containing start_v\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        # Swap colors on the component\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(new_sol), \"REINIT\", \"Random\"\n\n    sol = list(solution)\n    adj = build_adj()\n\n    # Determine conflicts per vertex\n    conflicts_per_v = {i: 0 for i in range(1, n+1)}\n    total_conf = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u] += 1\n            conflicts_per_v[v] += 1\n            total_conf += 1\n\n    # Select target vertex: prioritize most conflicted; tie-break by degree\n    if total_conf > 0:\n        max_conf = max(conflicts_per_v.values())\n        candidates = [v for v, c in conflicts_per_v.items() if c == max_conf]\n        candidates.sort(key=lambda v: -len(adj[v]))\n        target = candidates[0]\n    else:\n        # No conflicts: focus on potential color reduction by recoloring a high-degree vertex\n        target = max(range(1, n+1), key=lambda v: len(adj[v]))\n\n    current_color = sol[target-1]\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    # Attempt greedy recolor to existing colors avoiding neighbor colors\n    neighbor_colors = {sol[u-1] for u in adj[target]}\n    candidates = [c for c in palette if c != current_color and c not in neighbor_colors]\n    # Prefer lower colors to encourage palette compaction\n    candidates.sort()\n\n    if candidates:\n        # Choose color minimizing new local conflicts (0 by construction), fallback to lowest\n        chosen = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = chosen\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"RECOLOR\", \"TargetedGreedy\"\n\n    # If recolor failed or identical, try a Kempe chain swap with a different color\n    if len(palette) >= 2:\n        # Pick second color: prefer one causing many neighbor matches\n        color_freq_neighbors = {}\n        for c in palette:\n            if c == current_color:\n                continue\n            color_freq_neighbors[c] = sum(1 for u in adj[target] if sol[u-1] == c)\n        if color_freq_neighbors:\n            other_color = max(color_freq_neighbors.items(), key=lambda kv: kv[1])[0]\n        else:\n            other_color = random.choice([c for c in palette if c != current_color])\n        new_sol = kempe_swap(sol, current_color, other_color, target, adj)\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"KEMPE_SWAP\", \"ColorPairComponent\"\n\n    # As a last resort, change to a different existing color (even if it may introduce conflicts)\n    fallback_colors = [c for c in palette if c != current_color]\n    if not fallback_colors:\n        fallback_colors = [max_color + 1]\n    new_color = random.choice(fallback_colors)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    # Guarantee change\n    if new_sol == sol:\n        # Flip a random different vertex's color as well\n        idx = random.randrange(n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = random.choice(alt_colors)\n        new_sol = normalize(new_sol)\n    return new_sol, \"RECOLOR\", \"FallbackDifferent\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n    adj = build_adj()\n    palette = sorted(set(sol))\n\n    # 1) Apply t random Kempe swaps\n    t = 3  # bounded strength\n    for _ in range(t):\n        if len(palette) < 2:\n            break\n        # pick a random vertex and a distinct color present in palette\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        other_choices = [c for c in palette if c != curr]\n        if not other_choices:\n            continue\n        other = random.choice(other_choices)\n        sol = kempe_swap(sol, curr, other, v, adj)\n        palette = sorted(set(sol))\n\n    # 2) Randomly recolor a few vertices to diversify\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n    for _ in range(k):\n        i = random.randrange(n)\n        choices = list(range(1, max_color + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_color + 1]\n        sol[i] = random.choice(choices)\n        palette = sorted(set(sol))\n        max_color = max(palette)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001826863}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a Python list of 9 positive integers [c1,...,c9], where ci is the color assigned to node i (i in {1..9}). Colors are labels; solutions are normalized to a compact palette 1..k after moves.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != n:\n        length_penalty = 1_000_000.0 + float(abs(len(solution) - n) * 100_000)\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                uniq.add(x)\n            obj = float(len(uniq))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return float(1_000_000.0 * invalid_vals)\n    # Objective: number of used colors\n    obj = float(len(uniq))\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_count_at(sol, v, adj):\n        c = sol[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if sol[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        # Build induced subgraph of colors {a,b} and get the component containing start_v\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        # Swap colors on the component\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(new_sol), \"REINIT\", \"Random\"\n\n    sol = list(solution)\n    adj = build_adj()\n\n    # Determine conflicts per vertex\n    conflicts_per_v = {i: 0 for i in range(1, n+1)}\n    total_conf = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u] += 1\n            conflicts_per_v[v] += 1\n            total_conf += 1\n\n    # Select target vertex: prioritize most conflicted; tie-break by degree\n    if total_conf > 0:\n        max_conf = max(conflicts_per_v.values())\n        candidates = [v for v, c in conflicts_per_v.items() if c == max_conf]\n        candidates.sort(key=lambda v: -len(adj[v]))\n        target = candidates[0]\n    else:\n        # No conflicts: focus on potential color reduction by recoloring a high-degree vertex\n        target = max(range(1, n+1), key=lambda v: len(adj[v]))\n\n    current_color = sol[target-1]\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    # Attempt greedy recolor to existing colors avoiding neighbor colors\n    neighbor_colors = {sol[u-1] for u in adj[target]}\n    candidates = [c for c in palette if c != current_color and c not in neighbor_colors]\n    # Prefer lower colors to encourage palette compaction\n    candidates.sort()\n\n    if candidates:\n        # Choose color minimizing new local conflicts (0 by construction), fallback to lowest\n        chosen = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = chosen\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"RECOLOR\", \"TargetedGreedy\"\n\n    # If recolor failed or identical, try a Kempe chain swap with a different color\n    if len(palette) >= 2:\n        # Pick second color: prefer one causing many neighbor matches\n        color_freq_neighbors = {}\n        for c in palette:\n            if c == current_color:\n                continue\n            color_freq_neighbors[c] = sum(1 for u in adj[target] if sol[u-1] == c)\n        if color_freq_neighbors:\n            other_color = max(color_freq_neighbors.items(), key=lambda kv: kv[1])[0]\n        else:\n            other_color = random.choice([c for c in palette if c != current_color])\n        new_sol = kempe_swap(sol, current_color, other_color, target, adj)\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"KEMPE_SWAP\", \"ColorPairComponent\"\n\n    # As a last resort, change to a different existing color (even if it may introduce conflicts)\n    fallback_colors = [c for c in palette if c != current_color]\n    if not fallback_colors:\n        fallback_colors = [max_color + 1]\n    new_color = random.choice(fallback_colors)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    # Guarantee change\n    if new_sol == sol:\n        # Flip a random different vertex's color as well\n        idx = random.randrange(n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = random.choice(alt_colors)\n        new_sol = normalize(new_sol)\n    return new_sol, \"RECOLOR\", \"FallbackDifferent\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n    adj = build_adj()\n    palette = sorted(set(sol))\n\n    # 1) Apply t random Kempe swaps\n    t = 3  # bounded strength\n    for _ in range(t):\n        if len(palette) < 2:\n            break\n        # pick a random vertex and a distinct color present in palette\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        other_choices = [c for c in palette if c != curr]\n        if not other_choices:\n            continue\n        other = random.choice(other_choices)\n        sol = kempe_swap(sol, curr, other, v, adj)\n        palette = sorted(set(sol))\n\n    # 2) Randomly recolor a few vertices to diversify\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n    for _ in range(k):\n        i = random.randrange(n)\n        choices = list(range(1, max_color + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_color + 1]\n        sol[i] = random.choice(choices)\n        palette = sorted(set(sol))\n        max_color = max(palette)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001617461}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a Python list of 9 positive integers [c1,...,c9], where ci is the color assigned to node i (i in {1..9}). Colors are labels; solutions are normalized to a compact palette 1..k after moves.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != n:\n        length_penalty = 1_000_000.0 + float(abs(len(solution) - n) * 100_000)\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                uniq.add(x)\n            obj = float(len(uniq))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return float(1_000_000.0 * invalid_vals)\n    # Objective: number of used colors\n    obj = float(len(uniq))\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_count_at(sol, v, adj):\n        c = sol[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if sol[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        # Build induced subgraph of colors {a,b} and get the component containing start_v\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        # Swap colors on the component\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(new_sol), \"REINIT\", \"Random\"\n\n    sol = list(solution)\n    adj = build_adj()\n\n    # Determine conflicts per vertex\n    conflicts_per_v = {i: 0 for i in range(1, n+1)}\n    total_conf = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u] += 1\n            conflicts_per_v[v] += 1\n            total_conf += 1\n\n    # Select target vertex: prioritize most conflicted; tie-break by degree\n    if total_conf > 0:\n        max_conf = max(conflicts_per_v.values())\n        candidates = [v for v, c in conflicts_per_v.items() if c == max_conf]\n        candidates.sort(key=lambda v: -len(adj[v]))\n        target = candidates[0]\n    else:\n        # No conflicts: focus on potential color reduction by recoloring a high-degree vertex\n        target = max(range(1, n+1), key=lambda v: len(adj[v]))\n\n    current_color = sol[target-1]\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    # Attempt greedy recolor to existing colors avoiding neighbor colors\n    neighbor_colors = {sol[u-1] for u in adj[target]}\n    candidates = [c for c in palette if c != current_color and c not in neighbor_colors]\n    # Prefer lower colors to encourage palette compaction\n    candidates.sort()\n\n    if candidates:\n        # Choose color minimizing new local conflicts (0 by construction), fallback to lowest\n        chosen = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = chosen\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"RECOLOR\", \"TargetedGreedy\"\n\n    # If recolor failed or identical, try a Kempe chain swap with a different color\n    if len(palette) >= 2:\n        # Pick second color: prefer one causing many neighbor matches\n        color_freq_neighbors = {}\n        for c in palette:\n            if c == current_color:\n                continue\n            color_freq_neighbors[c] = sum(1 for u in adj[target] if sol[u-1] == c)\n        if color_freq_neighbors:\n            other_color = max(color_freq_neighbors.items(), key=lambda kv: kv[1])[0]\n        else:\n            other_color = random.choice([c for c in palette if c != current_color])\n        new_sol = kempe_swap(sol, current_color, other_color, target, adj)\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"KEMPE_SWAP\", \"ColorPairComponent\"\n\n    # As a last resort, change to a different existing color (even if it may introduce conflicts)\n    fallback_colors = [c for c in palette if c != current_color]\n    if not fallback_colors:\n        fallback_colors = [max_color + 1]\n    new_color = random.choice(fallback_colors)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    # Guarantee change\n    if new_sol == sol:\n        # Flip a random different vertex's color as well\n        idx = random.randrange(n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = random.choice(alt_colors)\n        new_sol = normalize(new_sol)\n    return new_sol, \"RECOLOR\", \"FallbackDifferent\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n    adj = build_adj()\n    palette = sorted(set(sol))\n\n    # 1) Apply t random Kempe swaps\n    t = 3  # bounded strength\n    for _ in range(t):\n        if len(palette) < 2:\n            break\n        # pick a random vertex and a distinct color present in palette\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        other_choices = [c for c in palette if c != curr]\n        if not other_choices:\n            continue\n        other = random.choice(other_choices)\n        sol = kempe_swap(sol, curr, other, v, adj)\n        palette = sorted(set(sol))\n\n    # 2) Randomly recolor a few vertices to diversify\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n    for _ in range(k):\n        i = random.randrange(n)\n        choices = list(range(1, max_color + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_color + 1]\n        sol[i] = random.choice(choices)\n        palette = sorted(set(sol))\n        max_color = max(palette)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001530199}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses DSATUR-driven targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol, len(comp)\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 4\n        new_sol = [random.randint(1, base_k) for _ in range(n)]\n        return normalize(new_sol), (\"REINIT\", \"RandomPaletteK4\")\n\n    sol = list(solution)\n\n    # DSATUR-like vertex selection\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    def dsatur_vertex(sol):\n        # Saturation degree: number of distinct neighbor colors among neighbors\n        best_v = 1\n        best_key = (-1, -1)  # larger is better; we will compare tuples (sat, deg)\n        for v in range(1, n+1):\n            nb_cols = {sol[u-1] for u in adj[v]}\n            sat = len(nb_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        return best_v\n\n    # Strategy: if conflicts exist, pick the most conflicted with DSATUR tiebreak; else try to eliminate highest color\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        if len(cand) > 1:\n            # Choose by saturation degree then degree\n            best = None\n            best_key = (-1, -1)\n            for v in cand:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                sat = len(nb_cols)\n                deg = len(adj[v])\n                key = (sat, deg)\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = cand[0]\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max_color\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        if kmax_vertices:\n            # break ties by DSATUR\n            best = None\n            best_key = (-1, -1)\n            for v in kmax_vertices:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                key = (len(nb_cols), len(adj[v]))\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = dsatur_vertex(sol)\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap with the color that maximizes component size around target\n    if len(palette) >= 2:\n        best_other = None\n        best_size = -1\n        best_swap_sol = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            swp_sol, comp_size = kempe_swap(sol, curr_c, c, target)\n            if comp_size > best_size and swp_sol != sol:\n                best_size = comp_size\n                best_other = c\n                best_swap_sol = swp_sol\n        if best_swap_sol is not None:\n            best_swap_sol = normalize(best_swap_sol)\n            if best_swap_sol != sol:\n                return best_swap_sol, (\"KEMPE_SWAP\", f\"a{curr_c}_b{best_other}_size{best_size}\")\n\n    # 3) Fallback: recolor to another existing color (may create conflicts), prefer lowest different\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max_color + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a second vertex\n        idx = (target % n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = alt_colors[0]\n        new_sol = normalize(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps\n    t = 3\n    palette = sorted(set(sol))\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = random.choice(others)\n        sol = kempe_swap(sol, curr, other, v)\n\n    # 2) Random recolors\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    for _ in range(k):\n        i = random.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = random.choice(choices)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001881163}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses DSATUR-driven targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol, len(comp)\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 4\n        new_sol = [random.randint(1, base_k) for _ in range(n)]\n        return normalize(new_sol), (\"REINIT\", \"RandomPaletteK4\")\n\n    sol = list(solution)\n\n    # DSATUR-like vertex selection\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    def dsatur_vertex(sol):\n        # Saturation degree: number of distinct neighbor colors among neighbors\n        best_v = 1\n        best_key = (-1, -1)  # larger is better; we will compare tuples (sat, deg)\n        for v in range(1, n+1):\n            nb_cols = {sol[u-1] for u in adj[v]}\n            sat = len(nb_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        return best_v\n\n    # Strategy: if conflicts exist, pick the most conflicted with DSATUR tiebreak; else try to eliminate highest color\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        if len(cand) > 1:\n            # Choose by saturation degree then degree\n            best = None\n            best_key = (-1, -1)\n            for v in cand:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                sat = len(nb_cols)\n                deg = len(adj[v])\n                key = (sat, deg)\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = cand[0]\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max_color\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        if kmax_vertices:\n            # break ties by DSATUR\n            best = None\n            best_key = (-1, -1)\n            for v in kmax_vertices:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                key = (len(nb_cols), len(adj[v]))\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = dsatur_vertex(sol)\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap with the color that maximizes component size around target\n    if len(palette) >= 2:\n        best_other = None\n        best_size = -1\n        best_swap_sol = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            swp_sol, comp_size = kempe_swap(sol, curr_c, c, target)\n            if comp_size > best_size and swp_sol != sol:\n                best_size = comp_size\n                best_other = c\n                best_swap_sol = swp_sol\n        if best_swap_sol is not None:\n            best_swap_sol = normalize(best_swap_sol)\n            if best_swap_sol != sol:\n                return best_swap_sol, (\"KEMPE_SWAP\", f\"a{curr_c}_b{best_other}_size{best_size}\")\n\n    # 3) Fallback: recolor to another existing color (may create conflicts), prefer lowest different\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max_color + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a second vertex\n        idx = (target % n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = alt_colors[0]\n        new_sol = normalize(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps\n    t = 3\n    palette = sorted(set(sol))\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = random.choice(others)\n        sol = kempe_swap(sol, curr, other, v)\n\n    # 2) Random recolors\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    for _ in range(k):\n        i = random.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = random.choice(choices)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001669281}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses DSATUR-driven targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol, len(comp)\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 4\n        new_sol = [random.randint(1, base_k) for _ in range(n)]\n        return normalize(new_sol), (\"REINIT\", \"RandomPaletteK4\")\n\n    sol = list(solution)\n\n    # DSATUR-like vertex selection\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    def dsatur_vertex(sol):\n        # Saturation degree: number of distinct neighbor colors among neighbors\n        best_v = 1\n        best_key = (-1, -1)  # larger is better; we will compare tuples (sat, deg)\n        for v in range(1, n+1):\n            nb_cols = {sol[u-1] for u in adj[v]}\n            sat = len(nb_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        return best_v\n\n    # Strategy: if conflicts exist, pick the most conflicted with DSATUR tiebreak; else try to eliminate highest color\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        if len(cand) > 1:\n            # Choose by saturation degree then degree\n            best = None\n            best_key = (-1, -1)\n            for v in cand:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                sat = len(nb_cols)\n                deg = len(adj[v])\n                key = (sat, deg)\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = cand[0]\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max_color\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        if kmax_vertices:\n            # break ties by DSATUR\n            best = None\n            best_key = (-1, -1)\n            for v in kmax_vertices:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                key = (len(nb_cols), len(adj[v]))\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = dsatur_vertex(sol)\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap with the color that maximizes component size around target\n    if len(palette) >= 2:\n        best_other = None\n        best_size = -1\n        best_swap_sol = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            swp_sol, comp_size = kempe_swap(sol, curr_c, c, target)\n            if comp_size > best_size and swp_sol != sol:\n                best_size = comp_size\n                best_other = c\n                best_swap_sol = swp_sol\n        if best_swap_sol is not None:\n            best_swap_sol = normalize(best_swap_sol)\n            if best_swap_sol != sol:\n                return best_swap_sol, (\"KEMPE_SWAP\", f\"a{curr_c}_b{best_other}_size{best_size}\")\n\n    # 3) Fallback: recolor to another existing color (may create conflicts), prefer lowest different\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max_color + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a second vertex\n        idx = (target % n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = alt_colors[0]\n        new_sol = normalize(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps\n    t = 3\n    palette = sorted(set(sol))\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = random.choice(others)\n        sol = kempe_swap(sol, curr, other, v)\n\n    # 2) Random recolors\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    for _ in range(k):\n        i = random.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = random.choice(choices)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001680941}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 5\n        new_sol = [rng.randint(1, base_k) for _ in range(n)]\n        return compress_palette(new_sol), (\"REINIT\", \"RandomPaletteK5\")\n\n    sol = list(solution)\n\n    # Analyze current state\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n\n    # Select target vertex\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        # Tie-break by saturation degree then degree\n        best = None\n        best_key = (-1, -1)\n        for v in cand:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max(palette)\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        # break ties by saturation then degree\n        best = None\n        best_key = (-1, -1)\n        for v in kmax_vertices:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = compress_palette(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap: choose color that most reduces conflicts (evaluated locally by full check, small n)\n    if len(palette) >= 2:\n        best_swap = None\n        best_score = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            comp = kempe_component(sol, curr_c, c, target)\n            if not comp:\n                continue\n            swp_sol = apply_kempe(sol, comp, curr_c, c)\n            # Evaluate conflict count only (faster than full evaluate)\n            conf_after, _ = count_conflicts(swp_sol)\n            if best_score is None or conf_after < best_score:\n                best_score = conf_after\n                best_swap = swp_sol\n        if best_swap is not None and best_swap != sol:\n            best_swap = compress_palette(best_swap)\n            if best_swap != sol:\n                return best_swap, (\"KEMPE_SWAP\", \"BestConflictDelta\")\n\n    # 3) Fallback: recolor to another color (may create conflicts), prefer lowest different; ensure non-null move\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max(palette) + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = compress_palette(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a different vertex safely\n        indices = [i for i in range(n) if (i+1) != target]\n        if not indices:\n            # Should not happen for n>=2, but guard anyway\n            new_sol[target-1] = max(new_sol) + 1\n        else:\n            i = rng.choice(indices)\n            alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[i]]\n            if not alt_colors:\n                alt_colors = [max(new_sol) + 1]\n            new_sol[i] = alt_colors[0]\n            new_sol = compress_palette(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compression.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Repair if invalid\n    if not valid(solution):\n        sol = [rng.randint(1, 5) for _ in range(n)]\n        return compress_palette(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps biased by high colors\n    t = 3\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        # pick a start vertex among those with max color with 50% prob\n        if rng.random() < 0.5:\n            kmax = max(palette)\n            cand = [v for v in range(1, n+1) if sol[v-1] == kmax]\n            v = rng.choice(cand) if cand else rng.randrange(1, n+1)\n        else:\n            v = rng.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = rng.choice(others)\n        comp = kempe_component(sol, curr, other, v)\n        if comp:\n            sol = apply_kempe(sol, comp, curr, other)\n\n    # 2) Random recolors of k vertices\n    k = 4\n    for _ in range(k):\n        i = rng.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = rng.choice(choices)\n\n    # 3) Compress palette\n    sol = compress_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001904643}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 5\n        new_sol = [rng.randint(1, base_k) for _ in range(n)]\n        return compress_palette(new_sol), (\"REINIT\", \"RandomPaletteK5\")\n\n    sol = list(solution)\n\n    # Analyze current state\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n\n    # Select target vertex\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        # Tie-break by saturation degree then degree\n        best = None\n        best_key = (-1, -1)\n        for v in cand:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max(palette)\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        # break ties by saturation then degree\n        best = None\n        best_key = (-1, -1)\n        for v in kmax_vertices:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = compress_palette(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap: choose color that most reduces conflicts (evaluated locally by full check, small n)\n    if len(palette) >= 2:\n        best_swap = None\n        best_score = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            comp = kempe_component(sol, curr_c, c, target)\n            if not comp:\n                continue\n            swp_sol = apply_kempe(sol, comp, curr_c, c)\n            # Evaluate conflict count only (faster than full evaluate)\n            conf_after, _ = count_conflicts(swp_sol)\n            if best_score is None or conf_after < best_score:\n                best_score = conf_after\n                best_swap = swp_sol\n        if best_swap is not None and best_swap != sol:\n            best_swap = compress_palette(best_swap)\n            if best_swap != sol:\n                return best_swap, (\"KEMPE_SWAP\", \"BestConflictDelta\")\n\n    # 3) Fallback: recolor to another color (may create conflicts), prefer lowest different; ensure non-null move\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max(palette) + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = compress_palette(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a different vertex safely\n        indices = [i for i in range(n) if (i+1) != target]\n        if not indices:\n            # Should not happen for n>=2, but guard anyway\n            new_sol[target-1] = max(new_sol) + 1\n        else:\n            i = rng.choice(indices)\n            alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[i]]\n            if not alt_colors:\n                alt_colors = [max(new_sol) + 1]\n            new_sol[i] = alt_colors[0]\n            new_sol = compress_palette(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compression.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Repair if invalid\n    if not valid(solution):\n        sol = [rng.randint(1, 5) for _ in range(n)]\n        return compress_palette(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps biased by high colors\n    t = 3\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        # pick a start vertex among those with max color with 50% prob\n        if rng.random() < 0.5:\n            kmax = max(palette)\n            cand = [v for v in range(1, n+1) if sol[v-1] == kmax]\n            v = rng.choice(cand) if cand else rng.randrange(1, n+1)\n        else:\n            v = rng.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = rng.choice(others)\n        comp = kempe_component(sol, curr, other, v)\n        if comp:\n            sol = apply_kempe(sol, comp, curr, other)\n\n    # 2) Random recolors of k vertices\n    k = 4\n    for _ in range(k):\n        i = rng.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = rng.choice(choices)\n\n    # 3) Compress palette\n    sol = compress_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001607709}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 5\n        new_sol = [rng.randint(1, base_k) for _ in range(n)]\n        return compress_palette(new_sol), (\"REINIT\", \"RandomPaletteK5\")\n\n    sol = list(solution)\n\n    # Analyze current state\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n\n    # Select target vertex\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        # Tie-break by saturation degree then degree\n        best = None\n        best_key = (-1, -1)\n        for v in cand:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max(palette)\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        # break ties by saturation then degree\n        best = None\n        best_key = (-1, -1)\n        for v in kmax_vertices:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = compress_palette(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap: choose color that most reduces conflicts (evaluated locally by full check, small n)\n    if len(palette) >= 2:\n        best_swap = None\n        best_score = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            comp = kempe_component(sol, curr_c, c, target)\n            if not comp:\n                continue\n            swp_sol = apply_kempe(sol, comp, curr_c, c)\n            # Evaluate conflict count only (faster than full evaluate)\n            conf_after, _ = count_conflicts(swp_sol)\n            if best_score is None or conf_after < best_score:\n                best_score = conf_after\n                best_swap = swp_sol\n        if best_swap is not None and best_swap != sol:\n            best_swap = compress_palette(best_swap)\n            if best_swap != sol:\n                return best_swap, (\"KEMPE_SWAP\", \"BestConflictDelta\")\n\n    # 3) Fallback: recolor to another color (may create conflicts), prefer lowest different; ensure non-null move\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max(palette) + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = compress_palette(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a different vertex safely\n        indices = [i for i in range(n) if (i+1) != target]\n        if not indices:\n            # Should not happen for n>=2, but guard anyway\n            new_sol[target-1] = max(new_sol) + 1\n        else:\n            i = rng.choice(indices)\n            alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[i]]\n            if not alt_colors:\n                alt_colors = [max(new_sol) + 1]\n            new_sol[i] = alt_colors[0]\n            new_sol = compress_palette(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compression.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Repair if invalid\n    if not valid(solution):\n        sol = [rng.randint(1, 5) for _ in range(n)]\n        return compress_palette(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps biased by high colors\n    t = 3\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        # pick a start vertex among those with max color with 50% prob\n        if rng.random() < 0.5:\n            kmax = max(palette)\n            cand = [v for v in range(1, n+1) if sol[v-1] == kmax]\n            v = rng.choice(cand) if cand else rng.randrange(1, n+1)\n        else:\n            v = rng.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = rng.choice(others)\n        comp = kempe_component(sol, curr, other, v)\n        if comp:\n            sol = apply_kempe(sol, comp, curr, other)\n\n    # 2) Random recolors of k vertices\n    k = 4\n    for _ in range(k):\n        i = rng.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = rng.choice(choices)\n\n    # 3) Compress palette\n    sol = compress_palette(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001550429}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9, where index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    if invalid > 0 or conflicts > 0:\n        return 10**6 + 1000 * invalid + conflicts\n    return float(max_color)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random valid-shaped neighbor if malformed\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return new_sol, \"NB_InitFix\", \"RandomInit\"\n    cur = list(solution)\n    # Compute conflicts and auxiliary structures\n    conflicts = set()\n    for (u, v) in edges:\n        if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Strategy selection\n    if conflicts:\n        # Recolor a conflicting vertex towards lower colors if possible\n        idx = random.choice(list(conflicts))\n        # Try a color different from neighbors, biased to <= max_color\n        neighbor_colors = set(cur[v-1] for (u,v) in edges if u-1 == idx) | set(cur[u-1] for (u,v) in edges if v-1 == idx)\n        # Candidate colors: 1..max_color (ensure positive)\n        candidates = [c for c in range(1, max(2, max_color + 1)) if c not in neighbor_colors]\n        if not candidates:\n            candidates = list(range(1, max(2, max_color + 1)))\n        new_color = random.choice(candidates)\n        cur[idx] = int(new_color)\n        return cur, \"NB_Recolor\", \"ConflictVertex\"\n    else:\n        # Feasible: try to reduce the number of colors by modifying a max-color vertex\n        max_nodes = [i for i,c in enumerate(cur) if c == max_color]\n        if max_nodes and max_color > 1:\n            idx = random.choice(max_nodes)\n            # Prefer a lower color\n            target_pool = list(range(1, max_color)) or [max_color]\n            new_color = random.choice(target_pool)\n            cur[idx] = int(new_color)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n        # Otherwise small swap between two vertices' colors\n        i, j = random.sample(range(n), 2)\n        cur[i], cur[j] = cur[j], cur[i]\n        return cur, \"NB_Swap\", \"SwapTwoColors\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [random.randint(1, 4) for _ in range(n)]\n    cur = list(solution)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Two perturbation modes\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor a random subset (2..4) vertices to colors in 1..max_color+1\n        k = random.randint(2, 4)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            cur[idx] = int(random.randint(1, max(2, max_color + 1)))\n        return cur\n    else:\n        # Relabel colors by a random permutation of the used palette\n        used = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if not used:\n            return [random.randint(1, 4) for _ in range(n)]\n        perm = used[:]\n        random.shuffle(perm)\n        mapping = {u: p for u, p in zip(used, perm)}\n        cur = [mapping.get(c, c) if isinstance(c, int) and c > 0 else 1 for c in cur]\n        return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001159264}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9, where index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    if invalid > 0 or conflicts > 0:\n        return 10**6 + 1000 * invalid + conflicts\n    return float(max_color)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random valid-shaped neighbor if malformed\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return new_sol, \"NB_InitFix\", \"RandomInit\"\n    cur = list(solution)\n    # Compute conflicts and auxiliary structures\n    conflicts = set()\n    for (u, v) in edges:\n        if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Strategy selection\n    if conflicts:\n        # Recolor a conflicting vertex towards lower colors if possible\n        idx = random.choice(list(conflicts))\n        # Try a color different from neighbors, biased to <= max_color\n        neighbor_colors = set(cur[v-1] for (u,v) in edges if u-1 == idx) | set(cur[u-1] for (u,v) in edges if v-1 == idx)\n        # Candidate colors: 1..max_color (ensure positive)\n        candidates = [c for c in range(1, max(2, max_color + 1)) if c not in neighbor_colors]\n        if not candidates:\n            candidates = list(range(1, max(2, max_color + 1)))\n        new_color = random.choice(candidates)\n        cur[idx] = int(new_color)\n        return cur, \"NB_Recolor\", \"ConflictVertex\"\n    else:\n        # Feasible: try to reduce the number of colors by modifying a max-color vertex\n        max_nodes = [i for i,c in enumerate(cur) if c == max_color]\n        if max_nodes and max_color > 1:\n            idx = random.choice(max_nodes)\n            # Prefer a lower color\n            target_pool = list(range(1, max_color)) or [max_color]\n            new_color = random.choice(target_pool)\n            cur[idx] = int(new_color)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n        # Otherwise small swap between two vertices' colors\n        i, j = random.sample(range(n), 2)\n        cur[i], cur[j] = cur[j], cur[i]\n        return cur, \"NB_Swap\", \"SwapTwoColors\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [random.randint(1, 4) for _ in range(n)]\n    cur = list(solution)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Two perturbation modes\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor a random subset (2..4) vertices to colors in 1..max_color+1\n        k = random.randint(2, 4)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            cur[idx] = int(random.randint(1, max(2, max_color + 1)))\n        return cur\n    else:\n        # Relabel colors by a random permutation of the used palette\n        used = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if not used:\n            return [random.randint(1, 4) for _ in range(n)]\n        perm = used[:]\n        random.shuffle(perm)\n        mapping = {u: p for u, p in zip(used, perm)}\n        cur = [mapping.get(c, c) if isinstance(c, int) and c > 0 else 1 for c in cur]\n        return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001012842}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9, where index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    if invalid > 0 or conflicts > 0:\n        return 10**6 + 1000 * invalid + conflicts\n    return float(max_color)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random valid-shaped neighbor if malformed\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return new_sol, \"NB_InitFix\", \"RandomInit\"\n    cur = list(solution)\n    # Compute conflicts and auxiliary structures\n    conflicts = set()\n    for (u, v) in edges:\n        if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Strategy selection\n    if conflicts:\n        # Recolor a conflicting vertex towards lower colors if possible\n        idx = random.choice(list(conflicts))\n        # Try a color different from neighbors, biased to <= max_color\n        neighbor_colors = set(cur[v-1] for (u,v) in edges if u-1 == idx) | set(cur[u-1] for (u,v) in edges if v-1 == idx)\n        # Candidate colors: 1..max_color (ensure positive)\n        candidates = [c for c in range(1, max(2, max_color + 1)) if c not in neighbor_colors]\n        if not candidates:\n            candidates = list(range(1, max(2, max_color + 1)))\n        new_color = random.choice(candidates)\n        cur[idx] = int(new_color)\n        return cur, \"NB_Recolor\", \"ConflictVertex\"\n    else:\n        # Feasible: try to reduce the number of colors by modifying a max-color vertex\n        max_nodes = [i for i,c in enumerate(cur) if c == max_color]\n        if max_nodes and max_color > 1:\n            idx = random.choice(max_nodes)\n            # Prefer a lower color\n            target_pool = list(range(1, max_color)) or [max_color]\n            new_color = random.choice(target_pool)\n            cur[idx] = int(new_color)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n        # Otherwise small swap between two vertices' colors\n        i, j = random.sample(range(n), 2)\n        cur[i], cur[j] = cur[j], cur[i]\n        return cur, \"NB_Swap\", \"SwapTwoColors\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [random.randint(1, 4) for _ in range(n)]\n    cur = list(solution)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Two perturbation modes\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor a random subset (2..4) vertices to colors in 1..max_color+1\n        k = random.randint(2, 4)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            cur[idx] = int(random.randint(1, max(2, max_color + 1)))\n        return cur\n    else:\n        # Relabel colors by a random permutation of the used palette\n        used = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if not used:\n            return [random.randint(1, 4) for _ in range(n)]\n        perm = used[:]\n        random.shuffle(perm)\n        mapping = {u: p for u, p in zip(used, perm)}\n        cur = [mapping.get(c, c) if isinstance(c, int) and c > 0 else 1 for c in cur]\n        return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000983322}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9. Index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        return float(conflicts * 10**6 + invalid * 10**3 + max_color if max_color > 0 else conflicts * 10**6 + invalid * 10**3 + 10**2)\n    return float(max_color)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        conflicted = set()\n        for (u,v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor a conflicted vertex to the smallest feasible color (<= max_color+1)\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        used = neighbor_colors_of(idx, cur, adj)\n        # Try colors 1..max_color first, then allow max_color+1 if needed\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflict\"\n        # Fallback (should not happen): random color\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = random.choice(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, try relocating a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        # choose least used feasible to balance classes\n        feasible.sort(key=lambda c: color_usage.get(c, 0))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification (keeps feasibility)\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) within palette 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = list(range(n)) if len(indices) < 2 else indices\n        t = random.randint(2, min(4, len(pool))) if pool else random.randint(2, 4)\n        chosen = random.sample(pool if pool else list(range(n)), t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx]}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001567359}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9. Index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        return float(conflicts * 10**6 + invalid * 10**3 + max_color if max_color > 0 else conflicts * 10**6 + invalid * 10**3 + 10**2)\n    return float(max_color)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        conflicted = set()\n        for (u,v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor a conflicted vertex to the smallest feasible color (<= max_color+1)\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        used = neighbor_colors_of(idx, cur, adj)\n        # Try colors 1..max_color first, then allow max_color+1 if needed\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflict\"\n        # Fallback (should not happen): random color\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = random.choice(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, try relocating a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        # choose least used feasible to balance classes\n        feasible.sort(key=lambda c: color_usage.get(c, 0))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification (keeps feasibility)\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) within palette 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = list(range(n)) if len(indices) < 2 else indices\n        t = random.randint(2, min(4, len(pool))) if pool else random.randint(2, 4)\n        chosen = random.sample(pool if pool else list(range(n)), t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx]}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001335565}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9. Index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        return float(conflicts * 10**6 + invalid * 10**3 + max_color if max_color > 0 else conflicts * 10**6 + invalid * 10**3 + 10**2)\n    return float(max_color)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        conflicted = set()\n        for (u,v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor a conflicted vertex to the smallest feasible color (<= max_color+1)\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        used = neighbor_colors_of(idx, cur, adj)\n        # Try colors 1..max_color first, then allow max_color+1 if needed\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflict\"\n        # Fallback (should not happen): random color\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = random.choice(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, try relocating a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        # choose least used feasible to balance classes\n        feasible.sort(key=lambda c: color_usage.get(c, 0))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification (keeps feasibility)\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) within palette 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = list(range(n)) if len(indices) < 2 else indices\n        t = random.randint(2, min(4, len(pool))) if pool else random.randint(2, 4)\n        chosen = random.sample(pool if pool else list(range(n)), t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx]}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001266096}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        # Large integer penalties to dominate objective while preserving determinism\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            # bias to smallest feasible color to compress palette\n            cur[idx] = min(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.6:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0017526411}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        # Large integer penalties to dominate objective while preserving determinism\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            # bias to smallest feasible color to compress palette\n            cur[idx] = min(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.6:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001400587}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        # Large integer penalties to dominate objective while preserving determinism\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            # bias to smallest feasible color to compress palette\n            cur[idx] = min(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.6:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001323105}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        # Relabel colors to contiguous 1..k preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    def kempe_chain_swap(cur, a, b, start_idx, adj):\n        # BFS on subgraph induced by colors a and b, swap colors on the connected component containing start_idx\n        target = {a, b}\n        if cur[start_idx] not in target:\n            return None\n        visited = set()\n        stack = [start_idx]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if cur[v] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for w in adj[v]:\n                if cur[w] in target and w not in visited:\n                    stack.append(w)\n        if not comp:\n            return None\n        new_cur = cur[:]\n        for v in comp:\n            new_cur[v] = a if cur[v] == b else b\n        return new_cur\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        new_sol = normalize_palette(new_sol)\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    cur = normalize_palette(cur)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                cur = normalize_palette(cur)\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        # Fallback random recolor\n        cur[idx] = random.randint(1, max_color + 1)\n        cur = normalize_palette(cur)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = min(candidates)\n            cur = normalize_palette(cur)\n            return cur, \"NB_Recolor\", \"ReduceMaxColorGreedy\"\n\n    # Try Kempe-chain between max_color and a lower color\n    if max_color > 1:\n        base = random.choice(max_nodes)\n        for low in random.sample(list(range(1, max_color)), k=min(2, max_color-1)):\n            new_cur = kempe_chain_swap(cur, max_color, low, base, adj)\n            if new_cur is not None and new_cur != cur:\n                new_cur = normalize_palette(new_cur)\n                return new_cur, \"NB_Swap\", \"KempeChain\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        cur = normalize_palette(cur)\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    cur = normalize_palette(cur)\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation and encouraging palette compression\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    cur = normalize_palette(cur)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return normalize_palette(cur)\n    elif mode < 0.8:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n    else:\n        # Attempt merge: map one color class onto another and repair lightly\n        if max_color <= 1:\n            return cur\n        a, b = random.sample(list(range(1, max_color + 1)), 2)\n        merged = [a if x == b else x for x in cur]\n        # Light repair: for each conflict edge, push one endpoint to a feasible color if possible\n        adj = adj_list(n, edges)\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            if merged[ui] == merged[vi]:\n                used_u = {merged[w] for w in adj[ui]}\n                used_v = {merged[w] for w in adj[vi]}\n                # Try to recolor u first then v\n                moved = False\n                for cand in range(1, max_color + 2):\n                    if cand not in used_u:\n                        merged[ui] = cand\n                        moved = True\n                        break\n                if not moved:\n                    for cand in range(1, max_color + 2):\n                        if cand not in used_v:\n                            merged[vi] = cand\n                            break\n        return normalize_palette(merged)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002058935}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        # Relabel colors to contiguous 1..k preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    def kempe_chain_swap(cur, a, b, start_idx, adj):\n        # BFS on subgraph induced by colors a and b, swap colors on the connected component containing start_idx\n        target = {a, b}\n        if cur[start_idx] not in target:\n            return None\n        visited = set()\n        stack = [start_idx]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if cur[v] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for w in adj[v]:\n                if cur[w] in target and w not in visited:\n                    stack.append(w)\n        if not comp:\n            return None\n        new_cur = cur[:]\n        for v in comp:\n            new_cur[v] = a if cur[v] == b else b\n        return new_cur\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        new_sol = normalize_palette(new_sol)\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    cur = normalize_palette(cur)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                cur = normalize_palette(cur)\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        # Fallback random recolor\n        cur[idx] = random.randint(1, max_color + 1)\n        cur = normalize_palette(cur)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = min(candidates)\n            cur = normalize_palette(cur)\n            return cur, \"NB_Recolor\", \"ReduceMaxColorGreedy\"\n\n    # Try Kempe-chain between max_color and a lower color\n    if max_color > 1:\n        base = random.choice(max_nodes)\n        for low in random.sample(list(range(1, max_color)), k=min(2, max_color-1)):\n            new_cur = kempe_chain_swap(cur, max_color, low, base, adj)\n            if new_cur is not None and new_cur != cur:\n                new_cur = normalize_palette(new_cur)\n                return new_cur, \"NB_Swap\", \"KempeChain\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        cur = normalize_palette(cur)\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    cur = normalize_palette(cur)\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation and encouraging palette compression\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    cur = normalize_palette(cur)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return normalize_palette(cur)\n    elif mode < 0.8:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n    else:\n        # Attempt merge: map one color class onto another and repair lightly\n        if max_color <= 1:\n            return cur\n        a, b = random.sample(list(range(1, max_color + 1)), 2)\n        merged = [a if x == b else x for x in cur]\n        # Light repair: for each conflict edge, push one endpoint to a feasible color if possible\n        adj = adj_list(n, edges)\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            if merged[ui] == merged[vi]:\n                used_u = {merged[w] for w in adj[ui]}\n                used_v = {merged[w] for w in adj[vi]}\n                # Try to recolor u first then v\n                moved = False\n                for cand in range(1, max_color + 2):\n                    if cand not in used_u:\n                        merged[ui] = cand\n                        moved = True\n                        break\n                if not moved:\n                    for cand in range(1, max_color + 2):\n                        if cand not in used_v:\n                            merged[vi] = cand\n                            break\n        return normalize_palette(merged)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001926222}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        # Relabel colors to contiguous 1..k preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    def kempe_chain_swap(cur, a, b, start_idx, adj):\n        # BFS on subgraph induced by colors a and b, swap colors on the connected component containing start_idx\n        target = {a, b}\n        if cur[start_idx] not in target:\n            return None\n        visited = set()\n        stack = [start_idx]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if cur[v] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for w in adj[v]:\n                if cur[w] in target and w not in visited:\n                    stack.append(w)\n        if not comp:\n            return None\n        new_cur = cur[:]\n        for v in comp:\n            new_cur[v] = a if cur[v] == b else b\n        return new_cur\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        new_sol = normalize_palette(new_sol)\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    cur = normalize_palette(cur)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                cur = normalize_palette(cur)\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        # Fallback random recolor\n        cur[idx] = random.randint(1, max_color + 1)\n        cur = normalize_palette(cur)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = min(candidates)\n            cur = normalize_palette(cur)\n            return cur, \"NB_Recolor\", \"ReduceMaxColorGreedy\"\n\n    # Try Kempe-chain between max_color and a lower color\n    if max_color > 1:\n        base = random.choice(max_nodes)\n        for low in random.sample(list(range(1, max_color)), k=min(2, max_color-1)):\n            new_cur = kempe_chain_swap(cur, max_color, low, base, adj)\n            if new_cur is not None and new_cur != cur:\n                new_cur = normalize_palette(new_cur)\n                return new_cur, \"NB_Swap\", \"KempeChain\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        cur = normalize_palette(cur)\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    cur = normalize_palette(cur)\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation and encouraging palette compression\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    cur = normalize_palette(cur)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return normalize_palette(cur)\n    elif mode < 0.8:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n    else:\n        # Attempt merge: map one color class onto another and repair lightly\n        if max_color <= 1:\n            return cur\n        a, b = random.sample(list(range(1, max_color + 1)), 2)\n        merged = [a if x == b else x for x in cur]\n        # Light repair: for each conflict edge, push one endpoint to a feasible color if possible\n        adj = adj_list(n, edges)\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            if merged[ui] == merged[vi]:\n                used_u = {merged[w] for w in adj[ui]}\n                used_v = {merged[w] for w in adj[vi]}\n                # Try to recolor u first then v\n                moved = False\n                for cand in range(1, max_color + 2):\n                    if cand not in used_u:\n                        merged[ui] = cand\n                        moved = True\n                        break\n                if not moved:\n                    for cand in range(1, max_color + 2):\n                        if cand not in used_v:\n                            merged[vi] = cand\n                            break\n        return normalize_palette(merged)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002268037}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9. Representation is a list of length 9 of positive integers >=1, e.g., [c1,...,c9], where ci is the party\/color index for node i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Single node recolor to a different color (possibly new color up to max_color+1)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"SingleNodeRecolor\", \"InvalidPassthrough\"\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    idx = random.randrange(n)\n\n    current = nb[idx]\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Determine forbidden colors from neighbors to bias towards feasible moves\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        val = nb[j]\n        if isinstance(val, int) and val >= 1:\n            forbidden.add(val)\n\n    # Candidate colors: 1..max_color, prefer smallest feasible; if none, allow max_color+1\n    candidates = [c for c in range(1, max_color + 1) if c != current and c not in forbidden]\n    if not candidates:\n        # fallback options including possibly introducing a new color\n        pool = list(range(1, max_color + 2))\n        pool = [c for c in pool if c != current]\n        new_color = random.choice(pool)\n    else:\n        # Greedy pick smallest feasible to reduce colors\/conflicts\n        new_color = min(candidates)\n\n    nb[idx] = int(new_color)\n    return nb, \"SingleNodeRecolor\", \"GreedyPreferFeasible\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node random recoloring to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    k = random.randint(2, 4)\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Select k distinct indices to recolor\n    indices = random.sample(range(n), k)\n\n    # For each selected node, attempt a conflict-avoiding recolor; allow new color if necessary\n    for idx in indices:\n        neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n        forbidden = set()\n        for j in neighbor_indices:\n            val = nb[j]\n            if isinstance(val, int) and val >= 1:\n                forbidden.add(val)\n        pool = list(range(1, max(max_color, 2) + 1)) + [max(max_color, 2) + 1]\n        pool = [c for c in pool if c not in forbidden]\n        if not pool:\n            pool = list(range(1, max_color + 2))\n        nb[idx] = int(random.choice(pool))\n        max_color = max(max_color, nb[idx])\n\n    return nb\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001000311}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9. Representation is a list of length 9 of positive integers >=1, e.g., [c1,...,c9], where ci is the party\/color index for node i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Single node recolor to a different color (possibly new color up to max_color+1)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"SingleNodeRecolor\", \"InvalidPassthrough\"\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    idx = random.randrange(n)\n\n    current = nb[idx]\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Determine forbidden colors from neighbors to bias towards feasible moves\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        val = nb[j]\n        if isinstance(val, int) and val >= 1:\n            forbidden.add(val)\n\n    # Candidate colors: 1..max_color, prefer smallest feasible; if none, allow max_color+1\n    candidates = [c for c in range(1, max_color + 1) if c != current and c not in forbidden]\n    if not candidates:\n        # fallback options including possibly introducing a new color\n        pool = list(range(1, max_color + 2))\n        pool = [c for c in pool if c != current]\n        new_color = random.choice(pool)\n    else:\n        # Greedy pick smallest feasible to reduce colors\/conflicts\n        new_color = min(candidates)\n\n    nb[idx] = int(new_color)\n    return nb, \"SingleNodeRecolor\", \"GreedyPreferFeasible\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node random recoloring to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    k = random.randint(2, 4)\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Select k distinct indices to recolor\n    indices = random.sample(range(n), k)\n\n    # For each selected node, attempt a conflict-avoiding recolor; allow new color if necessary\n    for idx in indices:\n        neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n        forbidden = set()\n        for j in neighbor_indices:\n            val = nb[j]\n            if isinstance(val, int) and val >= 1:\n                forbidden.add(val)\n        pool = list(range(1, max(max_color, 2) + 1)) + [max(max_color, 2) + 1]\n        pool = [c for c in pool if c not in forbidden]\n        if not pool:\n            pool = list(range(1, max_color + 2))\n        nb[idx] = int(random.choice(pool))\n        max_color = max(max_color, nb[idx])\n\n    return nb\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.0008189499}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9. Representation is a list of length 9 of positive integers >=1, e.g., [c1,...,c9], where ci is the party\/color index for node i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Single node recolor to a different color (possibly new color up to max_color+1)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"SingleNodeRecolor\", \"InvalidPassthrough\"\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    idx = random.randrange(n)\n\n    current = nb[idx]\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Determine forbidden colors from neighbors to bias towards feasible moves\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        val = nb[j]\n        if isinstance(val, int) and val >= 1:\n            forbidden.add(val)\n\n    # Candidate colors: 1..max_color, prefer smallest feasible; if none, allow max_color+1\n    candidates = [c for c in range(1, max_color + 1) if c != current and c not in forbidden]\n    if not candidates:\n        # fallback options including possibly introducing a new color\n        pool = list(range(1, max_color + 2))\n        pool = [c for c in pool if c != current]\n        new_color = random.choice(pool)\n    else:\n        # Greedy pick smallest feasible to reduce colors\/conflicts\n        new_color = min(candidates)\n\n    nb[idx] = int(new_color)\n    return nb, \"SingleNodeRecolor\", \"GreedyPreferFeasible\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node random recoloring to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    k = random.randint(2, 4)\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Select k distinct indices to recolor\n    indices = random.sample(range(n), k)\n\n    # For each selected node, attempt a conflict-avoiding recolor; allow new color if necessary\n    for idx in indices:\n        neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n        forbidden = set()\n        for j in neighbor_indices:\n            val = nb[j]\n            if isinstance(val, int) and val >= 1:\n                forbidden.add(val)\n        pool = list(range(1, max(max_color, 2) + 1)) + [max(max_color, 2) + 1]\n        pool = [c for c in pool if c not in forbidden]\n        if not pool:\n            pool = list(range(1, max_color + 2))\n        nb[idx] = int(random.choice(pool))\n        max_color = max(max_color, nb[idx])\n\n    return nb\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000790929}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Implements biased single-node recolor and occasional Kempe-chain swap\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb), \"Repair\", \"RandomInit\"\n\n    nb = solution[:]\n\n    # With small probability perform a 2-color (Kempe) swap on a connected component\n    if random.random() < 0.2:\n        # pick two distinct colors present\n        present = list(sorted(set(nb)))\n        if len(present) >= 2:\n            c1, c2 = random.sample(present, 2)\n            # pick a start vertex that has color c1 or c2\n            candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                # BFS on subgraph induced by colors c1 and c2\n                adj = [[] for _ in range(n)]\n                for (u, v) in edges:\n                    u0, v0 = u-1, v-1\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n                queue = [start]\n                visited = set([start])\n                comp = []\n                while queue:\n                    u = queue.pop()\n                    comp.append(u)\n                    for w in adj[u]:\n                        if w not in visited and nb[w] in (c1, c2):\n                            visited.add(w)\n                            queue.append(w)\n                # swap colors c1 <-> c2 in this component\n                for u in comp:\n                    nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n                nb = compress_colors(nb)\n                return nb, \"KempeSwap\", \"TwoColorComponentSwap\"\n\n    # Otherwise single-node recolor biased toward feasibility and color reduction\n    max_color = max(nb)\n\n    # Prefer conflicted vertices; if none, pick a random vertex\n    conflicts = set()\n    edge_list = edges\n    for (u, v) in edge_list:\n        if nb[u-1] == nb[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    if conflicts:\n        idx = random.choice(list(conflicts))\n        move_tag = \"ConflictDirected\"\n    else:\n        idx = random.randrange(n)\n        move_tag = \"RandomPick\"\n\n    # Determine forbidden colors from neighbors\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        forbidden.add(nb[j])\n\n    # Candidate colors within current palette\n    candidates = [c for c in range(1, max_color + 1) if c != nb[idx] and c not in forbidden]\n    if candidates:\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_FeasibleMinColor\"\n    else:\n        # Allow introducing a new color only if necessary\n        nb[idx] = max_color + 1\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_ExpandPalette\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node adaptive perturbation: random recolors and a possible Kempe cascade\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb)\n\n    nb = solution[:]\n\n    # Step 1: random recolor k vertices with colors sampled from existing palette plus one extra\n    k = random.randint(2, 4)\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        nb[idx] = int(random.choice(pool))\n\n    # Step 2: perform 1-2 Kempe component swaps to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        queue = [start]\n        visited = set([start])\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    nb = compress_colors(nb)\n    return nb\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001370896}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Implements biased single-node recolor and occasional Kempe-chain swap\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb), \"Repair\", \"RandomInit\"\n\n    nb = solution[:]\n\n    # With small probability perform a 2-color (Kempe) swap on a connected component\n    if random.random() < 0.2:\n        # pick two distinct colors present\n        present = list(sorted(set(nb)))\n        if len(present) >= 2:\n            c1, c2 = random.sample(present, 2)\n            # pick a start vertex that has color c1 or c2\n            candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                # BFS on subgraph induced by colors c1 and c2\n                adj = [[] for _ in range(n)]\n                for (u, v) in edges:\n                    u0, v0 = u-1, v-1\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n                queue = [start]\n                visited = set([start])\n                comp = []\n                while queue:\n                    u = queue.pop()\n                    comp.append(u)\n                    for w in adj[u]:\n                        if w not in visited and nb[w] in (c1, c2):\n                            visited.add(w)\n                            queue.append(w)\n                # swap colors c1 <-> c2 in this component\n                for u in comp:\n                    nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n                nb = compress_colors(nb)\n                return nb, \"KempeSwap\", \"TwoColorComponentSwap\"\n\n    # Otherwise single-node recolor biased toward feasibility and color reduction\n    max_color = max(nb)\n\n    # Prefer conflicted vertices; if none, pick a random vertex\n    conflicts = set()\n    edge_list = edges\n    for (u, v) in edge_list:\n        if nb[u-1] == nb[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    if conflicts:\n        idx = random.choice(list(conflicts))\n        move_tag = \"ConflictDirected\"\n    else:\n        idx = random.randrange(n)\n        move_tag = \"RandomPick\"\n\n    # Determine forbidden colors from neighbors\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        forbidden.add(nb[j])\n\n    # Candidate colors within current palette\n    candidates = [c for c in range(1, max_color + 1) if c != nb[idx] and c not in forbidden]\n    if candidates:\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_FeasibleMinColor\"\n    else:\n        # Allow introducing a new color only if necessary\n        nb[idx] = max_color + 1\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_ExpandPalette\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node adaptive perturbation: random recolors and a possible Kempe cascade\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb)\n\n    nb = solution[:]\n\n    # Step 1: random recolor k vertices with colors sampled from existing palette plus one extra\n    k = random.randint(2, 4)\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        nb[idx] = int(random.choice(pool))\n\n    # Step 2: perform 1-2 Kempe component swaps to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        queue = [start]\n        visited = set([start])\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    nb = compress_colors(nb)\n    return nb\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001211394}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Implements biased single-node recolor and occasional Kempe-chain swap\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb), \"Repair\", \"RandomInit\"\n\n    nb = solution[:]\n\n    # With small probability perform a 2-color (Kempe) swap on a connected component\n    if random.random() < 0.2:\n        # pick two distinct colors present\n        present = list(sorted(set(nb)))\n        if len(present) >= 2:\n            c1, c2 = random.sample(present, 2)\n            # pick a start vertex that has color c1 or c2\n            candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                # BFS on subgraph induced by colors c1 and c2\n                adj = [[] for _ in range(n)]\n                for (u, v) in edges:\n                    u0, v0 = u-1, v-1\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n                queue = [start]\n                visited = set([start])\n                comp = []\n                while queue:\n                    u = queue.pop()\n                    comp.append(u)\n                    for w in adj[u]:\n                        if w not in visited and nb[w] in (c1, c2):\n                            visited.add(w)\n                            queue.append(w)\n                # swap colors c1 <-> c2 in this component\n                for u in comp:\n                    nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n                nb = compress_colors(nb)\n                return nb, \"KempeSwap\", \"TwoColorComponentSwap\"\n\n    # Otherwise single-node recolor biased toward feasibility and color reduction\n    max_color = max(nb)\n\n    # Prefer conflicted vertices; if none, pick a random vertex\n    conflicts = set()\n    edge_list = edges\n    for (u, v) in edge_list:\n        if nb[u-1] == nb[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    if conflicts:\n        idx = random.choice(list(conflicts))\n        move_tag = \"ConflictDirected\"\n    else:\n        idx = random.randrange(n)\n        move_tag = \"RandomPick\"\n\n    # Determine forbidden colors from neighbors\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        forbidden.add(nb[j])\n\n    # Candidate colors within current palette\n    candidates = [c for c in range(1, max_color + 1) if c != nb[idx] and c not in forbidden]\n    if candidates:\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_FeasibleMinColor\"\n    else:\n        # Allow introducing a new color only if necessary\n        nb[idx] = max_color + 1\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_ExpandPalette\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node adaptive perturbation: random recolors and a possible Kempe cascade\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb)\n\n    nb = solution[:]\n\n    # Step 1: random recolor k vertices with colors sampled from existing palette plus one extra\n    k = random.randint(2, 4)\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        nb[idx] = int(random.choice(pool))\n\n    # Step 2: perform 1-2 Kempe component swaps to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        queue = [start]\n        visited = set([start])\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    nb = compress_colors(nb)\n    return nb\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001127464}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9 \/\/ encoding: list of 9 positive integers [c1..c9], colors start at 1; graph nodes are 1..9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a neighbor solution (list of 9 ints >=1).\n    Metadata (\"NB_Type\",\"Movement_Type\") omitted to satisfy 2-ary unpackers.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by a simple greedy initialization\n    def greedy_init():\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        for i in order:\n            forbidden = {sol[j] for j in adj[i] if sol[j] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[i] = c\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return greedy_init()\n\n    nb = solution[:]\n\n    # Precompute adjacency lists\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Pick vertex: prefer conflicted with higher degree, else random\n    if conflicted:\n        idx = max(conflicted, key=lambda i: (len(adj[i]), random.random()))\n    else:\n        idx = random.randrange(n)\n\n    # Determine forbidden colors from neighbors\n    forbidden = {nb[j] for j in adj[idx]}\n\n    # Consider feasible colors within current palette\n    max_color = max(nb) if nb else 1\n    candidates = [c for c in range(1, max_color+1) if c != nb[idx] and c not in forbidden]\n\n    if candidates:\n        # Least-conflicting tie-broken randomly\n        random.shuffle(candidates)\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        return compress_colors(nb)\n\n    # Try a localized two-color Kempe swap to create feasibility without increasing palette\n    present = list(sorted(set(nb)))\n    if len(present) >= 2:\n        c1 = nb[idx]\n        others = [c for c in present if c != c1]\n        if others:\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n            # After swap, retry assigning a feasible existing color to idx\n            forbidden = {nb[j] for j in adj[idx]}\n            candidates = [c for c in range(1, max(nb)+1) if c != nb[idx] and c not in forbidden]\n            if candidates:\n                nb[idx] = int(min(candidates))\n                return compress_colors(nb)\n\n    # As last resort, temporarily expand palette by one color\n    nb[idx] = max_color + 1\n    return compress_colors(nb)\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Multi-node recolor + optional Kempe cascades.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def fallback_init():\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return fallback_init()\n\n    nb = solution[:]\n\n    # Build adjacency and conflict set\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: random recolor k nodes (biased to conflicted if any)\n    k = random.randint(2, 4)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) < k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]  # allow one extra color occasionally\n\n    for idx in indices:\n        # choose a color avoiding immediate neighbor clashes if possible\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas:\n            nb[idx] = int(random.choice(feas))\n        else:\n            nb[idx] = int(random.choice(pool))\n\n    # Step 2: 1-2 Kempe swaps from random seeds to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    return compress_colors(nb)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001627059}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9 \/\/ encoding: list of 9 positive integers [c1..c9], colors start at 1; graph nodes are 1..9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a neighbor solution (list of 9 ints >=1).\n    Metadata (\"NB_Type\",\"Movement_Type\") omitted to satisfy 2-ary unpackers.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by a simple greedy initialization\n    def greedy_init():\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        for i in order:\n            forbidden = {sol[j] for j in adj[i] if sol[j] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[i] = c\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return greedy_init()\n\n    nb = solution[:]\n\n    # Precompute adjacency lists\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Pick vertex: prefer conflicted with higher degree, else random\n    if conflicted:\n        idx = max(conflicted, key=lambda i: (len(adj[i]), random.random()))\n    else:\n        idx = random.randrange(n)\n\n    # Determine forbidden colors from neighbors\n    forbidden = {nb[j] for j in adj[idx]}\n\n    # Consider feasible colors within current palette\n    max_color = max(nb) if nb else 1\n    candidates = [c for c in range(1, max_color+1) if c != nb[idx] and c not in forbidden]\n\n    if candidates:\n        # Least-conflicting tie-broken randomly\n        random.shuffle(candidates)\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        return compress_colors(nb)\n\n    # Try a localized two-color Kempe swap to create feasibility without increasing palette\n    present = list(sorted(set(nb)))\n    if len(present) >= 2:\n        c1 = nb[idx]\n        others = [c for c in present if c != c1]\n        if others:\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n            # After swap, retry assigning a feasible existing color to idx\n            forbidden = {nb[j] for j in adj[idx]}\n            candidates = [c for c in range(1, max(nb)+1) if c != nb[idx] and c not in forbidden]\n            if candidates:\n                nb[idx] = int(min(candidates))\n                return compress_colors(nb)\n\n    # As last resort, temporarily expand palette by one color\n    nb[idx] = max_color + 1\n    return compress_colors(nb)\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Multi-node recolor + optional Kempe cascades.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def fallback_init():\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return fallback_init()\n\n    nb = solution[:]\n\n    # Build adjacency and conflict set\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: random recolor k nodes (biased to conflicted if any)\n    k = random.randint(2, 4)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) < k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]  # allow one extra color occasionally\n\n    for idx in indices:\n        # choose a color avoiding immediate neighbor clashes if possible\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas:\n            nb[idx] = int(random.choice(feas))\n        else:\n            nb[idx] = int(random.choice(pool))\n\n    # Step 2: 1-2 Kempe swaps from random seeds to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    return compress_colors(nb)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001456197}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9 \/\/ encoding: list of 9 positive integers [c1..c9], colors start at 1; graph nodes are 1..9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a neighbor solution (list of 9 ints >=1).\n    Metadata (\"NB_Type\",\"Movement_Type\") omitted to satisfy 2-ary unpackers.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by a simple greedy initialization\n    def greedy_init():\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        for i in order:\n            forbidden = {sol[j] for j in adj[i] if sol[j] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[i] = c\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return greedy_init()\n\n    nb = solution[:]\n\n    # Precompute adjacency lists\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Pick vertex: prefer conflicted with higher degree, else random\n    if conflicted:\n        idx = max(conflicted, key=lambda i: (len(adj[i]), random.random()))\n    else:\n        idx = random.randrange(n)\n\n    # Determine forbidden colors from neighbors\n    forbidden = {nb[j] for j in adj[idx]}\n\n    # Consider feasible colors within current palette\n    max_color = max(nb) if nb else 1\n    candidates = [c for c in range(1, max_color+1) if c != nb[idx] and c not in forbidden]\n\n    if candidates:\n        # Least-conflicting tie-broken randomly\n        random.shuffle(candidates)\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        return compress_colors(nb)\n\n    # Try a localized two-color Kempe swap to create feasibility without increasing palette\n    present = list(sorted(set(nb)))\n    if len(present) >= 2:\n        c1 = nb[idx]\n        others = [c for c in present if c != c1]\n        if others:\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n            # After swap, retry assigning a feasible existing color to idx\n            forbidden = {nb[j] for j in adj[idx]}\n            candidates = [c for c in range(1, max(nb)+1) if c != nb[idx] and c not in forbidden]\n            if candidates:\n                nb[idx] = int(min(candidates))\n                return compress_colors(nb)\n\n    # As last resort, temporarily expand palette by one color\n    nb[idx] = max_color + 1\n    return compress_colors(nb)\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Multi-node recolor + optional Kempe cascades.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def fallback_init():\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return fallback_init()\n\n    nb = solution[:]\n\n    # Build adjacency and conflict set\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: random recolor k nodes (biased to conflicted if any)\n    k = random.randint(2, 4)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) < k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]  # allow one extra color occasionally\n\n    for idx in indices:\n        # choose a color avoiding immediate neighbor clashes if possible\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas:\n            nb[idx] = int(random.choice(feas))\n        else:\n            nb[idx] = int(random.choice(pool))\n\n    # Step 2: 1-2 Kempe swaps from random seeds to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    return compress_colors(nb)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001341395}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns a scalar fitness (lower is better): number of colors used + conflict penalties.\n    Expects solution: list of 9 positive ints (colors start at 1).\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties (scaled to dominate color count but not overflow)\n    conflict_penalty = 1000.0\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    penalty += conflict_penalty * conflicts\n\n    # Objective: number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport math\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (neighbor_solution, movement_type_str)\n    - Keeps color labels stable; does NOT compress\/relabel the palette.\n    - Repairs invalid inputs via DSATUR initialization.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            # select uncolored vertex with highest saturation; break ties on degree\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (dsatur_init(), \"RepairInit\")\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicts_nodes = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicts_nodes.add(u-1); conflicts_nodes.add(v-1)\n\n    # Helper: min-conflicts recolor within existing palette if possible\n    def min_conflicts_recolor(idx):\n        cur = nb[idx]\n        palette = sorted(set(nb))\n        best_c = None\n        best_cnt = math.inf\n        for c in palette:\n            if c == cur:\n                continue\n            cnt = 0\n            for j in adj[idx]:\n                if nb[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_c = c\n        if best_c is not None and best_cnt < sum(1 for j in adj[idx] if nb[j]==cur):\n            nb[idx] = best_c\n            return True\n        return False\n\n    # Try to fix conflicts first\n    if conflicts_nodes:\n        # pick most conflicted with degree tiebreak\n        def conflict_count(i):\n            c = nb[i]\n            return sum(1 for j in adj[i] if nb[j]==c)\n        idx = max(conflicts_nodes, key=lambda i: (conflict_count(i), len(adj[i]), random.random()))\n        # try feasible recolor that avoids immediate neighbor clashes\n        forbidden = {nb[j] for j in adj[idx]}\n        palette = sorted(set(nb))\n        feas = [c for c in palette if c != nb[idx] and c not in forbidden]\n        if feas:\n            nb[idx] = min(feas)\n            return (nb, \"SingleVertexRecolor\")\n        # else use min-conflicts among palette\n        if min_conflicts_recolor(idx):\n            return (nb, \"MinConflictsRecolor\")\n        # Kempe swap between current color and a random other color\n        present = sorted(set(nb))\n        if len(present) >= 2:\n            c1 = nb[idx]\n            others = [c for c in present if c != c1]\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                if nb[u] == c1:\n                    nb[u] = c2\n                elif nb[u] == c2:\n                    nb[u] = c1\n            return (nb, \"KempeSwap\")\n        # As last resort, introduce a new color to break deadlock\n        nb[idx] = max(nb) + 1\n        return (nb, \"PaletteExpand\")\n\n    # No conflicts: try to reduce number of colors by merging a sparse color class\n    palette = sorted(set(nb))\n    if len(palette) > 1:\n        # pick smallest class size color to eliminate\n        counts = {c: sum(1 for x in nb if x==c) for c in palette}\n        target = min(palette, key=lambda c: (counts[c], c))\n        # attempt to recolor its vertices into other colors greedily\n        verts = [i for i, x in enumerate(nb) if x == target]\n        success = True\n        for i in verts:\n            forbidden = {nb[j] for j in adj[i]}\n            feas = [c for c in palette if c != target and c not in forbidden]\n            if feas:\n                nb[i] = min(feas)\n            else:\n                success = False\n                break\n        if success:\n            return (nb, \"ClassMergeGreedy\")\n        # fallback: swap two color classes to shake\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            for i in range(n):\n                if nb[i] == c1:\n                    nb[i] = c2\n                elif nb[i] == c2:\n                    nb[i] = c1\n            return (nb, \"ClassSwap\")\n\n    # Default small diversification: recolor a random vertex to a random feasible color (or same)\n    idx = random.randrange(n)\n    forbidden = {nb[j] for j in adj[idx]}\n    feas = [c for c in palette if c not in forbidden]\n    if feas:\n        nb[idx] = random.choice(feas)\n        return (nb, \"RandomFeasibleRecolor\")\n    return (nb, \"NoOp\")\n","Perturbacion":"import random\nimport math\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Keeps labels stable; repairs invalid input.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return dsatur_init()\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: recolor k nodes (biased to conflicted if any)\n    k = random.randint(3, 5)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) <= k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n\n    for idx in indices:\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas and random.random() < 0.85:\n            nb[idx] = random.choice(feas)\n        else:\n            nb[idx] = random.choice(pool)\n\n    # Step 2: 1-2 Kempe swaps for diversification\n    iters = random.randint(1, 2)\n    for _ in range(iters):\n        present = sorted(set(nb))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            if nb[u] == c1:\n                nb[u] = c2\n            elif nb[u] == c2:\n                nb[u] = c1\n\n    return nb\n","Resultados":[[1,2,3,4,4,1,1,3,2],4.0,[1,2,3,4,4,1,1,3,2],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0029701981}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns a scalar fitness (lower is better): number of colors used + conflict penalties.\n    Expects solution: list of 9 positive ints (colors start at 1).\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties (scaled to dominate color count but not overflow)\n    conflict_penalty = 1000.0\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    penalty += conflict_penalty * conflicts\n\n    # Objective: number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport math\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (neighbor_solution, movement_type_str)\n    - Keeps color labels stable; does NOT compress\/relabel the palette.\n    - Repairs invalid inputs via DSATUR initialization.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            # select uncolored vertex with highest saturation; break ties on degree\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (dsatur_init(), \"RepairInit\")\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicts_nodes = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicts_nodes.add(u-1); conflicts_nodes.add(v-1)\n\n    # Helper: min-conflicts recolor within existing palette if possible\n    def min_conflicts_recolor(idx):\n        cur = nb[idx]\n        palette = sorted(set(nb))\n        best_c = None\n        best_cnt = math.inf\n        for c in palette:\n            if c == cur:\n                continue\n            cnt = 0\n            for j in adj[idx]:\n                if nb[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_c = c\n        if best_c is not None and best_cnt < sum(1 for j in adj[idx] if nb[j]==cur):\n            nb[idx] = best_c\n            return True\n        return False\n\n    # Try to fix conflicts first\n    if conflicts_nodes:\n        # pick most conflicted with degree tiebreak\n        def conflict_count(i):\n            c = nb[i]\n            return sum(1 for j in adj[i] if nb[j]==c)\n        idx = max(conflicts_nodes, key=lambda i: (conflict_count(i), len(adj[i]), random.random()))\n        # try feasible recolor that avoids immediate neighbor clashes\n        forbidden = {nb[j] for j in adj[idx]}\n        palette = sorted(set(nb))\n        feas = [c for c in palette if c != nb[idx] and c not in forbidden]\n        if feas:\n            nb[idx] = min(feas)\n            return (nb, \"SingleVertexRecolor\")\n        # else use min-conflicts among palette\n        if min_conflicts_recolor(idx):\n            return (nb, \"MinConflictsRecolor\")\n        # Kempe swap between current color and a random other color\n        present = sorted(set(nb))\n        if len(present) >= 2:\n            c1 = nb[idx]\n            others = [c for c in present if c != c1]\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                if nb[u] == c1:\n                    nb[u] = c2\n                elif nb[u] == c2:\n                    nb[u] = c1\n            return (nb, \"KempeSwap\")\n        # As last resort, introduce a new color to break deadlock\n        nb[idx] = max(nb) + 1\n        return (nb, \"PaletteExpand\")\n\n    # No conflicts: try to reduce number of colors by merging a sparse color class\n    palette = sorted(set(nb))\n    if len(palette) > 1:\n        # pick smallest class size color to eliminate\n        counts = {c: sum(1 for x in nb if x==c) for c in palette}\n        target = min(palette, key=lambda c: (counts[c], c))\n        # attempt to recolor its vertices into other colors greedily\n        verts = [i for i, x in enumerate(nb) if x == target]\n        success = True\n        for i in verts:\n            forbidden = {nb[j] for j in adj[i]}\n            feas = [c for c in palette if c != target and c not in forbidden]\n            if feas:\n                nb[i] = min(feas)\n            else:\n                success = False\n                break\n        if success:\n            return (nb, \"ClassMergeGreedy\")\n        # fallback: swap two color classes to shake\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            for i in range(n):\n                if nb[i] == c1:\n                    nb[i] = c2\n                elif nb[i] == c2:\n                    nb[i] = c1\n            return (nb, \"ClassSwap\")\n\n    # Default small diversification: recolor a random vertex to a random feasible color (or same)\n    idx = random.randrange(n)\n    forbidden = {nb[j] for j in adj[idx]}\n    feas = [c for c in palette if c not in forbidden]\n    if feas:\n        nb[idx] = random.choice(feas)\n        return (nb, \"RandomFeasibleRecolor\")\n    return (nb, \"NoOp\")\n","Perturbacion":"import random\nimport math\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Keeps labels stable; repairs invalid input.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return dsatur_init()\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: recolor k nodes (biased to conflicted if any)\n    k = random.randint(3, 5)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) <= k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n\n    for idx in indices:\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas and random.random() < 0.85:\n            nb[idx] = random.choice(feas)\n        else:\n            nb[idx] = random.choice(pool)\n\n    # Step 2: 1-2 Kempe swaps for diversification\n    iters = random.randint(1, 2)\n    for _ in range(iters):\n        present = sorted(set(nb))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            if nb[u] == c1:\n                nb[u] = c2\n            elif nb[u] == c2:\n                nb[u] = c1\n\n    return nb\n","Resultados":[[3,4,6,7,3,7,3,6,4],4.0,[1,2,3,4,4,1,1,3,2],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003476962}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns a scalar fitness (lower is better): number of colors used + conflict penalties.\n    Expects solution: list of 9 positive ints (colors start at 1).\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties (scaled to dominate color count but not overflow)\n    conflict_penalty = 1000.0\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    penalty += conflict_penalty * conflicts\n\n    # Objective: number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport math\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (neighbor_solution, movement_type_str)\n    - Keeps color labels stable; does NOT compress\/relabel the palette.\n    - Repairs invalid inputs via DSATUR initialization.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            # select uncolored vertex with highest saturation; break ties on degree\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (dsatur_init(), \"RepairInit\")\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicts_nodes = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicts_nodes.add(u-1); conflicts_nodes.add(v-1)\n\n    # Helper: min-conflicts recolor within existing palette if possible\n    def min_conflicts_recolor(idx):\n        cur = nb[idx]\n        palette = sorted(set(nb))\n        best_c = None\n        best_cnt = math.inf\n        for c in palette:\n            if c == cur:\n                continue\n            cnt = 0\n            for j in adj[idx]:\n                if nb[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_c = c\n        if best_c is not None and best_cnt < sum(1 for j in adj[idx] if nb[j]==cur):\n            nb[idx] = best_c\n            return True\n        return False\n\n    # Try to fix conflicts first\n    if conflicts_nodes:\n        # pick most conflicted with degree tiebreak\n        def conflict_count(i):\n            c = nb[i]\n            return sum(1 for j in adj[i] if nb[j]==c)\n        idx = max(conflicts_nodes, key=lambda i: (conflict_count(i), len(adj[i]), random.random()))\n        # try feasible recolor that avoids immediate neighbor clashes\n        forbidden = {nb[j] for j in adj[idx]}\n        palette = sorted(set(nb))\n        feas = [c for c in palette if c != nb[idx] and c not in forbidden]\n        if feas:\n            nb[idx] = min(feas)\n            return (nb, \"SingleVertexRecolor\")\n        # else use min-conflicts among palette\n        if min_conflicts_recolor(idx):\n            return (nb, \"MinConflictsRecolor\")\n        # Kempe swap between current color and a random other color\n        present = sorted(set(nb))\n        if len(present) >= 2:\n            c1 = nb[idx]\n            others = [c for c in present if c != c1]\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                if nb[u] == c1:\n                    nb[u] = c2\n                elif nb[u] == c2:\n                    nb[u] = c1\n            return (nb, \"KempeSwap\")\n        # As last resort, introduce a new color to break deadlock\n        nb[idx] = max(nb) + 1\n        return (nb, \"PaletteExpand\")\n\n    # No conflicts: try to reduce number of colors by merging a sparse color class\n    palette = sorted(set(nb))\n    if len(palette) > 1:\n        # pick smallest class size color to eliminate\n        counts = {c: sum(1 for x in nb if x==c) for c in palette}\n        target = min(palette, key=lambda c: (counts[c], c))\n        # attempt to recolor its vertices into other colors greedily\n        verts = [i for i, x in enumerate(nb) if x == target]\n        success = True\n        for i in verts:\n            forbidden = {nb[j] for j in adj[i]}\n            feas = [c for c in palette if c != target and c not in forbidden]\n            if feas:\n                nb[i] = min(feas)\n            else:\n                success = False\n                break\n        if success:\n            return (nb, \"ClassMergeGreedy\")\n        # fallback: swap two color classes to shake\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            for i in range(n):\n                if nb[i] == c1:\n                    nb[i] = c2\n                elif nb[i] == c2:\n                    nb[i] = c1\n            return (nb, \"ClassSwap\")\n\n    # Default small diversification: recolor a random vertex to a random feasible color (or same)\n    idx = random.randrange(n)\n    forbidden = {nb[j] for j in adj[idx]}\n    feas = [c for c in palette if c not in forbidden]\n    if feas:\n        nb[idx] = random.choice(feas)\n        return (nb, \"RandomFeasibleRecolor\")\n    return (nb, \"NoOp\")\n","Perturbacion":"import random\nimport math\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Keeps labels stable; repairs invalid input.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return dsatur_init()\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: recolor k nodes (biased to conflicted if any)\n    k = random.randint(3, 5)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) <= k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n\n    for idx in indices:\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas and random.random() < 0.85:\n            nb[idx] = random.choice(feas)\n        else:\n            nb[idx] = random.choice(pool)\n\n    # Step 2: 1-2 Kempe swaps for diversification\n    iters = random.randint(1, 2)\n    for _ in range(iters):\n        present = sorted(set(nb))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            if nb[u] == c1:\n                nb[u] = c2\n            elif nb[u] == c2:\n                nb[u] = c1\n\n    return nb\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001744086}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    LARGE = 1000000.0\n    HUGE = 1000000000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in edges:\n            try:\n                if isinstance(solution[u], int) and isinstance(solution[v], int) and solution[u] >= 1 and solution[v] >= 1:\n                    if solution[u] == solution[v]:\n                        conflicts += 1\n                else:\n                    pass\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, \"INDEX_LIST\", movement_type)\n    # Internal graph (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    def conflicts_of(idx, arr):\n        c = 0\n        for u,v in edges:\n            if u == idx and arr[u] == arr[v]:\n                c += 1\n            elif v == idx and arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def feasible_colors(idx, arr, max_col):\n        forbidden = set()\n        for u,v in edges:\n            if u == idx:\n                forbidden.add(arr[v])\n            elif v == idx:\n                forbidden.add(arr[u])\n        return [c for c in range(1, max_col+1) if c not in forbidden]\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = []\n    for u,v in edges:\n        if new_s[u] == new_s[v]:\n            if u not in conflicted:\n                conflicted.append(u)\n            if v not in conflicted:\n                conflicted.append(v)\n\n    move_type = \"HeuristicRecolor\"\n\n    if conflicted:\n        # Pick a conflicted vertex and recolor to reduce conflicts\n        idx = random.choice(conflicted)\n        feas = feasible_colors(idx, new_s, max_color)\n        if feas:\n            # Greedy: prefer smallest feasible color\n            new_color = min(feas)\n        else:\n            # No feasible within current range: expand palette by 1\n            new_color = max_color + 1\n            move_type = \"PaletteExpand\"\n        new_s[idx] = new_color\n    else:\n        # No conflicts: try to reduce max color if possible\n        candidates = [i for i, c in enumerate(new_s) if c == max_color]\n        if candidates:\n            idx = random.choice(candidates)\n            feas = feasible_colors(idx, new_s, max_color-1) if max_color > 1 else []\n            if feas:\n                # Choose lowest feasible to encourage compression\n                new_s[idx] = min(feas)\n                move_type = \"PaletteCompress\"\n            else:\n                # Small random recolor within current palette to escape plateaus\n                new_s[idx] = random.randint(1, max_color)\n                move_type = \"RandomShake\"\n        else:\n            # Safety fallback: random single-vertex recolor\n            idx = random.randrange(n)\n            new_s[idx] = random.randint(1, max_color)\n            move_type = \"RandomShake\"\n\n    return new_s, \"INDEX_LIST\", move_type\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Randomly remap colors (color permutation) to change landscape without altering feasibility\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Additionally, perform k random vertex recolors within palette to inject noise\n    k = max(2, n \/\/ 4)\n    for _ in range(k):\n        idx = random.randrange(n)\n        new_s[idx] = random.randint(1, max_color)\n\n    return new_s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001127921}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    LARGE = 1000000.0\n    HUGE = 1000000000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in edges:\n            try:\n                if isinstance(solution[u], int) and isinstance(solution[v], int) and solution[u] >= 1 and solution[v] >= 1:\n                    if solution[u] == solution[v]:\n                        conflicts += 1\n                else:\n                    pass\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, \"INDEX_LIST\", movement_type)\n    # Internal graph (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    def conflicts_of(idx, arr):\n        c = 0\n        for u,v in edges:\n            if u == idx and arr[u] == arr[v]:\n                c += 1\n            elif v == idx and arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def feasible_colors(idx, arr, max_col):\n        forbidden = set()\n        for u,v in edges:\n            if u == idx:\n                forbidden.add(arr[v])\n            elif v == idx:\n                forbidden.add(arr[u])\n        return [c for c in range(1, max_col+1) if c not in forbidden]\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = []\n    for u,v in edges:\n        if new_s[u] == new_s[v]:\n            if u not in conflicted:\n                conflicted.append(u)\n            if v not in conflicted:\n                conflicted.append(v)\n\n    move_type = \"HeuristicRecolor\"\n\n    if conflicted:\n        # Pick a conflicted vertex and recolor to reduce conflicts\n        idx = random.choice(conflicted)\n        feas = feasible_colors(idx, new_s, max_color)\n        if feas:\n            # Greedy: prefer smallest feasible color\n            new_color = min(feas)\n        else:\n            # No feasible within current range: expand palette by 1\n            new_color = max_color + 1\n            move_type = \"PaletteExpand\"\n        new_s[idx] = new_color\n    else:\n        # No conflicts: try to reduce max color if possible\n        candidates = [i for i, c in enumerate(new_s) if c == max_color]\n        if candidates:\n            idx = random.choice(candidates)\n            feas = feasible_colors(idx, new_s, max_color-1) if max_color > 1 else []\n            if feas:\n                # Choose lowest feasible to encourage compression\n                new_s[idx] = min(feas)\n                move_type = \"PaletteCompress\"\n            else:\n                # Small random recolor within current palette to escape plateaus\n                new_s[idx] = random.randint(1, max_color)\n                move_type = \"RandomShake\"\n        else:\n            # Safety fallback: random single-vertex recolor\n            idx = random.randrange(n)\n            new_s[idx] = random.randint(1, max_color)\n            move_type = \"RandomShake\"\n\n    return new_s, \"INDEX_LIST\", move_type\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Randomly remap colors (color permutation) to change landscape without altering feasibility\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Additionally, perform k random vertex recolors within palette to inject noise\n    k = max(2, n \/\/ 4)\n    for _ in range(k):\n        idx = random.randrange(n)\n        new_s[idx] = random.randint(1, max_color)\n\n    return new_s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000964899}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    LARGE = 1000000.0\n    HUGE = 1000000000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in edges:\n            try:\n                if isinstance(solution[u], int) and isinstance(solution[v], int) and solution[u] >= 1 and solution[v] >= 1:\n                    if solution[u] == solution[v]:\n                        conflicts += 1\n                else:\n                    pass\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, \"INDEX_LIST\", movement_type)\n    # Internal graph (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    def conflicts_of(idx, arr):\n        c = 0\n        for u,v in edges:\n            if u == idx and arr[u] == arr[v]:\n                c += 1\n            elif v == idx and arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def feasible_colors(idx, arr, max_col):\n        forbidden = set()\n        for u,v in edges:\n            if u == idx:\n                forbidden.add(arr[v])\n            elif v == idx:\n                forbidden.add(arr[u])\n        return [c for c in range(1, max_col+1) if c not in forbidden]\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = []\n    for u,v in edges:\n        if new_s[u] == new_s[v]:\n            if u not in conflicted:\n                conflicted.append(u)\n            if v not in conflicted:\n                conflicted.append(v)\n\n    move_type = \"HeuristicRecolor\"\n\n    if conflicted:\n        # Pick a conflicted vertex and recolor to reduce conflicts\n        idx = random.choice(conflicted)\n        feas = feasible_colors(idx, new_s, max_color)\n        if feas:\n            # Greedy: prefer smallest feasible color\n            new_color = min(feas)\n        else:\n            # No feasible within current range: expand palette by 1\n            new_color = max_color + 1\n            move_type = \"PaletteExpand\"\n        new_s[idx] = new_color\n    else:\n        # No conflicts: try to reduce max color if possible\n        candidates = [i for i, c in enumerate(new_s) if c == max_color]\n        if candidates:\n            idx = random.choice(candidates)\n            feas = feasible_colors(idx, new_s, max_color-1) if max_color > 1 else []\n            if feas:\n                # Choose lowest feasible to encourage compression\n                new_s[idx] = min(feas)\n                move_type = \"PaletteCompress\"\n            else:\n                # Small random recolor within current palette to escape plateaus\n                new_s[idx] = random.randint(1, max_color)\n                move_type = \"RandomShake\"\n        else:\n            # Safety fallback: random single-vertex recolor\n            idx = random.randrange(n)\n            new_s[idx] = random.randint(1, max_color)\n            move_type = \"RandomShake\"\n\n    return new_s, \"INDEX_LIST\", move_type\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Randomly remap colors (color permutation) to change landscape without altering feasibility\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Additionally, perform k random vertex recolors within palette to inject noise\n    k = max(2, n \/\/ 4)\n    for _ in range(k):\n        idx = random.randrange(n)\n        new_s[idx] = random.randint(1, max_color)\n\n    return new_s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000926689}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (5,9-1), (7,9-1), (8,9-1) # duplicates guarded below; harmless\n    ]\n    # Deduplicate edges and ensure 0-based correctness\n    E = []\n    seen = set()\n    for u,v in edges:\n        if u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen and 0 <= a < 9 and 0 <= b < 9:\n            seen.add((a,b))\n            E.append((a,b))\n\n    LARGE = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution[:n]:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in E:\n            try:\n                su = solution[u]\n                sv = solution[v]\n                if isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1:\n                    if su == sv:\n                        conflicts += 1\n                else:\n                    conflicts += 1\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator with palette compression, best-improvement recolor, and Kempe-chain flips\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize solution to INDEX_LIST of length 9 with ints >=1\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    # Graph data (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (4,5)  # duplicates safe\n    ]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def count_conflicts(arr):\n        c = 0\n        for u in range(n):\n            cu = arr[u]\n            for v in adj[u]:\n                if v > u and cu == arr[v]:\n                    c += 1\n        return c\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, max_color):\n        # Try colors 1..max_color, choose one minimizing conflicts; allow staying same if best\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        # Current conflicts at idx\n        base = vertex_conflicts(idx, arr)\n        for c in range(1, max_color+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        # Build component in subgraph induced by colors a and b, then swap colors\n        if a == b:\n            return None\n        if arr[start_idx] not in (a, b):\n            return None\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        new_arr = arr[:]\n        for u in comp:\n            new_arr[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return new_arr\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        # Resolve conflicts: pick a conflicted vertex and try best recolor; else Kempe; else expand palette\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None:\n            new_s = cand\n        else:\n            # Try a Kempe flip between current color and a random other color\n            current = new_s[idx]\n            other = random.randint(1, max_color)\n            if other == current:\n                other = (other % max_color) + 1 if max_color > 1 else current\n            kc = kempe_chain_flip(idx, current, other, new_s)\n            if kc is not None and count_conflicts(kc) <= count_conflicts(new_s):\n                new_s = kc\n            else:\n                # Last resort: expand palette for this vertex\n                new_s[idx] = max_color + 1\n    else:\n        # No conflicts: attempt palette compression on max color class\n        max_color = max(new_s)\n        max_vertices = [i for i,c in enumerate(new_s) if c == max_color]\n        if max_vertices:\n            idx = random.choice(max_vertices)\n            # Try recolor to any color < max that is feasible\n            feas = []\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    feas.append(c)\n            if feas:\n                new_s[idx] = min(feas)\n            else:\n                # Try Kempe chain with a lower color to make space\n                if max_color > 1:\n                    target = random.randint(1, max_color-1)\n                    kc = kempe_chain_flip(idx, max_color, target, new_s)\n                    if kc is not None:\n                        # Accept if max color reduces or stays same without introducing conflicts\n                        if max(kc) < max_color or count_conflicts(kc) <= count_conflicts(new_s):\n                            new_s = kc\n                # If still no change, small shake: recolor a random vertex to a random existing color\n                if new_s[idx] == s[idx]:\n                    j = random.randrange(n)\n                    new_s[j] = random.randint(1, max_color)\n\n    # Return as required by local solvers: (solution, 'INDEX_LIST')\n    return new_s, \"INDEX_LIST\"\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Structured perturbation: remap colors, then reassign a subset of max-color vertices with min-conflicts,\n# followed by 1-2 random Kempe-chain flips to escape deep local minima.\n\ndef perturb_solution(solution):\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7)\n    ]\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[start_idx] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Color remapping (palette permutation)\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(new_s)\n    max_class = [i for i,c in enumerate(new_s) if c == max_color]\n    if max_class:\n        k = max(2, len(max_class) \/\/ 2)\n        random.shuffle(max_class)\n        for idx in max_class[:k]:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            choices = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if choices:\n                new_s[idx] = random.choice(choices)\n            else:\n                # pick color minimizing conflicts\n                best_c = 1\n                best_hits = math.inf\n                for c in range(1, max_color):\n                    hits = 0\n                    for v in adj[idx]:\n                        if new_s[v] == c:\n                            hits += 1\n                    if hits < best_hits:\n                        best_hits = hits\n                        best_c = c\n                new_s[idx] = best_c\n\n    # 1-2 random Kempe-chain flips to diversify\n    for _ in range(random.randint(1,2)):\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a == b:\n            b = (b % max(new_s)) + 1 if max(new_s) > 1 else b\n        seed = random.randrange(n)\n        new_s = kempe_chain_flip(seed, a, b, new_s)\n\n    return new_s\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000595}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (5,9-1), (7,9-1), (8,9-1) # duplicates guarded below; harmless\n    ]\n    # Deduplicate edges and ensure 0-based correctness\n    E = []\n    seen = set()\n    for u,v in edges:\n        if u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen and 0 <= a < 9 and 0 <= b < 9:\n            seen.add((a,b))\n            E.append((a,b))\n\n    LARGE = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution[:n]:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in E:\n            try:\n                su = solution[u]\n                sv = solution[v]\n                if isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1:\n                    if su == sv:\n                        conflicts += 1\n                else:\n                    conflicts += 1\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator with palette compression, best-improvement recolor, and Kempe-chain flips\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize solution to INDEX_LIST of length 9 with ints >=1\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    # Graph data (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (4,5)  # duplicates safe\n    ]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def count_conflicts(arr):\n        c = 0\n        for u in range(n):\n            cu = arr[u]\n            for v in adj[u]:\n                if v > u and cu == arr[v]:\n                    c += 1\n        return c\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, max_color):\n        # Try colors 1..max_color, choose one minimizing conflicts; allow staying same if best\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        # Current conflicts at idx\n        base = vertex_conflicts(idx, arr)\n        for c in range(1, max_color+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        # Build component in subgraph induced by colors a and b, then swap colors\n        if a == b:\n            return None\n        if arr[start_idx] not in (a, b):\n            return None\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        new_arr = arr[:]\n        for u in comp:\n            new_arr[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return new_arr\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        # Resolve conflicts: pick a conflicted vertex and try best recolor; else Kempe; else expand palette\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None:\n            new_s = cand\n        else:\n            # Try a Kempe flip between current color and a random other color\n            current = new_s[idx]\n            other = random.randint(1, max_color)\n            if other == current:\n                other = (other % max_color) + 1 if max_color > 1 else current\n            kc = kempe_chain_flip(idx, current, other, new_s)\n            if kc is not None and count_conflicts(kc) <= count_conflicts(new_s):\n                new_s = kc\n            else:\n                # Last resort: expand palette for this vertex\n                new_s[idx] = max_color + 1\n    else:\n        # No conflicts: attempt palette compression on max color class\n        max_color = max(new_s)\n        max_vertices = [i for i,c in enumerate(new_s) if c == max_color]\n        if max_vertices:\n            idx = random.choice(max_vertices)\n            # Try recolor to any color < max that is feasible\n            feas = []\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    feas.append(c)\n            if feas:\n                new_s[idx] = min(feas)\n            else:\n                # Try Kempe chain with a lower color to make space\n                if max_color > 1:\n                    target = random.randint(1, max_color-1)\n                    kc = kempe_chain_flip(idx, max_color, target, new_s)\n                    if kc is not None:\n                        # Accept if max color reduces or stays same without introducing conflicts\n                        if max(kc) < max_color or count_conflicts(kc) <= count_conflicts(new_s):\n                            new_s = kc\n                # If still no change, small shake: recolor a random vertex to a random existing color\n                if new_s[idx] == s[idx]:\n                    j = random.randrange(n)\n                    new_s[j] = random.randint(1, max_color)\n\n    # Return as required by local solvers: (solution, 'INDEX_LIST')\n    return new_s, \"INDEX_LIST\"\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Structured perturbation: remap colors, then reassign a subset of max-color vertices with min-conflicts,\n# followed by 1-2 random Kempe-chain flips to escape deep local minima.\n\ndef perturb_solution(solution):\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7)\n    ]\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[start_idx] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Color remapping (palette permutation)\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(new_s)\n    max_class = [i for i,c in enumerate(new_s) if c == max_color]\n    if max_class:\n        k = max(2, len(max_class) \/\/ 2)\n        random.shuffle(max_class)\n        for idx in max_class[:k]:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            choices = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if choices:\n                new_s[idx] = random.choice(choices)\n            else:\n                # pick color minimizing conflicts\n                best_c = 1\n                best_hits = math.inf\n                for c in range(1, max_color):\n                    hits = 0\n                    for v in adj[idx]:\n                        if new_s[v] == c:\n                            hits += 1\n                    if hits < best_hits:\n                        best_hits = hits\n                        best_c = c\n                new_s[idx] = best_c\n\n    # 1-2 random Kempe-chain flips to diversify\n    for _ in range(random.randint(1,2)):\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a == b:\n            b = (b % max(new_s)) + 1 if max(new_s) > 1 else b\n        seed = random.randrange(n)\n        new_s = kempe_chain_flip(seed, a, b, new_s)\n\n    return new_s\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000142}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (5,9-1), (7,9-1), (8,9-1) # duplicates guarded below; harmless\n    ]\n    # Deduplicate edges and ensure 0-based correctness\n    E = []\n    seen = set()\n    for u,v in edges:\n        if u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen and 0 <= a < 9 and 0 <= b < 9:\n            seen.add((a,b))\n            E.append((a,b))\n\n    LARGE = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution[:n]:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in E:\n            try:\n                su = solution[u]\n                sv = solution[v]\n                if isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1:\n                    if su == sv:\n                        conflicts += 1\n                else:\n                    conflicts += 1\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator with palette compression, best-improvement recolor, and Kempe-chain flips\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize solution to INDEX_LIST of length 9 with ints >=1\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    # Graph data (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (4,5)  # duplicates safe\n    ]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def count_conflicts(arr):\n        c = 0\n        for u in range(n):\n            cu = arr[u]\n            for v in adj[u]:\n                if v > u and cu == arr[v]:\n                    c += 1\n        return c\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, max_color):\n        # Try colors 1..max_color, choose one minimizing conflicts; allow staying same if best\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        # Current conflicts at idx\n        base = vertex_conflicts(idx, arr)\n        for c in range(1, max_color+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        # Build component in subgraph induced by colors a and b, then swap colors\n        if a == b:\n            return None\n        if arr[start_idx] not in (a, b):\n            return None\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        new_arr = arr[:]\n        for u in comp:\n            new_arr[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return new_arr\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        # Resolve conflicts: pick a conflicted vertex and try best recolor; else Kempe; else expand palette\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None:\n            new_s = cand\n        else:\n            # Try a Kempe flip between current color and a random other color\n            current = new_s[idx]\n            other = random.randint(1, max_color)\n            if other == current:\n                other = (other % max_color) + 1 if max_color > 1 else current\n            kc = kempe_chain_flip(idx, current, other, new_s)\n            if kc is not None and count_conflicts(kc) <= count_conflicts(new_s):\n                new_s = kc\n            else:\n                # Last resort: expand palette for this vertex\n                new_s[idx] = max_color + 1\n    else:\n        # No conflicts: attempt palette compression on max color class\n        max_color = max(new_s)\n        max_vertices = [i for i,c in enumerate(new_s) if c == max_color]\n        if max_vertices:\n            idx = random.choice(max_vertices)\n            # Try recolor to any color < max that is feasible\n            feas = []\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    feas.append(c)\n            if feas:\n                new_s[idx] = min(feas)\n            else:\n                # Try Kempe chain with a lower color to make space\n                if max_color > 1:\n                    target = random.randint(1, max_color-1)\n                    kc = kempe_chain_flip(idx, max_color, target, new_s)\n                    if kc is not None:\n                        # Accept if max color reduces or stays same without introducing conflicts\n                        if max(kc) < max_color or count_conflicts(kc) <= count_conflicts(new_s):\n                            new_s = kc\n                # If still no change, small shake: recolor a random vertex to a random existing color\n                if new_s[idx] == s[idx]:\n                    j = random.randrange(n)\n                    new_s[j] = random.randint(1, max_color)\n\n    # Return as required by local solvers: (solution, 'INDEX_LIST')\n    return new_s, \"INDEX_LIST\"\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Structured perturbation: remap colors, then reassign a subset of max-color vertices with min-conflicts,\n# followed by 1-2 random Kempe-chain flips to escape deep local minima.\n\ndef perturb_solution(solution):\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7)\n    ]\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[start_idx] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Color remapping (palette permutation)\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(new_s)\n    max_class = [i for i,c in enumerate(new_s) if c == max_color]\n    if max_class:\n        k = max(2, len(max_class) \/\/ 2)\n        random.shuffle(max_class)\n        for idx in max_class[:k]:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            choices = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if choices:\n                new_s[idx] = random.choice(choices)\n            else:\n                # pick color minimizing conflicts\n                best_c = 1\n                best_hits = math.inf\n                for c in range(1, max_color):\n                    hits = 0\n                    for v in adj[idx]:\n                        if new_s[v] == c:\n                            hits += 1\n                    if hits < best_hits:\n                        best_hits = hits\n                        best_c = c\n                new_s[idx] = best_c\n\n    # 1-2 random Kempe-chain flips to diversify\n    for _ in range(random.randint(1,2)):\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a == b:\n            b = (b % max(new_s)) + 1 if max(new_s) > 1 else b\n        seed = random.randrange(n)\n        new_s = kempe_chain_flip(seed, a, b, new_s)\n\n    return new_s\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000118}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Build canonical 0-based edge set from PROBLEM_DEF once per call (self-contained)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n\n    INF = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    def parse_to_index_list(x):\n        # Accept str\/list\/tuple; coerce to list[int] length n; ints must be >=1\n        if isinstance(x, str):\n            # split by comma or whitespace\n            if \",\" in x:\n                parts = [p.strip() for p in x.replace(\"[\",\" \").replace(\"]\",\" \").split(\",\")]\n            else:\n                parts = x.strip().replace(\"[\",\" \").replace(\"]\",\" \").split()\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        # Normalize length strictly\n        if len(vals) != n:\n            return None\n        # Validate entries (>=1), coerce by taking max(1, val)\n        out = []\n        for v in vals:\n            out.append(int(v) if isinstance(v, int) else 1)\n        return out\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return HUGE\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in E:\n        su = s[u]\n        sv = s[v]\n        if not (isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1):\n            conflicts += 1\n        elif su == sv:\n            conflicts += 1\n\n    max_color = max(s) if all(isinstance(v, int) for v in s) else n\n\n    # Lexicographic objective: minimize conflicts first, then max_color\n    score = conflicts * INF + float(max_color)\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator: conflict-directed recolor, Kempe-chain flips, and palette compression\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Graph data\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1]*n\n\n    def vertex_conflicts(idx, arr):\n        c = 0\n        col = arr[idx]\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def total_conflicts(arr):\n        c = 0\n        for (u,v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, palette_max):\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        for c in range(1, palette_max+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        n_local = len(arr)\n        in_colors = (a, b)\n        if arr[seed] not in in_colors:\n            return None\n        visited = [False]*n_local\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in in_colors:\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None and total_conflicts(cand) <= total_conflicts(new_s):\n            new_s = cand\n        else:\n            # Try a few Kempe flips; pick the best non-worsening\n            best = new_s\n            best_conf = total_conflicts(new_s)\n            tried = set()\n            for _ in range(4):\n                a = new_s[idx]\n                b = random.randint(1, max_color)\n                if b == a:\n                    b = (b % max_color) + 1 if max_color > 1 else b\n                key = (a,b)\n                if key in tried:\n                    continue\n                tried.add(key)\n                kc = kempe_chain_flip(idx, a, b, new_s)\n                if kc is not None:\n                    c = total_conflicts(kc)\n                    if c < best_conf or (c == best_conf and max(kc) < max(best)):\n                        best = kc\n                        best_conf = c\n            if best is new_s:\n                # As a last resort, expand palette for this vertex\n                new_s[idx] = max_color + 1\n            else:\n                new_s = best\n    else:\n        # Palette compression: try to recolor vertices in the max color class to lower feasible colors\n        max_color = max(new_s)\n        candidates = [i for i,c in enumerate(new_s) if c == max_color]\n        random.shuffle(candidates)\n        changed = False\n        for idx in candidates:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if feasible:\n                new_s[idx] = min(feasible)\n                changed = True\n                break\n        if not changed and max_color > 1:\n            # Try Kempe flip between max_color and a lower color\n            idx = random.choice(candidates) if candidates else random.randrange(n)\n            target = random.randint(1, max_color - 1)\n            kc = kempe_chain_flip(idx, max_color, target, new_s)\n            if kc is not None:\n                # accept if does not increase palette size and non-worsens conflicts\n                if max(kc) <= max_color and total_conflicts(kc) <= total_conflicts(new_s):\n                    new_s = kc\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Perturbation: palette shuffle, partial reassignment of max-color class, and random Kempe flips\n\ndef perturb_solution(solution):\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1]*n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1]*n\n        else:\n            return [1]*n\n        if len(vals) != n:\n            return [1]*n\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    max_color = max(s)\n\n    # Palette permutation to change basin\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(s)\n    max_class = [i for i,c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = 1 + max(1, len(max_class)\/\/2)\n    for idx in max_class[:k]:\n        # Try any color in 1..max_color-1 with minimal neighbor hits\n        best_c = 1 if max_color > 1 else 1\n        best_hits = math.inf\n        for c in range(1, max(2, max_color)):\n            if c == max_color:\n                continue\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c\n\n    # 1-2 random Kempe flips between random color pairs\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Resultados":["2,4,3,1,1,2,2,3,4",4.0,[1,2,3,4,4,1,1,3,2],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.004552907}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Build canonical 0-based edge set from PROBLEM_DEF once per call (self-contained)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n\n    INF = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    def parse_to_index_list(x):\n        # Accept str\/list\/tuple; coerce to list[int] length n; ints must be >=1\n        if isinstance(x, str):\n            # split by comma or whitespace\n            if \",\" in x:\n                parts = [p.strip() for p in x.replace(\"[\",\" \").replace(\"]\",\" \").split(\",\")]\n            else:\n                parts = x.strip().replace(\"[\",\" \").replace(\"]\",\" \").split()\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        # Normalize length strictly\n        if len(vals) != n:\n            return None\n        # Validate entries (>=1), coerce by taking max(1, val)\n        out = []\n        for v in vals:\n            out.append(int(v) if isinstance(v, int) else 1)\n        return out\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return HUGE\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in E:\n        su = s[u]\n        sv = s[v]\n        if not (isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1):\n            conflicts += 1\n        elif su == sv:\n            conflicts += 1\n\n    max_color = max(s) if all(isinstance(v, int) for v in s) else n\n\n    # Lexicographic objective: minimize conflicts first, then max_color\n    score = conflicts * INF + float(max_color)\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator: conflict-directed recolor, Kempe-chain flips, and palette compression\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Graph data\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1]*n\n\n    def vertex_conflicts(idx, arr):\n        c = 0\n        col = arr[idx]\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def total_conflicts(arr):\n        c = 0\n        for (u,v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, palette_max):\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        for c in range(1, palette_max+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        n_local = len(arr)\n        in_colors = (a, b)\n        if arr[seed] not in in_colors:\n            return None\n        visited = [False]*n_local\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in in_colors:\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None and total_conflicts(cand) <= total_conflicts(new_s):\n            new_s = cand\n        else:\n            # Try a few Kempe flips; pick the best non-worsening\n            best = new_s\n            best_conf = total_conflicts(new_s)\n            tried = set()\n            for _ in range(4):\n                a = new_s[idx]\n                b = random.randint(1, max_color)\n                if b == a:\n                    b = (b % max_color) + 1 if max_color > 1 else b\n                key = (a,b)\n                if key in tried:\n                    continue\n                tried.add(key)\n                kc = kempe_chain_flip(idx, a, b, new_s)\n                if kc is not None:\n                    c = total_conflicts(kc)\n                    if c < best_conf or (c == best_conf and max(kc) < max(best)):\n                        best = kc\n                        best_conf = c\n            if best is new_s:\n                # As a last resort, expand palette for this vertex\n                new_s[idx] = max_color + 1\n            else:\n                new_s = best\n    else:\n        # Palette compression: try to recolor vertices in the max color class to lower feasible colors\n        max_color = max(new_s)\n        candidates = [i for i,c in enumerate(new_s) if c == max_color]\n        random.shuffle(candidates)\n        changed = False\n        for idx in candidates:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if feasible:\n                new_s[idx] = min(feasible)\n                changed = True\n                break\n        if not changed and max_color > 1:\n            # Try Kempe flip between max_color and a lower color\n            idx = random.choice(candidates) if candidates else random.randrange(n)\n            target = random.randint(1, max_color - 1)\n            kc = kempe_chain_flip(idx, max_color, target, new_s)\n            if kc is not None:\n                # accept if does not increase palette size and non-worsens conflicts\n                if max(kc) <= max_color and total_conflicts(kc) <= total_conflicts(new_s):\n                    new_s = kc\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Perturbation: palette shuffle, partial reassignment of max-color class, and random Kempe flips\n\ndef perturb_solution(solution):\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1]*n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1]*n\n        else:\n            return [1]*n\n        if len(vals) != n:\n            return [1]*n\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    max_color = max(s)\n\n    # Palette permutation to change basin\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(s)\n    max_class = [i for i,c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = 1 + max(1, len(max_class)\/\/2)\n    for idx in max_class[:k]:\n        # Try any color in 1..max_color-1 with minimal neighbor hits\n        best_c = 1 if max_color > 1 else 1\n        best_hits = math.inf\n        for c in range(1, max(2, max_color)):\n            if c == max_color:\n                continue\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c\n\n    # 1-2 random Kempe flips between random color pairs\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Resultados":["1,2,1,2,1,2,1,1,2",4.0,[1,2,3,4,4,1,1,3,2],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.004283355}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Build canonical 0-based edge set from PROBLEM_DEF once per call (self-contained)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n\n    INF = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    def parse_to_index_list(x):\n        # Accept str\/list\/tuple; coerce to list[int] length n; ints must be >=1\n        if isinstance(x, str):\n            # split by comma or whitespace\n            if \",\" in x:\n                parts = [p.strip() for p in x.replace(\"[\",\" \").replace(\"]\",\" \").split(\",\")]\n            else:\n                parts = x.strip().replace(\"[\",\" \").replace(\"]\",\" \").split()\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        # Normalize length strictly\n        if len(vals) != n:\n            return None\n        # Validate entries (>=1), coerce by taking max(1, val)\n        out = []\n        for v in vals:\n            out.append(int(v) if isinstance(v, int) else 1)\n        return out\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return HUGE\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in E:\n        su = s[u]\n        sv = s[v]\n        if not (isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1):\n            conflicts += 1\n        elif su == sv:\n            conflicts += 1\n\n    max_color = max(s) if all(isinstance(v, int) for v in s) else n\n\n    # Lexicographic objective: minimize conflicts first, then max_color\n    score = conflicts * INF + float(max_color)\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator: conflict-directed recolor, Kempe-chain flips, and palette compression\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Graph data\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1]*n\n\n    def vertex_conflicts(idx, arr):\n        c = 0\n        col = arr[idx]\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def total_conflicts(arr):\n        c = 0\n        for (u,v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, palette_max):\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        for c in range(1, palette_max+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        n_local = len(arr)\n        in_colors = (a, b)\n        if arr[seed] not in in_colors:\n            return None\n        visited = [False]*n_local\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in in_colors:\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None and total_conflicts(cand) <= total_conflicts(new_s):\n            new_s = cand\n        else:\n            # Try a few Kempe flips; pick the best non-worsening\n            best = new_s\n            best_conf = total_conflicts(new_s)\n            tried = set()\n            for _ in range(4):\n                a = new_s[idx]\n                b = random.randint(1, max_color)\n                if b == a:\n                    b = (b % max_color) + 1 if max_color > 1 else b\n                key = (a,b)\n                if key in tried:\n                    continue\n                tried.add(key)\n                kc = kempe_chain_flip(idx, a, b, new_s)\n                if kc is not None:\n                    c = total_conflicts(kc)\n                    if c < best_conf or (c == best_conf and max(kc) < max(best)):\n                        best = kc\n                        best_conf = c\n            if best is new_s:\n                # As a last resort, expand palette for this vertex\n                new_s[idx] = max_color + 1\n            else:\n                new_s = best\n    else:\n        # Palette compression: try to recolor vertices in the max color class to lower feasible colors\n        max_color = max(new_s)\n        candidates = [i for i,c in enumerate(new_s) if c == max_color]\n        random.shuffle(candidates)\n        changed = False\n        for idx in candidates:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if feasible:\n                new_s[idx] = min(feasible)\n                changed = True\n                break\n        if not changed and max_color > 1:\n            # Try Kempe flip between max_color and a lower color\n            idx = random.choice(candidates) if candidates else random.randrange(n)\n            target = random.randint(1, max_color - 1)\n            kc = kempe_chain_flip(idx, max_color, target, new_s)\n            if kc is not None:\n                # accept if does not increase palette size and non-worsens conflicts\n                if max(kc) <= max_color and total_conflicts(kc) <= total_conflicts(new_s):\n                    new_s = kc\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Perturbation: palette shuffle, partial reassignment of max-color class, and random Kempe flips\n\ndef perturb_solution(solution):\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1]*n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1]*n\n        else:\n            return [1]*n\n        if len(vals) != n:\n            return [1]*n\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    max_color = max(s)\n\n    # Palette permutation to change basin\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(s)\n    max_class = [i for i,c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = 1 + max(1, len(max_class)\/\/2)\n    for idx in max_class[:k]:\n        # Try any color in 1..max_color-1 with minimal neighbor hits\n        best_c = 1 if max_color > 1 else 1\n        best_hits = math.inf\n        for c in range(1, max(2, max_color)):\n            if c == max_color:\n                continue\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c\n\n    # 1-2 random Kempe flips between random color pairs\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00193285}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Problem data (internal to function per constraints)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    # Strict parser: accept list\/tuple of length n or comma\/space separated string of n integers >=1\n    def parse_to_index_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    v = int(p)\n                except Exception:\n                    return None\n                vals.append(v)\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    iv = int(v)\n                except Exception:\n                    return None\n                vals.append(iv)\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return float(10**9)\n\n    # Build edge list 0-based (deduplicate defensively)\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if s[u] == s[v]:\n            conflicts += 1\n\n    max_color = max(s) if s else 0\n\n    # Lexicographic scalarization: weight larger than max possible max_color\n    # |E| <= 24 here, but use a conservative K\n    K = 1000\n    score = conflicts * K + max_color\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(arr):\n        c = 0\n        for (u, v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def score_tuple(arr):\n        return (total_conflicts(arr), max(arr) if arr else 0)\n\n    def better(a, b):\n        return a[0] < b[0] or (a[0] == b[0] and a[1] < b[1])\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr):\n        palette_max = max(arr)\n        cur = arr[idx]\n        best = None\n        best_sc = None\n        for c in range(1, palette_max + 1):\n            if c == cur:\n                continue\n            cand = arr[:]\n            cand[idx] = c\n            sc = score_tuple(cand)\n            if best is None or better(sc, best_sc) or (sc == best_sc and c < (best[idx] if best is not None else c)):\n                best = cand\n                best_sc = sc\n        return best, best_sc\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        if arr[seed] not in (a, b):\n            return None\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1] * n\n\n    cur_sc = score_tuple(s)\n    new_s = s[:]\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    moved = False\n    if conflicted:\n        # Target a random conflicted vertex, try best recolor then Kempe improvements\n        idx = random.choice(conflicted)\n        cand, cand_sc = best_recolor(idx, new_s)\n        if cand is not None and (better(cand_sc, cur_sc) or cand_sc == cur_sc):\n            new_s = cand\n            cur_sc = cand_sc\n            moved = True\n        else:\n            # Try Kempe flips with all b in palette\n            a = new_s[idx]\n            palette_max = max(new_s)\n            best = None\n            best_sc = None\n            for b_col in range(1, palette_max + 1):\n                if b_col == a:\n                    continue\n                kc = kempe_chain_flip(idx, a, b_col, new_s)\n                if kc is None:\n                    continue\n                sc = score_tuple(kc)\n                if best is None or better(sc, best_sc):\n                    best = kc\n                    best_sc = sc\n            if best is not None and (better(best_sc, cur_sc) or best_sc == cur_sc):\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n    if not moved:\n        # Compression: try to lower max color class\n        palette_max = max(new_s)\n        targets = [i for i, c in enumerate(new_s) if c == palette_max]\n        random.shuffle(targets)\n        for idx in targets:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, palette_max) if c not in neighbor_colors]\n            for c in feasible:\n                cand = new_s[:]\n                cand[idx] = c\n                sc = score_tuple(cand)\n                if better(sc, cur_sc) or sc == cur_sc:\n                    new_s = cand\n                    cur_sc = sc\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved and palette_max > 1 and targets:\n            # Kempe swap between max color and lower colors, pick best non-worsening\n            best = None\n            best_sc = None\n            for idx in targets:\n                for c in range(1, palette_max):\n                    kc = kempe_chain_flip(idx, palette_max, c, new_s)\n                    if kc is None:\n                        continue\n                    sc = score_tuple(kc)\n                    if (best is None or better(sc, best_sc)) and (better(sc, cur_sc) or sc == cur_sc):\n                        best = kc\n                        best_sc = sc\n            if best is not None:\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1] * n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return [1] * n\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1] * n\n        else:\n            return [1] * n\n        if len(vals) != n:\n            return [1] * n\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return [1] * n\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a, b):\n            return arr[:]\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n\n    # Palette shuffle to escape basin\n    max_color = max(s)\n    palette = list(range(1, max_color + 1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color + 1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign half of vertices from current max color to least-conflicting lower colors\n    max_color = max(s)\n    max_class = [i for i, c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = max(1, len(max_class) \/\/ 2)\n    for idx in max_class[:k]:\n        best_c = 1\n        best_hits = math.inf\n        for c in range(1, max_color):\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c if max_color > 1 else s[idx]\n\n    # Apply 1-2 random Kempe flips\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Resultados":["2,4,3,1,1,2,2,3,4",4.0,[2,4,3,1,1,2,2,3,4],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.005100664}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Problem data (internal to function per constraints)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    # Strict parser: accept list\/tuple of length n or comma\/space separated string of n integers >=1\n    def parse_to_index_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    v = int(p)\n                except Exception:\n                    return None\n                vals.append(v)\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    iv = int(v)\n                except Exception:\n                    return None\n                vals.append(iv)\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return float(10**9)\n\n    # Build edge list 0-based (deduplicate defensively)\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if s[u] == s[v]:\n            conflicts += 1\n\n    max_color = max(s) if s else 0\n\n    # Lexicographic scalarization: weight larger than max possible max_color\n    # |E| <= 24 here, but use a conservative K\n    K = 1000\n    score = conflicts * K + max_color\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(arr):\n        c = 0\n        for (u, v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def score_tuple(arr):\n        return (total_conflicts(arr), max(arr) if arr else 0)\n\n    def better(a, b):\n        return a[0] < b[0] or (a[0] == b[0] and a[1] < b[1])\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr):\n        palette_max = max(arr)\n        cur = arr[idx]\n        best = None\n        best_sc = None\n        for c in range(1, palette_max + 1):\n            if c == cur:\n                continue\n            cand = arr[:]\n            cand[idx] = c\n            sc = score_tuple(cand)\n            if best is None or better(sc, best_sc) or (sc == best_sc and c < (best[idx] if best is not None else c)):\n                best = cand\n                best_sc = sc\n        return best, best_sc\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        if arr[seed] not in (a, b):\n            return None\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1] * n\n\n    cur_sc = score_tuple(s)\n    new_s = s[:]\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    moved = False\n    if conflicted:\n        # Target a random conflicted vertex, try best recolor then Kempe improvements\n        idx = random.choice(conflicted)\n        cand, cand_sc = best_recolor(idx, new_s)\n        if cand is not None and (better(cand_sc, cur_sc) or cand_sc == cur_sc):\n            new_s = cand\n            cur_sc = cand_sc\n            moved = True\n        else:\n            # Try Kempe flips with all b in palette\n            a = new_s[idx]\n            palette_max = max(new_s)\n            best = None\n            best_sc = None\n            for b_col in range(1, palette_max + 1):\n                if b_col == a:\n                    continue\n                kc = kempe_chain_flip(idx, a, b_col, new_s)\n                if kc is None:\n                    continue\n                sc = score_tuple(kc)\n                if best is None or better(sc, best_sc):\n                    best = kc\n                    best_sc = sc\n            if best is not None and (better(best_sc, cur_sc) or best_sc == cur_sc):\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n    if not moved:\n        # Compression: try to lower max color class\n        palette_max = max(new_s)\n        targets = [i for i, c in enumerate(new_s) if c == palette_max]\n        random.shuffle(targets)\n        for idx in targets:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, palette_max) if c not in neighbor_colors]\n            for c in feasible:\n                cand = new_s[:]\n                cand[idx] = c\n                sc = score_tuple(cand)\n                if better(sc, cur_sc) or sc == cur_sc:\n                    new_s = cand\n                    cur_sc = sc\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved and palette_max > 1 and targets:\n            # Kempe swap between max color and lower colors, pick best non-worsening\n            best = None\n            best_sc = None\n            for idx in targets:\n                for c in range(1, palette_max):\n                    kc = kempe_chain_flip(idx, palette_max, c, new_s)\n                    if kc is None:\n                        continue\n                    sc = score_tuple(kc)\n                    if (best is None or better(sc, best_sc)) and (better(sc, cur_sc) or sc == cur_sc):\n                        best = kc\n                        best_sc = sc\n            if best is not None:\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1] * n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return [1] * n\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1] * n\n        else:\n            return [1] * n\n        if len(vals) != n:\n            return [1] * n\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return [1] * n\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a, b):\n            return arr[:]\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n\n    # Palette shuffle to escape basin\n    max_color = max(s)\n    palette = list(range(1, max_color + 1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color + 1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign half of vertices from current max color to least-conflicting lower colors\n    max_color = max(s)\n    max_class = [i for i, c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = max(1, len(max_class) \/\/ 2)\n    for idx in max_class[:k]:\n        best_c = 1\n        best_hits = math.inf\n        for c in range(1, max_color):\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c if max_color > 1 else s[idx]\n\n    # Apply 1-2 random Kempe flips\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Resultados":["3,1,1,2,2,2,3,2,2",4.0,[2,4,3,1,1,2,2,3,4],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.004405956}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Problem data (internal to function per constraints)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    # Strict parser: accept list\/tuple of length n or comma\/space separated string of n integers >=1\n    def parse_to_index_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    v = int(p)\n                except Exception:\n                    return None\n                vals.append(v)\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    iv = int(v)\n                except Exception:\n                    return None\n                vals.append(iv)\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return float(10**9)\n\n    # Build edge list 0-based (deduplicate defensively)\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if s[u] == s[v]:\n            conflicts += 1\n\n    max_color = max(s) if s else 0\n\n    # Lexicographic scalarization: weight larger than max possible max_color\n    # |E| <= 24 here, but use a conservative K\n    K = 1000\n    score = conflicts * K + max_color\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(arr):\n        c = 0\n        for (u, v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def score_tuple(arr):\n        return (total_conflicts(arr), max(arr) if arr else 0)\n\n    def better(a, b):\n        return a[0] < b[0] or (a[0] == b[0] and a[1] < b[1])\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr):\n        palette_max = max(arr)\n        cur = arr[idx]\n        best = None\n        best_sc = None\n        for c in range(1, palette_max + 1):\n            if c == cur:\n                continue\n            cand = arr[:]\n            cand[idx] = c\n            sc = score_tuple(cand)\n            if best is None or better(sc, best_sc) or (sc == best_sc and c < (best[idx] if best is not None else c)):\n                best = cand\n                best_sc = sc\n        return best, best_sc\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        if arr[seed] not in (a, b):\n            return None\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1] * n\n\n    cur_sc = score_tuple(s)\n    new_s = s[:]\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    moved = False\n    if conflicted:\n        # Target a random conflicted vertex, try best recolor then Kempe improvements\n        idx = random.choice(conflicted)\n        cand, cand_sc = best_recolor(idx, new_s)\n        if cand is not None and (better(cand_sc, cur_sc) or cand_sc == cur_sc):\n            new_s = cand\n            cur_sc = cand_sc\n            moved = True\n        else:\n            # Try Kempe flips with all b in palette\n            a = new_s[idx]\n            palette_max = max(new_s)\n            best = None\n            best_sc = None\n            for b_col in range(1, palette_max + 1):\n                if b_col == a:\n                    continue\n                kc = kempe_chain_flip(idx, a, b_col, new_s)\n                if kc is None:\n                    continue\n                sc = score_tuple(kc)\n                if best is None or better(sc, best_sc):\n                    best = kc\n                    best_sc = sc\n            if best is not None and (better(best_sc, cur_sc) or best_sc == cur_sc):\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n    if not moved:\n        # Compression: try to lower max color class\n        palette_max = max(new_s)\n        targets = [i for i, c in enumerate(new_s) if c == palette_max]\n        random.shuffle(targets)\n        for idx in targets:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, palette_max) if c not in neighbor_colors]\n            for c in feasible:\n                cand = new_s[:]\n                cand[idx] = c\n                sc = score_tuple(cand)\n                if better(sc, cur_sc) or sc == cur_sc:\n                    new_s = cand\n                    cur_sc = sc\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved and palette_max > 1 and targets:\n            # Kempe swap between max color and lower colors, pick best non-worsening\n            best = None\n            best_sc = None\n            for idx in targets:\n                for c in range(1, palette_max):\n                    kc = kempe_chain_flip(idx, palette_max, c, new_s)\n                    if kc is None:\n                        continue\n                    sc = score_tuple(kc)\n                    if (best is None or better(sc, best_sc)) and (better(sc, cur_sc) or sc == cur_sc):\n                        best = kc\n                        best_sc = sc\n            if best is not None:\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1] * n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return [1] * n\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1] * n\n        else:\n            return [1] * n\n        if len(vals) != n:\n            return [1] * n\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return [1] * n\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a, b):\n            return arr[:]\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n\n    # Palette shuffle to escape basin\n    max_color = max(s)\n    palette = list(range(1, max_color + 1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color + 1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign half of vertices from current max color to least-conflicting lower colors\n    max_color = max(s)\n    max_class = [i for i, c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = max(1, len(max_class) \/\/ 2)\n    for idx in max_class[:k]:\n        best_c = 1\n        best_hits = math.inf\n        for c in range(1, max_color):\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c if max_color > 1 else s[idx]\n\n    # Apply 1-2 random Kempe flips\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002049102}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN9_POSITIVE_INTS_ROOMS_1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based conversion inline)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: greedy recolor a single node to reduce conflicts\/rooms.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    # Recompute conflicts per node\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    max_room_current = max(solution)\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Pick a node with probability proportional to its conflict count (+1 smoothing)\n    conflicts_per_node = [0]*n\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0, total_w)\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors plus possibly one new color\n    used_colors = set(solution)\n    candidate_colors = list(sorted(used_colors))\n    candidate_colors.append(max_room_current + 1)\n    # Evaluate each candidate color for chosen node\n    best_color = solution[chosen]\n    best_score = (10**9, 10**9)  # tuple: (conflicts_incident, new_max_room)\n    for c in candidate_colors:\n        # Count incident conflicts if node takes color c\n        conf = 0\n        for nb in adj[chosen]:\n            if solution[nb] == c:\n                conf += 1\n        new_max = max(max_room_current, c)\n        score = (conf, new_max)\n        if score < best_score:\n            best_score = score\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, attempt random recolor among candidates\n        best_color = random.choice(candidate_colors)\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    return (new_solution, \"recolor_one_node\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Perturbation: Kempe-like color swap between two colors; fallback to random reassign for a few nodes.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(solution))\n    new_solution = solution.copy()\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Build the subgraph induced by colors c1 and c2 and pick a random connected component to swap\n        nodes = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes:\n            visited = [False]*n\n            # pick a random seed among nodes in (c1,c2)\n            seed = random.choice(nodes)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            # swap colors in this component\n            for u in comp:\n                new_solution[u] = c1 if new_solution[u] == c2 else (c2 if new_solution[u] == c1 else new_solution[u])\n            return new_solution\n    # Fallback: randomly reassign k nodes to existing or new color\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    return new_solution\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000503}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN9_POSITIVE_INTS_ROOMS_1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based conversion inline)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: greedy recolor a single node to reduce conflicts\/rooms.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    # Recompute conflicts per node\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    max_room_current = max(solution)\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Pick a node with probability proportional to its conflict count (+1 smoothing)\n    conflicts_per_node = [0]*n\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0, total_w)\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors plus possibly one new color\n    used_colors = set(solution)\n    candidate_colors = list(sorted(used_colors))\n    candidate_colors.append(max_room_current + 1)\n    # Evaluate each candidate color for chosen node\n    best_color = solution[chosen]\n    best_score = (10**9, 10**9)  # tuple: (conflicts_incident, new_max_room)\n    for c in candidate_colors:\n        # Count incident conflicts if node takes color c\n        conf = 0\n        for nb in adj[chosen]:\n            if solution[nb] == c:\n                conf += 1\n        new_max = max(max_room_current, c)\n        score = (conf, new_max)\n        if score < best_score:\n            best_score = score\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, attempt random recolor among candidates\n        best_color = random.choice(candidate_colors)\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    return (new_solution, \"recolor_one_node\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Perturbation: Kempe-like color swap between two colors; fallback to random reassign for a few nodes.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(solution))\n    new_solution = solution.copy()\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Build the subgraph induced by colors c1 and c2 and pick a random connected component to swap\n        nodes = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes:\n            visited = [False]*n\n            # pick a random seed among nodes in (c1,c2)\n            seed = random.choice(nodes)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            # swap colors in this component\n            for u in comp:\n                new_solution[u] = c1 if new_solution[u] == c2 else (c2 if new_solution[u] == c1 else new_solution[u])\n            return new_solution\n    # Fallback: randomly reassign k nodes to existing or new color\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    return new_solution\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000146}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN9_POSITIVE_INTS_ROOMS_1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based conversion inline)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: greedy recolor a single node to reduce conflicts\/rooms.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    # Recompute conflicts per node\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    max_room_current = max(solution)\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Pick a node with probability proportional to its conflict count (+1 smoothing)\n    conflicts_per_node = [0]*n\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0, total_w)\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors plus possibly one new color\n    used_colors = set(solution)\n    candidate_colors = list(sorted(used_colors))\n    candidate_colors.append(max_room_current + 1)\n    # Evaluate each candidate color for chosen node\n    best_color = solution[chosen]\n    best_score = (10**9, 10**9)  # tuple: (conflicts_incident, new_max_room)\n    for c in candidate_colors:\n        # Count incident conflicts if node takes color c\n        conf = 0\n        for nb in adj[chosen]:\n            if solution[nb] == c:\n                conf += 1\n        new_max = max(max_room_current, c)\n        score = (conf, new_max)\n        if score < best_score:\n            best_score = score\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, attempt random recolor among candidates\n        best_color = random.choice(candidate_colors)\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    return (new_solution, \"recolor_one_node\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Perturbation: Kempe-like color swap between two colors; fallback to random reassign for a few nodes.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(solution))\n    new_solution = solution.copy()\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Build the subgraph induced by colors c1 and c2 and pick a random connected component to swap\n        nodes = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes:\n            visited = [False]*n\n            # pick a random seed among nodes in (c1,c2)\n            seed = random.choice(nodes)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            # swap colors in this component\n            for u in comp:\n                new_solution[u] = c1 if new_solution[u] == c2 else (c2 if new_solution[u] == c1 else new_solution[u])\n            return new_solution\n    # Fallback: randomly reassign k nodes to existing or new color\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    return new_solution\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000119}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9. Each solution is a list of 9 positive integers [r1,r2,...,r9], where ri is the room (color) assigned to node i (1-based nodes). Valid domains: ri >= 1. Objective: minimize max(ri) subject to r_u != r_v for all edges.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based inline conversion)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute current conflicts per node and total\n    conflicts_per_node = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n    max_room_current = max(solution)\n    # Select a node (bias to higher conflict; +1 smoothing)\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0.0, float(total_w))\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors; optionally try removing highest color\n    used_colors = sorted(set(solution))\n    candidate_colors = list(used_colors)\n    # Do not introduce a new color unless we still have conflicts\n    if total_conflicts > 0:\n        candidate_colors.append(max_room_current + 1)\n    # Evaluate objective delta for recoloring chosen node\n    def objective(sol):\n        # Inline evaluation to avoid external dependency\n        max_room = 0\n        conflicts = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 1000 + max_room\n    base_obj = objective(solution)\n    best_color = solution[chosen]\n    best_obj = base_obj\n    # Prefer smaller colors on ties to encourage palette compression\n    for c in candidate_colors:\n        if c == solution[chosen]:\n            continue\n        trial = solution.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"random_recolor\"\n    else:\n        move_type = \"greedy_recolor\"\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    # Canonicalize colors to 1..k by first occurrence to reduce symmetry\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    new_solution = [remap[v] for v in new_solution]\n    return (new_solution, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style color swap between two colors; fallback to multi-node random reassignment\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_solution = solution.copy()\n    colors = sorted(set(new_solution))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False]*n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_solution[u] == c1:\n                    new_solution[u] = c2\n                elif new_solution[u] == c2:\n                    new_solution[u] = c1\n            # Canonicalize colors to 1..k by first occurrence\n            remap = {}\n            next_c = 1\n            for v in new_solution:\n                if v not in remap:\n                    remap[v] = next_c\n                    next_c += 1\n            return [remap[v] for v in new_solution]\n    # Fallback: reassign a small block of nodes\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    # Canonicalize\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    return [remap[v] for v in new_solution]\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001045951}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9. Each solution is a list of 9 positive integers [r1,r2,...,r9], where ri is the room (color) assigned to node i (1-based nodes). Valid domains: ri >= 1. Objective: minimize max(ri) subject to r_u != r_v for all edges.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based inline conversion)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute current conflicts per node and total\n    conflicts_per_node = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n    max_room_current = max(solution)\n    # Select a node (bias to higher conflict; +1 smoothing)\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0.0, float(total_w))\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors; optionally try removing highest color\n    used_colors = sorted(set(solution))\n    candidate_colors = list(used_colors)\n    # Do not introduce a new color unless we still have conflicts\n    if total_conflicts > 0:\n        candidate_colors.append(max_room_current + 1)\n    # Evaluate objective delta for recoloring chosen node\n    def objective(sol):\n        # Inline evaluation to avoid external dependency\n        max_room = 0\n        conflicts = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 1000 + max_room\n    base_obj = objective(solution)\n    best_color = solution[chosen]\n    best_obj = base_obj\n    # Prefer smaller colors on ties to encourage palette compression\n    for c in candidate_colors:\n        if c == solution[chosen]:\n            continue\n        trial = solution.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"random_recolor\"\n    else:\n        move_type = \"greedy_recolor\"\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    # Canonicalize colors to 1..k by first occurrence to reduce symmetry\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    new_solution = [remap[v] for v in new_solution]\n    return (new_solution, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style color swap between two colors; fallback to multi-node random reassignment\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_solution = solution.copy()\n    colors = sorted(set(new_solution))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False]*n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_solution[u] == c1:\n                    new_solution[u] = c2\n                elif new_solution[u] == c2:\n                    new_solution[u] = c1\n            # Canonicalize colors to 1..k by first occurrence\n            remap = {}\n            next_c = 1\n            for v in new_solution:\n                if v not in remap:\n                    remap[v] = next_c\n                    next_c += 1\n            return [remap[v] for v in new_solution]\n    # Fallback: reassign a small block of nodes\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    # Canonicalize\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    return [remap[v] for v in new_solution]\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00092066}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9. Each solution is a list of 9 positive integers [r1,r2,...,r9], where ri is the room (color) assigned to node i (1-based nodes). Valid domains: ri >= 1. Objective: minimize max(ri) subject to r_u != r_v for all edges.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based inline conversion)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute current conflicts per node and total\n    conflicts_per_node = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n    max_room_current = max(solution)\n    # Select a node (bias to higher conflict; +1 smoothing)\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0.0, float(total_w))\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors; optionally try removing highest color\n    used_colors = sorted(set(solution))\n    candidate_colors = list(used_colors)\n    # Do not introduce a new color unless we still have conflicts\n    if total_conflicts > 0:\n        candidate_colors.append(max_room_current + 1)\n    # Evaluate objective delta for recoloring chosen node\n    def objective(sol):\n        # Inline evaluation to avoid external dependency\n        max_room = 0\n        conflicts = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 1000 + max_room\n    base_obj = objective(solution)\n    best_color = solution[chosen]\n    best_obj = base_obj\n    # Prefer smaller colors on ties to encourage palette compression\n    for c in candidate_colors:\n        if c == solution[chosen]:\n            continue\n        trial = solution.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"random_recolor\"\n    else:\n        move_type = \"greedy_recolor\"\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    # Canonicalize colors to 1..k by first occurrence to reduce symmetry\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    new_solution = [remap[v] for v in new_solution]\n    return (new_solution, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style color swap between two colors; fallback to multi-node random reassignment\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_solution = solution.copy()\n    colors = sorted(set(new_solution))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False]*n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_solution[u] == c1:\n                    new_solution[u] = c2\n                elif new_solution[u] == c2:\n                    new_solution[u] = c1\n            # Canonicalize colors to 1..k by first occurrence\n            remap = {}\n            next_c = 1\n            for v in new_solution:\n                if v not in remap:\n                    remap[v] = next_c\n                    next_c += 1\n            return [remap[v] for v in new_solution]\n    # Fallback: reassign a small block of nodes\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    # Canonicalize\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    return [remap[v] for v in new_solution]\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.0009012891}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: A solution is a Python list of 9 positive ints [r1,...,r9], ri>=1, representing colors assigned to nodes 1..9.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    # Scale = |E|+1 = 24+1 = 25 ensures strict lexicographic order\n    return conflicts * 25 + max_room\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: objective consistent with evaluate_solution\n    def objective(sol):\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 25 + max_room\n\n    cur = solution\n    base_obj = objective(cur)\n\n    # Compute conflicts per node and total conflicts\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Node selection: choose among max-conflict nodes; tie-break at random\n    max_c = max(conflicts_per_node) if conflicts_per_node else 0\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    chosen = random.choice(candidates) if candidates else random.randrange(n)\n\n    new_sol = cur.copy()\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: prefer existing colors; introduce new color only when conflicts remain and with small probability\n    candidate_colors = list(used_colors)\n    if total_conflicts > 0 and random.random() < 0.15:\n        candidate_colors.append(max_color + 1)\n\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        trial = new_sol.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n\n    if best_color == new_sol[chosen]:\n        # No improvement found: random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"recolor_random\"\n\n    new_sol[chosen] = best_color\n\n    # Optional palette compression if conflict-free: try to reduce max color by recoloring a node using highest color\n    if max_c == 0:\n        max_color_now = max(new_sol)\n        if max_color_now > 1:\n            nodes_max = [i for i, c in enumerate(new_sol) if c == max_color_now]\n            if nodes_max:\n                i = random.choice(nodes_max)\n                best_c = new_sol[i]\n                best_o = objective(new_sol)\n                # Try lower colors only\n                for c in range(1, max_color_now):\n                    t = new_sol.copy()\n                    t[i] = c\n                    o = objective(t)\n                    if o < best_o or (o == best_o and c < best_c):\n                        best_o = o\n                        best_c = c\n                if best_c != new_sol[i]:\n                    new_sol[i] = best_c\n                    move_type = \"palette_compress\"\n\n    return (new_sol, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution.copy()\n    colors = sorted(set(new_sol))\n\n    # Try Kempe-chain swap between two colors\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            # Swap colors on the component\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            return canonicalize(new_sol)\n\n    # Fallback: shuffle a few nodes among existing colors or introduce one new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n\n    return canonicalize(new_sol)\n","Resultados":[[1,3,2,4,4,1,1,2,3],4,[1,3,2,4,4,1,1,2,3],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00276061}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: A solution is a Python list of 9 positive ints [r1,...,r9], ri>=1, representing colors assigned to nodes 1..9.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    # Scale = |E|+1 = 24+1 = 25 ensures strict lexicographic order\n    return conflicts * 25 + max_room\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: objective consistent with evaluate_solution\n    def objective(sol):\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 25 + max_room\n\n    cur = solution\n    base_obj = objective(cur)\n\n    # Compute conflicts per node and total conflicts\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Node selection: choose among max-conflict nodes; tie-break at random\n    max_c = max(conflicts_per_node) if conflicts_per_node else 0\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    chosen = random.choice(candidates) if candidates else random.randrange(n)\n\n    new_sol = cur.copy()\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: prefer existing colors; introduce new color only when conflicts remain and with small probability\n    candidate_colors = list(used_colors)\n    if total_conflicts > 0 and random.random() < 0.15:\n        candidate_colors.append(max_color + 1)\n\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        trial = new_sol.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n\n    if best_color == new_sol[chosen]:\n        # No improvement found: random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"recolor_random\"\n\n    new_sol[chosen] = best_color\n\n    # Optional palette compression if conflict-free: try to reduce max color by recoloring a node using highest color\n    if max_c == 0:\n        max_color_now = max(new_sol)\n        if max_color_now > 1:\n            nodes_max = [i for i, c in enumerate(new_sol) if c == max_color_now]\n            if nodes_max:\n                i = random.choice(nodes_max)\n                best_c = new_sol[i]\n                best_o = objective(new_sol)\n                # Try lower colors only\n                for c in range(1, max_color_now):\n                    t = new_sol.copy()\n                    t[i] = c\n                    o = objective(t)\n                    if o < best_o or (o == best_o and c < best_c):\n                        best_o = o\n                        best_c = c\n                if best_c != new_sol[i]:\n                    new_sol[i] = best_c\n                    move_type = \"palette_compress\"\n\n    return (new_sol, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution.copy()\n    colors = sorted(set(new_sol))\n\n    # Try Kempe-chain swap between two colors\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            # Swap colors on the component\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            return canonicalize(new_sol)\n\n    # Fallback: shuffle a few nodes among existing colors or introduce one new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n\n    return canonicalize(new_sol)\n","Resultados":[[1,2,3,4,1,4,5,4,2],29,[1,2,3,4,4,1,1,3,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003088773}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: A solution is a Python list of 9 positive ints [r1,...,r9], ri>=1, representing colors assigned to nodes 1..9.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    # Scale = |E|+1 = 24+1 = 25 ensures strict lexicographic order\n    return conflicts * 25 + max_room\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: objective consistent with evaluate_solution\n    def objective(sol):\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 25 + max_room\n\n    cur = solution\n    base_obj = objective(cur)\n\n    # Compute conflicts per node and total conflicts\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Node selection: choose among max-conflict nodes; tie-break at random\n    max_c = max(conflicts_per_node) if conflicts_per_node else 0\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    chosen = random.choice(candidates) if candidates else random.randrange(n)\n\n    new_sol = cur.copy()\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: prefer existing colors; introduce new color only when conflicts remain and with small probability\n    candidate_colors = list(used_colors)\n    if total_conflicts > 0 and random.random() < 0.15:\n        candidate_colors.append(max_color + 1)\n\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        trial = new_sol.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n\n    if best_color == new_sol[chosen]:\n        # No improvement found: random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"recolor_random\"\n\n    new_sol[chosen] = best_color\n\n    # Optional palette compression if conflict-free: try to reduce max color by recoloring a node using highest color\n    if max_c == 0:\n        max_color_now = max(new_sol)\n        if max_color_now > 1:\n            nodes_max = [i for i, c in enumerate(new_sol) if c == max_color_now]\n            if nodes_max:\n                i = random.choice(nodes_max)\n                best_c = new_sol[i]\n                best_o = objective(new_sol)\n                # Try lower colors only\n                for c in range(1, max_color_now):\n                    t = new_sol.copy()\n                    t[i] = c\n                    o = objective(t)\n                    if o < best_o or (o == best_o and c < best_c):\n                        best_o = o\n                        best_c = c\n                if best_c != new_sol[i]:\n                    new_sol[i] = best_c\n                    move_type = \"palette_compress\"\n\n    return (new_sol, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution.copy()\n    colors = sorted(set(new_sol))\n\n    # Try Kempe-chain swap between two colors\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            # Swap colors on the component\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            return canonicalize(new_sol)\n\n    # Fallback: shuffle a few nodes among existing colors or introduce one new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n\n    return canonicalize(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001586818}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: list of 9 positive integers [r1,...,r9], ri>=1, representing colors\/rooms for nodes 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    scale = len(edges) + 1  # ensures lexicographic order: conflicts prioritized over palette size\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    return conflicts * scale + max_room\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    scale = len(edges) + 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def obj(sol: List[int]) -> int:\n        # Fast objective consistent with evaluate_solution\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * scale + max_room\n\n    cur = solution\n    base_obj = obj(cur)\n\n    # Conflicts per node and total\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Helper: saturation degree\n    def sat_deg(i: int) -> int:\n        return len(set(cur[j] for j in adj[i]))\n\n    # Conflict-free state: only attempt safe palette compression (non-worsening guard)\n    if total_conflicts == 0:\n        maxc = max(cur)\n        nodes_max = [i for i, c in enumerate(cur) if c == maxc]\n        if not nodes_max or maxc == 1:\n            return (cur[:], \"noop_conflict_free\")\n        i = random.choice(nodes_max)\n        best_c = cur[i]\n        best_o = base_obj\n        for c in range(1, maxc):\n            ok = True\n            for nb in adj[i]:\n                if cur[nb] == c:\n                    ok = False\n                    break\n            if not ok:\n                continue\n            cand = cur[:]\n            cand[i] = c\n            o = obj(cand)\n            if o < best_o or (o == best_o and c < best_c):\n                best_o = o\n                best_c = c\n        if best_c != cur[i]:\n            new_sol = cur[:]\n            new_sol[i] = best_c\n            return (new_sol, \"palette_compress\")\n        else:\n            return (cur[:], \"noop_conflict_free\")\n\n    # Choose a node: max conflicts, then higher saturation, then higher degree\n    max_c = max(conflicts_per_node)\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    candidates.sort(key=lambda i: (sat_deg(i), len(adj[i])), reverse=True)\n    chosen = candidates[0]\n\n    new_sol = cur[:]\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: existing colors\n    candidate_colors = list(used_colors)\n\n    # Try recolor chosen to minimize objective; prefer conflict reduction\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n    improved = False\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        conflict_here = any(cur[nb] == c for nb in adj[chosen])\n        trial = new_sol[:]\n        trial[chosen] = c\n        o = obj(trial)\n        if o < best_obj or (o == best_obj and not conflict_here):\n            best_obj = o\n            best_color = c\n            improved = True\n    if best_color != new_sol[chosen]:\n        new_sol[chosen] = best_color\n        move_type = \"recolor_greedy\"\n        return (new_sol, move_type)\n\n    # Kempe-chain swap attempt between chosen color and one of neighbor colors\n    neighbor_colors = list(set(cur[j] for j in adj[chosen]))\n    random.shuffle(neighbor_colors)\n    for c2 in neighbor_colors:\n        c1 = cur[chosen]\n        # Build Kempe component in colors {c1,c2}\n        stack = [chosen]\n        visited = [False]*n\n        comp = []\n        while stack:\n            u = stack.pop()\n            if visited[u]:\n                continue\n            visited[u] = True\n            if cur[u] in (c1, c2):\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        stack.append(v)\n        trial = cur[:]\n        for u in comp:\n            trial[u] = c2 if cur[u] == c1 else c1\n        o = obj(trial)\n        if o < base_obj:\n            return (trial, \"kempe_swap\")\n\n    # Pair-swap colors on an offending edge\n    offending_edges = [(u, v) for (u, v) in edges if cur[u] == cur[v]]\n    if offending_edges:\n        u, v = random.choice(offending_edges)\n        trial = cur[:]\n        trial[u], trial[v] = trial[v], trial[u]\n        o = obj(trial)\n        if o <= base_obj:\n            return (trial, \"pair_swap_nonworsening\")\n\n    # As last resort, allow introducing a new color only if no non-worsening found\n    new_color = max_color + 1\n    trial = cur[:]\n    trial[chosen] = new_color\n    o = obj(trial)\n    if o < base_obj:\n        return (trial, \"introduce_color\")\n\n    # Fallback: random recolor among existing colors (non-improving plateau move)\n    rc = random.choice(candidate_colors) if candidate_colors else new_color\n    trial = cur[:]\n    trial[chosen] = rc\n    return (trial, \"recolor_random_plateau\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution[:]\n\n    # Primary: multiple Kempe-chain shakes\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        shakes = random.randint(2, 4)\n        for _ in range(shakes):\n            if len(colors) < 2:\n                break\n            c1, c2 = random.sample(colors, 2)\n            nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n            if not nodes_c12:\n                continue\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            colors = list(sorted(set(new_sol)))\n        return canonicalize(new_sol)\n\n    # Fallback: random recolor of a small subset with possible introduction of a new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used) if used else 1\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n    return canonicalize(new_sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0017752}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: list of 9 positive integers [r1,...,r9], ri>=1, representing colors\/rooms for nodes 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    scale = len(edges) + 1  # ensures lexicographic order: conflicts prioritized over palette size\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    return conflicts * scale + max_room\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    scale = len(edges) + 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def obj(sol: List[int]) -> int:\n        # Fast objective consistent with evaluate_solution\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * scale + max_room\n\n    cur = solution\n    base_obj = obj(cur)\n\n    # Conflicts per node and total\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Helper: saturation degree\n    def sat_deg(i: int) -> int:\n        return len(set(cur[j] for j in adj[i]))\n\n    # Conflict-free state: only attempt safe palette compression (non-worsening guard)\n    if total_conflicts == 0:\n        maxc = max(cur)\n        nodes_max = [i for i, c in enumerate(cur) if c == maxc]\n        if not nodes_max or maxc == 1:\n            return (cur[:], \"noop_conflict_free\")\n        i = random.choice(nodes_max)\n        best_c = cur[i]\n        best_o = base_obj\n        for c in range(1, maxc):\n            ok = True\n            for nb in adj[i]:\n                if cur[nb] == c:\n                    ok = False\n                    break\n            if not ok:\n                continue\n            cand = cur[:]\n            cand[i] = c\n            o = obj(cand)\n            if o < best_o or (o == best_o and c < best_c):\n                best_o = o\n                best_c = c\n        if best_c != cur[i]:\n            new_sol = cur[:]\n            new_sol[i] = best_c\n            return (new_sol, \"palette_compress\")\n        else:\n            return (cur[:], \"noop_conflict_free\")\n\n    # Choose a node: max conflicts, then higher saturation, then higher degree\n    max_c = max(conflicts_per_node)\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    candidates.sort(key=lambda i: (sat_deg(i), len(adj[i])), reverse=True)\n    chosen = candidates[0]\n\n    new_sol = cur[:]\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: existing colors\n    candidate_colors = list(used_colors)\n\n    # Try recolor chosen to minimize objective; prefer conflict reduction\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n    improved = False\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        conflict_here = any(cur[nb] == c for nb in adj[chosen])\n        trial = new_sol[:]\n        trial[chosen] = c\n        o = obj(trial)\n        if o < best_obj or (o == best_obj and not conflict_here):\n            best_obj = o\n            best_color = c\n            improved = True\n    if best_color != new_sol[chosen]:\n        new_sol[chosen] = best_color\n        move_type = \"recolor_greedy\"\n        return (new_sol, move_type)\n\n    # Kempe-chain swap attempt between chosen color and one of neighbor colors\n    neighbor_colors = list(set(cur[j] for j in adj[chosen]))\n    random.shuffle(neighbor_colors)\n    for c2 in neighbor_colors:\n        c1 = cur[chosen]\n        # Build Kempe component in colors {c1,c2}\n        stack = [chosen]\n        visited = [False]*n\n        comp = []\n        while stack:\n            u = stack.pop()\n            if visited[u]:\n                continue\n            visited[u] = True\n            if cur[u] in (c1, c2):\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        stack.append(v)\n        trial = cur[:]\n        for u in comp:\n            trial[u] = c2 if cur[u] == c1 else c1\n        o = obj(trial)\n        if o < base_obj:\n            return (trial, \"kempe_swap\")\n\n    # Pair-swap colors on an offending edge\n    offending_edges = [(u, v) for (u, v) in edges if cur[u] == cur[v]]\n    if offending_edges:\n        u, v = random.choice(offending_edges)\n        trial = cur[:]\n        trial[u], trial[v] = trial[v], trial[u]\n        o = obj(trial)\n        if o <= base_obj:\n            return (trial, \"pair_swap_nonworsening\")\n\n    # As last resort, allow introducing a new color only if no non-worsening found\n    new_color = max_color + 1\n    trial = cur[:]\n    trial[chosen] = new_color\n    o = obj(trial)\n    if o < base_obj:\n        return (trial, \"introduce_color\")\n\n    # Fallback: random recolor among existing colors (non-improving plateau move)\n    rc = random.choice(candidate_colors) if candidate_colors else new_color\n    trial = cur[:]\n    trial[chosen] = rc\n    return (trial, \"recolor_random_plateau\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution[:]\n\n    # Primary: multiple Kempe-chain shakes\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        shakes = random.randint(2, 4)\n        for _ in range(shakes):\n            if len(colors) < 2:\n                break\n            c1, c2 = random.sample(colors, 2)\n            nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n            if not nodes_c12:\n                continue\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            colors = list(sorted(set(new_sol)))\n        return canonicalize(new_sol)\n\n    # Fallback: random recolor of a small subset with possible introduction of a new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used) if used else 1\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n    return canonicalize(new_sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001630968}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: list of 9 positive integers [r1,...,r9], ri>=1, representing colors\/rooms for nodes 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    scale = len(edges) + 1  # ensures lexicographic order: conflicts prioritized over palette size\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    return conflicts * scale + max_room\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    scale = len(edges) + 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def obj(sol: List[int]) -> int:\n        # Fast objective consistent with evaluate_solution\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * scale + max_room\n\n    cur = solution\n    base_obj = obj(cur)\n\n    # Conflicts per node and total\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Helper: saturation degree\n    def sat_deg(i: int) -> int:\n        return len(set(cur[j] for j in adj[i]))\n\n    # Conflict-free state: only attempt safe palette compression (non-worsening guard)\n    if total_conflicts == 0:\n        maxc = max(cur)\n        nodes_max = [i for i, c in enumerate(cur) if c == maxc]\n        if not nodes_max or maxc == 1:\n            return (cur[:], \"noop_conflict_free\")\n        i = random.choice(nodes_max)\n        best_c = cur[i]\n        best_o = base_obj\n        for c in range(1, maxc):\n            ok = True\n            for nb in adj[i]:\n                if cur[nb] == c:\n                    ok = False\n                    break\n            if not ok:\n                continue\n            cand = cur[:]\n            cand[i] = c\n            o = obj(cand)\n            if o < best_o or (o == best_o and c < best_c):\n                best_o = o\n                best_c = c\n        if best_c != cur[i]:\n            new_sol = cur[:]\n            new_sol[i] = best_c\n            return (new_sol, \"palette_compress\")\n        else:\n            return (cur[:], \"noop_conflict_free\")\n\n    # Choose a node: max conflicts, then higher saturation, then higher degree\n    max_c = max(conflicts_per_node)\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    candidates.sort(key=lambda i: (sat_deg(i), len(adj[i])), reverse=True)\n    chosen = candidates[0]\n\n    new_sol = cur[:]\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: existing colors\n    candidate_colors = list(used_colors)\n\n    # Try recolor chosen to minimize objective; prefer conflict reduction\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n    improved = False\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        conflict_here = any(cur[nb] == c for nb in adj[chosen])\n        trial = new_sol[:]\n        trial[chosen] = c\n        o = obj(trial)\n        if o < best_obj or (o == best_obj and not conflict_here):\n            best_obj = o\n            best_color = c\n            improved = True\n    if best_color != new_sol[chosen]:\n        new_sol[chosen] = best_color\n        move_type = \"recolor_greedy\"\n        return (new_sol, move_type)\n\n    # Kempe-chain swap attempt between chosen color and one of neighbor colors\n    neighbor_colors = list(set(cur[j] for j in adj[chosen]))\n    random.shuffle(neighbor_colors)\n    for c2 in neighbor_colors:\n        c1 = cur[chosen]\n        # Build Kempe component in colors {c1,c2}\n        stack = [chosen]\n        visited = [False]*n\n        comp = []\n        while stack:\n            u = stack.pop()\n            if visited[u]:\n                continue\n            visited[u] = True\n            if cur[u] in (c1, c2):\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        stack.append(v)\n        trial = cur[:]\n        for u in comp:\n            trial[u] = c2 if cur[u] == c1 else c1\n        o = obj(trial)\n        if o < base_obj:\n            return (trial, \"kempe_swap\")\n\n    # Pair-swap colors on an offending edge\n    offending_edges = [(u, v) for (u, v) in edges if cur[u] == cur[v]]\n    if offending_edges:\n        u, v = random.choice(offending_edges)\n        trial = cur[:]\n        trial[u], trial[v] = trial[v], trial[u]\n        o = obj(trial)\n        if o <= base_obj:\n            return (trial, \"pair_swap_nonworsening\")\n\n    # As last resort, allow introducing a new color only if no non-worsening found\n    new_color = max_color + 1\n    trial = cur[:]\n    trial[chosen] = new_color\n    o = obj(trial)\n    if o < base_obj:\n        return (trial, \"introduce_color\")\n\n    # Fallback: random recolor among existing colors (non-improving plateau move)\n    rc = random.choice(candidate_colors) if candidate_colors else new_color\n    trial = cur[:]\n    trial[chosen] = rc\n    return (trial, \"recolor_random_plateau\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution[:]\n\n    # Primary: multiple Kempe-chain shakes\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        shakes = random.randint(2, 4)\n        for _ in range(shakes):\n            if len(colors) < 2:\n                break\n            c1, c2 = random.sample(colors, 2)\n            nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n            if not nodes_c12:\n                continue\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            colors = list(sorted(set(new_sol)))\n        return canonicalize(new_sol)\n\n    # Fallback: random recolor of a small subset with possible introduction of a new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used) if used else 1\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n    return canonicalize(new_sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001296274}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"LIST_INT_LEN9. Each solution is a list of 9 positive integers [x1,...,x9], where xi is the color of vertex i in {1,2,...}. Objective minimizes k = max(xi) subject to edge constraints x_i != x_j.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return 1e9\n    # Validate all entries are positive integers\n    for c in solution:\n        if not isinstance(c, int):\n            return 1e9\n        if c <= 0:\n            return 1e9\n    # Compute k = max color\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Fitness: lower is better\n    return float(conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"GreedyMinConflicts\")\n    sol = list(solution)\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # current max color\n    k = max(max(sol), 1)\n    # Select a random vertex\n    i = random.randint(1, n)\n    # Compute conflicts per color for vertex i\n    neighbor_colors = {sol[v-1] for v in adj[i]}\n    # Candidate colors: 1..k (prefer stay within current palette)\n    candidates = list(range(1, k+1))\n    # Evaluate conflicts if assign each candidate\n    best_colors = []\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # If all candidates conflict (best_conf > 0), allow k+1 with small probability\n    if best_conf is None:\n        new_color = sol[i-1]\n    else:\n        new_color = random.choice(best_colors)\n        if best_conf > 0 and random.random() < 0.2:\n            new_color = k + 1\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"GreedyMinConflicts\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger random shake: recolor a random subset of vertices\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    sol = list(solution)\n    n = 9\n    k = max(max(sol), 1)\n    # Number of vertices to perturb: between 2 and 5\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # With 70% use colors in 1..k, 30% allow introducing k+1\n        if random.random() < 0.7:\n            sol[idx] = random.randint(1, k)\n        else:\n            sol[idx] = k + 1\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000445}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"LIST_INT_LEN9. Each solution is a list of 9 positive integers [x1,...,x9], where xi is the color of vertex i in {1,2,...}. Objective minimizes k = max(xi) subject to edge constraints x_i != x_j.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return 1e9\n    # Validate all entries are positive integers\n    for c in solution:\n        if not isinstance(c, int):\n            return 1e9\n        if c <= 0:\n            return 1e9\n    # Compute k = max color\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Fitness: lower is better\n    return float(conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"GreedyMinConflicts\")\n    sol = list(solution)\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # current max color\n    k = max(max(sol), 1)\n    # Select a random vertex\n    i = random.randint(1, n)\n    # Compute conflicts per color for vertex i\n    neighbor_colors = {sol[v-1] for v in adj[i]}\n    # Candidate colors: 1..k (prefer stay within current palette)\n    candidates = list(range(1, k+1))\n    # Evaluate conflicts if assign each candidate\n    best_colors = []\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # If all candidates conflict (best_conf > 0), allow k+1 with small probability\n    if best_conf is None:\n        new_color = sol[i-1]\n    else:\n        new_color = random.choice(best_colors)\n        if best_conf > 0 and random.random() < 0.2:\n            new_color = k + 1\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"GreedyMinConflicts\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger random shake: recolor a random subset of vertices\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    sol = list(solution)\n    n = 9\n    k = max(max(sol), 1)\n    # Number of vertices to perturb: between 2 and 5\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # With 70% use colors in 1..k, 30% allow introducing k+1\n        if random.random() < 0.7:\n            sol[idx] = random.randint(1, k)\n        else:\n            sol[idx] = k + 1\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000147}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"LIST_INT_LEN9. Each solution is a list of 9 positive integers [x1,...,x9], where xi is the color of vertex i in {1,2,...}. Objective minimizes k = max(xi) subject to edge constraints x_i != x_j.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return 1e9\n    # Validate all entries are positive integers\n    for c in solution:\n        if not isinstance(c, int):\n            return 1e9\n        if c <= 0:\n            return 1e9\n    # Compute k = max color\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Fitness: lower is better\n    return float(conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"GreedyMinConflicts\")\n    sol = list(solution)\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # current max color\n    k = max(max(sol), 1)\n    # Select a random vertex\n    i = random.randint(1, n)\n    # Compute conflicts per color for vertex i\n    neighbor_colors = {sol[v-1] for v in adj[i]}\n    # Candidate colors: 1..k (prefer stay within current palette)\n    candidates = list(range(1, k+1))\n    # Evaluate conflicts if assign each candidate\n    best_colors = []\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # If all candidates conflict (best_conf > 0), allow k+1 with small probability\n    if best_conf is None:\n        new_color = sol[i-1]\n    else:\n        new_color = random.choice(best_colors)\n        if best_conf > 0 and random.random() < 0.2:\n            new_color = k + 1\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"GreedyMinConflicts\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger random shake: recolor a random subset of vertices\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    sol = list(solution)\n    n = 9\n    k = max(max(sol), 1)\n    # Number of vertices to perturb: between 2 and 5\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # With 70% use colors in 1..k, 30% allow introducing k+1\n        if random.random() < 0.7:\n            sol[idx] = random.randint(1, k)\n        else:\n            sol[idx] = k + 1\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000105}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9; solution encodes colors [x1..x9] with xi>=1. Example: '1 2 3 1 2 3 1 2 3'","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef _parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution) -> float:\n    # Robust parser to accept the defined string representation or a list\/tuple\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 1e9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts and compute k\n    k = 0\n    conflicts = 0\n    for c in sol:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then k\n    return float(conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef _nb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"MinConflictsBounded\")\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    # Vertex choice: prefer conflicting; else pick a vertex with highest current color to encourage compaction\n    if conflicting:\n        i = random.choice(conflicting)\n    else:\n        maxc = max(sol)\n        idxs = [idx+1 for idx, c in enumerate(sol) if c == maxc]\n        i = random.choice(idxs)\n    # Candidate colors: 1..k (bounded palette, do not introduce new colors here)\n    candidates = list(range(1, k+1))\n    # Global color usage for tiebreaking\n    usage = {}\n    for c in sol:\n        usage[c] = usage.get(c, 0) + 1\n    # Evaluate conflict count for assigning color c to vertex i\n    best_conf = None\n    best_colors = []\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # Tiebreak: prefer least used color to aid balancing\/compaction\n    if not best_colors:\n        new_color = sol[i-1]\n    else:\n        best_colors.sort(key=lambda c: (usage.get(c, 0), c))\n        new_color = best_colors[0]\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef _pb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random chain; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present (invalid but robust), randomly recolor a few vertices to color 2\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        # Swap colors a<->b on this component\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n        colors = sorted(set(sol))\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001431716}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9; solution encodes colors [x1..x9] with xi>=1. Example: '1 2 3 1 2 3 1 2 3'","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef _parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution) -> float:\n    # Robust parser to accept the defined string representation or a list\/tuple\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 1e9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts and compute k\n    k = 0\n    conflicts = 0\n    for c in sol:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then k\n    return float(conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef _nb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"MinConflictsBounded\")\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    # Vertex choice: prefer conflicting; else pick a vertex with highest current color to encourage compaction\n    if conflicting:\n        i = random.choice(conflicting)\n    else:\n        maxc = max(sol)\n        idxs = [idx+1 for idx, c in enumerate(sol) if c == maxc]\n        i = random.choice(idxs)\n    # Candidate colors: 1..k (bounded palette, do not introduce new colors here)\n    candidates = list(range(1, k+1))\n    # Global color usage for tiebreaking\n    usage = {}\n    for c in sol:\n        usage[c] = usage.get(c, 0) + 1\n    # Evaluate conflict count for assigning color c to vertex i\n    best_conf = None\n    best_colors = []\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # Tiebreak: prefer least used color to aid balancing\/compaction\n    if not best_colors:\n        new_color = sol[i-1]\n    else:\n        best_colors.sort(key=lambda c: (usage.get(c, 0), c))\n        new_color = best_colors[0]\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef _pb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random chain; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present (invalid but robust), randomly recolor a few vertices to color 2\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        # Swap colors a<->b on this component\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n        colors = sorted(set(sol))\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001205643}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9; solution encodes colors [x1..x9] with xi>=1. Example: '1 2 3 1 2 3 1 2 3'","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef _parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution) -> float:\n    # Robust parser to accept the defined string representation or a list\/tuple\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 1e9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts and compute k\n    k = 0\n    conflicts = 0\n    for c in sol:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then k\n    return float(conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef _nb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"MinConflictsBounded\")\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    # Vertex choice: prefer conflicting; else pick a vertex with highest current color to encourage compaction\n    if conflicting:\n        i = random.choice(conflicting)\n    else:\n        maxc = max(sol)\n        idxs = [idx+1 for idx, c in enumerate(sol) if c == maxc]\n        i = random.choice(idxs)\n    # Candidate colors: 1..k (bounded palette, do not introduce new colors here)\n    candidates = list(range(1, k+1))\n    # Global color usage for tiebreaking\n    usage = {}\n    for c in sol:\n        usage[c] = usage.get(c, 0) + 1\n    # Evaluate conflict count for assigning color c to vertex i\n    best_conf = None\n    best_colors = []\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # Tiebreak: prefer least used color to aid balancing\/compaction\n    if not best_colors:\n        new_color = sol[i-1]\n    else:\n        best_colors.sort(key=lambda c: (usage.get(c, 0), c))\n        new_color = best_colors[0]\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef _pb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random chain; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present (invalid but robust), randomly recolor a few vertices to color 2\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        # Swap colors a<->b on this component\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n        colors = sorted(set(sol))\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001215674}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return float(conflicts * 25 + k)\n\n# Target Simulated Annealing heuristic signature\n# SA tries to minimize the evaluate_solution value (smaller is better)\n# It accepts a callable generate_neighbour and evaluate_solution\n# Note: perturbation can be injected externally by caller between temperature schedules if desired\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Parse\/normalize current solution\n    cur = _parse_solution_to_list(currentSolution)\n    if len(cur) != 9:\n        cur = [i % 3 + 1 for i in range(9)]\n    if best is None:\n        best = cur[:]\n        best_score = evaluate_solution(best)\n    cur_score = evaluate_solution(cur)\n    if best_score is None or cur_score < best_score:\n        best = cur[:]\n        best_score = cur_score\n    # SA loop\n    T = float(max(temp, 1e-6))\n    minT = float(max(minTemp, 1e-6))\n    alpha = float(min(max(cooling_factor, 0.80), 0.9999))\n    rng = random.random\n    while T > minT:\n        # Generate neighbour\n        nb, _, _ = generate_neighbour(cur)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - cur_score\n        if delta <= 0:\n            cur, cur_score = nb, nb_score\n        else:\n            if rng() < math.exp(-delta \/ max(T, 1e-12)):\n                cur, cur_score = nb, nb_score\n        if cur_score < best_score:\n            best = cur[:]\n            best_score = cur_score\n        T *= alpha\n    return {\n        \"current\": cur,\n        \"currentScore\": cur_score,\n        \"best\": best,\n        \"bestScore\": best_score\n    }\n","Vecindad":"import random\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    new_sol = sol[:]\n    if conflicting:\n        # Min-conflicts recolor on a random conflicting vertex using palette 1..k\n        i = random.choice(conflicting)\n        candidates = list(range(1, k+1))\n        best_conf = None\n        best_colors = []\n        for c in candidates:\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Prefer smallest color to promote compaction\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n    else:\n        # No conflicts: attempt k-reduction by trying to recolor one highest-color vertex into [1..k-1] feasibly\n        maxc = max(new_sol)\n        idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n        i = random.choice(idxs)\n        feasible = []\n        for c in range(1, max(1, maxc)):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            # If we eliminated max color from all vertices, compact palette by remapping maxc -> smallest missing\n            if maxc not in new_sol:\n                # Palette compaction: map colors to 1..max\n                mapping = {}\n                nextc = 1\n                for c in sorted(set(new_sol)):\n                    mapping[c] = nextc\n                    nextc += 1\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n        else:\n            # As a diversification when k-reduction fails, perform a small color-class swap on a random color pair\n            colors = sorted(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx, c in enumerate(new_sol):\n                    if c == a:\n                        new_sol[idx] = b\n                    elif c == b:\n                        new_sol[idx] = a\n                return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n            else:\n                # Fallback: random recolor one vertex\n                i = random.randint(1, n)\n                new_sol[i-1] = 1\n                return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random connected component; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present, recolor a few vertices to color 2 to enable movement\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n    return sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 0).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001581688}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return float(conflicts * 25 + k)\n\n# Target Simulated Annealing heuristic signature\n# SA tries to minimize the evaluate_solution value (smaller is better)\n# It accepts a callable generate_neighbour and evaluate_solution\n# Note: perturbation can be injected externally by caller between temperature schedules if desired\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Parse\/normalize current solution\n    cur = _parse_solution_to_list(currentSolution)\n    if len(cur) != 9:\n        cur = [i % 3 + 1 for i in range(9)]\n    if best is None:\n        best = cur[:]\n        best_score = evaluate_solution(best)\n    cur_score = evaluate_solution(cur)\n    if best_score is None or cur_score < best_score:\n        best = cur[:]\n        best_score = cur_score\n    # SA loop\n    T = float(max(temp, 1e-6))\n    minT = float(max(minTemp, 1e-6))\n    alpha = float(min(max(cooling_factor, 0.80), 0.9999))\n    rng = random.random\n    while T > minT:\n        # Generate neighbour\n        nb, _, _ = generate_neighbour(cur)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - cur_score\n        if delta <= 0:\n            cur, cur_score = nb, nb_score\n        else:\n            if rng() < math.exp(-delta \/ max(T, 1e-12)):\n                cur, cur_score = nb, nb_score\n        if cur_score < best_score:\n            best = cur[:]\n            best_score = cur_score\n        T *= alpha\n    return {\n        \"current\": cur,\n        \"currentScore\": cur_score,\n        \"best\": best,\n        \"bestScore\": best_score\n    }\n","Vecindad":"import random\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    new_sol = sol[:]\n    if conflicting:\n        # Min-conflicts recolor on a random conflicting vertex using palette 1..k\n        i = random.choice(conflicting)\n        candidates = list(range(1, k+1))\n        best_conf = None\n        best_colors = []\n        for c in candidates:\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Prefer smallest color to promote compaction\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n    else:\n        # No conflicts: attempt k-reduction by trying to recolor one highest-color vertex into [1..k-1] feasibly\n        maxc = max(new_sol)\n        idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n        i = random.choice(idxs)\n        feasible = []\n        for c in range(1, max(1, maxc)):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            # If we eliminated max color from all vertices, compact palette by remapping maxc -> smallest missing\n            if maxc not in new_sol:\n                # Palette compaction: map colors to 1..max\n                mapping = {}\n                nextc = 1\n                for c in sorted(set(new_sol)):\n                    mapping[c] = nextc\n                    nextc += 1\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n        else:\n            # As a diversification when k-reduction fails, perform a small color-class swap on a random color pair\n            colors = sorted(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx, c in enumerate(new_sol):\n                    if c == a:\n                        new_sol[idx] = b\n                    elif c == b:\n                        new_sol[idx] = a\n                return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n            else:\n                # Fallback: random recolor one vertex\n                i = random.randint(1, n)\n                new_sol[i-1] = 1\n                return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random connected component; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present, recolor a few vertices to color 2 to enable movement\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n    return sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 0).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001392645}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return float(conflicts * 25 + k)\n\n# Target Simulated Annealing heuristic signature\n# SA tries to minimize the evaluate_solution value (smaller is better)\n# It accepts a callable generate_neighbour and evaluate_solution\n# Note: perturbation can be injected externally by caller between temperature schedules if desired\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Parse\/normalize current solution\n    cur = _parse_solution_to_list(currentSolution)\n    if len(cur) != 9:\n        cur = [i % 3 + 1 for i in range(9)]\n    if best is None:\n        best = cur[:]\n        best_score = evaluate_solution(best)\n    cur_score = evaluate_solution(cur)\n    if best_score is None or cur_score < best_score:\n        best = cur[:]\n        best_score = cur_score\n    # SA loop\n    T = float(max(temp, 1e-6))\n    minT = float(max(minTemp, 1e-6))\n    alpha = float(min(max(cooling_factor, 0.80), 0.9999))\n    rng = random.random\n    while T > minT:\n        # Generate neighbour\n        nb, _, _ = generate_neighbour(cur)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - cur_score\n        if delta <= 0:\n            cur, cur_score = nb, nb_score\n        else:\n            if rng() < math.exp(-delta \/ max(T, 1e-12)):\n                cur, cur_score = nb, nb_score\n        if cur_score < best_score:\n            best = cur[:]\n            best_score = cur_score\n        T *= alpha\n    return {\n        \"current\": cur,\n        \"currentScore\": cur_score,\n        \"best\": best,\n        \"bestScore\": best_score\n    }\n","Vecindad":"import random\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    new_sol = sol[:]\n    if conflicting:\n        # Min-conflicts recolor on a random conflicting vertex using palette 1..k\n        i = random.choice(conflicting)\n        candidates = list(range(1, k+1))\n        best_conf = None\n        best_colors = []\n        for c in candidates:\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Prefer smallest color to promote compaction\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n    else:\n        # No conflicts: attempt k-reduction by trying to recolor one highest-color vertex into [1..k-1] feasibly\n        maxc = max(new_sol)\n        idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n        i = random.choice(idxs)\n        feasible = []\n        for c in range(1, max(1, maxc)):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            # If we eliminated max color from all vertices, compact palette by remapping maxc -> smallest missing\n            if maxc not in new_sol:\n                # Palette compaction: map colors to 1..max\n                mapping = {}\n                nextc = 1\n                for c in sorted(set(new_sol)):\n                    mapping[c] = nextc\n                    nextc += 1\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n        else:\n            # As a diversification when k-reduction fails, perform a small color-class swap on a random color pair\n            colors = sorted(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx, c in enumerate(new_sol):\n                    if c == a:\n                        new_sol[idx] = b\n                    elif c == b:\n                        new_sol[idx] = a\n                return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n            else:\n                # Fallback: random recolor one vertex\n                i = random.randint(1, n)\n                new_sol[i-1] = 1\n                return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random connected component; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present, recolor a few vertices to color 2 to enable movement\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n    return sol\n","Resultados":[123123123,[],123123123,[]],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001421096}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return int(conflicts * 25 + k)\n","Vecindad":"import random\nfrom collections import deque\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _graph_def():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _conflicting_vertices(sol, adj):\n    n = len(sol)\n    conf = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conf.append(i)\n                break\n    return conf\n\ndef _kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _graph_def()\n    new_sol = sol[:]\n    k = max(max(sol), 1)\n\n    # 1) If conflicts exist: min-conflicts recolor on a random conflicting vertex\n    conflicting = _conflicting_vertices(sol, adj)\n    if conflicting:\n        i = random.choice(conflicting)\n        # Occasionally try a Kempe swap between two best colors to escape plateaus\n        if random.random() < 0.25:\n            palette = sorted(set(sol))\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                # choose a starting vertex among {a,b} near i if possible\n                start = i if sol[i-1] in (a, b) else i\n                comp = _kempe_component(sol, adj, start, a, b)\n                if comp:\n                    for u in comp:\n                        new_sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n                    return (new_sol, \"KempeSwap\", \"KempeComponentSwap\")\n        # Min-conflicts recolor\n        best_conf = None\n        best_colors = []\n        for c in range(1, k+1):\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n\n    # 2) No conflicts: attempt k-reduction by recoloring one max-color vertex to [1..k-1]\n    maxc = max(new_sol)\n    idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n    random.shuffle(idxs)\n    for i in idxs:\n        feasible = []\n        for c in range(1, maxc):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            if maxc not in new_sol:\n                # Compact palette only when maxc eliminated\n                mapping = {}\n                for rank, c in enumerate(sorted(set(new_sol)), start=1):\n                    mapping[c] = rank\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n\n    # 3) Diversification: color-class swap to reshuffle structure\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for idx, c in enumerate(new_sol):\n            if c == a:\n                new_sol[idx] = b\n            elif c == b:\n                new_sol[idx] = a\n        return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n\n    # 4) Fallback\n    i = random.randint(1, n)\n    new_sol[i-1] = 1\n    return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _pb_graph():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _pb_kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef perturb_solution(solution):\n    # Kempe-chain based multi-swap plus random recolor shake\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _pb_graph()\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # seed a second color\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    reps = random.randint(2, 4)\n    for _ in range(reps):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        comp = _pb_kempe_component(sol, adj, start, a, b)\n        if comp:\n            for u in comp:\n                sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n    # Additional shake: recolor a small random subset to random existing colors\n    m = max(1, n \/\/ 5)\n    idxs = random.sample(range(n), k=m)\n    palette = sorted(set(sol))\n    for idx in idxs:\n        sol[idx] = random.choice(palette)\n    return sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001868581}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return int(conflicts * 25 + k)\n","Vecindad":"import random\nfrom collections import deque\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _graph_def():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _conflicting_vertices(sol, adj):\n    n = len(sol)\n    conf = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conf.append(i)\n                break\n    return conf\n\ndef _kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _graph_def()\n    new_sol = sol[:]\n    k = max(max(sol), 1)\n\n    # 1) If conflicts exist: min-conflicts recolor on a random conflicting vertex\n    conflicting = _conflicting_vertices(sol, adj)\n    if conflicting:\n        i = random.choice(conflicting)\n        # Occasionally try a Kempe swap between two best colors to escape plateaus\n        if random.random() < 0.25:\n            palette = sorted(set(sol))\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                # choose a starting vertex among {a,b} near i if possible\n                start = i if sol[i-1] in (a, b) else i\n                comp = _kempe_component(sol, adj, start, a, b)\n                if comp:\n                    for u in comp:\n                        new_sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n                    return (new_sol, \"KempeSwap\", \"KempeComponentSwap\")\n        # Min-conflicts recolor\n        best_conf = None\n        best_colors = []\n        for c in range(1, k+1):\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n\n    # 2) No conflicts: attempt k-reduction by recoloring one max-color vertex to [1..k-1]\n    maxc = max(new_sol)\n    idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n    random.shuffle(idxs)\n    for i in idxs:\n        feasible = []\n        for c in range(1, maxc):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            if maxc not in new_sol:\n                # Compact palette only when maxc eliminated\n                mapping = {}\n                for rank, c in enumerate(sorted(set(new_sol)), start=1):\n                    mapping[c] = rank\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n\n    # 3) Diversification: color-class swap to reshuffle structure\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for idx, c in enumerate(new_sol):\n            if c == a:\n                new_sol[idx] = b\n            elif c == b:\n                new_sol[idx] = a\n        return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n\n    # 4) Fallback\n    i = random.randint(1, n)\n    new_sol[i-1] = 1\n    return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _pb_graph():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _pb_kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef perturb_solution(solution):\n    # Kempe-chain based multi-swap plus random recolor shake\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _pb_graph()\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # seed a second color\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    reps = random.randint(2, 4)\n    for _ in range(reps):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        comp = _pb_kempe_component(sol, adj, start, a, b)\n        if comp:\n            for u in comp:\n                sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n    # Additional shake: recolor a small random subset to random existing colors\n    m = max(1, n \/\/ 5)\n    idxs = random.sample(range(n), k=m)\n    palette = sorted(set(sol))\n    for idx in idxs:\n        sol[idx] = random.choice(palette)\n    return sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001570927}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return int(conflicts * 25 + k)\n","Vecindad":"import random\nfrom collections import deque\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _graph_def():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _conflicting_vertices(sol, adj):\n    n = len(sol)\n    conf = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conf.append(i)\n                break\n    return conf\n\ndef _kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _graph_def()\n    new_sol = sol[:]\n    k = max(max(sol), 1)\n\n    # 1) If conflicts exist: min-conflicts recolor on a random conflicting vertex\n    conflicting = _conflicting_vertices(sol, adj)\n    if conflicting:\n        i = random.choice(conflicting)\n        # Occasionally try a Kempe swap between two best colors to escape plateaus\n        if random.random() < 0.25:\n            palette = sorted(set(sol))\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                # choose a starting vertex among {a,b} near i if possible\n                start = i if sol[i-1] in (a, b) else i\n                comp = _kempe_component(sol, adj, start, a, b)\n                if comp:\n                    for u in comp:\n                        new_sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n                    return (new_sol, \"KempeSwap\", \"KempeComponentSwap\")\n        # Min-conflicts recolor\n        best_conf = None\n        best_colors = []\n        for c in range(1, k+1):\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n\n    # 2) No conflicts: attempt k-reduction by recoloring one max-color vertex to [1..k-1]\n    maxc = max(new_sol)\n    idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n    random.shuffle(idxs)\n    for i in idxs:\n        feasible = []\n        for c in range(1, maxc):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            if maxc not in new_sol:\n                # Compact palette only when maxc eliminated\n                mapping = {}\n                for rank, c in enumerate(sorted(set(new_sol)), start=1):\n                    mapping[c] = rank\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n\n    # 3) Diversification: color-class swap to reshuffle structure\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for idx, c in enumerate(new_sol):\n            if c == a:\n                new_sol[idx] = b\n            elif c == b:\n                new_sol[idx] = a\n        return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n\n    # 4) Fallback\n    i = random.randint(1, n)\n    new_sol[i-1] = 1\n    return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _pb_graph():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _pb_kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef perturb_solution(solution):\n    # Kempe-chain based multi-swap plus random recolor shake\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _pb_graph()\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # seed a second color\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    reps = random.randint(2, 4)\n    for _ in range(reps):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        comp = _pb_kempe_component(sol, adj, start, a, b)\n        if comp:\n            for u in comp:\n                sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n    # Additional shake: recolor a small random subset to random existing colors\n    m = max(1, n \/\/ 5)\n    idxs = random.sample(range(n), k=m)\n    palette = sorted(set(sol))\n    for idx in idxs:\n        sol[idx] = random.choice(palette)\n    return sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001400345}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input type and domain\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed vertices)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors used (max color index)\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple valid seed neighbour if invalid input\n        base = [1]*9\n        return (base, \"Recolor\", \"Single-Vertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            base = [1]*9\n            return (base, \"Recolor\", \"Single-Vertex\")\n    new_sol = solution[:]\n    n = len(new_sol)\n    idx = random.randrange(n)\n    current_color = new_sol[idx]\n    max_color = max(new_sol)\n    # Candidate colors include existing colors and possibly introducing a new color (max_color+1)\n    candidates = list(range(1, max_color + 2))\n    if current_color in candidates:\n        candidates.remove(current_color)\n    if not candidates:\n        candidates = [max_color if max_color >= 1 else 1]\n    new_sol[idx] = random.choice(candidates)\n    return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Return a perturbed solution with multiple random recolors\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return [1]*9\n    new_sol = solution[:]\n    n = len(new_sol)\n    max_color = max(new_sol)\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        current_color = new_sol[idx]\n        candidates = list(range(1, max_color + 2))\n        if current_color in candidates:\n            candidates.remove(current_color)\n        if not candidates:\n            candidates = [max_color if max_color >= 1 else 1]\n        new_sol[idx] = random.choice(candidates)\n        max_color = max(max_color, new_sol[idx])\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000630257}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input type and domain\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed vertices)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors used (max color index)\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple valid seed neighbour if invalid input\n        base = [1]*9\n        return (base, \"Recolor\", \"Single-Vertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            base = [1]*9\n            return (base, \"Recolor\", \"Single-Vertex\")\n    new_sol = solution[:]\n    n = len(new_sol)\n    idx = random.randrange(n)\n    current_color = new_sol[idx]\n    max_color = max(new_sol)\n    # Candidate colors include existing colors and possibly introducing a new color (max_color+1)\n    candidates = list(range(1, max_color + 2))\n    if current_color in candidates:\n        candidates.remove(current_color)\n    if not candidates:\n        candidates = [max_color if max_color >= 1 else 1]\n    new_sol[idx] = random.choice(candidates)\n    return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Return a perturbed solution with multiple random recolors\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return [1]*9\n    new_sol = solution[:]\n    n = len(new_sol)\n    max_color = max(new_sol)\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        current_color = new_sol[idx]\n        candidates = list(range(1, max_color + 2))\n        if current_color in candidates:\n            candidates.remove(current_color)\n        if not candidates:\n            candidates = [max_color if max_color >= 1 else 1]\n        new_sol[idx] = random.choice(candidates)\n        max_color = max(max_color, new_sol[idx])\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000645387}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input type and domain\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed vertices)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors used (max color index)\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple valid seed neighbour if invalid input\n        base = [1]*9\n        return (base, \"Recolor\", \"Single-Vertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            base = [1]*9\n            return (base, \"Recolor\", \"Single-Vertex\")\n    new_sol = solution[:]\n    n = len(new_sol)\n    idx = random.randrange(n)\n    current_color = new_sol[idx]\n    max_color = max(new_sol)\n    # Candidate colors include existing colors and possibly introducing a new color (max_color+1)\n    candidates = list(range(1, max_color + 2))\n    if current_color in candidates:\n        candidates.remove(current_color)\n    if not candidates:\n        candidates = [max_color if max_color >= 1 else 1]\n    new_sol[idx] = random.choice(candidates)\n    return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Return a perturbed solution with multiple random recolors\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return [1]*9\n    new_sol = solution[:]\n    n = len(new_sol)\n    max_color = max(new_sol)\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        current_color = new_sol[idx]\n        candidates = list(range(1, max_color + 2))\n        if current_color in candidates:\n            candidates.remove(current_color)\n        if not candidates:\n            candidates = [max_color if max_color >= 1 else 1]\n        new_sol[idx] = random.choice(candidates)\n        max_color = max(max_color, new_sol[idx])\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000507486}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations\n    base = max(solution)\n    # Penalty scaled to dominate base objective but not overflow\n    penalty = 100 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair to a trivial feasible domain element\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1]*9, \"Recolor\")\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Build adjacency list 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicting vertices set\n    conflicts = []\n    for u, neighs in enumerate(adj):\n        cu = sol[u]\n        for v in neighs:\n            if v > u and sol[v] == cu:\n                conflicts.append(u)\n                conflicts.append(v)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    current_color = sol[idx]\n    max_color = max(sol)\n    # Candidate colors: prefer within 1..max_color; allow +1 with small diversification probability\n    p_div = 0.1\n    candidates = list(range(1, max_color + 1))\n    if random.random() < p_div:\n        candidates.append(max_color + 1)\n    # Remove current color if present\n    candidates = [c for c in candidates if c != current_color]\n    if not candidates:\n        candidates = [current_color if current_color >= 1 else 1]\n    # Score colors by induced conflicts at idx\n    def local_conflicts(color):\n        cnt = 0\n        for v in adj[idx]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        if best_score is None or sc < best_score:\n            best_score = sc\n            best_colors = [c]\n        elif sc == best_score:\n            best_colors.append(c)\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1]*9\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Adjacency 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n    # Select k vertices to recolor\n    k_low, k_high = 2, 4\n    k = random.randint(k_low, k_high)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) < k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n    # Recolor chosen vertices with diversification\n    for idx in picks:\n        max_color = max(sol)\n        candidates = list(range(1, max_color + 1))\n        # higher diversification than neighbour move\n        if random.random() < 0.2:\n            candidates.append(max_color + 1)\n        # Exclude current color\n        candidates = [c for c in candidates if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts\n        best_score = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            if best_score is None or sc < best_score:\n                best_score = sc\n                best_colors = [c]\n            elif sc == best_score:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n    return sol\n","Resultados":[[4,3,2,3,5,6,1,4,3],6,[3,4,1,2,2,1,3,3,4],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00179418}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations\n    base = max(solution)\n    # Penalty scaled to dominate base objective but not overflow\n    penalty = 100 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair to a trivial feasible domain element\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1]*9, \"Recolor\")\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Build adjacency list 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicting vertices set\n    conflicts = []\n    for u, neighs in enumerate(adj):\n        cu = sol[u]\n        for v in neighs:\n            if v > u and sol[v] == cu:\n                conflicts.append(u)\n                conflicts.append(v)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    current_color = sol[idx]\n    max_color = max(sol)\n    # Candidate colors: prefer within 1..max_color; allow +1 with small diversification probability\n    p_div = 0.1\n    candidates = list(range(1, max_color + 1))\n    if random.random() < p_div:\n        candidates.append(max_color + 1)\n    # Remove current color if present\n    candidates = [c for c in candidates if c != current_color]\n    if not candidates:\n        candidates = [current_color if current_color >= 1 else 1]\n    # Score colors by induced conflicts at idx\n    def local_conflicts(color):\n        cnt = 0\n        for v in adj[idx]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        if best_score is None or sc < best_score:\n            best_score = sc\n            best_colors = [c]\n        elif sc == best_score:\n            best_colors.append(c)\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1]*9\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Adjacency 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n    # Select k vertices to recolor\n    k_low, k_high = 2, 4\n    k = random.randint(k_low, k_high)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) < k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n    # Recolor chosen vertices with diversification\n    for idx in picks:\n        max_color = max(sol)\n        candidates = list(range(1, max_color + 1))\n        # higher diversification than neighbour move\n        if random.random() < 0.2:\n            candidates.append(max_color + 1)\n        # Exclude current color\n        candidates = [c for c in candidates if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts\n        best_score = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            if best_score is None or sc < best_score:\n                best_score = sc\n                best_colors = [c]\n            elif sc == best_score:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n    return sol\n","Resultados":[[1,7,5,7,8,5,2,1,7],104,[3,4,1,5,5,1,3,3,4],5],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002389086}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations\n    base = max(solution)\n    # Penalty scaled to dominate base objective but not overflow\n    penalty = 100 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair to a trivial feasible domain element\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1]*9, \"Recolor\")\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Build adjacency list 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicting vertices set\n    conflicts = []\n    for u, neighs in enumerate(adj):\n        cu = sol[u]\n        for v in neighs:\n            if v > u and sol[v] == cu:\n                conflicts.append(u)\n                conflicts.append(v)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    current_color = sol[idx]\n    max_color = max(sol)\n    # Candidate colors: prefer within 1..max_color; allow +1 with small diversification probability\n    p_div = 0.1\n    candidates = list(range(1, max_color + 1))\n    if random.random() < p_div:\n        candidates.append(max_color + 1)\n    # Remove current color if present\n    candidates = [c for c in candidates if c != current_color]\n    if not candidates:\n        candidates = [current_color if current_color >= 1 else 1]\n    # Score colors by induced conflicts at idx\n    def local_conflicts(color):\n        cnt = 0\n        for v in adj[idx]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        if best_score is None or sc < best_score:\n            best_score = sc\n            best_colors = [c]\n        elif sc == best_score:\n            best_colors.append(c)\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1]*9\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Adjacency 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n    # Select k vertices to recolor\n    k_low, k_high = 2, 4\n    k = random.randint(k_low, k_high)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) < k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n    # Recolor chosen vertices with diversification\n    for idx in picks:\n        max_color = max(sol)\n        candidates = list(range(1, max_color + 1))\n        # higher diversification than neighbour move\n        if random.random() < 0.2:\n            candidates.append(max_color + 1)\n        # Exclude current color\n        candidates = [c for c in candidates if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts\n        best_score = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            if best_score is None or sc < best_score:\n                best_score = sc\n                best_colors = [c]\n            elif sc == best_score:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001306945}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations heavily\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers and data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR: pick vertex with max saturation, break ties by degree\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving order of appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive validation and repair using DSATUR\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts and violations count\n    conflict_vertices = set()\n    violations = 0\n    for u in range(n):\n        cu = sol[u]\n        for v in adj[u]:\n            if v > u and sol[v] == cu:\n                violations += 1\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Selection strategy\n    if conflict_vertices:\n        # focus on most conflicting vertex (break ties by degree)\n        def conflict_count(u):\n            cu = sol[u]\n            return sum(1 for v in adj[u] if sol[v] == cu)\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        # try to reduce max color usage\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color = max(sol)\n\n    # Candidate colors: avoid increasing palette if no violations\n    allow_new_color = violations > 0 and random.random() < 0.1\n    candidates = list(range(1, max_color + (1 if allow_new_color else 0)))\n    # Exclude current color to enforce a move\n    candidates = [c for c in candidates if c != current_color and c >= 1]\n    if not candidates:\n        # If no alternative, pick a different vertex randomly\n        other = (idx + 1) % n\n        if sol[other] != sol[idx]:\n            idx = other\n            current_color = sol[idx]\n            candidates = [c for c in range(1, max_color+1) if c != current_color]\n        if not candidates:\n            # fallback: return compressed solution unchanged (rare)\n            return (compress_colors(sol), \"Recolor\")\n\n    # Score candidates by local conflicts, tie-break by color frequency (favor rarer colors to enable class elimination)\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    def local_conflicts(color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        key = (sc, freq.get(c, 0))  # minimize conflicts, then prefer rarer\n        if best_score is None or key < best_score:\n            best_score = key\n            best_colors = [c]\n        elif key == best_score:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive: if invalid, create a simple feasible seed via greedy\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Select k vertices to recolor (bounded to avoid destroying structure)\n    k = random.randint(2, 3)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) <= k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n\n    # Recolor chosen vertices with diversification but no palette expansion when already feasible\n    for idx in picks:\n        max_color = max(sol)\n        # Allow new color only if there are conflicts overall to help escape; small probability\n        allow_new = (len(conflict_vertices) > 0) and (random.random() < 0.15)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts; tie-break by rarity\n        freq = {}\n        for c in sol:\n            freq[c] = freq.get(c, 0) + 1\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, freq.get(c, 0))\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":[[1,2,3,2,4,4,1,1,3],1004,[3,4,1,2,2,1,3,3,4],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003218545}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations heavily\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers and data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR: pick vertex with max saturation, break ties by degree\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving order of appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive validation and repair using DSATUR\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts and violations count\n    conflict_vertices = set()\n    violations = 0\n    for u in range(n):\n        cu = sol[u]\n        for v in adj[u]:\n            if v > u and sol[v] == cu:\n                violations += 1\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Selection strategy\n    if conflict_vertices:\n        # focus on most conflicting vertex (break ties by degree)\n        def conflict_count(u):\n            cu = sol[u]\n            return sum(1 for v in adj[u] if sol[v] == cu)\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        # try to reduce max color usage\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color = max(sol)\n\n    # Candidate colors: avoid increasing palette if no violations\n    allow_new_color = violations > 0 and random.random() < 0.1\n    candidates = list(range(1, max_color + (1 if allow_new_color else 0)))\n    # Exclude current color to enforce a move\n    candidates = [c for c in candidates if c != current_color and c >= 1]\n    if not candidates:\n        # If no alternative, pick a different vertex randomly\n        other = (idx + 1) % n\n        if sol[other] != sol[idx]:\n            idx = other\n            current_color = sol[idx]\n            candidates = [c for c in range(1, max_color+1) if c != current_color]\n        if not candidates:\n            # fallback: return compressed solution unchanged (rare)\n            return (compress_colors(sol), \"Recolor\")\n\n    # Score candidates by local conflicts, tie-break by color frequency (favor rarer colors to enable class elimination)\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    def local_conflicts(color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        key = (sc, freq.get(c, 0))  # minimize conflicts, then prefer rarer\n        if best_score is None or key < best_score:\n            best_score = key\n            best_colors = [c]\n        elif key == best_score:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive: if invalid, create a simple feasible seed via greedy\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Select k vertices to recolor (bounded to avoid destroying structure)\n    k = random.randint(2, 3)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) <= k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n\n    # Recolor chosen vertices with diversification but no palette expansion when already feasible\n    for idx in picks:\n        max_color = max(sol)\n        # Allow new color only if there are conflicts overall to help escape; small probability\n        allow_new = (len(conflict_vertices) > 0) and (random.random() < 0.15)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts; tie-break by rarity\n        freq = {}\n        for c in sol:\n            freq[c] = freq.get(c, 0) + 1\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, freq.get(c, 0))\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":[[1,2,3,4,3,5,5,4,5],1004,[1,2,3,2,4,3,1,1,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002739261}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations heavily\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers and data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR: pick vertex with max saturation, break ties by degree\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving order of appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive validation and repair using DSATUR\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts and violations count\n    conflict_vertices = set()\n    violations = 0\n    for u in range(n):\n        cu = sol[u]\n        for v in adj[u]:\n            if v > u and sol[v] == cu:\n                violations += 1\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Selection strategy\n    if conflict_vertices:\n        # focus on most conflicting vertex (break ties by degree)\n        def conflict_count(u):\n            cu = sol[u]\n            return sum(1 for v in adj[u] if sol[v] == cu)\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        # try to reduce max color usage\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color = max(sol)\n\n    # Candidate colors: avoid increasing palette if no violations\n    allow_new_color = violations > 0 and random.random() < 0.1\n    candidates = list(range(1, max_color + (1 if allow_new_color else 0)))\n    # Exclude current color to enforce a move\n    candidates = [c for c in candidates if c != current_color and c >= 1]\n    if not candidates:\n        # If no alternative, pick a different vertex randomly\n        other = (idx + 1) % n\n        if sol[other] != sol[idx]:\n            idx = other\n            current_color = sol[idx]\n            candidates = [c for c in range(1, max_color+1) if c != current_color]\n        if not candidates:\n            # fallback: return compressed solution unchanged (rare)\n            return (compress_colors(sol), \"Recolor\")\n\n    # Score candidates by local conflicts, tie-break by color frequency (favor rarer colors to enable class elimination)\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    def local_conflicts(color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        key = (sc, freq.get(c, 0))  # minimize conflicts, then prefer rarer\n        if best_score is None or key < best_score:\n            best_score = key\n            best_colors = [c]\n        elif key == best_score:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive: if invalid, create a simple feasible seed via greedy\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Select k vertices to recolor (bounded to avoid destroying structure)\n    k = random.randint(2, 3)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) <= k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n\n    # Recolor chosen vertices with diversification but no palette expansion when already feasible\n    for idx in picks:\n        max_color = max(sol)\n        # Allow new color only if there are conflicts overall to help escape; small probability\n        allow_new = (len(conflict_vertices) > 0) and (random.random() < 0.15)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts; tie-break by rarity\n        freq = {}\n        for c in sol:\n            freq[c] = freq.get(c, 0) + 1\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, freq.get(c, 0))\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001515447}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: lexicographic (violations, max_color)\n    max_color = max(solution)\n    M = 100  # > n ensures feasibility prioritized\n    return violations * M + max_color\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers and embedded data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    # Validate\/repair input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts\n    conflict_edges = []\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_edges.append((u, v))\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Try Kempe-chain swap if conflicts exist\n    if conflict_edges and random.random() < 0.6:\n        u, v = random.choice(conflict_edges)\n        a = sol[u]\n        b = sol[v]\n        if a == b:\n            # pick a neighbor color different from a to attempt swap\n            neigh_colors = [sol[w] for w in adj[u] if sol[w] != a]\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n        if a != b:\n            # BFS on subgraph induced by colors {a,b}, starting from u\n            visited = [False]*n\n            queue = [u]\n            visited[u] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and sol[y] in (a, b):\n                        visited[y] = True\n                        queue.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x] == a:\n                    new_sol[x] = b\n                elif new_sol[x] == b:\n                    new_sol[x] = a\n            new_sol = compress_colors(new_sol)\n            if new_sol != sol:\n                return (new_sol, \"KempeSwap\")\n\n    # Otherwise perform targeted recolor\n    def local_conflicts(idx, color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    # Choose vertex: conflicting first; else from max color class to reduce palette\n    if conflict_vertices:\n        def conflict_count(u):\n            return sum(1 for v in adj[u] if sol[v] == sol[u])\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color_now = max(sol)\n\n    # Allow temporary palette expansion when conflicts exist\n    allow_new = (len(conflict_vertices) > 0 and random.random() < 0.2)\n    upper = max_color_now + (1 if allow_new else 0)\n    candidates = [c for c in range(1, upper+1) if c != current_color]\n    if not candidates:\n        # force a different vertex\n        idx = (idx + 1) % n\n        current_color = sol[idx]\n        candidates = [c for c in range(1, max(sol)+1) if c != current_color]\n        if not candidates:\n            # as last resort, introduce a new color\n            candidates = [max(sol)+1]\n\n    # Score candidates: prioritize reducing conflicts, then max color usage\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    best_key = None\n    best_colors = []\n    for c in candidates:\n        before_conf = local_conflicts(idx, current_color)\n        after_conf = local_conflicts(idx, c)\n        delta_viol = after_conf - before_conf  # prefer negative\n        new_max = max(max_color_now, c)\n        key = (delta_viol, new_max, freq.get(c, 0))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_colors = [c]\n        elif key == best_key:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    if new_sol == sol:\n        # ensure a move: flip to any different color\n        alt = new_color + 1 if new_color < max(sol)+1 else 1\n        if alt == current_color:\n            alt = (alt % (max(sol)+1)) + 1\n        new_sol[idx] = alt\n        new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts and largest color class\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    freq = {}\n    for i, c in enumerate(sol):\n        freq[c] = freq.get(c, 0) + 1\n    largest_color = max(freq, key=lambda k: (freq[k], k))\n    largest_class_vertices = [i for i, c in enumerate(sol) if c == largest_color]\n\n    # Perturb strength: 2-4 vertices, prefer conflicts and largest class\n    k = random.randint(2, 4)\n    pool = list(dict.fromkeys(list(conflict_vertices) + largest_class_vertices))\n    if not pool:\n        pool = list(range(n))\n    picks = random.sample(pool, k if len(pool) >= k else len(pool))\n    while len(picks) < k:\n        x = random.randrange(n)\n        if x not in picks:\n            picks.append(x)\n\n    # Recolor picks with minimized local conflicts; allow temporary new color with small prob if conflicts present\n    has_conflicts = len(conflict_vertices) > 0\n    for idx in picks:\n        max_color = max(sol)\n        allow_new = has_conflicts and (random.random() < 0.2)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000568}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: lexicographic (violations, max_color)\n    max_color = max(solution)\n    M = 100  # > n ensures feasibility prioritized\n    return violations * M + max_color\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers and embedded data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    # Validate\/repair input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts\n    conflict_edges = []\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_edges.append((u, v))\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Try Kempe-chain swap if conflicts exist\n    if conflict_edges and random.random() < 0.6:\n        u, v = random.choice(conflict_edges)\n        a = sol[u]\n        b = sol[v]\n        if a == b:\n            # pick a neighbor color different from a to attempt swap\n            neigh_colors = [sol[w] for w in adj[u] if sol[w] != a]\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n        if a != b:\n            # BFS on subgraph induced by colors {a,b}, starting from u\n            visited = [False]*n\n            queue = [u]\n            visited[u] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and sol[y] in (a, b):\n                        visited[y] = True\n                        queue.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x] == a:\n                    new_sol[x] = b\n                elif new_sol[x] == b:\n                    new_sol[x] = a\n            new_sol = compress_colors(new_sol)\n            if new_sol != sol:\n                return (new_sol, \"KempeSwap\")\n\n    # Otherwise perform targeted recolor\n    def local_conflicts(idx, color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    # Choose vertex: conflicting first; else from max color class to reduce palette\n    if conflict_vertices:\n        def conflict_count(u):\n            return sum(1 for v in adj[u] if sol[v] == sol[u])\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color_now = max(sol)\n\n    # Allow temporary palette expansion when conflicts exist\n    allow_new = (len(conflict_vertices) > 0 and random.random() < 0.2)\n    upper = max_color_now + (1 if allow_new else 0)\n    candidates = [c for c in range(1, upper+1) if c != current_color]\n    if not candidates:\n        # force a different vertex\n        idx = (idx + 1) % n\n        current_color = sol[idx]\n        candidates = [c for c in range(1, max(sol)+1) if c != current_color]\n        if not candidates:\n            # as last resort, introduce a new color\n            candidates = [max(sol)+1]\n\n    # Score candidates: prioritize reducing conflicts, then max color usage\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    best_key = None\n    best_colors = []\n    for c in candidates:\n        before_conf = local_conflicts(idx, current_color)\n        after_conf = local_conflicts(idx, c)\n        delta_viol = after_conf - before_conf  # prefer negative\n        new_max = max(max_color_now, c)\n        key = (delta_viol, new_max, freq.get(c, 0))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_colors = [c]\n        elif key == best_key:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    if new_sol == sol:\n        # ensure a move: flip to any different color\n        alt = new_color + 1 if new_color < max(sol)+1 else 1\n        if alt == current_color:\n            alt = (alt % (max(sol)+1)) + 1\n        new_sol[idx] = alt\n        new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts and largest color class\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    freq = {}\n    for i, c in enumerate(sol):\n        freq[c] = freq.get(c, 0) + 1\n    largest_color = max(freq, key=lambda k: (freq[k], k))\n    largest_class_vertices = [i for i, c in enumerate(sol) if c == largest_color]\n\n    # Perturb strength: 2-4 vertices, prefer conflicts and largest class\n    k = random.randint(2, 4)\n    pool = list(dict.fromkeys(list(conflict_vertices) + largest_class_vertices))\n    if not pool:\n        pool = list(range(n))\n    picks = random.sample(pool, k if len(pool) >= k else len(pool))\n    while len(picks) < k:\n        x = random.randrange(n)\n        if x not in picks:\n            picks.append(x)\n\n    # Recolor picks with minimized local conflicts; allow temporary new color with small prob if conflicts present\n    has_conflicts = len(conflict_vertices) > 0\n    for idx in picks:\n        max_color = max(sol)\n        allow_new = has_conflicts and (random.random() < 0.2)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.0000019801}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: lexicographic (violations, max_color)\n    max_color = max(solution)\n    M = 100  # > n ensures feasibility prioritized\n    return violations * M + max_color\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers and embedded data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    # Validate\/repair input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts\n    conflict_edges = []\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_edges.append((u, v))\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Try Kempe-chain swap if conflicts exist\n    if conflict_edges and random.random() < 0.6:\n        u, v = random.choice(conflict_edges)\n        a = sol[u]\n        b = sol[v]\n        if a == b:\n            # pick a neighbor color different from a to attempt swap\n            neigh_colors = [sol[w] for w in adj[u] if sol[w] != a]\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n        if a != b:\n            # BFS on subgraph induced by colors {a,b}, starting from u\n            visited = [False]*n\n            queue = [u]\n            visited[u] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and sol[y] in (a, b):\n                        visited[y] = True\n                        queue.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x] == a:\n                    new_sol[x] = b\n                elif new_sol[x] == b:\n                    new_sol[x] = a\n            new_sol = compress_colors(new_sol)\n            if new_sol != sol:\n                return (new_sol, \"KempeSwap\")\n\n    # Otherwise perform targeted recolor\n    def local_conflicts(idx, color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    # Choose vertex: conflicting first; else from max color class to reduce palette\n    if conflict_vertices:\n        def conflict_count(u):\n            return sum(1 for v in adj[u] if sol[v] == sol[u])\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color_now = max(sol)\n\n    # Allow temporary palette expansion when conflicts exist\n    allow_new = (len(conflict_vertices) > 0 and random.random() < 0.2)\n    upper = max_color_now + (1 if allow_new else 0)\n    candidates = [c for c in range(1, upper+1) if c != current_color]\n    if not candidates:\n        # force a different vertex\n        idx = (idx + 1) % n\n        current_color = sol[idx]\n        candidates = [c for c in range(1, max(sol)+1) if c != current_color]\n        if not candidates:\n            # as last resort, introduce a new color\n            candidates = [max(sol)+1]\n\n    # Score candidates: prioritize reducing conflicts, then max color usage\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    best_key = None\n    best_colors = []\n    for c in candidates:\n        before_conf = local_conflicts(idx, current_color)\n        after_conf = local_conflicts(idx, c)\n        delta_viol = after_conf - before_conf  # prefer negative\n        new_max = max(max_color_now, c)\n        key = (delta_viol, new_max, freq.get(c, 0))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_colors = [c]\n        elif key == best_key:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    if new_sol == sol:\n        # ensure a move: flip to any different color\n        alt = new_color + 1 if new_color < max(sol)+1 else 1\n        if alt == current_color:\n            alt = (alt % (max(sol)+1)) + 1\n        new_sol[idx] = alt\n        new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts and largest color class\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    freq = {}\n    for i, c in enumerate(sol):\n        freq[c] = freq.get(c, 0) + 1\n    largest_color = max(freq, key=lambda k: (freq[k], k))\n    largest_class_vertices = [i for i, c in enumerate(sol) if c == largest_color]\n\n    # Perturb strength: 2-4 vertices, prefer conflicts and largest class\n    k = random.randint(2, 4)\n    pool = list(dict.fromkeys(list(conflict_vertices) + largest_class_vertices))\n    if not pool:\n        pool = list(range(n))\n    picks = random.sample(pool, k if len(pool) >= k else len(pool))\n    while len(picks) < k:\n        x = random.randrange(n)\n        if x not in picks:\n            picks.append(x)\n\n    # Recolor picks with minimized local conflicts; allow temporary new color with small prob if conflicts present\n    has_conflicts = len(conflict_vertices) > 0\n    for idx in picks:\n        max_color = max(sol)\n        allow_new = has_conflicts and (random.random() < 0.2)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000105}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return BIG\n    if len(solution) != V_count:\n        return BIG - 1\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG - 2\n    k = max(solution) if solution else BIG - 3\n    labels = set(solution)\n    # Contiguity: labels must be exactly {1..k}\n    if labels != set(range(1, k + 1)):\n        return (10**8) + k\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        return (10**7) + violations * 10**4 + k\n    # Feasible: objective equals k (minimize number of groups)\n    return float(k)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a list copy and basic repair\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    r = random.random()\n    if r < 0.5:\n        # Recolor a single vertex, biased to reduce palette\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            new_color = random.randint(1, k - 1)\n        else:\n            new_color = random.randint(1, k)\n        sol[i] = new_color\n        move = (\"SingleIndexRecolor\", \"Reassign\")\n    else:\n        # Swap two color labels to change many assignments coherently\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move = (\"LabelSwap\", \"SwapColors\")\n        else:\n            i = random.randrange(n)\n            sol[i] = 1\n            move = (\"NoOpFallback\", \"Reassign\")\n\n    # Relabel to ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    neighbour = [mapping[x] for x in sol]\n    return neighbour, move\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Multi-step random perturbation with palette-reduction bias and label swaps\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    steps = 3 + random.randrange(4)  # 3..6 random edits\n    for _ in range(steps):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.5:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, max(1, k))\n        if random.random() < 0.3 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n        k = max(sol)\n\n    # Ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    pert = [mapping[x] for x in sol]\n    return pert\n","Resultados":[[2,1,4,1,3,3,2,2,1],4.0,[1,4,2,3,3,2,1,1,4],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001073684}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return BIG\n    if len(solution) != V_count:\n        return BIG - 1\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG - 2\n    k = max(solution) if solution else BIG - 3\n    labels = set(solution)\n    # Contiguity: labels must be exactly {1..k}\n    if labels != set(range(1, k + 1)):\n        return (10**8) + k\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        return (10**7) + violations * 10**4 + k\n    # Feasible: objective equals k (minimize number of groups)\n    return float(k)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a list copy and basic repair\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    r = random.random()\n    if r < 0.5:\n        # Recolor a single vertex, biased to reduce palette\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            new_color = random.randint(1, k - 1)\n        else:\n            new_color = random.randint(1, k)\n        sol[i] = new_color\n        move = (\"SingleIndexRecolor\", \"Reassign\")\n    else:\n        # Swap two color labels to change many assignments coherently\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move = (\"LabelSwap\", \"SwapColors\")\n        else:\n            i = random.randrange(n)\n            sol[i] = 1\n            move = (\"NoOpFallback\", \"Reassign\")\n\n    # Relabel to ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    neighbour = [mapping[x] for x in sol]\n    return neighbour, move\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Multi-step random perturbation with palette-reduction bias and label swaps\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    steps = 3 + random.randrange(4)  # 3..6 random edits\n    for _ in range(steps):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.5:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, max(1, k))\n        if random.random() < 0.3 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n        k = max(sol)\n\n    # Ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    pert = [mapping[x] for x in sol]\n    return pert\n","Resultados":[[1,1,1,1,1,1,1,1,1],4.0,[1,4,2,3,3,2,1,1,4],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001127133}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return BIG\n    if len(solution) != V_count:\n        return BIG - 1\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG - 2\n    k = max(solution) if solution else BIG - 3\n    labels = set(solution)\n    # Contiguity: labels must be exactly {1..k}\n    if labels != set(range(1, k + 1)):\n        return (10**8) + k\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        return (10**7) + violations * 10**4 + k\n    # Feasible: objective equals k (minimize number of groups)\n    return float(k)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a list copy and basic repair\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    r = random.random()\n    if r < 0.5:\n        # Recolor a single vertex, biased to reduce palette\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            new_color = random.randint(1, k - 1)\n        else:\n            new_color = random.randint(1, k)\n        sol[i] = new_color\n        move = (\"SingleIndexRecolor\", \"Reassign\")\n    else:\n        # Swap two color labels to change many assignments coherently\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move = (\"LabelSwap\", \"SwapColors\")\n        else:\n            i = random.randrange(n)\n            sol[i] = 1\n            move = (\"NoOpFallback\", \"Reassign\")\n\n    # Relabel to ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    neighbour = [mapping[x] for x in sol]\n    return neighbour, move\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Multi-step random perturbation with palette-reduction bias and label swaps\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    steps = 3 + random.randrange(4)  # 3..6 random edits\n    for _ in range(steps):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.5:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, max(1, k))\n        if random.random() < 0.3 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n        k = max(sol)\n\n    # Ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    pert = [mapping[x] for x in sol]\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000614458}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != V_count:\n        return float(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Core objective components\n    k = max(solution)\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better)\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + float(k)\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef generate_neighbour(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        colors = list(range(1, max(2, k) + 1))\n        # With small probability allow a new color to escape plateaus\n        if random.random() < 0.1:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            if c == current_color and random.random() < 0.5:\n                # sometimes skip staying put\n                continue\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: perform label-aware exploration\n        r = random.random()\n        if r < 0.5 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.8:\n            # Kempe chain swap between two colors starting at random vertex\n            if k >= 2:\n                v = random.randrange(n)\n                a, b = random.sample(range(1, k + 1), 2)\n                target_colors = {a, b}\n                stack = [v]\n                visited = set([v])\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target_colors:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target_colors:\n                                visited.add(j)\n                                stack.append(j)\n                # swap a<->b in component\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                i = random.randrange(n)\n                sol[i] = 1\n                move_desc = (\"NoOpFallback\", \"Reassign\")\n        else:\n            # Merge attempt: try to recolor a random vertex to a lower label to reduce k\n            i = random.randrange(n)\n            candidate_colors = list(range(1, k)) if k > 1 else [1]\n            if candidate_colors:\n                sol[i] = random.choice(candidate_colors)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Kick parameters\n    t = 4 + random.randrange(4)  # 4..7 vertex edits\n\n    # 1) Random recolors with slight palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n        k = max(sol)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair\n    k = max(sol)\n    if k >= 2:\n        v = random.randrange(n)\n        a, b = random.sample(range(1, k + 1), 2)\n        target_colors = {a, b}\n        stack = [v]\n        visited = set([v])\n        component = []\n        while stack:\n            u = stack.pop()\n            if sol[u] in target_colors:\n                component.append(u)\n                for nb in adj[u + 1]:\n                    j = nb - 1\n                    if j not in visited and sol[j] in target_colors:\n                        visited.add(j)\n                        stack.append(j)\n        for u in component:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    return _canonicalize_labels(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001520979}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != V_count:\n        return float(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Core objective components\n    k = max(solution)\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better)\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + float(k)\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef generate_neighbour(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        colors = list(range(1, max(2, k) + 1))\n        # With small probability allow a new color to escape plateaus\n        if random.random() < 0.1:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            if c == current_color and random.random() < 0.5:\n                # sometimes skip staying put\n                continue\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: perform label-aware exploration\n        r = random.random()\n        if r < 0.5 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.8:\n            # Kempe chain swap between two colors starting at random vertex\n            if k >= 2:\n                v = random.randrange(n)\n                a, b = random.sample(range(1, k + 1), 2)\n                target_colors = {a, b}\n                stack = [v]\n                visited = set([v])\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target_colors:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target_colors:\n                                visited.add(j)\n                                stack.append(j)\n                # swap a<->b in component\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                i = random.randrange(n)\n                sol[i] = 1\n                move_desc = (\"NoOpFallback\", \"Reassign\")\n        else:\n            # Merge attempt: try to recolor a random vertex to a lower label to reduce k\n            i = random.randrange(n)\n            candidate_colors = list(range(1, k)) if k > 1 else [1]\n            if candidate_colors:\n                sol[i] = random.choice(candidate_colors)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Kick parameters\n    t = 4 + random.randrange(4)  # 4..7 vertex edits\n\n    # 1) Random recolors with slight palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n        k = max(sol)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair\n    k = max(sol)\n    if k >= 2:\n        v = random.randrange(n)\n        a, b = random.sample(range(1, k + 1), 2)\n        target_colors = {a, b}\n        stack = [v]\n        visited = set([v])\n        component = []\n        while stack:\n            u = stack.pop()\n            if sol[u] in target_colors:\n                component.append(u)\n                for nb in adj[u + 1]:\n                    j = nb - 1\n                    if j not in visited and sol[j] in target_colors:\n                        visited.add(j)\n                        stack.append(j)\n        for u in component:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    return _canonicalize_labels(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001197425}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != V_count:\n        return float(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Core objective components\n    k = max(solution)\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better)\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + float(k)\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef generate_neighbour(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        colors = list(range(1, max(2, k) + 1))\n        # With small probability allow a new color to escape plateaus\n        if random.random() < 0.1:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            if c == current_color and random.random() < 0.5:\n                # sometimes skip staying put\n                continue\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: perform label-aware exploration\n        r = random.random()\n        if r < 0.5 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.8:\n            # Kempe chain swap between two colors starting at random vertex\n            if k >= 2:\n                v = random.randrange(n)\n                a, b = random.sample(range(1, k + 1), 2)\n                target_colors = {a, b}\n                stack = [v]\n                visited = set([v])\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target_colors:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target_colors:\n                                visited.add(j)\n                                stack.append(j)\n                # swap a<->b in component\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                i = random.randrange(n)\n                sol[i] = 1\n                move_desc = (\"NoOpFallback\", \"Reassign\")\n        else:\n            # Merge attempt: try to recolor a random vertex to a lower label to reduce k\n            i = random.randrange(n)\n            candidate_colors = list(range(1, k)) if k > 1 else [1]\n            if candidate_colors:\n                sol[i] = random.choice(candidate_colors)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Kick parameters\n    t = 4 + random.randrange(4)  # 4..7 vertex edits\n\n    # 1) Random recolors with slight palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n        k = max(sol)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair\n    k = max(sol)\n    if k >= 2:\n        v = random.randrange(n)\n        a, b = random.sample(range(1, k + 1), 2)\n        target_colors = {a, b}\n        stack = [v]\n        visited = set([v])\n        component = []\n        while stack:\n            u = stack.pop()\n            if sol[u] in target_colors:\n                component.append(u)\n                for nb in adj[u + 1]:\n                    j = nb - 1\n                    if j not in visited and sol[j] in target_colors:\n                        visited.add(j)\n                        stack.append(j)\n        for u in component:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    return _canonicalize_labels(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001112514}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        # assemble candidate colors, bias to <= k; allow k+1 with very small prob only if conflicts exist\n        colors = list(range(1, max(2, k) + 1))\n        if random.random() < 0.05:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            # prefer lower color on tie to aid palette reduction later\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: label-aware exploration\n        k = max(sol)\n        r = random.random()\n        if r < 0.45 and k >= 2:\n            # direct label swap\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.85 and k >= 2:\n            # Kempe chain swap between two colors, ensure seed color in target set\n            a, b = random.sample(range(1, k + 1), 2)\n            target = {a, b}\n            # choose a vertex whose color is in {a,b}; if none exist (degenerate), fallback recolor\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                v = random.choice(candidates)\n                stack = [v]\n                visited = {v}\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target:\n                                visited.add(j)\n                                stack.append(j)\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                # fallback small recolor to lower labels\n                i = random.randrange(n)\n                if k > 1:\n                    sol[i] = random.randint(1, k - 1)\n                move_desc = (\"FallbackLowerRecolor\", \"Reassign\")\n        else:\n            # Palette reduction attempt: try to recolor a random vertex to a lower label avoiding immediate conflict if possible\n            i = random.randrange(n)\n            lowered = False\n            if k > 1:\n                for c in range(1, k):\n                    conflict = False\n                    for nb in adj[i + 1]:\n                        if sol[nb - 1] == c:\n                            conflict = True\n                            break\n                    if not conflict:\n                        sol[i] = c\n                        lowered = True\n                        break\n            if not lowered:\n                # if no conflict-free lower color, keep color or random minor tweak\n                if k > 1 and random.random() < 0.3:\n                    sol[i] = random.randint(1, k - 1)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    # Postcondition safety\n    if len(neighbour) != 9 or min(neighbour) < 1:\n        neighbour = [1] * 9\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    # Kick strength\n    t = 5 + random.randrange(3)  # 5..7 edits\n\n    # 1) Random recolors with palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        k = max(sol)\n        if k > 1 and random.random() < 0.65:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair (ensure seed in target)\n    k = max(sol)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        target = {a, b}\n        candidates = [idx for idx, x in enumerate(sol) if x in target]\n        if candidates:\n            v = random.choice(candidates)\n            stack = [v]\n            visited = {v}\n            component = []\n            while stack:\n                u = stack.pop()\n                if sol[u] in target:\n                    component.append(u)\n                    for nb in adj[u + 1]:\n                        j = nb - 1\n                        if j not in visited and sol[j] in target:\n                            visited.add(j)\n                            stack.append(j)\n            for u in component:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    sol = _canonicalize_labels(sol)\n    if len(sol) != 9 or min(sol) < 1:\n        sol = [1] * 9\n    return sol\n","Resultados":[[4,1,2,1,3,4,3,4,1],4,[4,2,1,2,3,1,3,4,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002209707}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        # assemble candidate colors, bias to <= k; allow k+1 with very small prob only if conflicts exist\n        colors = list(range(1, max(2, k) + 1))\n        if random.random() < 0.05:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            # prefer lower color on tie to aid palette reduction later\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: label-aware exploration\n        k = max(sol)\n        r = random.random()\n        if r < 0.45 and k >= 2:\n            # direct label swap\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.85 and k >= 2:\n            # Kempe chain swap between two colors, ensure seed color in target set\n            a, b = random.sample(range(1, k + 1), 2)\n            target = {a, b}\n            # choose a vertex whose color is in {a,b}; if none exist (degenerate), fallback recolor\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                v = random.choice(candidates)\n                stack = [v]\n                visited = {v}\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target:\n                                visited.add(j)\n                                stack.append(j)\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                # fallback small recolor to lower labels\n                i = random.randrange(n)\n                if k > 1:\n                    sol[i] = random.randint(1, k - 1)\n                move_desc = (\"FallbackLowerRecolor\", \"Reassign\")\n        else:\n            # Palette reduction attempt: try to recolor a random vertex to a lower label avoiding immediate conflict if possible\n            i = random.randrange(n)\n            lowered = False\n            if k > 1:\n                for c in range(1, k):\n                    conflict = False\n                    for nb in adj[i + 1]:\n                        if sol[nb - 1] == c:\n                            conflict = True\n                            break\n                    if not conflict:\n                        sol[i] = c\n                        lowered = True\n                        break\n            if not lowered:\n                # if no conflict-free lower color, keep color or random minor tweak\n                if k > 1 and random.random() < 0.3:\n                    sol[i] = random.randint(1, k - 1)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    # Postcondition safety\n    if len(neighbour) != 9 or min(neighbour) < 1:\n        neighbour = [1] * 9\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    # Kick strength\n    t = 5 + random.randrange(3)  # 5..7 edits\n\n    # 1) Random recolors with palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        k = max(sol)\n        if k > 1 and random.random() < 0.65:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair (ensure seed in target)\n    k = max(sol)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        target = {a, b}\n        candidates = [idx for idx, x in enumerate(sol) if x in target]\n        if candidates:\n            v = random.choice(candidates)\n            stack = [v]\n            visited = {v}\n            component = []\n            while stack:\n                u = stack.pop()\n                if sol[u] in target:\n                    component.append(u)\n                    for nb in adj[u + 1]:\n                        j = nb - 1\n                        if j not in visited and sol[j] in target:\n                            visited.add(j)\n                            stack.append(j)\n            for u in component:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    sol = _canonicalize_labels(sol)\n    if len(sol) != 9 or min(sol) < 1:\n        sol = [1] * 9\n    return sol\n","Resultados":[[1,2,1,1,1,1,1,1,1],4,[4,2,1,2,3,1,3,4,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002633002}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        # assemble candidate colors, bias to <= k; allow k+1 with very small prob only if conflicts exist\n        colors = list(range(1, max(2, k) + 1))\n        if random.random() < 0.05:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            # prefer lower color on tie to aid palette reduction later\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: label-aware exploration\n        k = max(sol)\n        r = random.random()\n        if r < 0.45 and k >= 2:\n            # direct label swap\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.85 and k >= 2:\n            # Kempe chain swap between two colors, ensure seed color in target set\n            a, b = random.sample(range(1, k + 1), 2)\n            target = {a, b}\n            # choose a vertex whose color is in {a,b}; if none exist (degenerate), fallback recolor\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                v = random.choice(candidates)\n                stack = [v]\n                visited = {v}\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target:\n                                visited.add(j)\n                                stack.append(j)\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                # fallback small recolor to lower labels\n                i = random.randrange(n)\n                if k > 1:\n                    sol[i] = random.randint(1, k - 1)\n                move_desc = (\"FallbackLowerRecolor\", \"Reassign\")\n        else:\n            # Palette reduction attempt: try to recolor a random vertex to a lower label avoiding immediate conflict if possible\n            i = random.randrange(n)\n            lowered = False\n            if k > 1:\n                for c in range(1, k):\n                    conflict = False\n                    for nb in adj[i + 1]:\n                        if sol[nb - 1] == c:\n                            conflict = True\n                            break\n                    if not conflict:\n                        sol[i] = c\n                        lowered = True\n                        break\n            if not lowered:\n                # if no conflict-free lower color, keep color or random minor tweak\n                if k > 1 and random.random() < 0.3:\n                    sol[i] = random.randint(1, k - 1)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    # Postcondition safety\n    if len(neighbour) != 9 or min(neighbour) < 1:\n        neighbour = [1] * 9\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    # Kick strength\n    t = 5 + random.randrange(3)  # 5..7 edits\n\n    # 1) Random recolors with palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        k = max(sol)\n        if k > 1 and random.random() < 0.65:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair (ensure seed in target)\n    k = max(sol)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        target = {a, b}\n        candidates = [idx for idx, x in enumerate(sol) if x in target]\n        if candidates:\n            v = random.choice(candidates)\n            stack = [v]\n            visited = {v}\n            component = []\n            while stack:\n                u = stack.pop()\n                if sol[u] in target:\n                    component.append(u)\n                    for nb in adj[u + 1]:\n                        j = nb - 1\n                        if j not in visited and sol[j] in target:\n                            visited.add(j)\n                            stack.append(j)\n            for u in component:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    sol = _canonicalize_labels(sol)\n    if len(sol) != 9 or min(sol) < 1:\n        sol = [1] * 9\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001189654}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    # length repair\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Repair invalid entries by greedy assignment to minimize immediate conflicts\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            best_c = 1\n            best_conf = math.inf\n            k_cur = max(1, max(c for c in sol if isinstance(c, int) and c >= 1))\n            for c in range(1, k_cur + 1):\n                cnt = 0\n                for nb in adj[i + 1]:\n                    if nb - 1 < n and sol[nb - 1] == c:\n                        cnt += 1\n                if cnt < best_conf:\n                    best_conf = cnt\n                    best_c = c\n            sol[i] = best_c\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    def saturation(idx):\n        return len({sol[j - 1] for j in adj[idx + 1]})\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"NoOp\", \"None\")\n\n    if conflicts:\n        # DSATUR-based pick: prioritize by (#conflicts, saturation, degree)\n        def key_func(i):\n            return (vertex_conflicts(i), saturation(i), len(adj[i + 1]))\n        i = max(conflicts, key=key_func)\n        k_cur = max(sol)\n        # Check if any conflicting vertex has a conflict-free color in 1..k_cur\n        exists_cf = False\n        for j in conflicts:\n            for c in range(1, k_cur + 1):\n                if c == sol[j]:\n                    continue\n                if count_conflicts_at(j, c) == 0:\n                    exists_cf = True\n                    break\n            if exists_cf:\n                break\n        # Try best color within current palette first\n        best_color = sol[i]\n        best_score = (count_conflicts_at(i, sol[i]), sol[i])\n        for c in range(1, k_cur + 1):\n            if c == sol[i]:\n                continue\n            cnt = count_conflicts_at(i, c)\n            # prefer fewer conflicts, then lower color\n            if (cnt, c) < best_score:\n                best_score = (cnt, c)\n                best_color = c\n        # Allow k+1 only if no vertex has a conflict-free recolor\n        if not exists_cf and count_conflicts_at(i, best_color) > 0:\n            best_color = k_cur + 1\n        old = sol[i]\n        sol[i] = best_color\n        move_desc = (\"ConflictRecolor_DSatur\", f\"{i}:{old}->{best_color}\")\n    else:\n        # No conflicts: label-aware exploration\n        k_cur = max(sol)\n        r = random.random()\n        if r < 0.25 and k_cur >= 2:\n            # Label swap (reduced frequency)\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            if a != b:\n                sol = [a if x == b else b if x == a else x for x in sol]\n                move_desc = (\"LabelSwap\", f\"{a}<->{b}\")\n        elif r < 0.7 and k_cur >= 2:\n            # Kempe chain swap with proper alternation between colors a and b\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            # seed must be in target\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                seed = random.choice(candidates)\n                # BFS alternating on colors a and b\n                from collections import deque\n                q = deque([seed])\n                visited = {seed}\n                while q:\n                    u = q.popleft()\n                    cu = sol[u]\n                    for nb in adj[u + 1]:\n                        v = nb - 1\n                        if v in visited:\n                            continue\n                        if sol[v] in target and sol[v] != cu:\n                            visited.add(v)\n                            q.append(v)\n                for u in visited:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChainAlt\", f\"{a}<->{b} size={len(visited)}\")\n            else:\n                # fallback: no-op\n                move_desc = (\"KempeFallback\", \"None\")\n        else:\n            # Palette reduction attempt: try to absorb highest color class into lower labels greedily\n            if k_cur >= 2:\n                highest = k_cur\n                idxs = [i for i, x in enumerate(sol) if x == highest]\n                absorbed = True\n                for i in idxs:\n                    placed = False\n                    for c in range(1, highest):\n                        if count_conflicts_at(i, c) == 0:\n                            sol[i] = c\n                            placed = True\n                            break\n                    if not placed:\n                        absorbed = False\n                        # try least-conflict lower color\n                        best_c = 1\n                        best_cnt = math.inf\n                        for c in range(1, highest):\n                            cnt = count_conflicts_at(i, c)\n                            if cnt < best_cnt:\n                                best_cnt = cnt\n                                best_c = c\n                        sol[i] = best_c\n                move_desc = (\"PaletteReduce\", f\"k={k_cur}{'->'+str(max(sol)) if absorbed else ''}\")\n            else:\n                move_desc = (\"NoChange\", \"k=1\")\n\n    # Ensure basic validity\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    # Sanitize entries\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n\n    # Choose perturbation mode\n    mode = 0 if random.random() < 0.5 else 1\n    # Intensity\n    intensity = 5 + random.randrange(3)  # 5..7\n\n    if mode == 0:\n        # Multiple Kempe swaps (with proper alternation)\n        for _ in range(intensity):\n            k_cur = max(sol)\n            if k_cur < 2:\n                break\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if not candidates:\n                continue\n            seed = random.choice(candidates)\n            from collections import deque\n            q = deque([seed])\n            visited = {seed}\n            while q:\n                u = q.popleft()\n                cu = sol[u]\n                for nb in adj[u + 1]:\n                    v = nb - 1\n                    if v in visited:\n                        continue\n                    if sol[v] in target and sol[v] != cu:\n                        visited.add(v)\n                        q.append(v)\n            for u in visited:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n    else:\n        # Merge two color classes then repair greedily\n        k_cur = max(sol)\n        if k_cur >= 2:\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            # Merge b into a\n            sol = [a if x == b else x for x in sol]\n            # Greedy repairs up to budget\n            budget = intensity * n\n            for _ in range(budget):\n                # find any conflicting vertex\n                bads = []\n                for (u, v) in E:\n                    if sol[u - 1] == sol[v - 1]:\n                        bads.append(u - 1)\n                        bads.append(v - 1)\n                if not bads:\n                    break\n                # DSATUR-like pick among conflicts\n                bads = list(set(bads))\n                # compute saturation on demand\n                def sat(idx):\n                    return len({sol[j - 1] for j in adj[idx + 1]})\n                i = max(bads, key=lambda x: (vertex_conflicts(x), sat(x), len(adj[x + 1])))\n                best_c = sol[i]\n                best_val = (vertex_conflicts(i), sol[i])\n                for c in range(1, k_cur + 1):\n                    if c == sol[i]:\n                        continue\n                    cnt = count_conflicts_at(i, c)\n                    if (cnt, c) < best_val:\n                        best_val = (cnt, c)\n                        best_c = c\n                sol[i] = best_c\n\n    # Canonicalize labels to enforce contiguity\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    sol = [mapping[x] for x in sol]\n\n    # Final safety\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol\n","Resultados":[[4,2,3,2,1,4,4,4,2],4,[4,2,1,2,3,1,3,4,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002320478}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    # length repair\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Repair invalid entries by greedy assignment to minimize immediate conflicts\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            best_c = 1\n            best_conf = math.inf\n            k_cur = max(1, max(c for c in sol if isinstance(c, int) and c >= 1))\n            for c in range(1, k_cur + 1):\n                cnt = 0\n                for nb in adj[i + 1]:\n                    if nb - 1 < n and sol[nb - 1] == c:\n                        cnt += 1\n                if cnt < best_conf:\n                    best_conf = cnt\n                    best_c = c\n            sol[i] = best_c\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    def saturation(idx):\n        return len({sol[j - 1] for j in adj[idx + 1]})\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"NoOp\", \"None\")\n\n    if conflicts:\n        # DSATUR-based pick: prioritize by (#conflicts, saturation, degree)\n        def key_func(i):\n            return (vertex_conflicts(i), saturation(i), len(adj[i + 1]))\n        i = max(conflicts, key=key_func)\n        k_cur = max(sol)\n        # Check if any conflicting vertex has a conflict-free color in 1..k_cur\n        exists_cf = False\n        for j in conflicts:\n            for c in range(1, k_cur + 1):\n                if c == sol[j]:\n                    continue\n                if count_conflicts_at(j, c) == 0:\n                    exists_cf = True\n                    break\n            if exists_cf:\n                break\n        # Try best color within current palette first\n        best_color = sol[i]\n        best_score = (count_conflicts_at(i, sol[i]), sol[i])\n        for c in range(1, k_cur + 1):\n            if c == sol[i]:\n                continue\n            cnt = count_conflicts_at(i, c)\n            # prefer fewer conflicts, then lower color\n            if (cnt, c) < best_score:\n                best_score = (cnt, c)\n                best_color = c\n        # Allow k+1 only if no vertex has a conflict-free recolor\n        if not exists_cf and count_conflicts_at(i, best_color) > 0:\n            best_color = k_cur + 1\n        old = sol[i]\n        sol[i] = best_color\n        move_desc = (\"ConflictRecolor_DSatur\", f\"{i}:{old}->{best_color}\")\n    else:\n        # No conflicts: label-aware exploration\n        k_cur = max(sol)\n        r = random.random()\n        if r < 0.25 and k_cur >= 2:\n            # Label swap (reduced frequency)\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            if a != b:\n                sol = [a if x == b else b if x == a else x for x in sol]\n                move_desc = (\"LabelSwap\", f\"{a}<->{b}\")\n        elif r < 0.7 and k_cur >= 2:\n            # Kempe chain swap with proper alternation between colors a and b\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            # seed must be in target\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                seed = random.choice(candidates)\n                # BFS alternating on colors a and b\n                from collections import deque\n                q = deque([seed])\n                visited = {seed}\n                while q:\n                    u = q.popleft()\n                    cu = sol[u]\n                    for nb in adj[u + 1]:\n                        v = nb - 1\n                        if v in visited:\n                            continue\n                        if sol[v] in target and sol[v] != cu:\n                            visited.add(v)\n                            q.append(v)\n                for u in visited:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChainAlt\", f\"{a}<->{b} size={len(visited)}\")\n            else:\n                # fallback: no-op\n                move_desc = (\"KempeFallback\", \"None\")\n        else:\n            # Palette reduction attempt: try to absorb highest color class into lower labels greedily\n            if k_cur >= 2:\n                highest = k_cur\n                idxs = [i for i, x in enumerate(sol) if x == highest]\n                absorbed = True\n                for i in idxs:\n                    placed = False\n                    for c in range(1, highest):\n                        if count_conflicts_at(i, c) == 0:\n                            sol[i] = c\n                            placed = True\n                            break\n                    if not placed:\n                        absorbed = False\n                        # try least-conflict lower color\n                        best_c = 1\n                        best_cnt = math.inf\n                        for c in range(1, highest):\n                            cnt = count_conflicts_at(i, c)\n                            if cnt < best_cnt:\n                                best_cnt = cnt\n                                best_c = c\n                        sol[i] = best_c\n                move_desc = (\"PaletteReduce\", f\"k={k_cur}{'->'+str(max(sol)) if absorbed else ''}\")\n            else:\n                move_desc = (\"NoChange\", \"k=1\")\n\n    # Ensure basic validity\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    # Sanitize entries\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n\n    # Choose perturbation mode\n    mode = 0 if random.random() < 0.5 else 1\n    # Intensity\n    intensity = 5 + random.randrange(3)  # 5..7\n\n    if mode == 0:\n        # Multiple Kempe swaps (with proper alternation)\n        for _ in range(intensity):\n            k_cur = max(sol)\n            if k_cur < 2:\n                break\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if not candidates:\n                continue\n            seed = random.choice(candidates)\n            from collections import deque\n            q = deque([seed])\n            visited = {seed}\n            while q:\n                u = q.popleft()\n                cu = sol[u]\n                for nb in adj[u + 1]:\n                    v = nb - 1\n                    if v in visited:\n                        continue\n                    if sol[v] in target and sol[v] != cu:\n                        visited.add(v)\n                        q.append(v)\n            for u in visited:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n    else:\n        # Merge two color classes then repair greedily\n        k_cur = max(sol)\n        if k_cur >= 2:\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            # Merge b into a\n            sol = [a if x == b else x for x in sol]\n            # Greedy repairs up to budget\n            budget = intensity * n\n            for _ in range(budget):\n                # find any conflicting vertex\n                bads = []\n                for (u, v) in E:\n                    if sol[u - 1] == sol[v - 1]:\n                        bads.append(u - 1)\n                        bads.append(v - 1)\n                if not bads:\n                    break\n                # DSATUR-like pick among conflicts\n                bads = list(set(bads))\n                # compute saturation on demand\n                def sat(idx):\n                    return len({sol[j - 1] for j in adj[idx + 1]})\n                i = max(bads, key=lambda x: (vertex_conflicts(x), sat(x), len(adj[x + 1])))\n                best_c = sol[i]\n                best_val = (vertex_conflicts(i), sol[i])\n                for c in range(1, k_cur + 1):\n                    if c == sol[i]:\n                        continue\n                    cnt = count_conflicts_at(i, c)\n                    if (cnt, c) < best_val:\n                        best_val = (cnt, c)\n                        best_c = c\n                sol[i] = best_c\n\n    # Canonicalize labels to enforce contiguity\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    sol = [mapping[x] for x in sol]\n\n    # Final safety\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol\n","Resultados":[[4,3,1,3,2,1,4,4,3],4,[4,2,1,2,3,1,3,4,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.004920401}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    # length repair\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Repair invalid entries by greedy assignment to minimize immediate conflicts\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            best_c = 1\n            best_conf = math.inf\n            k_cur = max(1, max(c for c in sol if isinstance(c, int) and c >= 1))\n            for c in range(1, k_cur + 1):\n                cnt = 0\n                for nb in adj[i + 1]:\n                    if nb - 1 < n and sol[nb - 1] == c:\n                        cnt += 1\n                if cnt < best_conf:\n                    best_conf = cnt\n                    best_c = c\n            sol[i] = best_c\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    def saturation(idx):\n        return len({sol[j - 1] for j in adj[idx + 1]})\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"NoOp\", \"None\")\n\n    if conflicts:\n        # DSATUR-based pick: prioritize by (#conflicts, saturation, degree)\n        def key_func(i):\n            return (vertex_conflicts(i), saturation(i), len(adj[i + 1]))\n        i = max(conflicts, key=key_func)\n        k_cur = max(sol)\n        # Check if any conflicting vertex has a conflict-free color in 1..k_cur\n        exists_cf = False\n        for j in conflicts:\n            for c in range(1, k_cur + 1):\n                if c == sol[j]:\n                    continue\n                if count_conflicts_at(j, c) == 0:\n                    exists_cf = True\n                    break\n            if exists_cf:\n                break\n        # Try best color within current palette first\n        best_color = sol[i]\n        best_score = (count_conflicts_at(i, sol[i]), sol[i])\n        for c in range(1, k_cur + 1):\n            if c == sol[i]:\n                continue\n            cnt = count_conflicts_at(i, c)\n            # prefer fewer conflicts, then lower color\n            if (cnt, c) < best_score:\n                best_score = (cnt, c)\n                best_color = c\n        # Allow k+1 only if no vertex has a conflict-free recolor\n        if not exists_cf and count_conflicts_at(i, best_color) > 0:\n            best_color = k_cur + 1\n        old = sol[i]\n        sol[i] = best_color\n        move_desc = (\"ConflictRecolor_DSatur\", f\"{i}:{old}->{best_color}\")\n    else:\n        # No conflicts: label-aware exploration\n        k_cur = max(sol)\n        r = random.random()\n        if r < 0.25 and k_cur >= 2:\n            # Label swap (reduced frequency)\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            if a != b:\n                sol = [a if x == b else b if x == a else x for x in sol]\n                move_desc = (\"LabelSwap\", f\"{a}<->{b}\")\n        elif r < 0.7 and k_cur >= 2:\n            # Kempe chain swap with proper alternation between colors a and b\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            # seed must be in target\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                seed = random.choice(candidates)\n                # BFS alternating on colors a and b\n                from collections import deque\n                q = deque([seed])\n                visited = {seed}\n                while q:\n                    u = q.popleft()\n                    cu = sol[u]\n                    for nb in adj[u + 1]:\n                        v = nb - 1\n                        if v in visited:\n                            continue\n                        if sol[v] in target and sol[v] != cu:\n                            visited.add(v)\n                            q.append(v)\n                for u in visited:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChainAlt\", f\"{a}<->{b} size={len(visited)}\")\n            else:\n                # fallback: no-op\n                move_desc = (\"KempeFallback\", \"None\")\n        else:\n            # Palette reduction attempt: try to absorb highest color class into lower labels greedily\n            if k_cur >= 2:\n                highest = k_cur\n                idxs = [i for i, x in enumerate(sol) if x == highest]\n                absorbed = True\n                for i in idxs:\n                    placed = False\n                    for c in range(1, highest):\n                        if count_conflicts_at(i, c) == 0:\n                            sol[i] = c\n                            placed = True\n                            break\n                    if not placed:\n                        absorbed = False\n                        # try least-conflict lower color\n                        best_c = 1\n                        best_cnt = math.inf\n                        for c in range(1, highest):\n                            cnt = count_conflicts_at(i, c)\n                            if cnt < best_cnt:\n                                best_cnt = cnt\n                                best_c = c\n                        sol[i] = best_c\n                move_desc = (\"PaletteReduce\", f\"k={k_cur}{'->'+str(max(sol)) if absorbed else ''}\")\n            else:\n                move_desc = (\"NoChange\", \"k=1\")\n\n    # Ensure basic validity\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    # Sanitize entries\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n\n    # Choose perturbation mode\n    mode = 0 if random.random() < 0.5 else 1\n    # Intensity\n    intensity = 5 + random.randrange(3)  # 5..7\n\n    if mode == 0:\n        # Multiple Kempe swaps (with proper alternation)\n        for _ in range(intensity):\n            k_cur = max(sol)\n            if k_cur < 2:\n                break\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if not candidates:\n                continue\n            seed = random.choice(candidates)\n            from collections import deque\n            q = deque([seed])\n            visited = {seed}\n            while q:\n                u = q.popleft()\n                cu = sol[u]\n                for nb in adj[u + 1]:\n                    v = nb - 1\n                    if v in visited:\n                        continue\n                    if sol[v] in target and sol[v] != cu:\n                        visited.add(v)\n                        q.append(v)\n            for u in visited:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n    else:\n        # Merge two color classes then repair greedily\n        k_cur = max(sol)\n        if k_cur >= 2:\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            # Merge b into a\n            sol = [a if x == b else x for x in sol]\n            # Greedy repairs up to budget\n            budget = intensity * n\n            for _ in range(budget):\n                # find any conflicting vertex\n                bads = []\n                for (u, v) in E:\n                    if sol[u - 1] == sol[v - 1]:\n                        bads.append(u - 1)\n                        bads.append(v - 1)\n                if not bads:\n                    break\n                # DSATUR-like pick among conflicts\n                bads = list(set(bads))\n                # compute saturation on demand\n                def sat(idx):\n                    return len({sol[j - 1] for j in adj[idx + 1]})\n                i = max(bads, key=lambda x: (vertex_conflicts(x), sat(x), len(adj[x + 1])))\n                best_c = sol[i]\n                best_val = (vertex_conflicts(i), sol[i])\n                for c in range(1, k_cur + 1):\n                    if c == sol[i]:\n                        continue\n                    cnt = count_conflicts_at(i, c)\n                    if (cnt, c) < best_val:\n                        best_val = (cnt, c)\n                        best_c = c\n                sol[i] = best_c\n\n    # Canonicalize labels to enforce contiguity\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    sol = [mapping[x] for x in sol]\n\n    # Final safety\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001738871}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid baseline solution (repair if needed)\n    if not isinstance(solution, (list, tuple)):\n        # default trivial coloring 1..n\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Conflict count per vertex\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    # Choose a vertex: prioritize conflicting vertices, else random\n    conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n    if conflict_vertices:\n        i = random.choice(conflict_vertices)\n    else:\n        i = random.randrange(n)\n    current_color = sol[i]\n    max_color = max(sol) if sol else 1\n    # Try recoloring i to best available color among 1..max_color+1\n    best_color = current_color\n    best_delta = math.inf\n    for c in range(1, max_color+2):\n        if c == current_color:\n            continue\n        delta = 0\n        for j in adj[i]:\n            if sol[j] == current_color:\n                delta -= 1\n            if sol[j] == c:\n                delta += 1\n        # Prefer reducing conflicts; tie-break by not increasing color count\n        color_increase = 1 if (c == max_color+1) else 0\n        score = (delta, color_increase)\n        if score < (best_delta, 1 if best_color == max_color+1 else 0):\n            best_delta = delta\n            best_color = c\n    new_sol = sol[:]\n    new_sol[i] = best_color\n    # Canonicalize after move\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2, \"SingleVertexRecolor\"\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Defensive copy and repair baseline\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Apply a sequence of random recolors and a Kempe-like swap\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 1 + 1)  # allow introducing new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        max_color = max(max_color, c)\n    # Kempe-like color swap between two colors on a connected component induced by those colors\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            # pick a seed vertex with color c1 or c2\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                # BFS on subgraph induced by colors c1 and c2\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                # swap c1 and c2 on this component\n                for u in component:\n                    new_sol[u] = c1 if new_sol[u] == c2 else (c2 if new_sol[u] == c1 else new_sol[u])\n    # Canonicalize\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001275515}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid baseline solution (repair if needed)\n    if not isinstance(solution, (list, tuple)):\n        # default trivial coloring 1..n\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Conflict count per vertex\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    # Choose a vertex: prioritize conflicting vertices, else random\n    conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n    if conflict_vertices:\n        i = random.choice(conflict_vertices)\n    else:\n        i = random.randrange(n)\n    current_color = sol[i]\n    max_color = max(sol) if sol else 1\n    # Try recoloring i to best available color among 1..max_color+1\n    best_color = current_color\n    best_delta = math.inf\n    for c in range(1, max_color+2):\n        if c == current_color:\n            continue\n        delta = 0\n        for j in adj[i]:\n            if sol[j] == current_color:\n                delta -= 1\n            if sol[j] == c:\n                delta += 1\n        # Prefer reducing conflicts; tie-break by not increasing color count\n        color_increase = 1 if (c == max_color+1) else 0\n        score = (delta, color_increase)\n        if score < (best_delta, 1 if best_color == max_color+1 else 0):\n            best_delta = delta\n            best_color = c\n    new_sol = sol[:]\n    new_sol[i] = best_color\n    # Canonicalize after move\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2, \"SingleVertexRecolor\"\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Defensive copy and repair baseline\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Apply a sequence of random recolors and a Kempe-like swap\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 1 + 1)  # allow introducing new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        max_color = max(max_color, c)\n    # Kempe-like color swap between two colors on a connected component induced by those colors\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            # pick a seed vertex with color c1 or c2\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                # BFS on subgraph induced by colors c1 and c2\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                # swap c1 and c2 on this component\n                for u in component:\n                    new_sol[u] = c1 if new_sol[u] == c2 else (c2 if new_sol[u] == c1 else new_sol[u])\n    # Canonicalize\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001255336}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid baseline solution (repair if needed)\n    if not isinstance(solution, (list, tuple)):\n        # default trivial coloring 1..n\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Conflict count per vertex\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    # Choose a vertex: prioritize conflicting vertices, else random\n    conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n    if conflict_vertices:\n        i = random.choice(conflict_vertices)\n    else:\n        i = random.randrange(n)\n    current_color = sol[i]\n    max_color = max(sol) if sol else 1\n    # Try recoloring i to best available color among 1..max_color+1\n    best_color = current_color\n    best_delta = math.inf\n    for c in range(1, max_color+2):\n        if c == current_color:\n            continue\n        delta = 0\n        for j in adj[i]:\n            if sol[j] == current_color:\n                delta -= 1\n            if sol[j] == c:\n                delta += 1\n        # Prefer reducing conflicts; tie-break by not increasing color count\n        color_increase = 1 if (c == max_color+1) else 0\n        score = (delta, color_increase)\n        if score < (best_delta, 1 if best_color == max_color+1 else 0):\n            best_delta = delta\n            best_color = c\n    new_sol = sol[:]\n    new_sol[i] = best_color\n    # Canonicalize after move\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2, \"SingleVertexRecolor\"\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Defensive copy and repair baseline\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Apply a sequence of random recolors and a Kempe-like swap\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 1 + 1)  # allow introducing new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        max_color = max(max_color, c)\n    # Kempe-like color swap between two colors on a connected component induced by those colors\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            # pick a seed vertex with color c1 or c2\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                # BFS on subgraph induced by colors c1 and c2\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                # swap c1 and c2 on this component\n                for u in component:\n                    new_sol[u] = c1 if new_sol[u] == c2 else (c2 if new_sol[u] == c1 else new_sol[u])\n    # Canonicalize\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001214904}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K by order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based in edges)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n\n# Optional orchestrator (SA) provided for completeness per TARGET_HEURISTIC_SA\n# Uses lexicographic acceptance (conflicts first, then K) with temperature on numeric proxy\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def conflicts_K(sol):\n        sol = canonicalize(sol)\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        conflicts = 0\n        for u,v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        K = len(set(sol))\n        return conflicts, K\n    # Defensive repair\n    if not isinstance(currentSolution, (list, tuple)) or len(currentSolution) != 9:\n        current = list(range(1, 10))\n    else:\n        current = [int(v) if isinstance(v, int) and v >= 1 else 1 for v in currentSolution]\n    current = canonicalize(current)\n    # Initialize best if needed\n    if best is None or best_score is None:\n        best = current[:]\n        best_score = evaluate_solution(best)\n    # SA loop (bounded)\n    iter_budget = 2000\n    for _ in range(iter_budget):\n        neighbour, _ = generate_neighbour(current)\n        cur_conf, cur_K = conflicts_K(current)\n        nb_conf, nb_K = conflicts_K(neighbour)\n        # Lexicographic improvement check\n        better = (nb_conf < cur_conf) or (nb_conf == cur_conf and nb_K < cur_K)\n        # Numeric delta for probabilistic acceptance\n        delta = evaluate_solution(neighbour) - evaluate_solution(current)\n        if better or (delta <= 0) or (random.random() < math.exp(-max(0, delta) \/ max(minTemp, temp))):\n            current = neighbour\n            # Update best if improved lexicographically\n            b_conf, b_K = conflicts_K(best)\n            if (nb_conf < b_conf) or (nb_conf == b_conf and nb_K < b_K):\n                best = neighbour\n                best_score = evaluate_solution(best)\n        temp = max(minTemp, temp * cooling_factor)\n        if temp <= minTemp and cur_conf == 0 and cur_K <= 4:\n            break\n    return {\n        'current': current,\n        'currentScore': evaluate_solution(current),\n        'best': best,\n        'bestScore': best_score,\n    }\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Conflict counts\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v)\/\/2\n    max_color = max(sol)\n    # Helper: drop empty color classes and canonicalize\n    def squeeze(arr):\n        counts = {}\n        for c in arr:\n            counts[c] = counts.get(c, 0) + 1\n        # Remove holes by relabeling\n        return canonicalize(arr)\n    # If conflicts exist: recolor a conflicting vertex with best delta\n    if total_conflicts > 0:\n        conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best_color = current_color\n        best_tuple = (10**9, 1, 1)  # (delta_conflicts, color_increase, color_index)\n        for c in range(1, max_color+2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            color_increase = 1 if c == max_color+1 else 0\n            cand = (delta, color_increase, c)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_color = c\n        new_sol = sol[:]\n        new_sol[i] = best_color\n        new_sol = squeeze(new_sol)\n        move = \"RecolorConflict\"\n        # Occasionally attempt a small Kempe swap to escape plateaus\n        if random.random() < 0.2 and max_color >= 2:\n            c1 = random.randrange(1, max_color+1)\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 5:\n                c2 = random.randrange(1, max_color+1)\n                tries += 1\n            if c2 != c1:\n                # pick seed with color c1 or c2\n                indices = [idx for idx,v in enumerate(new_sol) if v in (c1,c2)]\n                if indices:\n                    seed = random.choice(indices)\n                    queue = [seed]\n                    seen = {seed}\n                    component = [seed]\n                    while queue:\n                        u = queue.pop(0)\n                        for w in adj[u]:\n                            if new_sol[w] in (c1,c2) and w not in seen:\n                                seen.add(w)\n                                queue.append(w)\n                                component.append(w)\n                    for u in component:\n                        if new_sol[u] == c1:\n                            new_sol[u] = c2\n                        elif new_sol[u] == c2:\n                            new_sol[u] = c1\n                    new_sol = squeeze(new_sol)\n                    move = \"KempeSwap\"\n        return new_sol, move\n    # If no conflicts: try to reduce K by moving a vertex from the highest color class\n    # without introducing new colors\n    highest = max_color\n    indices_high = [i for i,v in enumerate(sol) if v == highest]\n    if indices_high:\n        random.shuffle(indices_high)\n        for i in indices_high:\n            # try assign to one of the lower colors only\n            candidate_colors = list(range(1, highest))\n            random.shuffle(candidate_colors)\n            for c in candidate_colors:\n                ok = True\n                for j in adj[i]:\n                    if sol[j] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = sol[:]\n                    new_sol[i] = c\n                    # if highest color becomes empty, squeeze\n                    if all(v != highest for v in new_sol):\n                        new_sol = squeeze(new_sol)\n                    else:\n                        new_sol = canonicalize(new_sol)\n                    return new_sol, \"ReduceK-Recolor\"\n    # If cannot reduce, perform a harmless color-class swap to diversify (keeps K)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        new_sol = sol[:]\n        for i,v in enumerate(new_sol):\n            if v == c1:\n                new_sol[i] = c2\n            elif v == c2:\n                new_sol[i] = c1\n        new_sol = canonicalize(new_sol)\n        return new_sol, \"ColorClassSwap\"\n    # Fallback: random recolor without increasing K\n    i = random.randrange(n)\n    c = random.randrange(1, max_color+1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Kick 1: recolor k random vertices; allow temporary new color\n    k = 3\n    for _ in range(k):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 2)  # may introduce a new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        if c > max_color:\n            max_color = c\n    # Kick 2: Kempe-chain swap on random color pair within a BFS component\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                for u in component:\n                    if new_sol[u] == c1:\n                        new_sol[u] = c2\n                    elif new_sol[u] == c2:\n                        new_sol[u] = c1\n    # Canonicalize result to drop empty classes\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","Resultados":[[1,2,3,2,4,1,1,1,2],4,[1,2,3,2,4,1,1,1,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002638627}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K by order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based in edges)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n\n# Optional orchestrator (SA) provided for completeness per TARGET_HEURISTIC_SA\n# Uses lexicographic acceptance (conflicts first, then K) with temperature on numeric proxy\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def conflicts_K(sol):\n        sol = canonicalize(sol)\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        conflicts = 0\n        for u,v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        K = len(set(sol))\n        return conflicts, K\n    # Defensive repair\n    if not isinstance(currentSolution, (list, tuple)) or len(currentSolution) != 9:\n        current = list(range(1, 10))\n    else:\n        current = [int(v) if isinstance(v, int) and v >= 1 else 1 for v in currentSolution]\n    current = canonicalize(current)\n    # Initialize best if needed\n    if best is None or best_score is None:\n        best = current[:]\n        best_score = evaluate_solution(best)\n    # SA loop (bounded)\n    iter_budget = 2000\n    for _ in range(iter_budget):\n        neighbour, _ = generate_neighbour(current)\n        cur_conf, cur_K = conflicts_K(current)\n        nb_conf, nb_K = conflicts_K(neighbour)\n        # Lexicographic improvement check\n        better = (nb_conf < cur_conf) or (nb_conf == cur_conf and nb_K < cur_K)\n        # Numeric delta for probabilistic acceptance\n        delta = evaluate_solution(neighbour) - evaluate_solution(current)\n        if better or (delta <= 0) or (random.random() < math.exp(-max(0, delta) \/ max(minTemp, temp))):\n            current = neighbour\n            # Update best if improved lexicographically\n            b_conf, b_K = conflicts_K(best)\n            if (nb_conf < b_conf) or (nb_conf == b_conf and nb_K < b_K):\n                best = neighbour\n                best_score = evaluate_solution(best)\n        temp = max(minTemp, temp * cooling_factor)\n        if temp <= minTemp and cur_conf == 0 and cur_K <= 4:\n            break\n    return {\n        'current': current,\n        'currentScore': evaluate_solution(current),\n        'best': best,\n        'bestScore': best_score,\n    }\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Conflict counts\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v)\/\/2\n    max_color = max(sol)\n    # Helper: drop empty color classes and canonicalize\n    def squeeze(arr):\n        counts = {}\n        for c in arr:\n            counts[c] = counts.get(c, 0) + 1\n        # Remove holes by relabeling\n        return canonicalize(arr)\n    # If conflicts exist: recolor a conflicting vertex with best delta\n    if total_conflicts > 0:\n        conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best_color = current_color\n        best_tuple = (10**9, 1, 1)  # (delta_conflicts, color_increase, color_index)\n        for c in range(1, max_color+2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            color_increase = 1 if c == max_color+1 else 0\n            cand = (delta, color_increase, c)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_color = c\n        new_sol = sol[:]\n        new_sol[i] = best_color\n        new_sol = squeeze(new_sol)\n        move = \"RecolorConflict\"\n        # Occasionally attempt a small Kempe swap to escape plateaus\n        if random.random() < 0.2 and max_color >= 2:\n            c1 = random.randrange(1, max_color+1)\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 5:\n                c2 = random.randrange(1, max_color+1)\n                tries += 1\n            if c2 != c1:\n                # pick seed with color c1 or c2\n                indices = [idx for idx,v in enumerate(new_sol) if v in (c1,c2)]\n                if indices:\n                    seed = random.choice(indices)\n                    queue = [seed]\n                    seen = {seed}\n                    component = [seed]\n                    while queue:\n                        u = queue.pop(0)\n                        for w in adj[u]:\n                            if new_sol[w] in (c1,c2) and w not in seen:\n                                seen.add(w)\n                                queue.append(w)\n                                component.append(w)\n                    for u in component:\n                        if new_sol[u] == c1:\n                            new_sol[u] = c2\n                        elif new_sol[u] == c2:\n                            new_sol[u] = c1\n                    new_sol = squeeze(new_sol)\n                    move = \"KempeSwap\"\n        return new_sol, move\n    # If no conflicts: try to reduce K by moving a vertex from the highest color class\n    # without introducing new colors\n    highest = max_color\n    indices_high = [i for i,v in enumerate(sol) if v == highest]\n    if indices_high:\n        random.shuffle(indices_high)\n        for i in indices_high:\n            # try assign to one of the lower colors only\n            candidate_colors = list(range(1, highest))\n            random.shuffle(candidate_colors)\n            for c in candidate_colors:\n                ok = True\n                for j in adj[i]:\n                    if sol[j] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = sol[:]\n                    new_sol[i] = c\n                    # if highest color becomes empty, squeeze\n                    if all(v != highest for v in new_sol):\n                        new_sol = squeeze(new_sol)\n                    else:\n                        new_sol = canonicalize(new_sol)\n                    return new_sol, \"ReduceK-Recolor\"\n    # If cannot reduce, perform a harmless color-class swap to diversify (keeps K)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        new_sol = sol[:]\n        for i,v in enumerate(new_sol):\n            if v == c1:\n                new_sol[i] = c2\n            elif v == c2:\n                new_sol[i] = c1\n        new_sol = canonicalize(new_sol)\n        return new_sol, \"ColorClassSwap\"\n    # Fallback: random recolor without increasing K\n    i = random.randrange(n)\n    c = random.randrange(1, max_color+1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Kick 1: recolor k random vertices; allow temporary new color\n    k = 3\n    for _ in range(k):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 2)  # may introduce a new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        if c > max_color:\n            max_color = c\n    # Kick 2: Kempe-chain swap on random color pair within a BFS component\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                for u in component:\n                    if new_sol[u] == c1:\n                        new_sol[u] = c2\n                    elif new_sol[u] == c2:\n                        new_sol[u] = c1\n    # Canonicalize result to drop empty classes\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","Resultados":[[1,2,3,2,4,3,3,2,5],4,[1,2,3,2,4,1,1,1,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002641648}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K by order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based in edges)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n\n# Optional orchestrator (SA) provided for completeness per TARGET_HEURISTIC_SA\n# Uses lexicographic acceptance (conflicts first, then K) with temperature on numeric proxy\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def conflicts_K(sol):\n        sol = canonicalize(sol)\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        conflicts = 0\n        for u,v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        K = len(set(sol))\n        return conflicts, K\n    # Defensive repair\n    if not isinstance(currentSolution, (list, tuple)) or len(currentSolution) != 9:\n        current = list(range(1, 10))\n    else:\n        current = [int(v) if isinstance(v, int) and v >= 1 else 1 for v in currentSolution]\n    current = canonicalize(current)\n    # Initialize best if needed\n    if best is None or best_score is None:\n        best = current[:]\n        best_score = evaluate_solution(best)\n    # SA loop (bounded)\n    iter_budget = 2000\n    for _ in range(iter_budget):\n        neighbour, _ = generate_neighbour(current)\n        cur_conf, cur_K = conflicts_K(current)\n        nb_conf, nb_K = conflicts_K(neighbour)\n        # Lexicographic improvement check\n        better = (nb_conf < cur_conf) or (nb_conf == cur_conf and nb_K < cur_K)\n        # Numeric delta for probabilistic acceptance\n        delta = evaluate_solution(neighbour) - evaluate_solution(current)\n        if better or (delta <= 0) or (random.random() < math.exp(-max(0, delta) \/ max(minTemp, temp))):\n            current = neighbour\n            # Update best if improved lexicographically\n            b_conf, b_K = conflicts_K(best)\n            if (nb_conf < b_conf) or (nb_conf == b_conf and nb_K < b_K):\n                best = neighbour\n                best_score = evaluate_solution(best)\n        temp = max(minTemp, temp * cooling_factor)\n        if temp <= minTemp and cur_conf == 0 and cur_K <= 4:\n            break\n    return {\n        'current': current,\n        'currentScore': evaluate_solution(current),\n        'best': best,\n        'bestScore': best_score,\n    }\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Conflict counts\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v)\/\/2\n    max_color = max(sol)\n    # Helper: drop empty color classes and canonicalize\n    def squeeze(arr):\n        counts = {}\n        for c in arr:\n            counts[c] = counts.get(c, 0) + 1\n        # Remove holes by relabeling\n        return canonicalize(arr)\n    # If conflicts exist: recolor a conflicting vertex with best delta\n    if total_conflicts > 0:\n        conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best_color = current_color\n        best_tuple = (10**9, 1, 1)  # (delta_conflicts, color_increase, color_index)\n        for c in range(1, max_color+2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            color_increase = 1 if c == max_color+1 else 0\n            cand = (delta, color_increase, c)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_color = c\n        new_sol = sol[:]\n        new_sol[i] = best_color\n        new_sol = squeeze(new_sol)\n        move = \"RecolorConflict\"\n        # Occasionally attempt a small Kempe swap to escape plateaus\n        if random.random() < 0.2 and max_color >= 2:\n            c1 = random.randrange(1, max_color+1)\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 5:\n                c2 = random.randrange(1, max_color+1)\n                tries += 1\n            if c2 != c1:\n                # pick seed with color c1 or c2\n                indices = [idx for idx,v in enumerate(new_sol) if v in (c1,c2)]\n                if indices:\n                    seed = random.choice(indices)\n                    queue = [seed]\n                    seen = {seed}\n                    component = [seed]\n                    while queue:\n                        u = queue.pop(0)\n                        for w in adj[u]:\n                            if new_sol[w] in (c1,c2) and w not in seen:\n                                seen.add(w)\n                                queue.append(w)\n                                component.append(w)\n                    for u in component:\n                        if new_sol[u] == c1:\n                            new_sol[u] = c2\n                        elif new_sol[u] == c2:\n                            new_sol[u] = c1\n                    new_sol = squeeze(new_sol)\n                    move = \"KempeSwap\"\n        return new_sol, move\n    # If no conflicts: try to reduce K by moving a vertex from the highest color class\n    # without introducing new colors\n    highest = max_color\n    indices_high = [i for i,v in enumerate(sol) if v == highest]\n    if indices_high:\n        random.shuffle(indices_high)\n        for i in indices_high:\n            # try assign to one of the lower colors only\n            candidate_colors = list(range(1, highest))\n            random.shuffle(candidate_colors)\n            for c in candidate_colors:\n                ok = True\n                for j in adj[i]:\n                    if sol[j] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = sol[:]\n                    new_sol[i] = c\n                    # if highest color becomes empty, squeeze\n                    if all(v != highest for v in new_sol):\n                        new_sol = squeeze(new_sol)\n                    else:\n                        new_sol = canonicalize(new_sol)\n                    return new_sol, \"ReduceK-Recolor\"\n    # If cannot reduce, perform a harmless color-class swap to diversify (keeps K)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        new_sol = sol[:]\n        for i,v in enumerate(new_sol):\n            if v == c1:\n                new_sol[i] = c2\n            elif v == c2:\n                new_sol[i] = c1\n        new_sol = canonicalize(new_sol)\n        return new_sol, \"ColorClassSwap\"\n    # Fallback: random recolor without increasing K\n    i = random.randrange(n)\n    c = random.randrange(1, max_color+1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Kick 1: recolor k random vertices; allow temporary new color\n    k = 3\n    for _ in range(k):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 2)  # may introduce a new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        if c > max_color:\n            max_color = c\n    # Kick 2: Kempe-chain swap on random color pair within a BFS component\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                for u in component:\n                    if new_sol[u] == c1:\n                        new_sol[u] = c2\n                    elif new_sol[u] == c2:\n                        new_sol[u] = c1\n    # Canonicalize result to drop empty classes\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001634463}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    # Conflict computation helpers\n    def conflicts_of(arr):\n        c = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Conflicts per vertex\n    conflicts_per_v = [0] * n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    max_color = max(sol)\n    # Helper to remove gaps in color labels\n    def squeeze(arr):\n        return canonicalize(arr)\n    # Operator 1: If conflicts exist, recolor a conflicting vertex with best improvement (no worse; cap K growth)\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best = sol[:]\n        best_tuple = (10**9, 1, 10**9)  # (delta_conflicts, color_increase, color_index)\n        base_conf = conflicts_per_v[i]\n        # Build neighbor color set (including current K; optionally K+1 only if strictly reduces conflicts)\n        for c in range(1, max_color + 2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            # Accept only non-worsening; allow new color only if strictly improves\n            color_increase = 1 if c == max_color + 1 else 0\n            if color_increase == 1 and delta >= 0:\n                continue\n            cand_tuple = (delta, color_increase, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_i_color = c\n        new_sol = sol[:]\n        if best_tuple[0] == 10**9:\n            # fallback: pick a different existing color randomly\n            choices = [c for c in range(1, max_color + 1) if c != current_color]\n            if choices:\n                best_i_color = random.choice(choices)\n            else:\n                best_i_color = current_color\n        new_sol[i] = best_i_color\n        new_sol = squeeze(new_sol)\n        # Guarded small Kempe swap (only if not worsening conflicts)\n        if random.random() < 0.25 and max(new_sol) >= 2:\n            c1 = new_sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 6:\n                c2 = random.randrange(1, max(new_sol) + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by colors c1, c2 starting at i\n                queue = [i]\n                seen = {i}\n                component = [i]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                trial = new_sol[:]\n                for u in component:\n                    trial[u] = c2 if new_sol[u] == c1 else (c1 if new_sol[u] == c2 else trial[u])\n                trial = squeeze(trial)\n                if conflicts_of(trial) <= conflicts_of(new_sol):\n                    return trial, \"KempeSwap\"\n        return new_sol, \"RecolorConflict\"\n    # Operator 2: K reduction attempt by moving vertices from highest color without conflicts\n    highest = max_color\n    indices_high = [i for i, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for i in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for j in adj[i]:\n                if sol[j] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[i] = c\n                new_sol = squeeze(new_sol)\n                return new_sol, \"ReduceK-Recolor\"\n    # Operator 3: Merge smallest color class into others if feasible\n    counts = {}\n    for v in sol:\n        counts[v] = counts.get(v, 0) + 1\n    smallest_color = min(counts, key=lambda c: counts[c]) if counts else 1\n    verts = [i for i, v in enumerate(sol) if v == smallest_color]\n    target_colors = [c for c in range(1, max_color + 1) if c != smallest_color]\n    random.shuffle(target_colors)\n    def can_assign_all(color):\n        for i in verts:\n            for j in adj[i]:\n                if sol[j] == color:\n                    return False\n        return True\n    for c in target_colors:\n        if can_assign_all(c):\n            new_sol = sol[:]\n            for i in verts:\n                new_sol[i] = c\n            new_sol = squeeze(new_sol)\n            return new_sol, \"MergeClasses\"\n    # Operator 4: Random localized Kempe chain for diversification (keeps K; guarded)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 6:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        # pick random seed with color c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if idxs:\n            seed = random.choice(idxs)\n            queue = [seed]\n            seen = {seed}\n            component = [seed]\n            while queue:\n                u = queue.pop(0)\n                for w in adj[u]:\n                    if sol[w] in (c1, c2) and w not in seen:\n                        seen.add(w)\n                        queue.append(w)\n                        component.append(w)\n            trial = sol[:]\n            for u in component:\n                trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n            trial = canonicalize(trial)\n            return trial, \"RandomKempeChain\"\n    # Fallback: random recolor within existing colors\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Kick 1: recolor a small random subset, allowing at most one extra color if it strictly reduces local conflicts\n    k = 3\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:k]\n    def local_conflicts(idx, arr):\n        c = 0\n        for j in adj[idx]:\n            if arr[j] == arr[idx]:\n                c += 1\n        return c\n    for i in indices:\n        base_c = local_conflicts(i, sol)\n        candidate_colors = list(range(1, max_color + 2))\n        random.shuffle(candidate_colors)\n        best = sol[i]\n        best_delta = 0\n        for c in candidate_colors:\n            if c == sol[i]:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == sol[i]:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            inc = 1 if c == max_color + 1 else 0\n            if inc == 1 and delta >= 0:\n                continue\n            if delta < best_delta or (delta == best_delta and inc == 0):\n                best_delta = delta\n                best = c\n        sol[i] = best\n        if best > max_color:\n            max_color = best\n    # Kick 2: One or two guarded Kempe-chain swaps for diversification\n    swaps = 2\n    for _ in range(swaps):\n        if max_color < 2:\n            break\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices colored c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not idxs:\n            continue\n        seed = random.choice(idxs)\n        queue = [seed]\n        seen = {seed}\n        component = [seed]\n        while queue:\n            u = queue.pop(0)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    queue.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        # accept non-worsening in terms of conflicts; tolerate small temporary K changes but canonicalize after\n        def conflicts_of(arr):\n            c = 0\n            for (u, v) in edges:\n                if arr[u-1] == arr[v-1]:\n                    c += 1\n            return c\n        if conflicts_of(trial) <= conflicts_of(sol):\n            sol = trial\n            max_color = max(sol)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,3,2,4,3,1,1,2],4,[1,2,3,2,4,1,1,1,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002770728}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    # Conflict computation helpers\n    def conflicts_of(arr):\n        c = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Conflicts per vertex\n    conflicts_per_v = [0] * n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    max_color = max(sol)\n    # Helper to remove gaps in color labels\n    def squeeze(arr):\n        return canonicalize(arr)\n    # Operator 1: If conflicts exist, recolor a conflicting vertex with best improvement (no worse; cap K growth)\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best = sol[:]\n        best_tuple = (10**9, 1, 10**9)  # (delta_conflicts, color_increase, color_index)\n        base_conf = conflicts_per_v[i]\n        # Build neighbor color set (including current K; optionally K+1 only if strictly reduces conflicts)\n        for c in range(1, max_color + 2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            # Accept only non-worsening; allow new color only if strictly improves\n            color_increase = 1 if c == max_color + 1 else 0\n            if color_increase == 1 and delta >= 0:\n                continue\n            cand_tuple = (delta, color_increase, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_i_color = c\n        new_sol = sol[:]\n        if best_tuple[0] == 10**9:\n            # fallback: pick a different existing color randomly\n            choices = [c for c in range(1, max_color + 1) if c != current_color]\n            if choices:\n                best_i_color = random.choice(choices)\n            else:\n                best_i_color = current_color\n        new_sol[i] = best_i_color\n        new_sol = squeeze(new_sol)\n        # Guarded small Kempe swap (only if not worsening conflicts)\n        if random.random() < 0.25 and max(new_sol) >= 2:\n            c1 = new_sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 6:\n                c2 = random.randrange(1, max(new_sol) + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by colors c1, c2 starting at i\n                queue = [i]\n                seen = {i}\n                component = [i]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                trial = new_sol[:]\n                for u in component:\n                    trial[u] = c2 if new_sol[u] == c1 else (c1 if new_sol[u] == c2 else trial[u])\n                trial = squeeze(trial)\n                if conflicts_of(trial) <= conflicts_of(new_sol):\n                    return trial, \"KempeSwap\"\n        return new_sol, \"RecolorConflict\"\n    # Operator 2: K reduction attempt by moving vertices from highest color without conflicts\n    highest = max_color\n    indices_high = [i for i, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for i in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for j in adj[i]:\n                if sol[j] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[i] = c\n                new_sol = squeeze(new_sol)\n                return new_sol, \"ReduceK-Recolor\"\n    # Operator 3: Merge smallest color class into others if feasible\n    counts = {}\n    for v in sol:\n        counts[v] = counts.get(v, 0) + 1\n    smallest_color = min(counts, key=lambda c: counts[c]) if counts else 1\n    verts = [i for i, v in enumerate(sol) if v == smallest_color]\n    target_colors = [c for c in range(1, max_color + 1) if c != smallest_color]\n    random.shuffle(target_colors)\n    def can_assign_all(color):\n        for i in verts:\n            for j in adj[i]:\n                if sol[j] == color:\n                    return False\n        return True\n    for c in target_colors:\n        if can_assign_all(c):\n            new_sol = sol[:]\n            for i in verts:\n                new_sol[i] = c\n            new_sol = squeeze(new_sol)\n            return new_sol, \"MergeClasses\"\n    # Operator 4: Random localized Kempe chain for diversification (keeps K; guarded)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 6:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        # pick random seed with color c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if idxs:\n            seed = random.choice(idxs)\n            queue = [seed]\n            seen = {seed}\n            component = [seed]\n            while queue:\n                u = queue.pop(0)\n                for w in adj[u]:\n                    if sol[w] in (c1, c2) and w not in seen:\n                        seen.add(w)\n                        queue.append(w)\n                        component.append(w)\n            trial = sol[:]\n            for u in component:\n                trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n            trial = canonicalize(trial)\n            return trial, \"RandomKempeChain\"\n    # Fallback: random recolor within existing colors\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Kick 1: recolor a small random subset, allowing at most one extra color if it strictly reduces local conflicts\n    k = 3\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:k]\n    def local_conflicts(idx, arr):\n        c = 0\n        for j in adj[idx]:\n            if arr[j] == arr[idx]:\n                c += 1\n        return c\n    for i in indices:\n        base_c = local_conflicts(i, sol)\n        candidate_colors = list(range(1, max_color + 2))\n        random.shuffle(candidate_colors)\n        best = sol[i]\n        best_delta = 0\n        for c in candidate_colors:\n            if c == sol[i]:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == sol[i]:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            inc = 1 if c == max_color + 1 else 0\n            if inc == 1 and delta >= 0:\n                continue\n            if delta < best_delta or (delta == best_delta and inc == 0):\n                best_delta = delta\n                best = c\n        sol[i] = best\n        if best > max_color:\n            max_color = best\n    # Kick 2: One or two guarded Kempe-chain swaps for diversification\n    swaps = 2\n    for _ in range(swaps):\n        if max_color < 2:\n            break\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices colored c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not idxs:\n            continue\n        seed = random.choice(idxs)\n        queue = [seed]\n        seen = {seed}\n        component = [seed]\n        while queue:\n            u = queue.pop(0)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    queue.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        # accept non-worsening in terms of conflicts; tolerate small temporary K changes but canonicalize after\n        def conflicts_of(arr):\n            c = 0\n            for (u, v) in edges:\n                if arr[u-1] == arr[v-1]:\n                    c += 1\n            return c\n        if conflicts_of(trial) <= conflicts_of(sol):\n            sol = trial\n            max_color = max(sol)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,3,2,4,3,1,1,2],4,[1,2,3,2,4,1,1,1,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003792071}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    # Conflict computation helpers\n    def conflicts_of(arr):\n        c = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Conflicts per vertex\n    conflicts_per_v = [0] * n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    max_color = max(sol)\n    # Helper to remove gaps in color labels\n    def squeeze(arr):\n        return canonicalize(arr)\n    # Operator 1: If conflicts exist, recolor a conflicting vertex with best improvement (no worse; cap K growth)\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best = sol[:]\n        best_tuple = (10**9, 1, 10**9)  # (delta_conflicts, color_increase, color_index)\n        base_conf = conflicts_per_v[i]\n        # Build neighbor color set (including current K; optionally K+1 only if strictly reduces conflicts)\n        for c in range(1, max_color + 2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            # Accept only non-worsening; allow new color only if strictly improves\n            color_increase = 1 if c == max_color + 1 else 0\n            if color_increase == 1 and delta >= 0:\n                continue\n            cand_tuple = (delta, color_increase, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_i_color = c\n        new_sol = sol[:]\n        if best_tuple[0] == 10**9:\n            # fallback: pick a different existing color randomly\n            choices = [c for c in range(1, max_color + 1) if c != current_color]\n            if choices:\n                best_i_color = random.choice(choices)\n            else:\n                best_i_color = current_color\n        new_sol[i] = best_i_color\n        new_sol = squeeze(new_sol)\n        # Guarded small Kempe swap (only if not worsening conflicts)\n        if random.random() < 0.25 and max(new_sol) >= 2:\n            c1 = new_sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 6:\n                c2 = random.randrange(1, max(new_sol) + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by colors c1, c2 starting at i\n                queue = [i]\n                seen = {i}\n                component = [i]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                trial = new_sol[:]\n                for u in component:\n                    trial[u] = c2 if new_sol[u] == c1 else (c1 if new_sol[u] == c2 else trial[u])\n                trial = squeeze(trial)\n                if conflicts_of(trial) <= conflicts_of(new_sol):\n                    return trial, \"KempeSwap\"\n        return new_sol, \"RecolorConflict\"\n    # Operator 2: K reduction attempt by moving vertices from highest color without conflicts\n    highest = max_color\n    indices_high = [i for i, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for i in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for j in adj[i]:\n                if sol[j] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[i] = c\n                new_sol = squeeze(new_sol)\n                return new_sol, \"ReduceK-Recolor\"\n    # Operator 3: Merge smallest color class into others if feasible\n    counts = {}\n    for v in sol:\n        counts[v] = counts.get(v, 0) + 1\n    smallest_color = min(counts, key=lambda c: counts[c]) if counts else 1\n    verts = [i for i, v in enumerate(sol) if v == smallest_color]\n    target_colors = [c for c in range(1, max_color + 1) if c != smallest_color]\n    random.shuffle(target_colors)\n    def can_assign_all(color):\n        for i in verts:\n            for j in adj[i]:\n                if sol[j] == color:\n                    return False\n        return True\n    for c in target_colors:\n        if can_assign_all(c):\n            new_sol = sol[:]\n            for i in verts:\n                new_sol[i] = c\n            new_sol = squeeze(new_sol)\n            return new_sol, \"MergeClasses\"\n    # Operator 4: Random localized Kempe chain for diversification (keeps K; guarded)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 6:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        # pick random seed with color c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if idxs:\n            seed = random.choice(idxs)\n            queue = [seed]\n            seen = {seed}\n            component = [seed]\n            while queue:\n                u = queue.pop(0)\n                for w in adj[u]:\n                    if sol[w] in (c1, c2) and w not in seen:\n                        seen.add(w)\n                        queue.append(w)\n                        component.append(w)\n            trial = sol[:]\n            for u in component:\n                trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n            trial = canonicalize(trial)\n            return trial, \"RandomKempeChain\"\n    # Fallback: random recolor within existing colors\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Kick 1: recolor a small random subset, allowing at most one extra color if it strictly reduces local conflicts\n    k = 3\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:k]\n    def local_conflicts(idx, arr):\n        c = 0\n        for j in adj[idx]:\n            if arr[j] == arr[idx]:\n                c += 1\n        return c\n    for i in indices:\n        base_c = local_conflicts(i, sol)\n        candidate_colors = list(range(1, max_color + 2))\n        random.shuffle(candidate_colors)\n        best = sol[i]\n        best_delta = 0\n        for c in candidate_colors:\n            if c == sol[i]:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == sol[i]:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            inc = 1 if c == max_color + 1 else 0\n            if inc == 1 and delta >= 0:\n                continue\n            if delta < best_delta or (delta == best_delta and inc == 0):\n                best_delta = delta\n                best = c\n        sol[i] = best\n        if best > max_color:\n            max_color = best\n    # Kick 2: One or two guarded Kempe-chain swaps for diversification\n    swaps = 2\n    for _ in range(swaps):\n        if max_color < 2:\n            break\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices colored c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not idxs:\n            continue\n        seed = random.choice(idxs)\n        queue = [seed]\n        seen = {seed}\n        component = [seed]\n        while queue:\n            u = queue.pop(0)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    queue.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        # accept non-worsening in terms of conflicts; tolerate small temporary K changes but canonicalize after\n        def conflicts_of(arr):\n            c = 0\n            for (u, v) in edges:\n                if arr[u-1] == arr[v-1]:\n                    c += 1\n            return c\n        if conflicts_of(trial) <= conflicts_of(sol):\n            sol = trial\n            max_color = max(sol)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002004008}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Build conflicts per vertex\n    conflicts_per_v = [0] * n\n    for (u, v) in edges:\n        cu = sol[u-1]; cv = sol[v-1]\n        if cu == cv:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    # If conflicts exist, try to recolor a conflicting vertex within existing colors\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current = sol[i]\n        best_color = current\n        best_conf = total_conflicts\n        for c in range(1, max_color + 1):\n            if c == current:\n                continue\n            trial = sol[:]\n            trial[i] = c\n            cval = conflicts_of(trial, edges)\n            if cval < best_conf:\n                best_conf = cval\n                best_color = c\n        if best_color != current:\n            sol2 = sol[:]\n            sol2[i] = best_color\n            sol2 = canonicalize(sol2)\n            return sol2, \"RecolorConflict\"\n        # Guarded Kempe chain swap (does not worsen conflicts)\n        if max_color >= 2:\n            c1 = sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 8:\n                c2 = random.randrange(1, max_color + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by c1,c2 from i\n                q = deque([i])\n                seen = {i}\n                component = [i]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) <= total_conflicts:\n                    trial = canonicalize(trial)\n                    return trial, \"KempeSwap\"\n        # Fallback random recolor within existing palette\n        c = random.randrange(1, max_color + 1)\n        j = i\n        sol3 = sol[:]\n        sol3[j] = c\n        sol3 = canonicalize(sol3)\n        return sol3, \"RandomRecolorConflict\"\n    # No conflicts: try reducing K by moving vertices from highest color downwards\n    highest = max_color\n    indices_high = [idx for idx, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for idx in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    ok = False\n                    break\n            if ok:\n                trial = sol[:]\n                trial[idx] = c\n                # Now squeeze labels to possibly remove the highest color\n                trial = canonicalize(trial)\n                return trial, \"ReduceK-Recolor\"\n    # If K-reduction not possible, diversify with a guarded Kempe swap that keeps conflicts at 0\n    if max_color >= 2:\n        colors = list(range(1, max_color + 1))\n        c1 = random.choice(colors)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.choice(colors)\n            tries += 1\n        if c2 != c1:\n            # pick seed from vertices colored c1 or c2\n            candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                q = deque([seed])\n                seen = {seed}\n                component = [seed]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) == 0:\n                    trial = canonicalize(trial)\n                    return trial, \"DiversifyKempe\"\n    # Final fallback: random recolor within existing colors (should keep feasibility in most cases)\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    trial = sol[:]\n    trial[i] = c\n    trial = canonicalize(trial)\n    return trial, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    K = max(sol)\n    # Kick 1: recolor k random vertices using only existing colors, aiming not to increase conflicts\n    k = 3\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:k]\n    for i in idxs:\n        current = sol[i]\n        best = current\n        base_conf = 0\n        for nb in adj[i]:\n            if sol[nb] == current:\n                base_conf += 1\n        best_delta = 0\n        cand_colors = list(range(1, K + 1))\n        random.shuffle(cand_colors)\n        for c in cand_colors:\n            if c == current:\n                continue\n            delta = 0\n            for nb in adj[i]:\n                if sol[nb] == current:\n                    delta -= 1\n                if sol[nb] == c:\n                    delta += 1\n            if delta < best_delta:\n                best_delta = delta\n                best = c\n        sol[i] = best\n    # Kick 2: up to 2 guarded Kempe-chain swaps that do not worsen total conflicts\n    total_c = conflicts_of(sol, edges)\n    swaps = 2\n    for _ in range(swaps):\n        if K < 2:\n            break\n        c1 = random.randrange(1, K + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, K + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices with color c1 or c2\n        candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not candidates:\n            continue\n        seed = random.choice(candidates)\n        # BFS component in (c1,c2)\n        from collections import deque as _dq\n        q = _dq([seed])\n        seen = {seed}\n        component = [seed]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    q.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        if conflicts_of(trial, edges) <= total_c:\n            sol = trial\n            total_c = conflicts_of(sol, edges)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002463003}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Build conflicts per vertex\n    conflicts_per_v = [0] * n\n    for (u, v) in edges:\n        cu = sol[u-1]; cv = sol[v-1]\n        if cu == cv:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    # If conflicts exist, try to recolor a conflicting vertex within existing colors\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current = sol[i]\n        best_color = current\n        best_conf = total_conflicts\n        for c in range(1, max_color + 1):\n            if c == current:\n                continue\n            trial = sol[:]\n            trial[i] = c\n            cval = conflicts_of(trial, edges)\n            if cval < best_conf:\n                best_conf = cval\n                best_color = c\n        if best_color != current:\n            sol2 = sol[:]\n            sol2[i] = best_color\n            sol2 = canonicalize(sol2)\n            return sol2, \"RecolorConflict\"\n        # Guarded Kempe chain swap (does not worsen conflicts)\n        if max_color >= 2:\n            c1 = sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 8:\n                c2 = random.randrange(1, max_color + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by c1,c2 from i\n                q = deque([i])\n                seen = {i}\n                component = [i]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) <= total_conflicts:\n                    trial = canonicalize(trial)\n                    return trial, \"KempeSwap\"\n        # Fallback random recolor within existing palette\n        c = random.randrange(1, max_color + 1)\n        j = i\n        sol3 = sol[:]\n        sol3[j] = c\n        sol3 = canonicalize(sol3)\n        return sol3, \"RandomRecolorConflict\"\n    # No conflicts: try reducing K by moving vertices from highest color downwards\n    highest = max_color\n    indices_high = [idx for idx, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for idx in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    ok = False\n                    break\n            if ok:\n                trial = sol[:]\n                trial[idx] = c\n                # Now squeeze labels to possibly remove the highest color\n                trial = canonicalize(trial)\n                return trial, \"ReduceK-Recolor\"\n    # If K-reduction not possible, diversify with a guarded Kempe swap that keeps conflicts at 0\n    if max_color >= 2:\n        colors = list(range(1, max_color + 1))\n        c1 = random.choice(colors)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.choice(colors)\n            tries += 1\n        if c2 != c1:\n            # pick seed from vertices colored c1 or c2\n            candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                q = deque([seed])\n                seen = {seed}\n                component = [seed]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) == 0:\n                    trial = canonicalize(trial)\n                    return trial, \"DiversifyKempe\"\n    # Final fallback: random recolor within existing colors (should keep feasibility in most cases)\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    trial = sol[:]\n    trial[i] = c\n    trial = canonicalize(trial)\n    return trial, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    K = max(sol)\n    # Kick 1: recolor k random vertices using only existing colors, aiming not to increase conflicts\n    k = 3\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:k]\n    for i in idxs:\n        current = sol[i]\n        best = current\n        base_conf = 0\n        for nb in adj[i]:\n            if sol[nb] == current:\n                base_conf += 1\n        best_delta = 0\n        cand_colors = list(range(1, K + 1))\n        random.shuffle(cand_colors)\n        for c in cand_colors:\n            if c == current:\n                continue\n            delta = 0\n            for nb in adj[i]:\n                if sol[nb] == current:\n                    delta -= 1\n                if sol[nb] == c:\n                    delta += 1\n            if delta < best_delta:\n                best_delta = delta\n                best = c\n        sol[i] = best\n    # Kick 2: up to 2 guarded Kempe-chain swaps that do not worsen total conflicts\n    total_c = conflicts_of(sol, edges)\n    swaps = 2\n    for _ in range(swaps):\n        if K < 2:\n            break\n        c1 = random.randrange(1, K + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, K + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices with color c1 or c2\n        candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not candidates:\n            continue\n        seed = random.choice(candidates)\n        # BFS component in (c1,c2)\n        from collections import deque as _dq\n        q = _dq([seed])\n        seen = {seed}\n        component = [seed]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    q.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        if conflicts_of(trial, edges) <= total_c:\n            sol = trial\n            total_c = conflicts_of(sol, edges)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001974266}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Build conflicts per vertex\n    conflicts_per_v = [0] * n\n    for (u, v) in edges:\n        cu = sol[u-1]; cv = sol[v-1]\n        if cu == cv:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    # If conflicts exist, try to recolor a conflicting vertex within existing colors\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current = sol[i]\n        best_color = current\n        best_conf = total_conflicts\n        for c in range(1, max_color + 1):\n            if c == current:\n                continue\n            trial = sol[:]\n            trial[i] = c\n            cval = conflicts_of(trial, edges)\n            if cval < best_conf:\n                best_conf = cval\n                best_color = c\n        if best_color != current:\n            sol2 = sol[:]\n            sol2[i] = best_color\n            sol2 = canonicalize(sol2)\n            return sol2, \"RecolorConflict\"\n        # Guarded Kempe chain swap (does not worsen conflicts)\n        if max_color >= 2:\n            c1 = sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 8:\n                c2 = random.randrange(1, max_color + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by c1,c2 from i\n                q = deque([i])\n                seen = {i}\n                component = [i]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) <= total_conflicts:\n                    trial = canonicalize(trial)\n                    return trial, \"KempeSwap\"\n        # Fallback random recolor within existing palette\n        c = random.randrange(1, max_color + 1)\n        j = i\n        sol3 = sol[:]\n        sol3[j] = c\n        sol3 = canonicalize(sol3)\n        return sol3, \"RandomRecolorConflict\"\n    # No conflicts: try reducing K by moving vertices from highest color downwards\n    highest = max_color\n    indices_high = [idx for idx, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for idx in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    ok = False\n                    break\n            if ok:\n                trial = sol[:]\n                trial[idx] = c\n                # Now squeeze labels to possibly remove the highest color\n                trial = canonicalize(trial)\n                return trial, \"ReduceK-Recolor\"\n    # If K-reduction not possible, diversify with a guarded Kempe swap that keeps conflicts at 0\n    if max_color >= 2:\n        colors = list(range(1, max_color + 1))\n        c1 = random.choice(colors)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.choice(colors)\n            tries += 1\n        if c2 != c1:\n            # pick seed from vertices colored c1 or c2\n            candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                q = deque([seed])\n                seen = {seed}\n                component = [seed]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) == 0:\n                    trial = canonicalize(trial)\n                    return trial, \"DiversifyKempe\"\n    # Final fallback: random recolor within existing colors (should keep feasibility in most cases)\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    trial = sol[:]\n    trial[i] = c\n    trial = canonicalize(trial)\n    return trial, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    K = max(sol)\n    # Kick 1: recolor k random vertices using only existing colors, aiming not to increase conflicts\n    k = 3\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:k]\n    for i in idxs:\n        current = sol[i]\n        best = current\n        base_conf = 0\n        for nb in adj[i]:\n            if sol[nb] == current:\n                base_conf += 1\n        best_delta = 0\n        cand_colors = list(range(1, K + 1))\n        random.shuffle(cand_colors)\n        for c in cand_colors:\n            if c == current:\n                continue\n            delta = 0\n            for nb in adj[i]:\n                if sol[nb] == current:\n                    delta -= 1\n                if sol[nb] == c:\n                    delta += 1\n            if delta < best_delta:\n                best_delta = delta\n                best = c\n        sol[i] = best\n    # Kick 2: up to 2 guarded Kempe-chain swaps that do not worsen total conflicts\n    total_c = conflicts_of(sol, edges)\n    swaps = 2\n    for _ in range(swaps):\n        if K < 2:\n            break\n        c1 = random.randrange(1, K + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, K + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices with color c1 or c2\n        candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not candidates:\n            continue\n        seed = random.choice(candidates)\n        # BFS component in (c1,c2)\n        from collections import deque as _dq\n        q = _dq([seed])\n        seen = {seed}\n        component = [seed]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    q.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        if conflicts_of(trial, edges) <= total_c:\n            sol = trial\n            total_c = conflicts_of(sol, edges)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001825825}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS: solution is a Python list of length 9 with integers >=1, where index i-1 stores color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph edges (1-indexed)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    if conflicts == 0:\n        return max(solution)\n    penalty = 10**6\n    k = max(solution)\n    return penalty + conflicts * 1000 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    # 1-indexed to 9 vertices; store neighbors as 1-indexed\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef _feasible_colors(node: int, sol: List[int], max_try: int = 6) -> List[int]:\n    # node is 1-indexed\n    adj = _adjacency()\n    used = {sol[v-1] for v in adj[node]}\n    # allow colors from 1..max(sol)+1\n    maxc = max(sol) if sol else 1\n    candidates = [c for c in range(1, maxc+2) if c not in used]\n    if candidates:\n        return candidates\n    # Fallback (should not happen often): try random colors in 1..maxc+1\n    pool = list(range(1, maxc+2))\n    random.shuffle(pool)\n    return pool[:max_try]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([1]*9, \"invalid_input_reset\")\n    sol = _safe_copy_list(solution)\n    n = 9\n    move_kind = None\n    # Choose a random vertex\n    v = random.randint(1, n)\n    feas = _feasible_colors(v, sol)\n    # Prefer a color different from current\n    current = sol[v-1]\n    choices = [c for c in feas if c != current] or feas\n    new_color = random.choice(choices)\n    sol[v-1] = new_color\n    # Optionally normalize colors to compact range 1..k (relabeling)\n    # Build mapping to keep color ids dense, order by first appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    move_kind = f\"recolor_vertex_{v}\"\n    return (sol, move_kind)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolors and occasional color merge attempt\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    sol = _safe_copy_list(solution)\n    n = 9\n    k = max(sol)\n    steps = max(3, n \/\/ 3)\n    adj = _adjacency()\n    for _ in range(steps):\n        v = random.randint(1, n)\n        # colors allowed up to k+1\n        used = {sol[w-1] for w in adj[v]}\n        pool = [c for c in range(1, k+2) if c not in used]\n        if not pool:\n            pool = list(range(1, k+2))\n        newc = random.choice(pool)\n        sol[v-1] = newc\n        k = max(k, newc)\n    # Try a random color relabel merge with small probability\n    if random.random() < 0.5:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            c_from, c_to = random.sample(colors, 2)\n            sol = [c_to if x == c_from else x for x in sol]\n    # Normalize color labels to 1..m preserving order of appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001240537}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS: solution is a Python list of length 9 with integers >=1, where index i-1 stores color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph edges (1-indexed)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    if conflicts == 0:\n        return max(solution)\n    penalty = 10**6\n    k = max(solution)\n    return penalty + conflicts * 1000 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    # 1-indexed to 9 vertices; store neighbors as 1-indexed\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef _feasible_colors(node: int, sol: List[int], max_try: int = 6) -> List[int]:\n    # node is 1-indexed\n    adj = _adjacency()\n    used = {sol[v-1] for v in adj[node]}\n    # allow colors from 1..max(sol)+1\n    maxc = max(sol) if sol else 1\n    candidates = [c for c in range(1, maxc+2) if c not in used]\n    if candidates:\n        return candidates\n    # Fallback (should not happen often): try random colors in 1..maxc+1\n    pool = list(range(1, maxc+2))\n    random.shuffle(pool)\n    return pool[:max_try]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([1]*9, \"invalid_input_reset\")\n    sol = _safe_copy_list(solution)\n    n = 9\n    move_kind = None\n    # Choose a random vertex\n    v = random.randint(1, n)\n    feas = _feasible_colors(v, sol)\n    # Prefer a color different from current\n    current = sol[v-1]\n    choices = [c for c in feas if c != current] or feas\n    new_color = random.choice(choices)\n    sol[v-1] = new_color\n    # Optionally normalize colors to compact range 1..k (relabeling)\n    # Build mapping to keep color ids dense, order by first appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    move_kind = f\"recolor_vertex_{v}\"\n    return (sol, move_kind)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolors and occasional color merge attempt\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    sol = _safe_copy_list(solution)\n    n = 9\n    k = max(sol)\n    steps = max(3, n \/\/ 3)\n    adj = _adjacency()\n    for _ in range(steps):\n        v = random.randint(1, n)\n        # colors allowed up to k+1\n        used = {sol[w-1] for w in adj[v]}\n        pool = [c for c in range(1, k+2) if c not in used]\n        if not pool:\n            pool = list(range(1, k+2))\n        newc = random.choice(pool)\n        sol[v-1] = newc\n        k = max(k, newc)\n    # Try a random color relabel merge with small probability\n    if random.random() < 0.5:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            c_from, c_to = random.sample(colors, 2)\n            sol = [c_to if x == c_from else x for x in sol]\n    # Normalize color labels to 1..m preserving order of appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001031884}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS: solution is a Python list of length 9 with integers >=1, where index i-1 stores color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph edges (1-indexed)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    if conflicts == 0:\n        return max(solution)\n    penalty = 10**6\n    k = max(solution)\n    return penalty + conflicts * 1000 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    # 1-indexed to 9 vertices; store neighbors as 1-indexed\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef _feasible_colors(node: int, sol: List[int], max_try: int = 6) -> List[int]:\n    # node is 1-indexed\n    adj = _adjacency()\n    used = {sol[v-1] for v in adj[node]}\n    # allow colors from 1..max(sol)+1\n    maxc = max(sol) if sol else 1\n    candidates = [c for c in range(1, maxc+2) if c not in used]\n    if candidates:\n        return candidates\n    # Fallback (should not happen often): try random colors in 1..maxc+1\n    pool = list(range(1, maxc+2))\n    random.shuffle(pool)\n    return pool[:max_try]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([1]*9, \"invalid_input_reset\")\n    sol = _safe_copy_list(solution)\n    n = 9\n    move_kind = None\n    # Choose a random vertex\n    v = random.randint(1, n)\n    feas = _feasible_colors(v, sol)\n    # Prefer a color different from current\n    current = sol[v-1]\n    choices = [c for c in feas if c != current] or feas\n    new_color = random.choice(choices)\n    sol[v-1] = new_color\n    # Optionally normalize colors to compact range 1..k (relabeling)\n    # Build mapping to keep color ids dense, order by first appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    move_kind = f\"recolor_vertex_{v}\"\n    return (sol, move_kind)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolors and occasional color merge attempt\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    sol = _safe_copy_list(solution)\n    n = 9\n    k = max(sol)\n    steps = max(3, n \/\/ 3)\n    adj = _adjacency()\n    for _ in range(steps):\n        v = random.randint(1, n)\n        # colors allowed up to k+1\n        used = {sol[w-1] for w in adj[v]}\n        pool = [c for c in range(1, k+2) if c not in used]\n        if not pool:\n            pool = list(range(1, k+2))\n        newc = random.choice(pool)\n        sol[v-1] = newc\n        k = max(k, newc)\n    # Try a random color relabel merge with small probability\n    if random.random() < 0.5:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            c_from, c_to = random.sample(colors, 2)\n            sol = [c_to if x == c_from else x for x in sol]\n    # Normalize color labels to 1..m preserving order of appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001011443}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor within current k; canonicalize labels\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        # Canonical by sorting color classes by (min vertex index, then color id)\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    # Identify conflicting vertices\n    conflicting_vertices = set()\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n\n    new_sol = sol[:]\n\n    if conflicting_vertices:\n        v = random.choice(list(conflicting_vertices))\n        current = new_sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing resulting conflicts at v\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            tmp = new_sol[:]\n            tmp[v-1] = c\n            # Only need to evaluate conflicts involving v\n            conf_v = 0\n            for w in adj[v]:\n                if tmp[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol[v-1] = best_c\n        move_desc = f\"recolor_conflicting_vertex_{v}_to_{best_c}\"\n    else:\n        # Feasible: do a lateral move without increasing conflicts and without increasing k\n        v = random.randint(1, 9)\n        current = new_sol[v-1]\n        candidates = [c for c in range(1, k+1) if c != current]\n        best_c = current\n        base_conf = 0  # feasible, local conflicts at v is 0\n        best_extra = None\n        for c in candidates:\n            extra = 0\n            for w in adj[v]:\n                if new_sol[w-1] == c:\n                    extra += 1\n            if best_extra is None or extra < best_extra:\n                best_extra = extra\n                best_c = c\n        if best_c != current and best_extra == 0:\n            new_sol[v-1] = best_c\n            move_desc = f\"lateral_recolor_vertex_{v}_to_{best_c}\"\n        else:\n            move_desc = f\"no_op_vertex_{v}\"\n\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_desc)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: multiple random conflict-directed recolors and Kempe swaps; may allow k+1 temporarily\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        # BFS on subgraph induced by colors a and b; swap colors on component containing v\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set()\n        q = deque([v])\n        visited.add(v)\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    steps = 5  # strength\n    cur = sol[:]\n\n    for _ in range(steps):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif move_type < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random color class relabel (diversification without changing feasibility)\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    cur = canonicalize(cur)\n    return cur\n","Resultados":[[1,2,3,4,4,3,1,1,2],4,[2,4,1,3,3,1,2,2,4],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002388472}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor within current k; canonicalize labels\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        # Canonical by sorting color classes by (min vertex index, then color id)\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    # Identify conflicting vertices\n    conflicting_vertices = set()\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n\n    new_sol = sol[:]\n\n    if conflicting_vertices:\n        v = random.choice(list(conflicting_vertices))\n        current = new_sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing resulting conflicts at v\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            tmp = new_sol[:]\n            tmp[v-1] = c\n            # Only need to evaluate conflicts involving v\n            conf_v = 0\n            for w in adj[v]:\n                if tmp[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol[v-1] = best_c\n        move_desc = f\"recolor_conflicting_vertex_{v}_to_{best_c}\"\n    else:\n        # Feasible: do a lateral move without increasing conflicts and without increasing k\n        v = random.randint(1, 9)\n        current = new_sol[v-1]\n        candidates = [c for c in range(1, k+1) if c != current]\n        best_c = current\n        base_conf = 0  # feasible, local conflicts at v is 0\n        best_extra = None\n        for c in candidates:\n            extra = 0\n            for w in adj[v]:\n                if new_sol[w-1] == c:\n                    extra += 1\n            if best_extra is None or extra < best_extra:\n                best_extra = extra\n                best_c = c\n        if best_c != current and best_extra == 0:\n            new_sol[v-1] = best_c\n            move_desc = f\"lateral_recolor_vertex_{v}_to_{best_c}\"\n        else:\n            move_desc = f\"no_op_vertex_{v}\"\n\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_desc)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: multiple random conflict-directed recolors and Kempe swaps; may allow k+1 temporarily\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        # BFS on subgraph induced by colors a and b; swap colors on component containing v\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set()\n        q = deque([v])\n        visited.add(v)\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    steps = 5  # strength\n    cur = sol[:]\n\n    for _ in range(steps):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif move_type < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random color class relabel (diversification without changing feasibility)\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    cur = canonicalize(cur)\n    return cur\n","Resultados":[[2,4,1,3,3,1,2,2,4],4,[2,4,1,3,3,1,2,2,4],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00156915}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor within current k; canonicalize labels\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        # Canonical by sorting color classes by (min vertex index, then color id)\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    # Identify conflicting vertices\n    conflicting_vertices = set()\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n\n    new_sol = sol[:]\n\n    if conflicting_vertices:\n        v = random.choice(list(conflicting_vertices))\n        current = new_sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing resulting conflicts at v\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            tmp = new_sol[:]\n            tmp[v-1] = c\n            # Only need to evaluate conflicts involving v\n            conf_v = 0\n            for w in adj[v]:\n                if tmp[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol[v-1] = best_c\n        move_desc = f\"recolor_conflicting_vertex_{v}_to_{best_c}\"\n    else:\n        # Feasible: do a lateral move without increasing conflicts and without increasing k\n        v = random.randint(1, 9)\n        current = new_sol[v-1]\n        candidates = [c for c in range(1, k+1) if c != current]\n        best_c = current\n        base_conf = 0  # feasible, local conflicts at v is 0\n        best_extra = None\n        for c in candidates:\n            extra = 0\n            for w in adj[v]:\n                if new_sol[w-1] == c:\n                    extra += 1\n            if best_extra is None or extra < best_extra:\n                best_extra = extra\n                best_c = c\n        if best_c != current and best_extra == 0:\n            new_sol[v-1] = best_c\n            move_desc = f\"lateral_recolor_vertex_{v}_to_{best_c}\"\n        else:\n            move_desc = f\"no_op_vertex_{v}\"\n\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_desc)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: multiple random conflict-directed recolors and Kempe swaps; may allow k+1 temporarily\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        # BFS on subgraph induced by colors a and b; swap colors on component containing v\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set()\n        q = deque([v])\n        visited.add(v)\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    steps = 5  # strength\n    cur = sol[:]\n\n    for _ in range(steps):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif move_type < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random color class relabel (diversification without changing feasibility)\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    cur = canonicalize(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001413369}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (DSATUR-like focus)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional k+1 expansion\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002176998}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (DSATUR-like focus)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional k+1 expansion\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001998236}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (DSATUR-like focus)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional k+1 expansion\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001590271}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS length=9; solution[i] is color of vertex i+1; colors in {1,2,...}","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (focus like TabuCol\/DSATUR)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional color relabels\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1 while perturbing\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001875984}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS length=9; solution[i] is color of vertex i+1; colors in {1,2,...}","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (focus like TabuCol\/DSATUR)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional color relabels\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1 while perturbing\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00156984}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS length=9; solution[i] is color of vertex i+1; colors in {1,2,...}","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (focus like TabuCol\/DSATUR)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional color relabels\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1 while perturbing\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00151751}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST.len=9.int>=1.contiguous_labels_1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns a numeric fitness: lower is better. Combines objective and feasibility + minimality checks.\n    n = 9\n    edges = [(1,4),(1,6),(1,8),\n             (2,3),(2,6),(2,7),(2,8),(2,9),\n             (3,5),(3,6),(3,7),(3,9),\n             (4,5),(4,6),(4,7),\n             (5,6),(5,8),\n             (7,8)]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n\n    PENALTY_INVALID = 10**6\n\n    def objective_function(colors: List[int]) -> int:\n        # Basic structural checks\n        if not isinstance(colors, list):\n            return PENALTY_INVALID + 10**5\n        if len(colors) != n:\n            return PENALTY_INVALID + 10**5 + abs(len(colors)-n)\n        used = set()\n        for x in colors:\n            if not isinstance(x, int) or x < 1:\n                return PENALTY_INVALID + 10**4\n            used.add(x)\n        k = max(colors) if colors else 0\n        if used != set(range(1, k+1)):\n            return PENALTY_INVALID + 5000 + abs(k - len(used))**2\n        conflicts = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                conflicts += 1\n        if conflicts > 0:\n            return PENALTY_INVALID + 1000*conflicts + (max(colors) if colors else 0)\n        return max(colors) if colors else 0\n\n    def is_valid(colors: List[int]) -> bool:\n        if not isinstance(colors, list) or len(colors) != n:\n            return False\n        if any((not isinstance(x,int) or x<1) for x in colors):\n            return False\n        k = max(colors)\n        if set(colors) != set(range(1,k+1)):\n            return False\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                return False\n        return True\n\n    # Build adjacency for backtracking\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    # Max clique lower bound (exact via brute force for n=9)\n    def max_clique_size() -> int:\n        best = 1\n        nodes = list(range(1,n+1))\n        for r in range(2, n+1):\n            found_r = False\n            idxs = list(range(r))\n            def next_comb(idxs, r, N):\n                i = r-1\n                while i>=0 and idxs[i] == N - r + i:\n                    i -= 1\n                if i < 0:\n                    return None\n                idxs[i] += 1\n                for j in range(i+1, r):\n                    idxs[j] = idxs[j-1] + 1\n                return idxs\n            N = n\n            while True:\n                S = [nodes[i] for i in idxs]\n                ok = True\n                for i in range(r):\n                    ui = S[i]\n                    for j in range(i+1, r):\n                        vj = S[j]\n                        a = ui if ui<vj else vj\n                        b = vj if ui<vj else ui\n                        if (a,b) not in edges:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    best = r\n                    found_r = True\n                    break\n                nxt = next_comb(idxs[:], r, N)\n                if nxt is None:\n                    break\n                idxs = nxt\n            if not found_r:\n                break\n        return best\n\n    def exists_coloring(k: int) -> bool:\n        order = sorted(range(1,n+1), key=lambda x: len(adj[x]), reverse=True)\n        assignment = [0]*n\n        def bt(t: int) -> bool:\n            if t == n:\n                return True\n            u = order[t]\n            forb = set()\n            for v in adj[u]:\n                c = assignment[v-1]\n                if c != 0:\n                    forb.add(c)\n            for c in range(1, k+1):\n                if c in forb:\n                    continue\n                assignment[u-1] = c\n                if bt(t+1):\n                    return True\n                assignment[u-1] = 0\n            return False\n        return bt(0)\n\n    base = objective_function(solution)\n    if base >= PENALTY_INVALID:\n        return base\n    k = base\n    lb = max_clique_size()\n    penalty = 0\n    if k < lb:\n        penalty += PENALTY_INVALID\n    if k > 1 and exists_coloring(k-1):\n        penalty += 10**5 + (k-1)\n    return k + penalty\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: recolor one vertex to a different existing color (or rarely a new color), then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1], \"Recolor-One\"\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    idx = random.randrange(n)\n    current = s[idx]\n\n    # Candidate colors: prefer within [1..k], exclude current\n    candidates = [c for c in range(1, k+1) if c != current]\n    # With small probability, allow introducing a new color k+1 to escape local minima\n    if random.random() < 0.05:\n        candidates.append(k+1)\n    if not candidates:\n        candidates = [1 if current != 1 else 2]\n\n    s[idx] = random.choice(candidates)\n    s = normalize_labels(s)\n    return s, \"Recolor-One\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger perturbation: multiple recolors and occasional color relabel shuffle; then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1]\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    # Random relabel shuffle between two colors (if at least 2 colors present)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Random multi-vertex recolors\n    t = max(2, min(n\/\/3, 4))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        choices = list(range(1, k_now+1))\n        # Occasionally allow a new color to escape local minima\n        if random.random() < 0.1:\n            choices.append(k_now+1)\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00150798}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST.len=9.int>=1.contiguous_labels_1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns a numeric fitness: lower is better. Combines objective and feasibility + minimality checks.\n    n = 9\n    edges = [(1,4),(1,6),(1,8),\n             (2,3),(2,6),(2,7),(2,8),(2,9),\n             (3,5),(3,6),(3,7),(3,9),\n             (4,5),(4,6),(4,7),\n             (5,6),(5,8),\n             (7,8)]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n\n    PENALTY_INVALID = 10**6\n\n    def objective_function(colors: List[int]) -> int:\n        # Basic structural checks\n        if not isinstance(colors, list):\n            return PENALTY_INVALID + 10**5\n        if len(colors) != n:\n            return PENALTY_INVALID + 10**5 + abs(len(colors)-n)\n        used = set()\n        for x in colors:\n            if not isinstance(x, int) or x < 1:\n                return PENALTY_INVALID + 10**4\n            used.add(x)\n        k = max(colors) if colors else 0\n        if used != set(range(1, k+1)):\n            return PENALTY_INVALID + 5000 + abs(k - len(used))**2\n        conflicts = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                conflicts += 1\n        if conflicts > 0:\n            return PENALTY_INVALID + 1000*conflicts + (max(colors) if colors else 0)\n        return max(colors) if colors else 0\n\n    def is_valid(colors: List[int]) -> bool:\n        if not isinstance(colors, list) or len(colors) != n:\n            return False\n        if any((not isinstance(x,int) or x<1) for x in colors):\n            return False\n        k = max(colors)\n        if set(colors) != set(range(1,k+1)):\n            return False\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                return False\n        return True\n\n    # Build adjacency for backtracking\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    # Max clique lower bound (exact via brute force for n=9)\n    def max_clique_size() -> int:\n        best = 1\n        nodes = list(range(1,n+1))\n        for r in range(2, n+1):\n            found_r = False\n            idxs = list(range(r))\n            def next_comb(idxs, r, N):\n                i = r-1\n                while i>=0 and idxs[i] == N - r + i:\n                    i -= 1\n                if i < 0:\n                    return None\n                idxs[i] += 1\n                for j in range(i+1, r):\n                    idxs[j] = idxs[j-1] + 1\n                return idxs\n            N = n\n            while True:\n                S = [nodes[i] for i in idxs]\n                ok = True\n                for i in range(r):\n                    ui = S[i]\n                    for j in range(i+1, r):\n                        vj = S[j]\n                        a = ui if ui<vj else vj\n                        b = vj if ui<vj else ui\n                        if (a,b) not in edges:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    best = r\n                    found_r = True\n                    break\n                nxt = next_comb(idxs[:], r, N)\n                if nxt is None:\n                    break\n                idxs = nxt\n            if not found_r:\n                break\n        return best\n\n    def exists_coloring(k: int) -> bool:\n        order = sorted(range(1,n+1), key=lambda x: len(adj[x]), reverse=True)\n        assignment = [0]*n\n        def bt(t: int) -> bool:\n            if t == n:\n                return True\n            u = order[t]\n            forb = set()\n            for v in adj[u]:\n                c = assignment[v-1]\n                if c != 0:\n                    forb.add(c)\n            for c in range(1, k+1):\n                if c in forb:\n                    continue\n                assignment[u-1] = c\n                if bt(t+1):\n                    return True\n                assignment[u-1] = 0\n            return False\n        return bt(0)\n\n    base = objective_function(solution)\n    if base >= PENALTY_INVALID:\n        return base\n    k = base\n    lb = max_clique_size()\n    penalty = 0\n    if k < lb:\n        penalty += PENALTY_INVALID\n    if k > 1 and exists_coloring(k-1):\n        penalty += 10**5 + (k-1)\n    return k + penalty\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: recolor one vertex to a different existing color (or rarely a new color), then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1], \"Recolor-One\"\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    idx = random.randrange(n)\n    current = s[idx]\n\n    # Candidate colors: prefer within [1..k], exclude current\n    candidates = [c for c in range(1, k+1) if c != current]\n    # With small probability, allow introducing a new color k+1 to escape local minima\n    if random.random() < 0.05:\n        candidates.append(k+1)\n    if not candidates:\n        candidates = [1 if current != 1 else 2]\n\n    s[idx] = random.choice(candidates)\n    s = normalize_labels(s)\n    return s, \"Recolor-One\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger perturbation: multiple recolors and occasional color relabel shuffle; then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1]\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    # Random relabel shuffle between two colors (if at least 2 colors present)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Random multi-vertex recolors\n    t = max(2, min(n\/\/3, 4))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        choices = list(range(1, k_now+1))\n        # Occasionally allow a new color to escape local minima\n        if random.random() < 0.1:\n            choices.append(k_now+1)\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001238656}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST.len=9.int>=1.contiguous_labels_1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns a numeric fitness: lower is better. Combines objective and feasibility + minimality checks.\n    n = 9\n    edges = [(1,4),(1,6),(1,8),\n             (2,3),(2,6),(2,7),(2,8),(2,9),\n             (3,5),(3,6),(3,7),(3,9),\n             (4,5),(4,6),(4,7),\n             (5,6),(5,8),\n             (7,8)]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n\n    PENALTY_INVALID = 10**6\n\n    def objective_function(colors: List[int]) -> int:\n        # Basic structural checks\n        if not isinstance(colors, list):\n            return PENALTY_INVALID + 10**5\n        if len(colors) != n:\n            return PENALTY_INVALID + 10**5 + abs(len(colors)-n)\n        used = set()\n        for x in colors:\n            if not isinstance(x, int) or x < 1:\n                return PENALTY_INVALID + 10**4\n            used.add(x)\n        k = max(colors) if colors else 0\n        if used != set(range(1, k+1)):\n            return PENALTY_INVALID + 5000 + abs(k - len(used))**2\n        conflicts = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                conflicts += 1\n        if conflicts > 0:\n            return PENALTY_INVALID + 1000*conflicts + (max(colors) if colors else 0)\n        return max(colors) if colors else 0\n\n    def is_valid(colors: List[int]) -> bool:\n        if not isinstance(colors, list) or len(colors) != n:\n            return False\n        if any((not isinstance(x,int) or x<1) for x in colors):\n            return False\n        k = max(colors)\n        if set(colors) != set(range(1,k+1)):\n            return False\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                return False\n        return True\n\n    # Build adjacency for backtracking\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    # Max clique lower bound (exact via brute force for n=9)\n    def max_clique_size() -> int:\n        best = 1\n        nodes = list(range(1,n+1))\n        for r in range(2, n+1):\n            found_r = False\n            idxs = list(range(r))\n            def next_comb(idxs, r, N):\n                i = r-1\n                while i>=0 and idxs[i] == N - r + i:\n                    i -= 1\n                if i < 0:\n                    return None\n                idxs[i] += 1\n                for j in range(i+1, r):\n                    idxs[j] = idxs[j-1] + 1\n                return idxs\n            N = n\n            while True:\n                S = [nodes[i] for i in idxs]\n                ok = True\n                for i in range(r):\n                    ui = S[i]\n                    for j in range(i+1, r):\n                        vj = S[j]\n                        a = ui if ui<vj else vj\n                        b = vj if ui<vj else ui\n                        if (a,b) not in edges:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    best = r\n                    found_r = True\n                    break\n                nxt = next_comb(idxs[:], r, N)\n                if nxt is None:\n                    break\n                idxs = nxt\n            if not found_r:\n                break\n        return best\n\n    def exists_coloring(k: int) -> bool:\n        order = sorted(range(1,n+1), key=lambda x: len(adj[x]), reverse=True)\n        assignment = [0]*n\n        def bt(t: int) -> bool:\n            if t == n:\n                return True\n            u = order[t]\n            forb = set()\n            for v in adj[u]:\n                c = assignment[v-1]\n                if c != 0:\n                    forb.add(c)\n            for c in range(1, k+1):\n                if c in forb:\n                    continue\n                assignment[u-1] = c\n                if bt(t+1):\n                    return True\n                assignment[u-1] = 0\n            return False\n        return bt(0)\n\n    base = objective_function(solution)\n    if base >= PENALTY_INVALID:\n        return base\n    k = base\n    lb = max_clique_size()\n    penalty = 0\n    if k < lb:\n        penalty += PENALTY_INVALID\n    if k > 1 and exists_coloring(k-1):\n        penalty += 10**5 + (k-1)\n    return k + penalty\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: recolor one vertex to a different existing color (or rarely a new color), then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1], \"Recolor-One\"\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    idx = random.randrange(n)\n    current = s[idx]\n\n    # Candidate colors: prefer within [1..k], exclude current\n    candidates = [c for c in range(1, k+1) if c != current]\n    # With small probability, allow introducing a new color k+1 to escape local minima\n    if random.random() < 0.05:\n        candidates.append(k+1)\n    if not candidates:\n        candidates = [1 if current != 1 else 2]\n\n    s[idx] = random.choice(candidates)\n    s = normalize_labels(s)\n    return s, \"Recolor-One\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger perturbation: multiple recolors and occasional color relabel shuffle; then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1]\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    # Random relabel shuffle between two colors (if at least 2 colors present)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Random multi-vertex recolors\n    t = max(2, min(n\/\/3, 4))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        choices = list(range(1, k_now+1))\n        # Occasionally allow a new color to escape local minima\n        if random.random() < 0.1:\n            choices.append(k_now+1)\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001181395}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9. solution = [c(1),...,c(9)] with integers >=1. Labels must be contiguous 1..k (no gaps).","Evaluacion":"import math\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution)-n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Label contiguity penalty (prefer canonical contiguous labels 1..k)\n    used = set(colors)\n    contig_ok = used == set(range(1, k+1))\n    gap_pen = 0 if contig_ok else 100 + (abs(k - len(used))**2)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    # Shaped score: prioritize feasibility (conflicts) first, then minimize k\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for advanced moves (Kempe chain)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        # Deterministic canonical mapping by ascending label value\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"Init-Fallback\")\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    move_choice = random.random()\n\n    if move_choice < 0.5:\n        # Recolor one vertex\n        i = random.randrange(n)\n        cur = s[i]\n        candidates = [c for c in range(1, k+1) if c != cur]\n        # Allow new color only if currently conflicting to escape plateaus\n        if count_conflicts(s) > 0 and random.random() < 0.1:\n            candidates.append(k+1)\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        s[i] = random.choice(candidates)\n        s = normalize_labels(s)\n        return s, \"Recolor-One\"\n    elif move_choice < 0.8:\n        # Kempe-chain swap between two colors a,b starting from a random vertex\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            start = random.randrange(1, n+1)\n            target_colors = {a, b}\n            visited = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                if s[u-1] in target_colors:\n                    visited.add(u)\n                    for v in adj[u]:\n                        if v not in visited and s[v-1] in target_colors:\n                            stack.append(v)\n            # Swap colors a<->b on the reached component\n            for u in visited:\n                if s[u-1] == a:\n                    s[u-1] = b\n                elif s[u-1] == b:\n                    s[u-1] = a\n            s = normalize_labels(s)\n            return s, \"Kempe-Chain\"\n        else:\n            # Fallback to recolor\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n    else:\n        # Color-swap: pick two colors and swap labels globally\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n            s = normalize_labels(s)\n            return s, \"Swap-Labels\"\n        else:\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex perturbation with occasional relabel shuffle\n    n = 9\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    # Random relabel swap between two colors (if at least 2 colors)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Multi-vertex recolors\n    t = max(3, min(n\/\/2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        # 90% pick within existing colors, 10% allow new color k_now+1\n        if random.random() < 0.9:\n            newc = random.randrange(1, k_now+1)\n        else:\n            newc = k_now + 1\n        s[i] = newc\n\n    s = normalize_labels(s)\n    return s\n","Resultados":[[3,3,1,1,3,2,2,1,2],3,[1,1,2,2,1,3,3,2,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00238801}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9. solution = [c(1),...,c(9)] with integers >=1. Labels must be contiguous 1..k (no gaps).","Evaluacion":"import math\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution)-n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Label contiguity penalty (prefer canonical contiguous labels 1..k)\n    used = set(colors)\n    contig_ok = used == set(range(1, k+1))\n    gap_pen = 0 if contig_ok else 100 + (abs(k - len(used))**2)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    # Shaped score: prioritize feasibility (conflicts) first, then minimize k\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for advanced moves (Kempe chain)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        # Deterministic canonical mapping by ascending label value\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"Init-Fallback\")\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    move_choice = random.random()\n\n    if move_choice < 0.5:\n        # Recolor one vertex\n        i = random.randrange(n)\n        cur = s[i]\n        candidates = [c for c in range(1, k+1) if c != cur]\n        # Allow new color only if currently conflicting to escape plateaus\n        if count_conflicts(s) > 0 and random.random() < 0.1:\n            candidates.append(k+1)\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        s[i] = random.choice(candidates)\n        s = normalize_labels(s)\n        return s, \"Recolor-One\"\n    elif move_choice < 0.8:\n        # Kempe-chain swap between two colors a,b starting from a random vertex\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            start = random.randrange(1, n+1)\n            target_colors = {a, b}\n            visited = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                if s[u-1] in target_colors:\n                    visited.add(u)\n                    for v in adj[u]:\n                        if v not in visited and s[v-1] in target_colors:\n                            stack.append(v)\n            # Swap colors a<->b on the reached component\n            for u in visited:\n                if s[u-1] == a:\n                    s[u-1] = b\n                elif s[u-1] == b:\n                    s[u-1] = a\n            s = normalize_labels(s)\n            return s, \"Kempe-Chain\"\n        else:\n            # Fallback to recolor\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n    else:\n        # Color-swap: pick two colors and swap labels globally\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n            s = normalize_labels(s)\n            return s, \"Swap-Labels\"\n        else:\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex perturbation with occasional relabel shuffle\n    n = 9\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    # Random relabel swap between two colors (if at least 2 colors)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Multi-vertex recolors\n    t = max(3, min(n\/\/2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        # 90% pick within existing colors, 10% allow new color k_now+1\n        if random.random() < 0.9:\n            newc = random.randrange(1, k_now+1)\n        else:\n            newc = k_now + 1\n        s[i] = newc\n\n    s = normalize_labels(s)\n    return s\n","Resultados":[[1,2,2,3,1,4,4,1,4],3003,[2,4,1,4,2,3,3,1,1],1004],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002103437}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9. solution = [c(1),...,c(9)] with integers >=1. Labels must be contiguous 1..k (no gaps).","Evaluacion":"import math\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution)-n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Label contiguity penalty (prefer canonical contiguous labels 1..k)\n    used = set(colors)\n    contig_ok = used == set(range(1, k+1))\n    gap_pen = 0 if contig_ok else 100 + (abs(k - len(used))**2)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    # Shaped score: prioritize feasibility (conflicts) first, then minimize k\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for advanced moves (Kempe chain)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        # Deterministic canonical mapping by ascending label value\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"Init-Fallback\")\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    move_choice = random.random()\n\n    if move_choice < 0.5:\n        # Recolor one vertex\n        i = random.randrange(n)\n        cur = s[i]\n        candidates = [c for c in range(1, k+1) if c != cur]\n        # Allow new color only if currently conflicting to escape plateaus\n        if count_conflicts(s) > 0 and random.random() < 0.1:\n            candidates.append(k+1)\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        s[i] = random.choice(candidates)\n        s = normalize_labels(s)\n        return s, \"Recolor-One\"\n    elif move_choice < 0.8:\n        # Kempe-chain swap between two colors a,b starting from a random vertex\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            start = random.randrange(1, n+1)\n            target_colors = {a, b}\n            visited = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                if s[u-1] in target_colors:\n                    visited.add(u)\n                    for v in adj[u]:\n                        if v not in visited and s[v-1] in target_colors:\n                            stack.append(v)\n            # Swap colors a<->b on the reached component\n            for u in visited:\n                if s[u-1] == a:\n                    s[u-1] = b\n                elif s[u-1] == b:\n                    s[u-1] = a\n            s = normalize_labels(s)\n            return s, \"Kempe-Chain\"\n        else:\n            # Fallback to recolor\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n    else:\n        # Color-swap: pick two colors and swap labels globally\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n            s = normalize_labels(s)\n            return s, \"Swap-Labels\"\n        else:\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex perturbation with occasional relabel shuffle\n    n = 9\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    # Random relabel swap between two colors (if at least 2 colors)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Multi-vertex recolors\n    t = max(3, min(n\/\/2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        # 90% pick within existing colors, 10% allow new color k_now+1\n        if random.random() < 0.9:\n            newc = random.randrange(1, k_now+1)\n        else:\n            newc = k_now + 1\n        s[i] = newc\n\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001025003}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; solution is a Python list of 9 positive integers [c(1),...,c(9)] with contiguous labels 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Label contiguity penalty (only when conflict-free; small weight)\n    used = set(colors)\n    contig_ok = used == set(range(1, k + 1))\n    gap_pen = 0\n    if conflicts == 0 and not contig_ok:\n        gap_pen = 5 + (abs(k - len(used)) ** 2)\n\n    # Objective: minimize conflicts first, then k, then contiguity\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure input validity minimally; fallback to trivial\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1] * n, \"Init-Fallback\")\n\n    # Problem data (embedded)\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    conf_set = conflict_vertices(s)\n\n    # If conflicts exist: min-conflicts recolor on a conflicting vertex\n    if conf_set:\n        v = random.choice(list(conf_set))\n        current_color = s[v - 1]\n        # Evaluate conflicts per color assignment\n        best_colors = []\n        best_conf = None\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [c]\n            elif cval == best_conf:\n                best_colors.append(c)\n        # Allow introducing k+1 only if all colors keep conflicts\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if best_conf > 0:\n            tmp = s[:]\n            tmp[v - 1] = k + 1\n            cval_new = count_conflicts(tmp)\n            if cval_new < best_conf:\n                s = tmp\n                s = normalize_labels(s)\n                return s, \"Recolor-Introduce-New\"\n        # Tie-breaker: least used color among best\n        if best_colors:\n            freq = Counter(s)\n            c_choice = min(best_colors, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback random recolor\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt k reduction via moving a vertex off highest color\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    moved = False\n    for v in idxs:\n        # Try to recolor v into existing colors < max_color feasibly\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # Choose color that minimally increases future conflicts (all zero here)\n            s[v - 1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        s = normalize_labels(s)\n        return s, \"ReduceK-Reassign\"\n\n    # If cannot move any vertex: Kempe-chain swap between two colors to diversify\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: random single-vertex recolor (keeps feasibility)\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1] * n\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Embedded graph\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    # Step 1: Random relabel swap to diversify\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Color merge-split perturbation\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a into a and new color a' greedily to reduce conflicts\n        new_color = max(s) + 1\n        # Identify conflicts within color a\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            # If v conflicts within color a, try recoloring to existing colors first\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            # Try to move to any existing color that is feasible\n            moved = False\n            for ctry in random.sample(list(range(1, max(s) + 1)), k=min(3, max(s))):\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                # Move to new color\n                s[v - 1] = new_color\n        s = normalize_labels(s)\n\n    # Step 3: Multi-vertex small random recolors\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001720402}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; solution is a Python list of 9 positive integers [c(1),...,c(9)] with contiguous labels 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Label contiguity penalty (only when conflict-free; small weight)\n    used = set(colors)\n    contig_ok = used == set(range(1, k + 1))\n    gap_pen = 0\n    if conflicts == 0 and not contig_ok:\n        gap_pen = 5 + (abs(k - len(used)) ** 2)\n\n    # Objective: minimize conflicts first, then k, then contiguity\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure input validity minimally; fallback to trivial\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1] * n, \"Init-Fallback\")\n\n    # Problem data (embedded)\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    conf_set = conflict_vertices(s)\n\n    # If conflicts exist: min-conflicts recolor on a conflicting vertex\n    if conf_set:\n        v = random.choice(list(conf_set))\n        current_color = s[v - 1]\n        # Evaluate conflicts per color assignment\n        best_colors = []\n        best_conf = None\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [c]\n            elif cval == best_conf:\n                best_colors.append(c)\n        # Allow introducing k+1 only if all colors keep conflicts\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if best_conf > 0:\n            tmp = s[:]\n            tmp[v - 1] = k + 1\n            cval_new = count_conflicts(tmp)\n            if cval_new < best_conf:\n                s = tmp\n                s = normalize_labels(s)\n                return s, \"Recolor-Introduce-New\"\n        # Tie-breaker: least used color among best\n        if best_colors:\n            freq = Counter(s)\n            c_choice = min(best_colors, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback random recolor\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt k reduction via moving a vertex off highest color\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    moved = False\n    for v in idxs:\n        # Try to recolor v into existing colors < max_color feasibly\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # Choose color that minimally increases future conflicts (all zero here)\n            s[v - 1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        s = normalize_labels(s)\n        return s, \"ReduceK-Reassign\"\n\n    # If cannot move any vertex: Kempe-chain swap between two colors to diversify\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: random single-vertex recolor (keeps feasibility)\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1] * n\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Embedded graph\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    # Step 1: Random relabel swap to diversify\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Color merge-split perturbation\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a into a and new color a' greedily to reduce conflicts\n        new_color = max(s) + 1\n        # Identify conflicts within color a\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            # If v conflicts within color a, try recoloring to existing colors first\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            # Try to move to any existing color that is feasible\n            moved = False\n            for ctry in random.sample(list(range(1, max(s) + 1)), k=min(3, max(s))):\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                # Move to new color\n                s[v - 1] = new_color\n        s = normalize_labels(s)\n\n    # Step 3: Multi-vertex small random recolors\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001506049}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; solution is a Python list of 9 positive integers [c(1),...,c(9)] with contiguous labels 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Label contiguity penalty (only when conflict-free; small weight)\n    used = set(colors)\n    contig_ok = used == set(range(1, k + 1))\n    gap_pen = 0\n    if conflicts == 0 and not contig_ok:\n        gap_pen = 5 + (abs(k - len(used)) ** 2)\n\n    # Objective: minimize conflicts first, then k, then contiguity\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure input validity minimally; fallback to trivial\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1] * n, \"Init-Fallback\")\n\n    # Problem data (embedded)\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    conf_set = conflict_vertices(s)\n\n    # If conflicts exist: min-conflicts recolor on a conflicting vertex\n    if conf_set:\n        v = random.choice(list(conf_set))\n        current_color = s[v - 1]\n        # Evaluate conflicts per color assignment\n        best_colors = []\n        best_conf = None\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [c]\n            elif cval == best_conf:\n                best_colors.append(c)\n        # Allow introducing k+1 only if all colors keep conflicts\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if best_conf > 0:\n            tmp = s[:]\n            tmp[v - 1] = k + 1\n            cval_new = count_conflicts(tmp)\n            if cval_new < best_conf:\n                s = tmp\n                s = normalize_labels(s)\n                return s, \"Recolor-Introduce-New\"\n        # Tie-breaker: least used color among best\n        if best_colors:\n            freq = Counter(s)\n            c_choice = min(best_colors, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback random recolor\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt k reduction via moving a vertex off highest color\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    moved = False\n    for v in idxs:\n        # Try to recolor v into existing colors < max_color feasibly\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # Choose color that minimally increases future conflicts (all zero here)\n            s[v - 1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        s = normalize_labels(s)\n        return s, \"ReduceK-Reassign\"\n\n    # If cannot move any vertex: Kempe-chain swap between two colors to diversify\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: random single-vertex recolor (keeps feasibility)\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1] * n\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Embedded graph\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    # Step 1: Random relabel swap to diversify\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Color merge-split perturbation\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a into a and new color a' greedily to reduce conflicts\n        new_color = max(s) + 1\n        # Identify conflicts within color a\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            # If v conflicts within color a, try recoloring to existing colors first\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            # Try to move to any existing color that is feasible\n            moved = False\n            for ctry in random.sample(list(range(1, max(s) + 1)), k=min(3, max(s))):\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                # Move to new color\n                s[v - 1] = new_color\n        s = normalize_labels(s)\n\n    # Step 3: Multi-vertex small random recolors\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001421008}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; contiguous labels 1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Constants (embedded problem data)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then k\n    score = conflicts * 1000 + k\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Minimal validation; fallback to DSATUR init if needed\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    # Helpers\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    k = max(s)\n    conf_set = conflict_vertices(s)\n\n    # If conflicts: DSATUR-guided min-conflicts recolor\n    if conf_set:\n        # Saturation degree among conflicting vertices\n        def sat_deg(v):\n            return len({s[u - 1] for u in adj[v]})\n        candidates = sorted(list(conf_set), key=lambda v: (sat_deg(v), len(adj[v])), reverse=True)\n        v = random.choice(candidates[:min(3, len(candidates))])\n        current_color = s[v - 1]\n        best_sol = None\n        best_conf = None\n        best_color_choices = []\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_color_choices = [c]\n                best_sol = tmp\n            elif cval == best_conf:\n                best_color_choices.append(c)\n        # Optionally try introducing new color if it reduces conflicts\n        tmp_new = s[:]\n        tmp_new[v - 1] = k + 1\n        cval_new = count_conflicts(tmp_new)\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if cval_new < best_conf:\n            s = normalize_labels(tmp_new)\n            return s, \"Recolor-Introduce-New\"\n        if best_color_choices:\n            freq = Counter(s)\n            c_choice = min(best_color_choices, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt to reduce max color by moving vertices off it\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    for v in idxs:\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # choose least frequent feasible color to balance\n            freq = Counter(s)\n            c_choice = min(feas, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"ReduceK-Reassign\"\n\n    # Kempe-chain swap between two colors\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: toggle a random vertex color within current palette\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter, deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Validation and fallback DSATUR init for robustness\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    # Step 1: Random color relabel swap (diversification)\n    k = max(s)\n    if k >= 2 and random.random() < 0.8:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Merge-split of two color classes to create structured disruption\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a by resolving conflicts greedily, possibly using a new color\n        new_color = max(s) + 1\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            moved = False\n            palette = list(range(1, max(s) + 1))\n            random.shuffle(palette)\n            for ctry in palette:\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                s[v - 1] = new_color\n    \n    # Step 3: Random multi-vertex recolors (bounded)\n    s = normalize_labels(s)\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001993995}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; contiguous labels 1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Constants (embedded problem data)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then k\n    score = conflicts * 1000 + k\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Minimal validation; fallback to DSATUR init if needed\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    # Helpers\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    k = max(s)\n    conf_set = conflict_vertices(s)\n\n    # If conflicts: DSATUR-guided min-conflicts recolor\n    if conf_set:\n        # Saturation degree among conflicting vertices\n        def sat_deg(v):\n            return len({s[u - 1] for u in adj[v]})\n        candidates = sorted(list(conf_set), key=lambda v: (sat_deg(v), len(adj[v])), reverse=True)\n        v = random.choice(candidates[:min(3, len(candidates))])\n        current_color = s[v - 1]\n        best_sol = None\n        best_conf = None\n        best_color_choices = []\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_color_choices = [c]\n                best_sol = tmp\n            elif cval == best_conf:\n                best_color_choices.append(c)\n        # Optionally try introducing new color if it reduces conflicts\n        tmp_new = s[:]\n        tmp_new[v - 1] = k + 1\n        cval_new = count_conflicts(tmp_new)\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if cval_new < best_conf:\n            s = normalize_labels(tmp_new)\n            return s, \"Recolor-Introduce-New\"\n        if best_color_choices:\n            freq = Counter(s)\n            c_choice = min(best_color_choices, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt to reduce max color by moving vertices off it\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    for v in idxs:\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # choose least frequent feasible color to balance\n            freq = Counter(s)\n            c_choice = min(feas, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"ReduceK-Reassign\"\n\n    # Kempe-chain swap between two colors\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: toggle a random vertex color within current palette\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter, deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Validation and fallback DSATUR init for robustness\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    # Step 1: Random color relabel swap (diversification)\n    k = max(s)\n    if k >= 2 and random.random() < 0.8:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Merge-split of two color classes to create structured disruption\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a by resolving conflicts greedily, possibly using a new color\n        new_color = max(s) + 1\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            moved = False\n            palette = list(range(1, max(s) + 1))\n            random.shuffle(palette)\n            for ctry in palette:\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                s[v - 1] = new_color\n    \n    # Step 3: Random multi-vertex recolors (bounded)\n    s = normalize_labels(s)\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.0016596511}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; contiguous labels 1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Constants (embedded problem data)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then k\n    score = conflicts * 1000 + k\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Minimal validation; fallback to DSATUR init if needed\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    # Helpers\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    k = max(s)\n    conf_set = conflict_vertices(s)\n\n    # If conflicts: DSATUR-guided min-conflicts recolor\n    if conf_set:\n        # Saturation degree among conflicting vertices\n        def sat_deg(v):\n            return len({s[u - 1] for u in adj[v]})\n        candidates = sorted(list(conf_set), key=lambda v: (sat_deg(v), len(adj[v])), reverse=True)\n        v = random.choice(candidates[:min(3, len(candidates))])\n        current_color = s[v - 1]\n        best_sol = None\n        best_conf = None\n        best_color_choices = []\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_color_choices = [c]\n                best_sol = tmp\n            elif cval == best_conf:\n                best_color_choices.append(c)\n        # Optionally try introducing new color if it reduces conflicts\n        tmp_new = s[:]\n        tmp_new[v - 1] = k + 1\n        cval_new = count_conflicts(tmp_new)\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if cval_new < best_conf:\n            s = normalize_labels(tmp_new)\n            return s, \"Recolor-Introduce-New\"\n        if best_color_choices:\n            freq = Counter(s)\n            c_choice = min(best_color_choices, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt to reduce max color by moving vertices off it\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    for v in idxs:\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # choose least frequent feasible color to balance\n            freq = Counter(s)\n            c_choice = min(feas, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"ReduceK-Reassign\"\n\n    # Kempe-chain swap between two colors\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: toggle a random vertex color within current palette\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter, deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Validation and fallback DSATUR init for robustness\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    # Step 1: Random color relabel swap (diversification)\n    k = max(s)\n    if k >= 2 and random.random() < 0.8:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Merge-split of two color classes to create structured disruption\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a by resolving conflicts greedily, possibly using a new color\n        new_color = max(s) + 1\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            moved = False\n            palette = list(range(1, max(s) + 1))\n            random.shuffle(palette)\n            for ctry in palette:\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                s[v - 1] = new_color\n    \n    # Step 3: Random multi-vertex recolors (bounded)\n    s = normalize_labels(s)\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002018896}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    PENALTY_BASE = 10**6\n    # basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != 9:\n        return PENALTY_BASE * 50 + abs(len(solution) - 9)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # feasible: objective is number of colors used (max label)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # NB_Type: representation type descriptor; Movement_Type: specific local move\n    # This function perturbs a copy internally but per required signature returns only labels\n    _ = list(solution)\n    n = 9\n    if len(_) != n:\n        return (\"INDEX_LIST\", \"NO_OP_INVALID_LENGTH\")\n    # try to recolor a conflicted vertex if any; else random recolor\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    conflicts = []\n    for (u, v) in E:\n        if _[u-1] == _[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    used = set(_)\n    # choose a color different from neighbors\n    neigh = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neigh.add(_[v-1])\n        elif v-1 == idx:\n            neigh.add(_[u-1])\n    candidates = [c for c in range(1, max(used) + 2) if c not in neigh]\n    if candidates:\n        _[idx] = random.choice(candidates)\n    else:\n        _[idx] = max(used) + 1\n    return (\"INDEX_LIST\", \"RECOLOR_ONE\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Stronger shake: random recolor of a subset followed by greedy repair attempt\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n:\n        # create a random starting solution if invalid\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # random subset recolor\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n    # greedy repair: for each vertex, pick smallest feasible color\n    for v in range(n):\n        neigh_colors = set()\n        for (u, w) in E:\n            if u-1 == v:\n                neigh_colors.add(sol[w-1])\n            elif w-1 == v:\n                neigh_colors.add(sol[u-1])\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000796311}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    PENALTY_BASE = 10**6\n    # basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != 9:\n        return PENALTY_BASE * 50 + abs(len(solution) - 9)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # feasible: objective is number of colors used (max label)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # NB_Type: representation type descriptor; Movement_Type: specific local move\n    # This function perturbs a copy internally but per required signature returns only labels\n    _ = list(solution)\n    n = 9\n    if len(_) != n:\n        return (\"INDEX_LIST\", \"NO_OP_INVALID_LENGTH\")\n    # try to recolor a conflicted vertex if any; else random recolor\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    conflicts = []\n    for (u, v) in E:\n        if _[u-1] == _[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    used = set(_)\n    # choose a color different from neighbors\n    neigh = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neigh.add(_[v-1])\n        elif v-1 == idx:\n            neigh.add(_[u-1])\n    candidates = [c for c in range(1, max(used) + 2) if c not in neigh]\n    if candidates:\n        _[idx] = random.choice(candidates)\n    else:\n        _[idx] = max(used) + 1\n    return (\"INDEX_LIST\", \"RECOLOR_ONE\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Stronger shake: random recolor of a subset followed by greedy repair attempt\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n:\n        # create a random starting solution if invalid\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # random subset recolor\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n    # greedy repair: for each vertex, pick smallest feasible color\n    for v in range(n):\n        neigh_colors = set()\n        for (u, w) in E:\n            if u-1 == v:\n                neigh_colors.add(sol[w-1])\n            elif w-1 == v:\n                neigh_colors.add(sol[u-1])\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000658238}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    PENALTY_BASE = 10**6\n    # basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != 9:\n        return PENALTY_BASE * 50 + abs(len(solution) - 9)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # feasible: objective is number of colors used (max label)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # NB_Type: representation type descriptor; Movement_Type: specific local move\n    # This function perturbs a copy internally but per required signature returns only labels\n    _ = list(solution)\n    n = 9\n    if len(_) != n:\n        return (\"INDEX_LIST\", \"NO_OP_INVALID_LENGTH\")\n    # try to recolor a conflicted vertex if any; else random recolor\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    conflicts = []\n    for (u, v) in E:\n        if _[u-1] == _[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    used = set(_)\n    # choose a color different from neighbors\n    neigh = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neigh.add(_[v-1])\n        elif v-1 == idx:\n            neigh.add(_[u-1])\n    candidates = [c for c in range(1, max(used) + 2) if c not in neigh]\n    if candidates:\n        _[idx] = random.choice(candidates)\n    else:\n        _[idx] = max(used) + 1\n    return (\"INDEX_LIST\", \"RECOLOR_ONE\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Stronger shake: random recolor of a subset followed by greedy repair attempt\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n:\n        # create a random starting solution if invalid\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # random subset recolor\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n    # greedy repair: for each vertex, pick smallest feasible color\n    for v in range(n):\n        neigh_colors = set()\n        for (u, w) in E:\n            if u-1 == v:\n                neigh_colors.add(sol[w-1])\n            elif w-1 == v:\n                neigh_colors.add(sol[u-1])\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000713769}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n      return PENALTY_BASE * 100\n    if len(solution) != n:\n      return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n      if not isinstance(x, int):\n        return PENALTY_BASE * 40\n      if x < 1:\n        return PENALTY_BASE * 30\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n      if solution[u-1] == solution[v-1]:\n        conflicts += 1\n    # Compute colors used\n    K = 0\n    for x in solution:\n      if x > K:\n        K = x\n    if conflicts > 0:\n      # Structured penalty to rank infeasible states\n      return PENALTY_BASE + 100 * conflicts + K\n    # Feasible: objective is number of colors used\n    return K\n","Vecindad":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    # Relabel colors to 1..m in order of first occurrence to stabilize K\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: Any):\n    \"\"\"\n    Neighbor operator for INDEX_LIST.\n    Movement types internally used:\n      - RECOLOR_CONFLICTED\n      - REDUCE_MAX_COLOR\n      - KEMPE_SWAP\n      - RANDOM_RECOLOR\n    Returns: new solution (INDEX_LIST)\n    \"\"\"\n    # Validate and clone\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1) for x in solution) or len(solution) != 9:\n        # create a simple random valid-length solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Normalize labels to avoid drift\n    sol = _normalize_colors(sol)\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def neighbors_of(idx: int) -> set:\n        neigh = set()\n        for (u, v) in E:\n            if u - 1 == idx:\n                neigh.add(v - 1)\n            elif v - 1 == idx:\n                neigh.add(u - 1)\n        return neigh\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[idx] = c\n        return _normalize_colors(sol)\n\n    # Strategy 2: attempt to reduce K by eliminating the max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    reduced = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        # try assign the smallest color strictly less than max_c\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            reduced = True\n    if reduced:\n        return _normalize_colors(sol)\n\n    # Strategy 3: Kempe chain swap between two colors to enable reduction later\n    # pick two colors a,b (prefer include max color)\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a = max(colors)\n        b = random.choice([c for c in colors if c != a])\n        # pick a random vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            # BFS on induced subgraph of colors {a,b}\n            queue = [start]\n            visited = set([start])\n            while queue:\n                v = queue.pop(0)\n                for nb in neighbors_of(v):\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        queue.append(nb)\n            # swap colors a<->b on visited component\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return _normalize_colors(sol)\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in neighbors_of(idx)}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return _normalize_colors(sol)\n","Perturbacion":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution: Any):\n    # Strong shake: multi-vertex recolor + optional color-class swap + greedy repair\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = _normalize_colors(sol)\n\n    def neighbors_of(idx: int) -> list:\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    # Step 1: random subset recolor into existing or new color\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap to reshuffle structure\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_colors = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001313716}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n      return PENALTY_BASE * 100\n    if len(solution) != n:\n      return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n      if not isinstance(x, int):\n        return PENALTY_BASE * 40\n      if x < 1:\n        return PENALTY_BASE * 30\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n      if solution[u-1] == solution[v-1]:\n        conflicts += 1\n    # Compute colors used\n    K = 0\n    for x in solution:\n      if x > K:\n        K = x\n    if conflicts > 0:\n      # Structured penalty to rank infeasible states\n      return PENALTY_BASE + 100 * conflicts + K\n    # Feasible: objective is number of colors used\n    return K\n","Vecindad":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    # Relabel colors to 1..m in order of first occurrence to stabilize K\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: Any):\n    \"\"\"\n    Neighbor operator for INDEX_LIST.\n    Movement types internally used:\n      - RECOLOR_CONFLICTED\n      - REDUCE_MAX_COLOR\n      - KEMPE_SWAP\n      - RANDOM_RECOLOR\n    Returns: new solution (INDEX_LIST)\n    \"\"\"\n    # Validate and clone\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1) for x in solution) or len(solution) != 9:\n        # create a simple random valid-length solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Normalize labels to avoid drift\n    sol = _normalize_colors(sol)\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def neighbors_of(idx: int) -> set:\n        neigh = set()\n        for (u, v) in E:\n            if u - 1 == idx:\n                neigh.add(v - 1)\n            elif v - 1 == idx:\n                neigh.add(u - 1)\n        return neigh\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[idx] = c\n        return _normalize_colors(sol)\n\n    # Strategy 2: attempt to reduce K by eliminating the max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    reduced = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        # try assign the smallest color strictly less than max_c\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            reduced = True\n    if reduced:\n        return _normalize_colors(sol)\n\n    # Strategy 3: Kempe chain swap between two colors to enable reduction later\n    # pick two colors a,b (prefer include max color)\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a = max(colors)\n        b = random.choice([c for c in colors if c != a])\n        # pick a random vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            # BFS on induced subgraph of colors {a,b}\n            queue = [start]\n            visited = set([start])\n            while queue:\n                v = queue.pop(0)\n                for nb in neighbors_of(v):\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        queue.append(nb)\n            # swap colors a<->b on visited component\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return _normalize_colors(sol)\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in neighbors_of(idx)}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return _normalize_colors(sol)\n","Perturbacion":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution: Any):\n    # Strong shake: multi-vertex recolor + optional color-class swap + greedy repair\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = _normalize_colors(sol)\n\n    def neighbors_of(idx: int) -> list:\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    # Step 1: random subset recolor into existing or new color\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap to reshuffle structure\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_colors = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001199445}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n      return PENALTY_BASE * 100\n    if len(solution) != n:\n      return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n      if not isinstance(x, int):\n        return PENALTY_BASE * 40\n      if x < 1:\n        return PENALTY_BASE * 30\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n      if solution[u-1] == solution[v-1]:\n        conflicts += 1\n    # Compute colors used\n    K = 0\n    for x in solution:\n      if x > K:\n        K = x\n    if conflicts > 0:\n      # Structured penalty to rank infeasible states\n      return PENALTY_BASE + 100 * conflicts + K\n    # Feasible: objective is number of colors used\n    return K\n","Vecindad":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    # Relabel colors to 1..m in order of first occurrence to stabilize K\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: Any):\n    \"\"\"\n    Neighbor operator for INDEX_LIST.\n    Movement types internally used:\n      - RECOLOR_CONFLICTED\n      - REDUCE_MAX_COLOR\n      - KEMPE_SWAP\n      - RANDOM_RECOLOR\n    Returns: new solution (INDEX_LIST)\n    \"\"\"\n    # Validate and clone\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1) for x in solution) or len(solution) != 9:\n        # create a simple random valid-length solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Normalize labels to avoid drift\n    sol = _normalize_colors(sol)\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def neighbors_of(idx: int) -> set:\n        neigh = set()\n        for (u, v) in E:\n            if u - 1 == idx:\n                neigh.add(v - 1)\n            elif v - 1 == idx:\n                neigh.add(u - 1)\n        return neigh\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[idx] = c\n        return _normalize_colors(sol)\n\n    # Strategy 2: attempt to reduce K by eliminating the max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    reduced = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        # try assign the smallest color strictly less than max_c\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            reduced = True\n    if reduced:\n        return _normalize_colors(sol)\n\n    # Strategy 3: Kempe chain swap between two colors to enable reduction later\n    # pick two colors a,b (prefer include max color)\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a = max(colors)\n        b = random.choice([c for c in colors if c != a])\n        # pick a random vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            # BFS on induced subgraph of colors {a,b}\n            queue = [start]\n            visited = set([start])\n            while queue:\n                v = queue.pop(0)\n                for nb in neighbors_of(v):\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        queue.append(nb)\n            # swap colors a<->b on visited component\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return _normalize_colors(sol)\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in neighbors_of(idx)}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return _normalize_colors(sol)\n","Perturbacion":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution: Any):\n    # Strong shake: multi-vertex recolor + optional color-class swap + greedy repair\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = _normalize_colors(sol)\n\n    def neighbors_of(idx: int) -> list:\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    # Step 1: random subset recolor into existing or new color\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap to reshuffle structure\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_colors = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001086934}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Early exit on first conflict (fast infeasible ranking)\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            return PENALTY_BASE + 100  # infeasible indicator\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color within [1..max_c], allow +1 only if necessary\n    if conflicted:\n        # bias: pick vertex with highest degree among conflicted\n        idx = max(conflicted, key=lambda i: len(adj[i]))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        c = 1\n        found = False\n        while c <= max_c:\n            if c not in neigh_cols:\n                sol[idx] = c\n                found = True\n                break\n            c += 1\n        if not found:\n            sol[idx] = max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Strategy 2: iterative reduction of max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    improved = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            improved = True\n    if improved:\n        return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return normalize(sol), \"KEMPE_SWAP\"\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def neighbors_of(idx):\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Step 1: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_cols = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001391067}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Early exit on first conflict (fast infeasible ranking)\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            return PENALTY_BASE + 100  # infeasible indicator\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color within [1..max_c], allow +1 only if necessary\n    if conflicted:\n        # bias: pick vertex with highest degree among conflicted\n        idx = max(conflicted, key=lambda i: len(adj[i]))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        c = 1\n        found = False\n        while c <= max_c:\n            if c not in neigh_cols:\n                sol[idx] = c\n                found = True\n                break\n            c += 1\n        if not found:\n            sol[idx] = max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Strategy 2: iterative reduction of max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    improved = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            improved = True\n    if improved:\n        return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return normalize(sol), \"KEMPE_SWAP\"\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def neighbors_of(idx):\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Step 1: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_cols = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001236246}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Early exit on first conflict (fast infeasible ranking)\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            return PENALTY_BASE + 100  # infeasible indicator\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color within [1..max_c], allow +1 only if necessary\n    if conflicted:\n        # bias: pick vertex with highest degree among conflicted\n        idx = max(conflicted, key=lambda i: len(adj[i]))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        c = 1\n        found = False\n        while c <= max_c:\n            if c not in neigh_cols:\n                sol[idx] = c\n                found = True\n                break\n            c += 1\n        if not found:\n            sol[idx] = max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Strategy 2: iterative reduction of max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    improved = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            improved = True\n    if improved:\n        return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return normalize(sol), \"KEMPE_SWAP\"\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def neighbors_of(idx):\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Step 1: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_cols = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001378457}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Compute conflict count for gradient penalties\n    conflict_count = 0\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            conflict_count += 1\n\n    if conflict_count > 0:\n        return PENALTY_BASE + conflict_count\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: DSATUR-biased recolor of a conflicted vertex (single change)\n    if conflicted:\n        def sat_deg(i):\n            return len({sol[j] for j in adj[i]})\n        idx = max(conflicted, key=lambda i: (sat_deg(i), len(adj[i])))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        best_c = None\n        best_proj = None\n        for c in range(1, max_c + 2):  # allow introducing one new color if needed\n            if c in neigh_cols:\n                continue\n            trial = sol[:]\n            trial[idx] = c\n            proj = conflict_count(trial)\n            if best_proj is None or proj < best_proj or (proj == best_proj and (best_c is None or c < best_c)):\n                best_proj = proj\n                best_c = c\n        sol[idx] = best_c if best_c is not None else max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Feasible region from here\n    max_c = max(sol) if sol else 1\n\n    # Strategy 2: try reducing max color by moving a single vertex to a lower feasible color\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        feasible = [c for c in range(1, max_c) if c not in neigh_cols]\n        if feasible:\n            # bias toward lower colors but randomize to avoid determinism\n            target = random.choice(feasible[:max(1, min(2, len(feasible)))])\n            sol[idx] = target\n            return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color; accept only if remains feasible\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            trial = sol[:]\n            for v in visited:\n                trial[v] = a if sol[v] == b else b\n            # accept only if feasible remains\n            if conflict_count(trial) == 0:\n                return normalize(trial), \"KEMPE_SWAP\"\n\n    # Strategy 4: random feasible recolor of a random vertex (single change)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    feasible = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n    if not feasible:\n        feasible = [max_c + 1]\n    # bias to smaller labels\n    feasible.sort()\n    pick_pool = feasible[:max(1, min(2, len(feasible)))]\n    sol[idx] = random.choice(pick_pool)\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def adj_list():\n        adj = {i: set() for i in range(n)}\n        for (u, v) in E:\n            ui, vi = u-1, v-1\n            adj[ui].add(vi)\n            adj[vi].add(ui)\n        return adj\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Initialize\/validate\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    adj = adj_list()\n\n    # Step 1: t random Kempe-like swaps focused on max color class to diversify\n    t = 2\n    for _ in range(t):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        target_colors = {a, b}\n        q = deque([start])\n        visited = {start}\n        while q:\n            v = q.popleft()\n            for nb in adj[v]:\n                if nb not in visited and sol[nb] in target_colors:\n                    visited.add(nb)\n                    q.append(nb)\n        for v in visited:\n            sol[v] = a if sol[v] == b else b\n\n    # Step 2: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 3: greedy repair to minimal feasible colors to restore feasibility\n    for v in range(n):\n        neigh_cols = {sol[j] for j in adj[v]}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001691482}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Compute conflict count for gradient penalties\n    conflict_count = 0\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            conflict_count += 1\n\n    if conflict_count > 0:\n        return PENALTY_BASE + conflict_count\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: DSATUR-biased recolor of a conflicted vertex (single change)\n    if conflicted:\n        def sat_deg(i):\n            return len({sol[j] for j in adj[i]})\n        idx = max(conflicted, key=lambda i: (sat_deg(i), len(adj[i])))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        best_c = None\n        best_proj = None\n        for c in range(1, max_c + 2):  # allow introducing one new color if needed\n            if c in neigh_cols:\n                continue\n            trial = sol[:]\n            trial[idx] = c\n            proj = conflict_count(trial)\n            if best_proj is None or proj < best_proj or (proj == best_proj and (best_c is None or c < best_c)):\n                best_proj = proj\n                best_c = c\n        sol[idx] = best_c if best_c is not None else max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Feasible region from here\n    max_c = max(sol) if sol else 1\n\n    # Strategy 2: try reducing max color by moving a single vertex to a lower feasible color\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        feasible = [c for c in range(1, max_c) if c not in neigh_cols]\n        if feasible:\n            # bias toward lower colors but randomize to avoid determinism\n            target = random.choice(feasible[:max(1, min(2, len(feasible)))])\n            sol[idx] = target\n            return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color; accept only if remains feasible\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            trial = sol[:]\n            for v in visited:\n                trial[v] = a if sol[v] == b else b\n            # accept only if feasible remains\n            if conflict_count(trial) == 0:\n                return normalize(trial), \"KEMPE_SWAP\"\n\n    # Strategy 4: random feasible recolor of a random vertex (single change)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    feasible = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n    if not feasible:\n        feasible = [max_c + 1]\n    # bias to smaller labels\n    feasible.sort()\n    pick_pool = feasible[:max(1, min(2, len(feasible)))]\n    sol[idx] = random.choice(pick_pool)\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def adj_list():\n        adj = {i: set() for i in range(n)}\n        for (u, v) in E:\n            ui, vi = u-1, v-1\n            adj[ui].add(vi)\n            adj[vi].add(ui)\n        return adj\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Initialize\/validate\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    adj = adj_list()\n\n    # Step 1: t random Kempe-like swaps focused on max color class to diversify\n    t = 2\n    for _ in range(t):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        target_colors = {a, b}\n        q = deque([start])\n        visited = {start}\n        while q:\n            v = q.popleft()\n            for nb in adj[v]:\n                if nb not in visited and sol[nb] in target_colors:\n                    visited.add(nb)\n                    q.append(nb)\n        for v in visited:\n            sol[v] = a if sol[v] == b else b\n\n    # Step 2: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 3: greedy repair to minimal feasible colors to restore feasibility\n    for v in range(n):\n        neigh_cols = {sol[j] for j in adj[v]}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001392197}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Compute conflict count for gradient penalties\n    conflict_count = 0\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            conflict_count += 1\n\n    if conflict_count > 0:\n        return PENALTY_BASE + conflict_count\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: DSATUR-biased recolor of a conflicted vertex (single change)\n    if conflicted:\n        def sat_deg(i):\n            return len({sol[j] for j in adj[i]})\n        idx = max(conflicted, key=lambda i: (sat_deg(i), len(adj[i])))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        best_c = None\n        best_proj = None\n        for c in range(1, max_c + 2):  # allow introducing one new color if needed\n            if c in neigh_cols:\n                continue\n            trial = sol[:]\n            trial[idx] = c\n            proj = conflict_count(trial)\n            if best_proj is None or proj < best_proj or (proj == best_proj and (best_c is None or c < best_c)):\n                best_proj = proj\n                best_c = c\n        sol[idx] = best_c if best_c is not None else max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Feasible region from here\n    max_c = max(sol) if sol else 1\n\n    # Strategy 2: try reducing max color by moving a single vertex to a lower feasible color\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        feasible = [c for c in range(1, max_c) if c not in neigh_cols]\n        if feasible:\n            # bias toward lower colors but randomize to avoid determinism\n            target = random.choice(feasible[:max(1, min(2, len(feasible)))])\n            sol[idx] = target\n            return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color; accept only if remains feasible\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            trial = sol[:]\n            for v in visited:\n                trial[v] = a if sol[v] == b else b\n            # accept only if feasible remains\n            if conflict_count(trial) == 0:\n                return normalize(trial), \"KEMPE_SWAP\"\n\n    # Strategy 4: random feasible recolor of a random vertex (single change)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    feasible = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n    if not feasible:\n        feasible = [max_c + 1]\n    # bias to smaller labels\n    feasible.sort()\n    pick_pool = feasible[:max(1, min(2, len(feasible)))]\n    sol[idx] = random.choice(pick_pool)\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def adj_list():\n        adj = {i: set() for i in range(n)}\n        for (u, v) in E:\n            ui, vi = u-1, v-1\n            adj[ui].add(vi)\n            adj[vi].add(ui)\n        return adj\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Initialize\/validate\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    adj = adj_list()\n\n    # Step 1: t random Kempe-like swaps focused on max color class to diversify\n    t = 2\n    for _ in range(t):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        target_colors = {a, b}\n        q = deque([start])\n        visited = {start}\n        while q:\n            v = q.popleft()\n            for nb in adj[v]:\n                if nb not in visited and sol[nb] in target_colors:\n                    visited.add(nb)\n                    q.append(nb)\n        for v in visited:\n            sol[v] = a if sol[v] == b else b\n\n    # Step 2: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 3: greedy repair to minimal feasible colors to restore feasibility\n    for v in range(n):\n        neigh_cols = {sol[j] for j in adj[v]}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001323797}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST of length 9; solution[i-1] is color of vertex i using positive integers starting at 1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and size\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints: adjacent vertices must have different colors\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Heuristic neighbor: prioritized conflict repair; else color-reduction recolor.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]  # safe no-op\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    # Helper: feasible colors for a vertex\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        # allow using colors 1..max(k,1)+1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a random conflicting vertex by recoloring to the smallest feasible\n        v = random.choice(list(conflicts))\n        feas = feasible_colors(v)\n        if feas:\n            # Prefer existing colors first to avoid increasing palette\n            feas_sorted = sorted(feas, key=lambda c: (c > k, c))\n            cur[v-1] = feas_sorted[0]\n        else:\n            # Fallback: assign a new color\n            cur[v-1] = k + 1\n        return cur\n\n    # No conflicts: try to reduce number of colors by recoloring one vertex of the highest color\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    # candidates from highest color class\n    candidates = [i+1 for i, col in enumerate(cur) if col == highest]\n    if not candidates:\n        return cur\n    random.shuffle(candidates)\n    for v in candidates:\n        feas = feasible_colors(v)\n        # Try only colors strictly less than 'highest' to reduce palette pressure\n        feas_reduct = [c for c in feas if c < highest]\n        if feas_reduct:\n            cur[v-1] = min(feas_reduct)\n            # Optional cleanup: if highest color becomes unused, remap gaps to compact palette\n            if highest not in cur:\n                # relabel colors to 1..m preserving relative order\n                mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n                cur = [mapping[c] for c in cur]\n            return cur\n\n    # If reduction failed, perform a mild recolor of a random vertex to a feasible alternative\n    v = random.randint(1, n)\n    feas = feasible_colors(v)\n    # remove current color if other options exist\n    alternatives = [c for c in feas if c != cur[v-1]]\n    if alternatives:\n        cur[v-1] = random.choice(alternatives)\n    return cur\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: randomly recolor a few vertices; may introduce a new color with small probability\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    p = random.randint(2, 4)  # number of vertices to perturb\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n        else:\n            # with small prob, allow using a new color k+1 if not forbidden\n            allow_new = random.random() < 0.2\n            choices = list(feas)\n            if allow_new and (k + 1) not in choices:\n                # ensure new color is allowed\n                if all(cur[nbr-1] != (k+1) for (u, nbr) in [(u, v) for (u, v) in E if u == v] ):\n                    pass  # not strictly necessary; edges ensure feasibility list is correct\n            # prefer changing color\n            alternatives = [c for c in choices if c != cur[v-1]]\n            if alternatives:\n                cur[v-1] = random.choice(alternatives)\n            else:\n                cur[v-1] = random.choice(choices)\n            k = max(k, cur[v-1])\n\n    # Optional palette compaction after perturbation\n    mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n    cur = [mapping[c] for c in cur]\n    return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001139915}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST of length 9; solution[i-1] is color of vertex i using positive integers starting at 1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and size\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints: adjacent vertices must have different colors\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Heuristic neighbor: prioritized conflict repair; else color-reduction recolor.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]  # safe no-op\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    # Helper: feasible colors for a vertex\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        # allow using colors 1..max(k,1)+1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a random conflicting vertex by recoloring to the smallest feasible\n        v = random.choice(list(conflicts))\n        feas = feasible_colors(v)\n        if feas:\n            # Prefer existing colors first to avoid increasing palette\n            feas_sorted = sorted(feas, key=lambda c: (c > k, c))\n            cur[v-1] = feas_sorted[0]\n        else:\n            # Fallback: assign a new color\n            cur[v-1] = k + 1\n        return cur\n\n    # No conflicts: try to reduce number of colors by recoloring one vertex of the highest color\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    # candidates from highest color class\n    candidates = [i+1 for i, col in enumerate(cur) if col == highest]\n    if not candidates:\n        return cur\n    random.shuffle(candidates)\n    for v in candidates:\n        feas = feasible_colors(v)\n        # Try only colors strictly less than 'highest' to reduce palette pressure\n        feas_reduct = [c for c in feas if c < highest]\n        if feas_reduct:\n            cur[v-1] = min(feas_reduct)\n            # Optional cleanup: if highest color becomes unused, remap gaps to compact palette\n            if highest not in cur:\n                # relabel colors to 1..m preserving relative order\n                mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n                cur = [mapping[c] for c in cur]\n            return cur\n\n    # If reduction failed, perform a mild recolor of a random vertex to a feasible alternative\n    v = random.randint(1, n)\n    feas = feasible_colors(v)\n    # remove current color if other options exist\n    alternatives = [c for c in feas if c != cur[v-1]]\n    if alternatives:\n        cur[v-1] = random.choice(alternatives)\n    return cur\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: randomly recolor a few vertices; may introduce a new color with small probability\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    p = random.randint(2, 4)  # number of vertices to perturb\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n        else:\n            # with small prob, allow using a new color k+1 if not forbidden\n            allow_new = random.random() < 0.2\n            choices = list(feas)\n            if allow_new and (k + 1) not in choices:\n                # ensure new color is allowed\n                if all(cur[nbr-1] != (k+1) for (u, nbr) in [(u, v) for (u, v) in E if u == v] ):\n                    pass  # not strictly necessary; edges ensure feasibility list is correct\n            # prefer changing color\n            alternatives = [c for c in choices if c != cur[v-1]]\n            if alternatives:\n                cur[v-1] = random.choice(alternatives)\n            else:\n                cur[v-1] = random.choice(choices)\n            k = max(k, cur[v-1])\n\n    # Optional palette compaction after perturbation\n    mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n    cur = [mapping[c] for c in cur]\n    return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000990322}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST of length 9; solution[i-1] is color of vertex i using positive integers starting at 1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and size\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints: adjacent vertices must have different colors\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Heuristic neighbor: prioritized conflict repair; else color-reduction recolor.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]  # safe no-op\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    # Helper: feasible colors for a vertex\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        # allow using colors 1..max(k,1)+1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a random conflicting vertex by recoloring to the smallest feasible\n        v = random.choice(list(conflicts))\n        feas = feasible_colors(v)\n        if feas:\n            # Prefer existing colors first to avoid increasing palette\n            feas_sorted = sorted(feas, key=lambda c: (c > k, c))\n            cur[v-1] = feas_sorted[0]\n        else:\n            # Fallback: assign a new color\n            cur[v-1] = k + 1\n        return cur\n\n    # No conflicts: try to reduce number of colors by recoloring one vertex of the highest color\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    # candidates from highest color class\n    candidates = [i+1 for i, col in enumerate(cur) if col == highest]\n    if not candidates:\n        return cur\n    random.shuffle(candidates)\n    for v in candidates:\n        feas = feasible_colors(v)\n        # Try only colors strictly less than 'highest' to reduce palette pressure\n        feas_reduct = [c for c in feas if c < highest]\n        if feas_reduct:\n            cur[v-1] = min(feas_reduct)\n            # Optional cleanup: if highest color becomes unused, remap gaps to compact palette\n            if highest not in cur:\n                # relabel colors to 1..m preserving relative order\n                mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n                cur = [mapping[c] for c in cur]\n            return cur\n\n    # If reduction failed, perform a mild recolor of a random vertex to a feasible alternative\n    v = random.randint(1, n)\n    feas = feasible_colors(v)\n    # remove current color if other options exist\n    alternatives = [c for c in feas if c != cur[v-1]]\n    if alternatives:\n        cur[v-1] = random.choice(alternatives)\n    return cur\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: randomly recolor a few vertices; may introduce a new color with small probability\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    p = random.randint(2, 4)  # number of vertices to perturb\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n        else:\n            # with small prob, allow using a new color k+1 if not forbidden\n            allow_new = random.random() < 0.2\n            choices = list(feas)\n            if allow_new and (k + 1) not in choices:\n                # ensure new color is allowed\n                if all(cur[nbr-1] != (k+1) for (u, nbr) in [(u, v) for (u, v) in E if u == v] ):\n                    pass  # not strictly necessary; edges ensure feasibility list is correct\n            # prefer changing color\n            alternatives = [c for c in choices if c != cur[v-1]]\n            if alternatives:\n                cur[v-1] = random.choice(alternatives)\n            else:\n                cur[v-1] = random.choice(choices)\n            k = max(k, cur[v-1])\n\n    # Optional palette compaction after perturbation\n    mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n    cur = [mapping[c] for c in cur]\n    return cur\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000979092}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST length=9; solution[i-1] is the color (positive int starting at 1) assigned to vertex i. Colors may be relabeled to maintain compact palette 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution: list):\n    # Graph coloring: return number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighboring solution (list of ints). Heuristic: conflict repair then color reduction.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n    cur = list(solution)\n    cur = compact_palette(cur)\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a conflicting vertex with highest degree first\n        v = max(conflicts, key=lambda x: (len(adj[x]), random.random()))\n        feas = feasible_colors(cur, v)\n        if feas:\n            # Prefer existing colors <= k, smallest first\n            feas.sort(key=lambda c: (c > k, c))\n            # Avoid current color if possible\n            candidates = [c for c in feas if c != cur[v-1]] or feas\n            cur[v-1] = candidates[0]\n        else:\n            cur[v-1] = k + 1\n        return compact_palette(cur)\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try multiple vertices from highest class\n    tried = 0\n    for v in class_vertices:\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != cur[v-1]]\n        if reduc:\n            cur[v-1] = min(reduc)\n            cur = compact_palette(cur)\n            return cur\n        tried += 1\n        if tried >= 3:\n            break\n\n    # If reduction failed, perform a mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != cur[v-1]]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    return compact_palette(cur)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: recolor a subset; may enable future color reduction. Palette is compacted at end.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    p = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        # Prefer changing color; slight chance to pick a higher\/new color to escape plateaus\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choices = alternatives or feas\n        cur[v-1] = random.choice(choices)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001291237}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST length=9; solution[i-1] is the color (positive int starting at 1) assigned to vertex i. Colors may be relabeled to maintain compact palette 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution: list):\n    # Graph coloring: return number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighboring solution (list of ints). Heuristic: conflict repair then color reduction.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n    cur = list(solution)\n    cur = compact_palette(cur)\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a conflicting vertex with highest degree first\n        v = max(conflicts, key=lambda x: (len(adj[x]), random.random()))\n        feas = feasible_colors(cur, v)\n        if feas:\n            # Prefer existing colors <= k, smallest first\n            feas.sort(key=lambda c: (c > k, c))\n            # Avoid current color if possible\n            candidates = [c for c in feas if c != cur[v-1]] or feas\n            cur[v-1] = candidates[0]\n        else:\n            cur[v-1] = k + 1\n        return compact_palette(cur)\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try multiple vertices from highest class\n    tried = 0\n    for v in class_vertices:\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != cur[v-1]]\n        if reduc:\n            cur[v-1] = min(reduc)\n            cur = compact_palette(cur)\n            return cur\n        tried += 1\n        if tried >= 3:\n            break\n\n    # If reduction failed, perform a mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != cur[v-1]]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    return compact_palette(cur)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: recolor a subset; may enable future color reduction. Palette is compacted at end.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    p = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        # Prefer changing color; slight chance to pick a higher\/new color to escape plateaus\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choices = alternatives or feas\n        cur[v-1] = random.choice(choices)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001132754}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST length=9; solution[i-1] is the color (positive int starting at 1) assigned to vertex i. Colors may be relabeled to maintain compact palette 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution: list):\n    # Graph coloring: return number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighboring solution (list of ints). Heuristic: conflict repair then color reduction.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n    cur = list(solution)\n    cur = compact_palette(cur)\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a conflicting vertex with highest degree first\n        v = max(conflicts, key=lambda x: (len(adj[x]), random.random()))\n        feas = feasible_colors(cur, v)\n        if feas:\n            # Prefer existing colors <= k, smallest first\n            feas.sort(key=lambda c: (c > k, c))\n            # Avoid current color if possible\n            candidates = [c for c in feas if c != cur[v-1]] or feas\n            cur[v-1] = candidates[0]\n        else:\n            cur[v-1] = k + 1\n        return compact_palette(cur)\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try multiple vertices from highest class\n    tried = 0\n    for v in class_vertices:\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != cur[v-1]]\n        if reduc:\n            cur[v-1] = min(reduc)\n            cur = compact_palette(cur)\n            return cur\n        tried += 1\n        if tried >= 3:\n            break\n\n    # If reduction failed, perform a mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != cur[v-1]]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    return compact_palette(cur)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: recolor a subset; may enable future color reduction. Palette is compacted at end.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    p = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        # Prefer changing color; slight chance to pick a higher\/new color to escape plateaus\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choices = alternatives or feas\n        cur[v-1] = random.choice(choices)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001099054}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9, 1-based colors. solution[i-1] is the color of vertex i. Colors are positive integers; palette compacted to 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Returns number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, Dict, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_metadata)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return same type with metadata indicating invalid input handled\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur)}\n\n    if conflicts:\n        # Select conflicting vertex with max saturation degree (DSATUR heuristic), tie-break by degree then random\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        if feas:\n            feas.sort()\n            # Prefer existing colors <= k and not equal to current color\n            feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n            cur[v-1] = feas_pref[0]\n        else:\n            cur[v-1] = k + 1\n        new_cur, post_map = compact_palette(cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur)\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction via highest color class move\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\"})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try recoloring up to 3 vertices from highest class to a lower feasible color\n    for v in class_vertices[:min(3, len(class_vertices))]:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            cur[v-1] = new_color\n            new_cur, post_map = compact_palette(cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur)\n            })\n            return new_cur, meta\n\n    # Mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != old]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    new_cur, post_map = compact_palette(cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur)\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor t random vertices; compact palette after\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choice_pool = alternatives or feas\n        cur[v-1] = random.choice(choice_pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000548}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9, 1-based colors. solution[i-1] is the color of vertex i. Colors are positive integers; palette compacted to 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Returns number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, Dict, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_metadata)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return same type with metadata indicating invalid input handled\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur)}\n\n    if conflicts:\n        # Select conflicting vertex with max saturation degree (DSATUR heuristic), tie-break by degree then random\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        if feas:\n            feas.sort()\n            # Prefer existing colors <= k and not equal to current color\n            feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n            cur[v-1] = feas_pref[0]\n        else:\n            cur[v-1] = k + 1\n        new_cur, post_map = compact_palette(cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur)\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction via highest color class move\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\"})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try recoloring up to 3 vertices from highest class to a lower feasible color\n    for v in class_vertices[:min(3, len(class_vertices))]:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            cur[v-1] = new_color\n            new_cur, post_map = compact_palette(cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur)\n            })\n            return new_cur, meta\n\n    # Mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != old]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    new_cur, post_map = compact_palette(cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur)\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor t random vertices; compact palette after\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choice_pool = alternatives or feas\n        cur[v-1] = random.choice(choice_pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000167}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9, 1-based colors. solution[i-1] is the color of vertex i. Colors are positive integers; palette compacted to 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Returns number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, Dict, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_metadata)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return same type with metadata indicating invalid input handled\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur)}\n\n    if conflicts:\n        # Select conflicting vertex with max saturation degree (DSATUR heuristic), tie-break by degree then random\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        if feas:\n            feas.sort()\n            # Prefer existing colors <= k and not equal to current color\n            feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n            cur[v-1] = feas_pref[0]\n        else:\n            cur[v-1] = k + 1\n        new_cur, post_map = compact_palette(cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur)\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction via highest color class move\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\"})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try recoloring up to 3 vertices from highest class to a lower feasible color\n    for v in class_vertices[:min(3, len(class_vertices))]:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            cur[v-1] = new_color\n            new_cur, post_map = compact_palette(cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur)\n            })\n            return new_cur, meta\n\n    # Mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != old]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    new_cur, post_map = compact_palette(cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur)\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor t random vertices; compact palette after\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choice_pool = alternatives or feas\n        cur[v-1] = random.choice(choice_pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000113}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9; solution[i-1] is the 1-based color assigned to vertex i. Colors are positive integers with a compact palette 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph Coloring evaluator: returns number of colors if feasible; else +inf\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Feasibility check: adjacent vertices must differ\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Cost = number of colors used\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import List, Dict, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution: List[int], move_metadata: Dict)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def num_conflicts(cols: List[int]) -> int:\n        c = 0\n        for (u, v) in E:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap at k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        # BFS on subgraph induced by colors {a,b} starting from v; swap a<->b on that component\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        new_cols = cols[:]\n        for x in comp:\n            new_cols[x-1] = a if cols[x-1] == b else b\n        return new_cols\n\n    # Validate and normalize input\n    if not isinstance(solution, list) or len(solution) != n:\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Conflict set\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur), \"pre_conflicts\": num_conflicts(cur)}\n\n    if conflicts:\n        # DSATUR-based repair with optional Kempe-chain\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        # Prefer colors <= k, avoid old if possible\n        feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n        new_cur = cur[:]\n        if feas_pref:\n            new_cur[v-1] = feas_pref[0]\n        else:\n            new_cur[v-1] = k + 1\n        # If still conflicting, try a Kempe-chain swap between old and chosen color\n        if num_conflicts(new_cur) >= num_conflicts(cur):\n            # pick neighbor color to swap with\n            neigh_colors = list({cur[nbr-1] for nbr in adj[v] if cur[nbr-1] != old}) or [((old % k) + 1) if k >= 1 else 1]\n            b = random.choice(neigh_colors)\n            a = old if old != b else ((b % max(k, 1)) + 1)\n            new_cur = kempe_chain_recolor(cur, v, a, b)\n        new_cur, post_map = compact_palette(new_cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur),\n            \"post_conflicts\": num_conflicts(new_cur),\n            \"delta_colors\": len(set(new_cur)) - len(set(cur))\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\", \"post_conflicts\": 0, \"delta_colors\": 0})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try all vertices in the highest class for reduction; exit on first success\n    for v in class_vertices:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            new_cur = cur[:]\n            new_cur[v-1] = new_color\n            new_cur, post_map = compact_palette(new_cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur),\n                \"post_conflicts\": num_conflicts(new_cur),\n                \"delta_colors\": len(set(new_cur)) - len(set(cur))\n            })\n            return new_cur, meta\n\n    # Diversification: recolor a random vertex to an alternative color (prefer <= k)\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt_existing = [c for c in feas if c != old and c <= k]\n    choice_pool = alt_existing or [c for c in feas if c != old] or feas\n    new_cur = cur[:]\n    new_cur[v-1] = random.choice(choice_pool)\n    new_cur, post_map = compact_palette(new_cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur),\n        \"post_conflicts\": num_conflicts(new_cur),\n        \"delta_colors\": len(set(new_cur)) - len(set(cur))\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification via multi-step Kempe-chain swaps and random recolors\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]) -> List[int]:\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap to at most k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        out = cols[:]\n        for x in comp:\n            out[x-1] = a if cols[x-1] == b else b\n        return out\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Perform p Kempe swaps on random vertices\n    p = random.randint(2, 4)\n    for _ in range(p):\n        v = random.randint(1, n)\n        # choose a neighbor color if possible, else random existing color\n        neigh_cols = list({cur[u-1] for u in adj[v] if cur[u-1] != cur[v-1]})\n        if not neigh_cols:\n            neigh_cols = list(set(cur))\n        if not neigh_cols:\n            continue\n        b = random.choice(neigh_cols)\n        a = cur[v-1]\n        if a == b:\n            continue\n        cur = kempe_chain_recolor(cur, v, a, b)\n\n    # Then randomly recolor t vertices (favor existing colors)\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alt_existing = [c for c in feas if c != cur[v-1] and c <= k]\n        pool = alt_existing or [c for c in feas if c != cur[v-1]] or feas\n        cur[v-1] = random.choice(pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001936114}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9; solution[i-1] is the 1-based color assigned to vertex i. Colors are positive integers with a compact palette 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph Coloring evaluator: returns number of colors if feasible; else +inf\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Feasibility check: adjacent vertices must differ\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Cost = number of colors used\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import List, Dict, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution: List[int], move_metadata: Dict)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def num_conflicts(cols: List[int]) -> int:\n        c = 0\n        for (u, v) in E:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap at k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        # BFS on subgraph induced by colors {a,b} starting from v; swap a<->b on that component\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        new_cols = cols[:]\n        for x in comp:\n            new_cols[x-1] = a if cols[x-1] == b else b\n        return new_cols\n\n    # Validate and normalize input\n    if not isinstance(solution, list) or len(solution) != n:\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Conflict set\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur), \"pre_conflicts\": num_conflicts(cur)}\n\n    if conflicts:\n        # DSATUR-based repair with optional Kempe-chain\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        # Prefer colors <= k, avoid old if possible\n        feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n        new_cur = cur[:]\n        if feas_pref:\n            new_cur[v-1] = feas_pref[0]\n        else:\n            new_cur[v-1] = k + 1\n        # If still conflicting, try a Kempe-chain swap between old and chosen color\n        if num_conflicts(new_cur) >= num_conflicts(cur):\n            # pick neighbor color to swap with\n            neigh_colors = list({cur[nbr-1] for nbr in adj[v] if cur[nbr-1] != old}) or [((old % k) + 1) if k >= 1 else 1]\n            b = random.choice(neigh_colors)\n            a = old if old != b else ((b % max(k, 1)) + 1)\n            new_cur = kempe_chain_recolor(cur, v, a, b)\n        new_cur, post_map = compact_palette(new_cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur),\n            \"post_conflicts\": num_conflicts(new_cur),\n            \"delta_colors\": len(set(new_cur)) - len(set(cur))\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\", \"post_conflicts\": 0, \"delta_colors\": 0})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try all vertices in the highest class for reduction; exit on first success\n    for v in class_vertices:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            new_cur = cur[:]\n            new_cur[v-1] = new_color\n            new_cur, post_map = compact_palette(new_cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur),\n                \"post_conflicts\": num_conflicts(new_cur),\n                \"delta_colors\": len(set(new_cur)) - len(set(cur))\n            })\n            return new_cur, meta\n\n    # Diversification: recolor a random vertex to an alternative color (prefer <= k)\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt_existing = [c for c in feas if c != old and c <= k]\n    choice_pool = alt_existing or [c for c in feas if c != old] or feas\n    new_cur = cur[:]\n    new_cur[v-1] = random.choice(choice_pool)\n    new_cur, post_map = compact_palette(new_cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur),\n        \"post_conflicts\": num_conflicts(new_cur),\n        \"delta_colors\": len(set(new_cur)) - len(set(cur))\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification via multi-step Kempe-chain swaps and random recolors\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]) -> List[int]:\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap to at most k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        out = cols[:]\n        for x in comp:\n            out[x-1] = a if cols[x-1] == b else b\n        return out\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Perform p Kempe swaps on random vertices\n    p = random.randint(2, 4)\n    for _ in range(p):\n        v = random.randint(1, n)\n        # choose a neighbor color if possible, else random existing color\n        neigh_cols = list({cur[u-1] for u in adj[v] if cur[u-1] != cur[v-1]})\n        if not neigh_cols:\n            neigh_cols = list(set(cur))\n        if not neigh_cols:\n            continue\n        b = random.choice(neigh_cols)\n        a = cur[v-1]\n        if a == b:\n            continue\n        cur = kempe_chain_recolor(cur, v, a, b)\n\n    # Then randomly recolor t vertices (favor existing colors)\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alt_existing = [c for c in feas if c != cur[v-1] and c <= k]\n        pool = alt_existing or [c for c in feas if c != cur[v-1]] or feas\n        cur[v-1] = random.choice(pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001624419}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9; solution[i-1] is the 1-based color assigned to vertex i. Colors are positive integers with a compact palette 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph Coloring evaluator: returns number of colors if feasible; else +inf\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Feasibility check: adjacent vertices must differ\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Cost = number of colors used\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import List, Dict, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution: List[int], move_metadata: Dict)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def num_conflicts(cols: List[int]) -> int:\n        c = 0\n        for (u, v) in E:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap at k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        # BFS on subgraph induced by colors {a,b} starting from v; swap a<->b on that component\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        new_cols = cols[:]\n        for x in comp:\n            new_cols[x-1] = a if cols[x-1] == b else b\n        return new_cols\n\n    # Validate and normalize input\n    if not isinstance(solution, list) or len(solution) != n:\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Conflict set\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur), \"pre_conflicts\": num_conflicts(cur)}\n\n    if conflicts:\n        # DSATUR-based repair with optional Kempe-chain\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        # Prefer colors <= k, avoid old if possible\n        feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n        new_cur = cur[:]\n        if feas_pref:\n            new_cur[v-1] = feas_pref[0]\n        else:\n            new_cur[v-1] = k + 1\n        # If still conflicting, try a Kempe-chain swap between old and chosen color\n        if num_conflicts(new_cur) >= num_conflicts(cur):\n            # pick neighbor color to swap with\n            neigh_colors = list({cur[nbr-1] for nbr in adj[v] if cur[nbr-1] != old}) or [((old % k) + 1) if k >= 1 else 1]\n            b = random.choice(neigh_colors)\n            a = old if old != b else ((b % max(k, 1)) + 1)\n            new_cur = kempe_chain_recolor(cur, v, a, b)\n        new_cur, post_map = compact_palette(new_cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur),\n            \"post_conflicts\": num_conflicts(new_cur),\n            \"delta_colors\": len(set(new_cur)) - len(set(cur))\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\", \"post_conflicts\": 0, \"delta_colors\": 0})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try all vertices in the highest class for reduction; exit on first success\n    for v in class_vertices:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            new_cur = cur[:]\n            new_cur[v-1] = new_color\n            new_cur, post_map = compact_palette(new_cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur),\n                \"post_conflicts\": num_conflicts(new_cur),\n                \"delta_colors\": len(set(new_cur)) - len(set(cur))\n            })\n            return new_cur, meta\n\n    # Diversification: recolor a random vertex to an alternative color (prefer <= k)\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt_existing = [c for c in feas if c != old and c <= k]\n    choice_pool = alt_existing or [c for c in feas if c != old] or feas\n    new_cur = cur[:]\n    new_cur[v-1] = random.choice(choice_pool)\n    new_cur, post_map = compact_palette(new_cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur),\n        \"post_conflicts\": num_conflicts(new_cur),\n        \"delta_colors\": len(set(new_cur)) - len(set(cur))\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification via multi-step Kempe-chain swaps and random recolors\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]) -> List[int]:\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap to at most k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        out = cols[:]\n        for x in comp:\n            out[x-1] = a if cols[x-1] == b else b\n        return out\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Perform p Kempe swaps on random vertices\n    p = random.randint(2, 4)\n    for _ in range(p):\n        v = random.randint(1, n)\n        # choose a neighbor color if possible, else random existing color\n        neigh_cols = list({cur[u-1] for u in adj[v] if cur[u-1] != cur[v-1]})\n        if not neigh_cols:\n            neigh_cols = list(set(cur))\n        if not neigh_cols:\n            continue\n        b = random.choice(neigh_cols)\n        a = cur[v-1]\n        if a == b:\n            continue\n        cur = kempe_chain_recolor(cur, v, a, b)\n\n    # Then randomly recolor t vertices (favor existing colors)\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alt_existing = [c for c in feas if c != cur[v-1] and c <= k]\n        pool = alt_existing or [c for c in feas if c != cur[v-1]] or feas\n        cur[v-1] = random.choice(pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002029395}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"INDEX_LIST_LEN9_POSINTS_COLORS_FOR_NODES_1..9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness combining feasibility and objective; lower is better\n    # Problem data embedded\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    k = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n        if x > k:\n            k = x\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Known lower bound from triangle (1,4,6)\n    lb = 3\n    if violations > 0:\n        return 1_000_000 + 10_000*violations + k\n    if k < lb:\n        return 100_000 + (lb - k)*10_000\n    # Tie-breaker: prefer lower sum of colors given same k to encourage compact color indices\n    sum_colors = 0\n    for x in solution:\n        sum_colors += x\n    return k*10_000 + sum_colors\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Generate a neighboring solution by either single-node recolor or color-swap\n    # Ensure input validity minimally; if invalid, attempt to repair by resetting to ones\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    # Decide move type\n    move_choice = random.random()\n    if move_choice < 0.7:\n        # Single node recolor within {1..max_color or max_color+1 with small prob}\n        idx = random.randrange(9)\n        current_max = max(sol)\n        # Allow exploring up to current_max+1 with small probability\n        if random.random() < 0.2:\n            new_color = random.randint(1, min(current_max + 1, max(4, current_max + 1)))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        # Avoid no-op\n        tries = 0\n        while new_color == sol[idx] and tries < 5:\n            new_color = random.randint(1, max(3, current_max))\n            tries += 1\n        new_sol = sol[:]\n        new_sol[idx] = new_color\n        return new_sol, \"Recolor-1\"\n    else:\n        # Swap two color labels to create a larger move while preserving feasibility if present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            idx = random.randrange(9)\n            current_max = max(sol)\n            new_color = random.randint(1, max(3, current_max))\n            if new_color == sol[idx]:\n                new_color = (new_color % max(3, current_max)) + 1\n            new_sol = sol[:]\n            new_sol[idx] = new_color\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Swap-Colors\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multiple random recolors to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    steps = random.randint(2, 5)\n    current_max = max(sol)\n    for _ in range(steps):\n        idx = random.randrange(9)\n        # Allow occasionally increasing max color to diversify search\n        if random.random() < 0.3:\n            new_color = random.randint(1, max(4, current_max + 1))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        if new_color == sol[idx]:\n            new_color = (new_color % max(3, max(sol))) + 1\n        sol[idx] = new_color\n        current_max = max(current_max, new_color)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000702318}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"INDEX_LIST_LEN9_POSINTS_COLORS_FOR_NODES_1..9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness combining feasibility and objective; lower is better\n    # Problem data embedded\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    k = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n        if x > k:\n            k = x\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Known lower bound from triangle (1,4,6)\n    lb = 3\n    if violations > 0:\n        return 1_000_000 + 10_000*violations + k\n    if k < lb:\n        return 100_000 + (lb - k)*10_000\n    # Tie-breaker: prefer lower sum of colors given same k to encourage compact color indices\n    sum_colors = 0\n    for x in solution:\n        sum_colors += x\n    return k*10_000 + sum_colors\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Generate a neighboring solution by either single-node recolor or color-swap\n    # Ensure input validity minimally; if invalid, attempt to repair by resetting to ones\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    # Decide move type\n    move_choice = random.random()\n    if move_choice < 0.7:\n        # Single node recolor within {1..max_color or max_color+1 with small prob}\n        idx = random.randrange(9)\n        current_max = max(sol)\n        # Allow exploring up to current_max+1 with small probability\n        if random.random() < 0.2:\n            new_color = random.randint(1, min(current_max + 1, max(4, current_max + 1)))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        # Avoid no-op\n        tries = 0\n        while new_color == sol[idx] and tries < 5:\n            new_color = random.randint(1, max(3, current_max))\n            tries += 1\n        new_sol = sol[:]\n        new_sol[idx] = new_color\n        return new_sol, \"Recolor-1\"\n    else:\n        # Swap two color labels to create a larger move while preserving feasibility if present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            idx = random.randrange(9)\n            current_max = max(sol)\n            new_color = random.randint(1, max(3, current_max))\n            if new_color == sol[idx]:\n                new_color = (new_color % max(3, current_max)) + 1\n            new_sol = sol[:]\n            new_sol[idx] = new_color\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Swap-Colors\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multiple random recolors to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    steps = random.randint(2, 5)\n    current_max = max(sol)\n    for _ in range(steps):\n        idx = random.randrange(9)\n        # Allow occasionally increasing max color to diversify search\n        if random.random() < 0.3:\n            new_color = random.randint(1, max(4, current_max + 1))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        if new_color == sol[idx]:\n            new_color = (new_color % max(3, max(sol))) + 1\n        sol[idx] = new_color\n        current_max = max(current_max, new_color)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000567527}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"INDEX_LIST_LEN9_POSINTS_COLORS_FOR_NODES_1..9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness combining feasibility and objective; lower is better\n    # Problem data embedded\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    k = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n        if x > k:\n            k = x\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Known lower bound from triangle (1,4,6)\n    lb = 3\n    if violations > 0:\n        return 1_000_000 + 10_000*violations + k\n    if k < lb:\n        return 100_000 + (lb - k)*10_000\n    # Tie-breaker: prefer lower sum of colors given same k to encourage compact color indices\n    sum_colors = 0\n    for x in solution:\n        sum_colors += x\n    return k*10_000 + sum_colors\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Generate a neighboring solution by either single-node recolor or color-swap\n    # Ensure input validity minimally; if invalid, attempt to repair by resetting to ones\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    # Decide move type\n    move_choice = random.random()\n    if move_choice < 0.7:\n        # Single node recolor within {1..max_color or max_color+1 with small prob}\n        idx = random.randrange(9)\n        current_max = max(sol)\n        # Allow exploring up to current_max+1 with small probability\n        if random.random() < 0.2:\n            new_color = random.randint(1, min(current_max + 1, max(4, current_max + 1)))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        # Avoid no-op\n        tries = 0\n        while new_color == sol[idx] and tries < 5:\n            new_color = random.randint(1, max(3, current_max))\n            tries += 1\n        new_sol = sol[:]\n        new_sol[idx] = new_color\n        return new_sol, \"Recolor-1\"\n    else:\n        # Swap two color labels to create a larger move while preserving feasibility if present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            idx = random.randrange(9)\n            current_max = max(sol)\n            new_color = random.randint(1, max(3, current_max))\n            if new_color == sol[idx]:\n                new_color = (new_color % max(3, current_max)) + 1\n            new_sol = sol[:]\n            new_sol[idx] = new_color\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Swap-Colors\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multiple random recolors to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    steps = random.randint(2, 5)\n    current_max = max(sol)\n    for _ in range(steps):\n        idx = random.randrange(9)\n        # Allow occasionally increasing max color to diversify search\n        if random.random() < 0.3:\n            new_color = random.randint(1, max(4, current_max + 1))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        if new_color == sol[idx]:\n            new_color = (new_color % max(3, max(sol))) + 1\n        sol[idx] = new_color\n        current_max = max(current_max, new_color)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000552647}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n    # Compute max color (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Degrees for structure-aware penalties\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Count violations and weighted conflict measure\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    lb = 3\n    if violations > 0:\n        # Large base + structure-aware gradient; lower is better\n        return 1_000_000 + 1000 * conflict_weight + 10 * k + violations\n    # Enforce known lower bound if labels produce k < lb\n    if k < lb:\n        return 100_000 + (lb - k) * 10_000\n    # Canonicalize labels to remove permutation bias\n    mapping = {}\n    nextc = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        canon.append(mapping[c])\n    kcanon = 0\n    ssum = 0\n    for c in canon:\n        ssum += c\n        if c > kcanon:\n            kcanon = c\n    # Primary objective on k, tie-break by compact label sum\n    return kcanon * 10_000 + ssum\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_list, move_tag)\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_swap(sol, start_node, c1, c2):\n        # Swap colors c1<->c2 on the Kempe chain component containing start_node\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    def try_k_reduction(sol):\n        # Attempt to eliminate the highest color by recoloring its nodes\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        targets = [i + 1 for i, c in enumerate(sol) if c == k]\n        random.shuffle(targets)\n        for node in targets:\n            # Try to assign the smallest feasible color in 1..k-1\n            new_c = lowest_feasible(node, sol, k - 1)\n            if new_c is None:\n                # Try Kempe-based escape with a random color among 1..k-1\n                pool = list(range(1, k))\n                random.shuffle(pool)\n                moved = False\n                for c2 in pool:\n                    if c2 == sol[node - 1]:\n                        continue\n                    candidate = kempe_swap(sol, node, k, c2)\n                    new_c2 = lowest_feasible(node, candidate, k - 1)\n                    if new_c2 is not None:\n                        candidate[node - 1] = new_c2\n                        sol = candidate\n                        moved = True\n                        break\n                if not moved:\n                    return sol, False\n            else:\n                sol[node - 1] = new_c\n        # If all reassigned, relabel to remove gaps\n        sol = canonize(sol)\n        return sol, True\n\n    # Initialize\/repair input\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    if r < 0.35:\n        # Conflict-directed recolor (or general recolor if no conflicts)\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        current_max = max(sol)\n        # Prefer colors within current range; occasionally allow +1 if currently feasible\n        allow_new = (viols == 0 and random.random() < 0.1)\n        upper = current_max + 1 if allow_new else current_max\n        upper = max(3, upper)\n        # Try lowest feasible first to bias towards feasibility\n        new_c = lowest_feasible(node, sol, upper)\n        if new_c is None:\n            # fallback random color\n            new_c = random.randint(1, upper)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % upper) + 1\n        new_sol = sol[:]\n        new_sol[node - 1] = new_c\n        return canonize(new_sol), \"Recolor-CD\"\n    elif r < 0.6:\n        # Color-label swap\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return canonize(new_sol), \"Swap-Labels\"\n    elif r < 0.85:\n        # Kempe-chain swap around a random node and random color pair present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        new_sol = kempe_swap(sol, node, c1, c2)\n        return canonize(new_sol), \"Kempe-Swap\"\n    else:\n        # Targeted k-reduction attempt\n        new_sol, ok = try_k_reduction(sol)\n        tag = \"K-Reduce-Success\" if ok else \"K-Reduce-Attempt\"\n        return canonize(new_sol), tag\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-step randomized perturbation combining recolors and Kempe swaps\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # random recolor within current range +\/- 1\n            idx = random.randrange(1, n + 1)\n            k = max(sol)\n            upper = max(3, k + (1 if random.random() < 0.2 else 0))\n            new_c = random.randint(1, upper)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % upper) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # label swap of two random colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap using two random colors from present set\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        # maintain canonical labeling after each sub-move\n        sol = canonize(sol)\n    return sol\n","Resultados":[[1,1,2,2,1,3,3,2,3],30018,[1,1,2,2,1,3,3,2,3],30018],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002574531}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n    # Compute max color (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Degrees for structure-aware penalties\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Count violations and weighted conflict measure\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    lb = 3\n    if violations > 0:\n        # Large base + structure-aware gradient; lower is better\n        return 1_000_000 + 1000 * conflict_weight + 10 * k + violations\n    # Enforce known lower bound if labels produce k < lb\n    if k < lb:\n        return 100_000 + (lb - k) * 10_000\n    # Canonicalize labels to remove permutation bias\n    mapping = {}\n    nextc = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        canon.append(mapping[c])\n    kcanon = 0\n    ssum = 0\n    for c in canon:\n        ssum += c\n        if c > kcanon:\n            kcanon = c\n    # Primary objective on k, tie-break by compact label sum\n    return kcanon * 10_000 + ssum\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_list, move_tag)\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_swap(sol, start_node, c1, c2):\n        # Swap colors c1<->c2 on the Kempe chain component containing start_node\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    def try_k_reduction(sol):\n        # Attempt to eliminate the highest color by recoloring its nodes\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        targets = [i + 1 for i, c in enumerate(sol) if c == k]\n        random.shuffle(targets)\n        for node in targets:\n            # Try to assign the smallest feasible color in 1..k-1\n            new_c = lowest_feasible(node, sol, k - 1)\n            if new_c is None:\n                # Try Kempe-based escape with a random color among 1..k-1\n                pool = list(range(1, k))\n                random.shuffle(pool)\n                moved = False\n                for c2 in pool:\n                    if c2 == sol[node - 1]:\n                        continue\n                    candidate = kempe_swap(sol, node, k, c2)\n                    new_c2 = lowest_feasible(node, candidate, k - 1)\n                    if new_c2 is not None:\n                        candidate[node - 1] = new_c2\n                        sol = candidate\n                        moved = True\n                        break\n                if not moved:\n                    return sol, False\n            else:\n                sol[node - 1] = new_c\n        # If all reassigned, relabel to remove gaps\n        sol = canonize(sol)\n        return sol, True\n\n    # Initialize\/repair input\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    if r < 0.35:\n        # Conflict-directed recolor (or general recolor if no conflicts)\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        current_max = max(sol)\n        # Prefer colors within current range; occasionally allow +1 if currently feasible\n        allow_new = (viols == 0 and random.random() < 0.1)\n        upper = current_max + 1 if allow_new else current_max\n        upper = max(3, upper)\n        # Try lowest feasible first to bias towards feasibility\n        new_c = lowest_feasible(node, sol, upper)\n        if new_c is None:\n            # fallback random color\n            new_c = random.randint(1, upper)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % upper) + 1\n        new_sol = sol[:]\n        new_sol[node - 1] = new_c\n        return canonize(new_sol), \"Recolor-CD\"\n    elif r < 0.6:\n        # Color-label swap\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return canonize(new_sol), \"Swap-Labels\"\n    elif r < 0.85:\n        # Kempe-chain swap around a random node and random color pair present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        new_sol = kempe_swap(sol, node, c1, c2)\n        return canonize(new_sol), \"Kempe-Swap\"\n    else:\n        # Targeted k-reduction attempt\n        new_sol, ok = try_k_reduction(sol)\n        tag = \"K-Reduce-Success\" if ok else \"K-Reduce-Attempt\"\n        return canonize(new_sol), tag\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-step randomized perturbation combining recolors and Kempe swaps\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # random recolor within current range +\/- 1\n            idx = random.randrange(1, n + 1)\n            k = max(sol)\n            upper = max(3, k + (1 if random.random() < 0.2 else 0))\n            new_c = random.randint(1, upper)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % upper) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # label swap of two random colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap using two random colors from present set\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        # maintain canonical labeling after each sub-move\n        sol = canonize(sol)\n    return sol\n","Resultados":[[1,2,1,1,1,2,3,2,1],30018,[1,1,2,2,1,3,3,2,3],30018],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002854336}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n    # Compute max color (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Degrees for structure-aware penalties\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Count violations and weighted conflict measure\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    lb = 3\n    if violations > 0:\n        # Large base + structure-aware gradient; lower is better\n        return 1_000_000 + 1000 * conflict_weight + 10 * k + violations\n    # Enforce known lower bound if labels produce k < lb\n    if k < lb:\n        return 100_000 + (lb - k) * 10_000\n    # Canonicalize labels to remove permutation bias\n    mapping = {}\n    nextc = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        canon.append(mapping[c])\n    kcanon = 0\n    ssum = 0\n    for c in canon:\n        ssum += c\n        if c > kcanon:\n            kcanon = c\n    # Primary objective on k, tie-break by compact label sum\n    return kcanon * 10_000 + ssum\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_list, move_tag)\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_swap(sol, start_node, c1, c2):\n        # Swap colors c1<->c2 on the Kempe chain component containing start_node\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    def try_k_reduction(sol):\n        # Attempt to eliminate the highest color by recoloring its nodes\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        targets = [i + 1 for i, c in enumerate(sol) if c == k]\n        random.shuffle(targets)\n        for node in targets:\n            # Try to assign the smallest feasible color in 1..k-1\n            new_c = lowest_feasible(node, sol, k - 1)\n            if new_c is None:\n                # Try Kempe-based escape with a random color among 1..k-1\n                pool = list(range(1, k))\n                random.shuffle(pool)\n                moved = False\n                for c2 in pool:\n                    if c2 == sol[node - 1]:\n                        continue\n                    candidate = kempe_swap(sol, node, k, c2)\n                    new_c2 = lowest_feasible(node, candidate, k - 1)\n                    if new_c2 is not None:\n                        candidate[node - 1] = new_c2\n                        sol = candidate\n                        moved = True\n                        break\n                if not moved:\n                    return sol, False\n            else:\n                sol[node - 1] = new_c\n        # If all reassigned, relabel to remove gaps\n        sol = canonize(sol)\n        return sol, True\n\n    # Initialize\/repair input\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    if r < 0.35:\n        # Conflict-directed recolor (or general recolor if no conflicts)\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        current_max = max(sol)\n        # Prefer colors within current range; occasionally allow +1 if currently feasible\n        allow_new = (viols == 0 and random.random() < 0.1)\n        upper = current_max + 1 if allow_new else current_max\n        upper = max(3, upper)\n        # Try lowest feasible first to bias towards feasibility\n        new_c = lowest_feasible(node, sol, upper)\n        if new_c is None:\n            # fallback random color\n            new_c = random.randint(1, upper)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % upper) + 1\n        new_sol = sol[:]\n        new_sol[node - 1] = new_c\n        return canonize(new_sol), \"Recolor-CD\"\n    elif r < 0.6:\n        # Color-label swap\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return canonize(new_sol), \"Swap-Labels\"\n    elif r < 0.85:\n        # Kempe-chain swap around a random node and random color pair present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        new_sol = kempe_swap(sol, node, c1, c2)\n        return canonize(new_sol), \"Kempe-Swap\"\n    else:\n        # Targeted k-reduction attempt\n        new_sol, ok = try_k_reduction(sol)\n        tag = \"K-Reduce-Success\" if ok else \"K-Reduce-Attempt\"\n        return canonize(new_sol), tag\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-step randomized perturbation combining recolors and Kempe swaps\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # random recolor within current range +\/- 1\n            idx = random.randrange(1, n + 1)\n            k = max(sol)\n            upper = max(3, k + (1 if random.random() < 0.2 else 0))\n            new_c = random.randint(1, upper)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % upper) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # label swap of two random colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap using two random colors from present set\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        # maintain canonical labeling after each sub-move\n        sol = canonize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00165652}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data (no globals)\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000\n    # Compute k and degrees\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Violations and conflict weight\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    # Scoring\n    if violations > 0:\n        base = 100_000\n        alpha = 2_000  # per conflicting edge\n        beta = 3       # structure-aware gradient\n        return base + alpha * violations + beta * conflict_weight + k\n    # Feasible: primary = minimize k; secondary deterministic tie-break by class sizes\n    # Count color class sizes irrespective of labels\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    sizes = sorted(counts.values(), reverse=True)\n    s1 = sizes[0] if len(sizes) > 0 else 0\n    s2 = sizes[1] if len(sizes) > 1 else 0\n    # Prefer larger leading classes (more compact usage) deterministically\n    secondary = (100 - s1) * 100 + (100 - s2)\n    return k * 10_000 + secondary\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data and precomputations scoped locally (no globals)\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol: List[int]):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node: int, color: int, sol: List[int]) -> bool:\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node: int, sol: List[int], max_color: int):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    # 1) Conflict-directed recolor (no k increase when currently feasible)\n    if r < 0.4:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a node with highest degree bias\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, k)\n        if new_c is None:\n            # fallback: random color in 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"Recolor-CD\"\n    # 2) Kempe-chain swap using two present colors\n    elif r < 0.75:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        # Build Kempe component and swap\n        stack = [node]\n        visited = set()\n        component = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                component.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in component:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n    # 3) Label swap of two colors present (diversification without changing feasibility)\n    else:\n        colors_present = list(set(sol))\n        if len(colors_present) >= 2:\n            c1, c2 = random.sample(colors_present, 2)\n            mapping = {c1: c2, c2: c1}\n            new_sol = [mapping.get(x, x) for x in sol]\n            return new_sol, \"Swap-Labels\"\n        # Fallback single recolor\n        node = random.randrange(1, n + 1)\n        new_sol = sol[:]\n        new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n        return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Embedded problem data\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start_node: int, c1: int, c2: int) -> List[int]:\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair and lock k to current max to avoid unnecessary expansion\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n    k = max(sol)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # random recolor within 1..k (k-preserving)\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.75:\n            # color label swap for diversification\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap between two present colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001560409}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data (no globals)\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000\n    # Compute k and degrees\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Violations and conflict weight\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    # Scoring\n    if violations > 0:\n        base = 100_000\n        alpha = 2_000  # per conflicting edge\n        beta = 3       # structure-aware gradient\n        return base + alpha * violations + beta * conflict_weight + k\n    # Feasible: primary = minimize k; secondary deterministic tie-break by class sizes\n    # Count color class sizes irrespective of labels\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    sizes = sorted(counts.values(), reverse=True)\n    s1 = sizes[0] if len(sizes) > 0 else 0\n    s2 = sizes[1] if len(sizes) > 1 else 0\n    # Prefer larger leading classes (more compact usage) deterministically\n    secondary = (100 - s1) * 100 + (100 - s2)\n    return k * 10_000 + secondary\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data and precomputations scoped locally (no globals)\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol: List[int]):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node: int, color: int, sol: List[int]) -> bool:\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node: int, sol: List[int], max_color: int):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    # 1) Conflict-directed recolor (no k increase when currently feasible)\n    if r < 0.4:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a node with highest degree bias\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, k)\n        if new_c is None:\n            # fallback: random color in 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"Recolor-CD\"\n    # 2) Kempe-chain swap using two present colors\n    elif r < 0.75:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        # Build Kempe component and swap\n        stack = [node]\n        visited = set()\n        component = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                component.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in component:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n    # 3) Label swap of two colors present (diversification without changing feasibility)\n    else:\n        colors_present = list(set(sol))\n        if len(colors_present) >= 2:\n            c1, c2 = random.sample(colors_present, 2)\n            mapping = {c1: c2, c2: c1}\n            new_sol = [mapping.get(x, x) for x in sol]\n            return new_sol, \"Swap-Labels\"\n        # Fallback single recolor\n        node = random.randrange(1, n + 1)\n        new_sol = sol[:]\n        new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n        return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Embedded problem data\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start_node: int, c1: int, c2: int) -> List[int]:\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair and lock k to current max to avoid unnecessary expansion\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n    k = max(sol)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # random recolor within 1..k (k-preserving)\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.75:\n            # color label swap for diversification\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap between two present colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001376887}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data (no globals)\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000\n    # Compute k and degrees\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Violations and conflict weight\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    # Scoring\n    if violations > 0:\n        base = 100_000\n        alpha = 2_000  # per conflicting edge\n        beta = 3       # structure-aware gradient\n        return base + alpha * violations + beta * conflict_weight + k\n    # Feasible: primary = minimize k; secondary deterministic tie-break by class sizes\n    # Count color class sizes irrespective of labels\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    sizes = sorted(counts.values(), reverse=True)\n    s1 = sizes[0] if len(sizes) > 0 else 0\n    s2 = sizes[1] if len(sizes) > 1 else 0\n    # Prefer larger leading classes (more compact usage) deterministically\n    secondary = (100 - s1) * 100 + (100 - s2)\n    return k * 10_000 + secondary\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data and precomputations scoped locally (no globals)\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol: List[int]):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node: int, color: int, sol: List[int]) -> bool:\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node: int, sol: List[int], max_color: int):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    # 1) Conflict-directed recolor (no k increase when currently feasible)\n    if r < 0.4:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a node with highest degree bias\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, k)\n        if new_c is None:\n            # fallback: random color in 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"Recolor-CD\"\n    # 2) Kempe-chain swap using two present colors\n    elif r < 0.75:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        # Build Kempe component and swap\n        stack = [node]\n        visited = set()\n        component = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                component.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in component:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n    # 3) Label swap of two colors present (diversification without changing feasibility)\n    else:\n        colors_present = list(set(sol))\n        if len(colors_present) >= 2:\n            c1, c2 = random.sample(colors_present, 2)\n            mapping = {c1: c2, c2: c1}\n            new_sol = [mapping.get(x, x) for x in sol]\n            return new_sol, \"Swap-Labels\"\n        # Fallback single recolor\n        node = random.randrange(1, n + 1)\n        new_sol = sol[:]\n        new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n        return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Embedded problem data\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start_node: int, c1: int, c2: int) -> List[int]:\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair and lock k to current max to avoid unnecessary expansion\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n    k = max(sol)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # random recolor within 1..k (k-preserving)\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.75:\n            # color label swap for diversification\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap between two present colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001247355}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"List of length 9 with positive integers as color labels, e.g., [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci>=1.","Evaluacion":"import random\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n\n    # Build adjacency and degrees (local scope)\n    adj = {i: [] for i in range(1, n + 1)}\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    # Count violations\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n\n    if violations > 0:\n        # Infeasible: make score strictly worse than any feasible\n        base = 20_000_000\n        alpha = 50_000\n        beta = 100\n        return base + alpha * violations + beta * conflict_weight + max(solution)\n\n    # Feasible: primary objective = minimize number of colors actually used\n    colors_present = {}\n    for c in solution:\n        colors_present[c] = 1\n    k = len(colors_present)\n\n    # Secondary: encourage balanced\/mergeable classes via larger min class size\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    min_class_size = min(counts.values()) if counts else 0\n\n    secondary = 1000 - min_class_size\n    return k * 1_000_000 + secondary\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency (local)\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n        return conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_component(sol, start, c1, c2):\n        stack = [start]\n        visited = set()\n        comp = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        return comp\n\n    # Prepare working copy\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k (symmetry reduction, stable k tracking)\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n    conf_nodes = conflicts(sol)\n\n    r = random.random()\n\n    # 0) Targeted color-drop attempt on highest label\n    if r < 0.2 and k > 1:\n        target_color = k\n        vertices = [i for i in range(1, n + 1) if sol[i - 1] == target_color]\n        new_sol = sol[:]\n        possible = True\n        for v in vertices:\n            # try greedy recolor into 1..k-1\n            recol = None\n            for c in range(1, k):\n                if feasible_color(v, c, new_sol):\n                    recol = c\n                    break\n            if recol is None:\n                possible = False\n                break\n            new_sol[v - 1] = recol\n        if possible:\n            # remove unused highest label -> reduce k\n            return new_sol, \"Color-Drop\"\n        # fallthrough to other moves if drop fails\n\n    # 1) Conflict-directed recolor\n    if r < 0.55:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a high-degree node to perturb\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, max(1, k))\n        if new_c is None:\n            # fallback random different color within 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"CD-Recolor\"\n\n    # 2) Kempe-chain swap using two present colors (conflict-guided when possible)\n    if r < 0.85:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        c1, c2 = random.sample(colors_present, 2)\n        comp = kempe_component(sol, node, c1, c2)\n        new_sol = sol[:]\n        for u in comp:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n\n    # 3) Label swap (diversification, symmetry move)\n    colors_present = list(set(sol))\n    if len(colors_present) >= 2:\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Label-Swap\"\n\n    # Fallback single-node recolor\n    node = random.randrange(1, n + 1)\n    new_sol = sol[:]\n    new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n    return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n\n    steps = random.randint(4, 8)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # multiple random recolors within current palette\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # Kempe-chain kick\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        else:\n            # Color label cycle among up to 3 colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 3:\n                c1, c2, c3 = random.sample(colors_present, 3)\n                mapping = {c1: c2, c2: c3, c3: c1}\n                sol = [mapping.get(x, x) for x in sol]\n            elif len(colors_present) == 2:\n                c1, c2 = colors_present\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n\n    return sol\n","Resultados":[[3,3,2,2,3,1,1,2,1],3000997,[2,2,3,3,2,1,1,3,1],3000997],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002345699}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"List of length 9 with positive integers as color labels, e.g., [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci>=1.","Evaluacion":"import random\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n\n    # Build adjacency and degrees (local scope)\n    adj = {i: [] for i in range(1, n + 1)}\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    # Count violations\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n\n    if violations > 0:\n        # Infeasible: make score strictly worse than any feasible\n        base = 20_000_000\n        alpha = 50_000\n        beta = 100\n        return base + alpha * violations + beta * conflict_weight + max(solution)\n\n    # Feasible: primary objective = minimize number of colors actually used\n    colors_present = {}\n    for c in solution:\n        colors_present[c] = 1\n    k = len(colors_present)\n\n    # Secondary: encourage balanced\/mergeable classes via larger min class size\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    min_class_size = min(counts.values()) if counts else 0\n\n    secondary = 1000 - min_class_size\n    return k * 1_000_000 + secondary\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency (local)\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n        return conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_component(sol, start, c1, c2):\n        stack = [start]\n        visited = set()\n        comp = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        return comp\n\n    # Prepare working copy\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k (symmetry reduction, stable k tracking)\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n    conf_nodes = conflicts(sol)\n\n    r = random.random()\n\n    # 0) Targeted color-drop attempt on highest label\n    if r < 0.2 and k > 1:\n        target_color = k\n        vertices = [i for i in range(1, n + 1) if sol[i - 1] == target_color]\n        new_sol = sol[:]\n        possible = True\n        for v in vertices:\n            # try greedy recolor into 1..k-1\n            recol = None\n            for c in range(1, k):\n                if feasible_color(v, c, new_sol):\n                    recol = c\n                    break\n            if recol is None:\n                possible = False\n                break\n            new_sol[v - 1] = recol\n        if possible:\n            # remove unused highest label -> reduce k\n            return new_sol, \"Color-Drop\"\n        # fallthrough to other moves if drop fails\n\n    # 1) Conflict-directed recolor\n    if r < 0.55:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a high-degree node to perturb\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, max(1, k))\n        if new_c is None:\n            # fallback random different color within 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"CD-Recolor\"\n\n    # 2) Kempe-chain swap using two present colors (conflict-guided when possible)\n    if r < 0.85:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        c1, c2 = random.sample(colors_present, 2)\n        comp = kempe_component(sol, node, c1, c2)\n        new_sol = sol[:]\n        for u in comp:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n\n    # 3) Label swap (diversification, symmetry move)\n    colors_present = list(set(sol))\n    if len(colors_present) >= 2:\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Label-Swap\"\n\n    # Fallback single-node recolor\n    node = random.randrange(1, n + 1)\n    new_sol = sol[:]\n    new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n    return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n\n    steps = random.randint(4, 8)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # multiple random recolors within current palette\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # Kempe-chain kick\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        else:\n            # Color label cycle among up to 3 colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 3:\n                c1, c2, c3 = random.sample(colors_present, 3)\n                mapping = {c1: c2, c2: c3, c3: c1}\n                sol = [mapping.get(x, x) for x in sol]\n            elif len(colors_present) == 2:\n                c1, c2 = colors_present\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n\n    return sol\n","Resultados":[[1,1,1,1,1,1,1,1,1],3000997,[2,2,3,3,2,1,1,3,1],3000997],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002189137}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"List of length 9 with positive integers as color labels, e.g., [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci>=1.","Evaluacion":"import random\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n\n    # Build adjacency and degrees (local scope)\n    adj = {i: [] for i in range(1, n + 1)}\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    # Count violations\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n\n    if violations > 0:\n        # Infeasible: make score strictly worse than any feasible\n        base = 20_000_000\n        alpha = 50_000\n        beta = 100\n        return base + alpha * violations + beta * conflict_weight + max(solution)\n\n    # Feasible: primary objective = minimize number of colors actually used\n    colors_present = {}\n    for c in solution:\n        colors_present[c] = 1\n    k = len(colors_present)\n\n    # Secondary: encourage balanced\/mergeable classes via larger min class size\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    min_class_size = min(counts.values()) if counts else 0\n\n    secondary = 1000 - min_class_size\n    return k * 1_000_000 + secondary\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency (local)\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n        return conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_component(sol, start, c1, c2):\n        stack = [start]\n        visited = set()\n        comp = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        return comp\n\n    # Prepare working copy\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k (symmetry reduction, stable k tracking)\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n    conf_nodes = conflicts(sol)\n\n    r = random.random()\n\n    # 0) Targeted color-drop attempt on highest label\n    if r < 0.2 and k > 1:\n        target_color = k\n        vertices = [i for i in range(1, n + 1) if sol[i - 1] == target_color]\n        new_sol = sol[:]\n        possible = True\n        for v in vertices:\n            # try greedy recolor into 1..k-1\n            recol = None\n            for c in range(1, k):\n                if feasible_color(v, c, new_sol):\n                    recol = c\n                    break\n            if recol is None:\n                possible = False\n                break\n            new_sol[v - 1] = recol\n        if possible:\n            # remove unused highest label -> reduce k\n            return new_sol, \"Color-Drop\"\n        # fallthrough to other moves if drop fails\n\n    # 1) Conflict-directed recolor\n    if r < 0.55:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a high-degree node to perturb\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, max(1, k))\n        if new_c is None:\n            # fallback random different color within 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"CD-Recolor\"\n\n    # 2) Kempe-chain swap using two present colors (conflict-guided when possible)\n    if r < 0.85:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        c1, c2 = random.sample(colors_present, 2)\n        comp = kempe_component(sol, node, c1, c2)\n        new_sol = sol[:]\n        for u in comp:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n\n    # 3) Label swap (diversification, symmetry move)\n    colors_present = list(set(sol))\n    if len(colors_present) >= 2:\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Label-Swap\"\n\n    # Fallback single-node recolor\n    node = random.randrange(1, n + 1)\n    new_sol = sol[:]\n    new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n    return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n\n    steps = random.randint(4, 8)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # multiple random recolors within current palette\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # Kempe-chain kick\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        else:\n            # Color label cycle among up to 3 colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 3:\n                c1, c2, c3 = random.sample(colors_present, 3)\n                mapping = {c1: c2, c2: c3, c3: c1}\n                sol = [mapping.get(x, x) for x in sol]\n            elif len(colors_present) == 2:\n                c1, c2 = colors_present\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001335047}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. solution[i] = color for vertex i+1. Labels arbitrary positive ints; evaluator canonically relabels to consecutive 1..k in first-appearance order.","Evaluacion":"import itertools\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    # Type checks and canonical relabeling\n    if not isinstance(solution, list):\n        return 10**9\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n    violations = 0\n    if len(colors) == n:\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                violations += 1\n    else:\n        # Length mismatch penalty with partial checks when available\n        partial_len_pen = abs(len(colors) - n)\n        for (u,v) in edges:\n            if u-1 < len(colors) and v-1 < len(colors):\n                if colors[u-1] == colors[v-1]:\n                    violations += 1\n        return violations * 1000 + partial_len_pen * 100 + (k if k > 0 else 0)\n    # Lower-bound via clique number (omega)\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n    V = list(range(1, n+1))\n    def is_clique(nodes):\n        for i in range(len(nodes)):\n            a = nodes[i]\n            for j in range(i+1, len(nodes)):\n                b = nodes[j]\n                e = (a,b) if a < b else (b,a)\n                if e not in Eset:\n                    return False\n        return True\n    omega = 1\n    for r in range(2, n+1):\n        found = False\n        for comb in itertools.combinations(V, r):\n            if is_clique(list(comb)):\n                omega = r\n                found = True\n        if not found:\n            break\n    fitness = violations * 1000 + k\n    if k < omega:\n        fitness += (omega - k) * 100\n    return fitness\n","Vecindad":"import random\nfrom copy import deepcopy\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Robust input handling\n    if not isinstance(solution, list) or len(solution) == 0:\n        # initialize a random length-9 solution with small color set\n        n = 9\n        base_k = 3\n        neighbor = [random.randint(1, base_k) for _ in range(n)]\n        return neighbor, (\"Random\", \"Initialize\")\n    n = len(solution)\n    neighbor = list(solution)\n    # Ensure positive ints\n    for i,x in enumerate(neighbor):\n        if not isinstance(x, int) or x <= 0:\n            neighbor[i] = 1\n    # Recolor one vertex to an existing or new color (max+1)\n    idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n    current_colors = set(c for c in neighbor if isinstance(c, int) and c > 0)\n    max_c = max(current_colors) if current_colors else 1\n    candidate_colors = list(range(1, max_c + 2))\n    new_c = random.choice(candidate_colors)\n    # Avoid null move if possible\n    if new_c == neighbor[idx] and len(candidate_colors) > 1:\n        candidate_colors.remove(new_c)\n        new_c = random.choice(candidate_colors)\n    neighbor[idx] = new_c\n    return neighbor, (\"Random\", \"RecolorOneVertex\")\n","Perturbacion":"import random\nfrom copy import deepcopy\n\ndef perturb_solution(solution):\n    # Applies multiple random recolorings; returns perturbed solution only\n    if not isinstance(solution, list) or len(solution) == 0:\n        n = 9\n        base_k = 3\n        return [random.randint(1, base_k) for _ in range(n)]\n    n = len(solution)\n    pert = list(solution)\n    for i,x in enumerate(pert):\n        if not isinstance(x, int) or x <= 0:\n            pert[i] = 1\n    # Number of perturbations proportional to n (at least 2)\n    steps = max(2, min(5, n \/\/ 3))\n    for _ in range(steps):\n        idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n        current_colors = set(c for c in pert if isinstance(c, int) and c > 0)\n        max_c = max(current_colors) if current_colors else 1\n        candidate_colors = list(range(1, max_c + 2))\n        new_c = random.choice(candidate_colors)\n        if new_c == pert[idx] and len(candidate_colors) > 1:\n            candidate_colors.remove(new_c)\n            new_c = random.choice(candidate_colors)\n        pert[idx] = new_c\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: name 'itertools' is not defined","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001153244}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. solution[i] = color for vertex i+1. Labels arbitrary positive ints; evaluator canonically relabels to consecutive 1..k in first-appearance order.","Evaluacion":"import itertools\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    # Type checks and canonical relabeling\n    if not isinstance(solution, list):\n        return 10**9\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n    violations = 0\n    if len(colors) == n:\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                violations += 1\n    else:\n        # Length mismatch penalty with partial checks when available\n        partial_len_pen = abs(len(colors) - n)\n        for (u,v) in edges:\n            if u-1 < len(colors) and v-1 < len(colors):\n                if colors[u-1] == colors[v-1]:\n                    violations += 1\n        return violations * 1000 + partial_len_pen * 100 + (k if k > 0 else 0)\n    # Lower-bound via clique number (omega)\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n    V = list(range(1, n+1))\n    def is_clique(nodes):\n        for i in range(len(nodes)):\n            a = nodes[i]\n            for j in range(i+1, len(nodes)):\n                b = nodes[j]\n                e = (a,b) if a < b else (b,a)\n                if e not in Eset:\n                    return False\n        return True\n    omega = 1\n    for r in range(2, n+1):\n        found = False\n        for comb in itertools.combinations(V, r):\n            if is_clique(list(comb)):\n                omega = r\n                found = True\n        if not found:\n            break\n    fitness = violations * 1000 + k\n    if k < omega:\n        fitness += (omega - k) * 100\n    return fitness\n","Vecindad":"import random\nfrom copy import deepcopy\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Robust input handling\n    if not isinstance(solution, list) or len(solution) == 0:\n        # initialize a random length-9 solution with small color set\n        n = 9\n        base_k = 3\n        neighbor = [random.randint(1, base_k) for _ in range(n)]\n        return neighbor, (\"Random\", \"Initialize\")\n    n = len(solution)\n    neighbor = list(solution)\n    # Ensure positive ints\n    for i,x in enumerate(neighbor):\n        if not isinstance(x, int) or x <= 0:\n            neighbor[i] = 1\n    # Recolor one vertex to an existing or new color (max+1)\n    idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n    current_colors = set(c for c in neighbor if isinstance(c, int) and c > 0)\n    max_c = max(current_colors) if current_colors else 1\n    candidate_colors = list(range(1, max_c + 2))\n    new_c = random.choice(candidate_colors)\n    # Avoid null move if possible\n    if new_c == neighbor[idx] and len(candidate_colors) > 1:\n        candidate_colors.remove(new_c)\n        new_c = random.choice(candidate_colors)\n    neighbor[idx] = new_c\n    return neighbor, (\"Random\", \"RecolorOneVertex\")\n","Perturbacion":"import random\nfrom copy import deepcopy\n\ndef perturb_solution(solution):\n    # Applies multiple random recolorings; returns perturbed solution only\n    if not isinstance(solution, list) or len(solution) == 0:\n        n = 9\n        base_k = 3\n        return [random.randint(1, base_k) for _ in range(n)]\n    n = len(solution)\n    pert = list(solution)\n    for i,x in enumerate(pert):\n        if not isinstance(x, int) or x <= 0:\n            pert[i] = 1\n    # Number of perturbations proportional to n (at least 2)\n    steps = max(2, min(5, n \/\/ 3))\n    for _ in range(steps):\n        idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n        current_colors = set(c for c in pert if isinstance(c, int) and c > 0)\n        max_c = max(current_colors) if current_colors else 1\n        candidate_colors = list(range(1, max_c + 2))\n        new_c = random.choice(candidate_colors)\n        if new_c == pert[idx] and len(candidate_colors) > 1:\n            candidate_colors.remove(new_c)\n            new_c = random.choice(candidate_colors)\n        pert[idx] = new_c\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: name 'itertools' is not defined","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001040663}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. solution[i] = color for vertex i+1. Labels arbitrary positive ints; evaluator canonically relabels to consecutive 1..k in first-appearance order.","Evaluacion":"import itertools\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    # Type checks and canonical relabeling\n    if not isinstance(solution, list):\n        return 10**9\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n    violations = 0\n    if len(colors) == n:\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                violations += 1\n    else:\n        # Length mismatch penalty with partial checks when available\n        partial_len_pen = abs(len(colors) - n)\n        for (u,v) in edges:\n            if u-1 < len(colors) and v-1 < len(colors):\n                if colors[u-1] == colors[v-1]:\n                    violations += 1\n        return violations * 1000 + partial_len_pen * 100 + (k if k > 0 else 0)\n    # Lower-bound via clique number (omega)\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n    V = list(range(1, n+1))\n    def is_clique(nodes):\n        for i in range(len(nodes)):\n            a = nodes[i]\n            for j in range(i+1, len(nodes)):\n                b = nodes[j]\n                e = (a,b) if a < b else (b,a)\n                if e not in Eset:\n                    return False\n        return True\n    omega = 1\n    for r in range(2, n+1):\n        found = False\n        for comb in itertools.combinations(V, r):\n            if is_clique(list(comb)):\n                omega = r\n                found = True\n        if not found:\n            break\n    fitness = violations * 1000 + k\n    if k < omega:\n        fitness += (omega - k) * 100\n    return fitness\n","Vecindad":"import random\nfrom copy import deepcopy\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Robust input handling\n    if not isinstance(solution, list) or len(solution) == 0:\n        # initialize a random length-9 solution with small color set\n        n = 9\n        base_k = 3\n        neighbor = [random.randint(1, base_k) for _ in range(n)]\n        return neighbor, (\"Random\", \"Initialize\")\n    n = len(solution)\n    neighbor = list(solution)\n    # Ensure positive ints\n    for i,x in enumerate(neighbor):\n        if not isinstance(x, int) or x <= 0:\n            neighbor[i] = 1\n    # Recolor one vertex to an existing or new color (max+1)\n    idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n    current_colors = set(c for c in neighbor if isinstance(c, int) and c > 0)\n    max_c = max(current_colors) if current_colors else 1\n    candidate_colors = list(range(1, max_c + 2))\n    new_c = random.choice(candidate_colors)\n    # Avoid null move if possible\n    if new_c == neighbor[idx] and len(candidate_colors) > 1:\n        candidate_colors.remove(new_c)\n        new_c = random.choice(candidate_colors)\n    neighbor[idx] = new_c\n    return neighbor, (\"Random\", \"RecolorOneVertex\")\n","Perturbacion":"import random\nfrom copy import deepcopy\n\ndef perturb_solution(solution):\n    # Applies multiple random recolorings; returns perturbed solution only\n    if not isinstance(solution, list) or len(solution) == 0:\n        n = 9\n        base_k = 3\n        return [random.randint(1, base_k) for _ in range(n)]\n    n = len(solution)\n    pert = list(solution)\n    for i,x in enumerate(pert):\n        if not isinstance(x, int) or x <= 0:\n            pert[i] = 1\n    # Number of perturbations proportional to n (at least 2)\n    steps = max(2, min(5, n \/\/ 3))\n    for _ in range(steps):\n        idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n        current_colors = set(c for c in pert if isinstance(c, int) and c > 0)\n        max_c = max(current_colors) if current_colors else 1\n        candidate_colors = list(range(1, max_c + 2))\n        new_c = random.choice(candidate_colors)\n        if new_c == pert[idx] and len(candidate_colors) > 1:\n            candidate_colors.remove(new_c)\n            new_c = random.choice(candidate_colors)\n        pert[idx] = new_c\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: name 'itertools' is not defined","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000917922}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    # Self-contained evaluator with canonical relabeling and strict length handling\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n\n    # Robust repair to exact length n with positive integers\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    colors_raw = repair_to_length_n(solution)\n\n    # Canonical relabeling to consecutive 1..k preserving first-appearance order\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in colors_raw:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    sum_conflicts = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Internal helpers and embedded graph\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def distinct_colors(colors):\n        return sorted(set(colors))\n\n    def min_conflict_color(colors, idx):\n        # Try existing colors plus possibly a new color (max+1)\n        current_set = set(colors)\n        max_c = max(current_set) if current_set else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = 10**9\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            # Score by (violations, local conflicts at idx, k)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = repair(solution)\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex\n        worst = max(range(n), key=lambda i: (deg[i], random.random()))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            # fallback: random recolor among expanded palette\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return nb, (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (try to reduce k)\n        color_list = distinct_colors(colors)\n        if len(color_list) <= 1:\n            # nothing to do; small random tweak\n            idx = random.randrange(n)\n            max_c = max(colors)\n            new_c = random.randint(1, max_c)\n            if new_c == colors[idx]:\n                new_c = max_c if colors[idx] != max_c else 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return nb, (\"Diversify\", \"RandomTweak\")\n        # pick a candidate color class to eliminate\n        target = random.choice(color_list)\n        if len(color_list) >= 2:\n            other_colors = [c for c in color_list if c != target]\n        else:\n            other_colors = color_list\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            # choose best color among existing other colors\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return nb, (\"Intensify\", \"ColorClassElimination\")\n        # Otherwise perform a color-class swap to diversify\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return nb, (\"Diversify\", \"SwapColorClasses\")\n        # Fallback\n        idx = random.randrange(n)\n        return colors, (\"NoOp\", \"Stable\")","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-move random shake combining recolors and occasional color-class swap\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = repair(solution)\n    steps = 5  # moderate intensity\n    for t in range(steps):\n        if random.random() < 0.25 and len(set(pert)) >= 2:\n            # color-class swap\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n    # Optional quick repair if became highly infeasible: one greedy pass\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n    return pert","Resultados":[[1,1,2,1,1,3,3,2,2],3000,[1,1,2,1,1,3,3,2,2],3000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003249821}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    # Self-contained evaluator with canonical relabeling and strict length handling\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n\n    # Robust repair to exact length n with positive integers\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    colors_raw = repair_to_length_n(solution)\n\n    # Canonical relabeling to consecutive 1..k preserving first-appearance order\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in colors_raw:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    sum_conflicts = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Internal helpers and embedded graph\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def distinct_colors(colors):\n        return sorted(set(colors))\n\n    def min_conflict_color(colors, idx):\n        # Try existing colors plus possibly a new color (max+1)\n        current_set = set(colors)\n        max_c = max(current_set) if current_set else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = 10**9\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            # Score by (violations, local conflicts at idx, k)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = repair(solution)\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex\n        worst = max(range(n), key=lambda i: (deg[i], random.random()))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            # fallback: random recolor among expanded palette\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return nb, (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (try to reduce k)\n        color_list = distinct_colors(colors)\n        if len(color_list) <= 1:\n            # nothing to do; small random tweak\n            idx = random.randrange(n)\n            max_c = max(colors)\n            new_c = random.randint(1, max_c)\n            if new_c == colors[idx]:\n                new_c = max_c if colors[idx] != max_c else 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return nb, (\"Diversify\", \"RandomTweak\")\n        # pick a candidate color class to eliminate\n        target = random.choice(color_list)\n        if len(color_list) >= 2:\n            other_colors = [c for c in color_list if c != target]\n        else:\n            other_colors = color_list\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            # choose best color among existing other colors\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return nb, (\"Intensify\", \"ColorClassElimination\")\n        # Otherwise perform a color-class swap to diversify\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return nb, (\"Diversify\", \"SwapColorClasses\")\n        # Fallback\n        idx = random.randrange(n)\n        return colors, (\"NoOp\", \"Stable\")","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-move random shake combining recolors and occasional color-class swap\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = repair(solution)\n    steps = 5  # moderate intensity\n    for t in range(steps):\n        if random.random() < 0.25 and len(set(pert)) >= 2:\n            # color-class swap\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n    # Optional quick repair if became highly infeasible: one greedy pass\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n    return pert","Resultados":[[2,9,5,2,2,7,6,1,1],3000,[1,1,2,1,1,3,3,2,2],3000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.006185106}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    # Self-contained evaluator with canonical relabeling and strict length handling\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n\n    # Robust repair to exact length n with positive integers\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    colors_raw = repair_to_length_n(solution)\n\n    # Canonical relabeling to consecutive 1..k preserving first-appearance order\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in colors_raw:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    sum_conflicts = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Internal helpers and embedded graph\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def distinct_colors(colors):\n        return sorted(set(colors))\n\n    def min_conflict_color(colors, idx):\n        # Try existing colors plus possibly a new color (max+1)\n        current_set = set(colors)\n        max_c = max(current_set) if current_set else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = 10**9\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            # Score by (violations, local conflicts at idx, k)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = repair(solution)\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex\n        worst = max(range(n), key=lambda i: (deg[i], random.random()))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            # fallback: random recolor among expanded palette\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return nb, (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (try to reduce k)\n        color_list = distinct_colors(colors)\n        if len(color_list) <= 1:\n            # nothing to do; small random tweak\n            idx = random.randrange(n)\n            max_c = max(colors)\n            new_c = random.randint(1, max_c)\n            if new_c == colors[idx]:\n                new_c = max_c if colors[idx] != max_c else 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return nb, (\"Diversify\", \"RandomTweak\")\n        # pick a candidate color class to eliminate\n        target = random.choice(color_list)\n        if len(color_list) >= 2:\n            other_colors = [c for c in color_list if c != target]\n        else:\n            other_colors = color_list\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            # choose best color among existing other colors\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return nb, (\"Intensify\", \"ColorClassElimination\")\n        # Otherwise perform a color-class swap to diversify\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return nb, (\"Diversify\", \"SwapColorClasses\")\n        # Fallback\n        idx = random.randrange(n)\n        return colors, (\"NoOp\", \"Stable\")","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-move random shake combining recolors and occasional color-class swap\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = repair(solution)\n    steps = 5  # moderate intensity\n    for t in range(steps):\n        if random.random() < 0.25 and len(set(pert)) >= 2:\n            # color-class swap\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n    # Optional quick repair if became highly infeasible: one greedy pass\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n    return pert","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001817373}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def min_conflict_color(colors, idx):\n        curset = sorted(set(colors))\n        max_c = curset[-1] if curset else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = (10**9, 10**9, 10**9)\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = canonicalize(repair(solution))\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex (deterministic tie-break)\n        worst = max(range(n), key=lambda i: (deg[i], i))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (reduce k)\n        color_list = sorted(set(colors))\n        if len(color_list) <= 1:\n            idx = 0\n            max_c = max(colors)\n            new_c = 1 if max_c == 1 else max_c\n            if new_c == colors[idx]:\n                new_c = 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n        target = random.choice(color_list)\n        other_colors = [c for c in color_list if c != target]\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return canonicalize(nb), (\"Intensify\", \"ColorClassElimination\")\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return canonicalize(nb), (\"Diversify\", \"SwapColorClasses\")\n        return colors, (\"NoOp\", \"Stable\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = canonicalize(repair(solution))\n    steps = 5\n    for _ in range(steps):\n        if random.random() < 0.3 and len(set(pert)) >= 2:\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n        pert = canonicalize(pert)\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n        pert = canonicalize(pert)\n    return pert\n","Resultados":[[1,1,2,1,1,3,3,2,2],3000,[1,1,2,1,1,3,3,2,2],3000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003028747}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def min_conflict_color(colors, idx):\n        curset = sorted(set(colors))\n        max_c = curset[-1] if curset else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = (10**9, 10**9, 10**9)\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = canonicalize(repair(solution))\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex (deterministic tie-break)\n        worst = max(range(n), key=lambda i: (deg[i], i))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (reduce k)\n        color_list = sorted(set(colors))\n        if len(color_list) <= 1:\n            idx = 0\n            max_c = max(colors)\n            new_c = 1 if max_c == 1 else max_c\n            if new_c == colors[idx]:\n                new_c = 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n        target = random.choice(color_list)\n        other_colors = [c for c in color_list if c != target]\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return canonicalize(nb), (\"Intensify\", \"ColorClassElimination\")\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return canonicalize(nb), (\"Diversify\", \"SwapColorClasses\")\n        return colors, (\"NoOp\", \"Stable\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = canonicalize(repair(solution))\n    steps = 5\n    for _ in range(steps):\n        if random.random() < 0.3 and len(set(pert)) >= 2:\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n        pert = canonicalize(pert)\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n        pert = canonicalize(pert)\n    return pert\n","Resultados":[[1,2,1,2,2,3,4,4,3],3000,[1,1,2,1,1,3,3,2,2],3000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.004260193}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def min_conflict_color(colors, idx):\n        curset = sorted(set(colors))\n        max_c = curset[-1] if curset else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = (10**9, 10**9, 10**9)\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = canonicalize(repair(solution))\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex (deterministic tie-break)\n        worst = max(range(n), key=lambda i: (deg[i], i))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (reduce k)\n        color_list = sorted(set(colors))\n        if len(color_list) <= 1:\n            idx = 0\n            max_c = max(colors)\n            new_c = 1 if max_c == 1 else max_c\n            if new_c == colors[idx]:\n                new_c = 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n        target = random.choice(color_list)\n        other_colors = [c for c in color_list if c != target]\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return canonicalize(nb), (\"Intensify\", \"ColorClassElimination\")\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return canonicalize(nb), (\"Diversify\", \"SwapColorClasses\")\n        return colors, (\"NoOp\", \"Stable\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = canonicalize(repair(solution))\n    steps = 5\n    for _ in range(steps):\n        if random.random() < 0.3 and len(set(pert)) >= 2:\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n        pert = canonicalize(pert)\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n        pert = canonicalize(pert)\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001319847}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    if not colors:\n        return 10**12\n    k = max(colors)\n\n    # Count edge violations and per-vertex conflict degrees\n    conflict_deg = [0]*n\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    # Stronger tie-breaker: sum of squared conflict degrees\n    weighted_conflicts = sum(d*d for d in conflict_deg)\n\n    # Lexicographic fitness: feasibility -> minimize k -> minimize conflict structure\n    fitness = violations * 1_000_000 + k * 1_000 + weighted_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    # Build adjacency list for efficient local checks\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts_and_deg(colors):\n        viol = 0\n        deg = [0]*n\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                deg[u-1] += 1\n                deg[v-1] += 1\n        return viol, deg\n\n    def saturation_degree(colors, i):\n        return len({colors[j] for j in adj[i]})\n\n    def min_conflict_color_repair(colors, i):\n        # restrict to existing colors only in infeasible phase\n        palette = sorted(set(colors))\n        best_c = colors[i]\n        best_tuple = (10**9, 10**9, 10**9)\n        for c in palette:\n            if c == colors[i] and len(palette) > 1:\n                continue\n            tmp_c = colors[i]\n            # delta evaluate: count conflicts at i only\n            viol_i = 0\n            for nb in adj[i]:\n                if colors[nb] == c:\n                    viol_i += 1\n            # tie-break by neighbor availability: prefer colors that reduce conflicts and increase neighbor diversity\n            k_tmp = len(set(colors))\n            score = (viol_i, -saturation_degree(colors, i), k_tmp)\n            if score < best_tuple:\n                best_tuple = score\n                best_c = c\n        return best_c\n\n    def kempe_chain_swap(colors, a, b, seed):\n        # BFS on subgraph induced by colors a and b, swap within the connected component of seed\n        if colors[seed] not in (a, b):\n            return colors[:]\n        target = colors[seed]\n        other = b if target == a else a\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    def try_color_class_elimination(colors):\n        # Attempt to eliminate the highest color label greedily\n        k = max(colors)\n        target = k\n        verts = [i for i,c in enumerate(colors) if c == target]\n        if not verts:\n            return colors[:], False\n        order = sorted(verts, key=lambda i: (-saturation_degree(colors, i), -len(adj[i]), i))\n        nb = colors[:]\n        palette = [c for c in sorted(set(nb)) if c != target]\n        for i in order:\n            best_c = None\n            best_v = 10**9\n            best_deg = 10**9\n            for c in palette:\n                # compute conflicts if i recolored to c\n                v_i = 0\n                for j in adj[i]:\n                    if nb[j] == c:\n                        v_i += 1\n                if v_i < best_v or (v_i == best_v and saturation_degree(nb, i) < best_deg):\n                    best_v = v_i\n                    best_deg = saturation_degree(nb, i)\n                    best_c = c\n            if best_c is None:\n                return colors[:], False\n            nb[i] = best_c\n            # if we created a conflict, abort\n            for (u,v) in edges:\n                if nb[u-1] == nb[v-1]:\n                    return colors[:], False\n        # success if feasible and color removed\n        if max(nb) < k:\n            return canonicalize(nb), True\n        return colors[:], False\n\n    colors = repair(solution)\n    # do not canonicalize internally to preserve structure; canonicalize only on return\n    viol, deg = conflicts_and_deg(colors)\n\n    if viol > 0:\n        # Infeasible phase: choose hard vertex by (conflict deg, saturation, degree, index)\n        scores = [ (deg[i], saturation_degree(colors, i), len(adj[i]), -i) for i in range(n) ]\n        worst = max(range(n), key=lambda i: scores[i])\n        new_color = min_conflict_color_repair(colors, worst)\n        nb = colors[:]\n        nb[worst] = new_color\n        # If still conflicted at worst, try a Kempe swap with the most frequent neighbor color\n        v_before = sum(1 for j in adj[worst] if colors[j] == colors[worst])\n        v_after = sum(1 for j in adj[worst] if nb[j] == nb[worst])\n        if v_after >= v_before and len(set(colors)) >= 2:\n            neigh_colors = [colors[j] for j in adj[worst]]\n            if neigh_colors:\n                # pick most common neighbor color distinct from current\n                curc = colors[worst]\n                freq = {}\n                for c in neigh_colors:\n                    if c != curc:\n                        freq[c] = freq.get(c, 0) + 1\n                if freq:\n                    b = max(freq, key=freq.get)\n                    a = curc\n                    nb2 = kempe_chain_swap(colors, a, b, worst)\n                    colors_ret = canonicalize(nb2)\n                    return colors_ret, (\"Heuristic\", \"KempeRepair\")\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt to reduce k by color class elimination, else Kempe diversify\n        nb1, ok = try_color_class_elimination(colors)\n        if ok:\n            return nb1, (\"Intensify\", \"ColorClassElimination\")\n        # Kempe chain between two random colors on random seed\n        palette = sorted(set(colors))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            nb2 = kempe_chain_swap(colors, a, b, seed)\n            return canonicalize(nb2), (\"Diversify\", \"KempeSwap\")\n        # Fallback: random tweak within palette\n        idx = random.randrange(n)\n        pal = sorted(set(colors)) or [1]\n        if len(pal) > 1 and colors[idx] in pal:\n            pal = [c for c in pal if c != colors[idx]]\n        nb = colors[:]\n        nb[idx] = random.choice(pal or [colors[idx]])\n        return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Multi-step Kempe-chain based shake with occasional recolor within current palette\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_chain_swap(colors, a, b, seed):\n        if colors[seed] not in (a, b):\n            return colors[:]\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    colors = canonicalize(repair(solution))\n    steps = 7\n    for _ in range(steps):\n        palette = sorted(set(colors)) or [1]\n        if len(palette) >= 2 and random.random() < 0.8:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            colors = canonicalize(kempe_chain_swap(colors, a, b, seed))\n        else:\n            # Local recolor within current palette or extend by +1 with small prob to escape\n            idx = random.randrange(n)\n            pal = palette[:]\n            if random.random() < 0.15:\n                pal = pal + [max(palette)+1]\n            if len(pal) > 1 and colors[idx] in pal:\n                pal = [c for c in pal if c != colors[idx]]\n            colors[idx] = random.choice(pal or [colors[idx]])\n            colors = canonicalize(colors)\n    return colors\n","Resultados":[[1,1,2,1,1,3,3,2,2],3000,[1,1,2,1,1,3,3,2,2],3000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003171689}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    if not colors:\n        return 10**12\n    k = max(colors)\n\n    # Count edge violations and per-vertex conflict degrees\n    conflict_deg = [0]*n\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    # Stronger tie-breaker: sum of squared conflict degrees\n    weighted_conflicts = sum(d*d for d in conflict_deg)\n\n    # Lexicographic fitness: feasibility -> minimize k -> minimize conflict structure\n    fitness = violations * 1_000_000 + k * 1_000 + weighted_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    # Build adjacency list for efficient local checks\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts_and_deg(colors):\n        viol = 0\n        deg = [0]*n\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                deg[u-1] += 1\n                deg[v-1] += 1\n        return viol, deg\n\n    def saturation_degree(colors, i):\n        return len({colors[j] for j in adj[i]})\n\n    def min_conflict_color_repair(colors, i):\n        # restrict to existing colors only in infeasible phase\n        palette = sorted(set(colors))\n        best_c = colors[i]\n        best_tuple = (10**9, 10**9, 10**9)\n        for c in palette:\n            if c == colors[i] and len(palette) > 1:\n                continue\n            tmp_c = colors[i]\n            # delta evaluate: count conflicts at i only\n            viol_i = 0\n            for nb in adj[i]:\n                if colors[nb] == c:\n                    viol_i += 1\n            # tie-break by neighbor availability: prefer colors that reduce conflicts and increase neighbor diversity\n            k_tmp = len(set(colors))\n            score = (viol_i, -saturation_degree(colors, i), k_tmp)\n            if score < best_tuple:\n                best_tuple = score\n                best_c = c\n        return best_c\n\n    def kempe_chain_swap(colors, a, b, seed):\n        # BFS on subgraph induced by colors a and b, swap within the connected component of seed\n        if colors[seed] not in (a, b):\n            return colors[:]\n        target = colors[seed]\n        other = b if target == a else a\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    def try_color_class_elimination(colors):\n        # Attempt to eliminate the highest color label greedily\n        k = max(colors)\n        target = k\n        verts = [i for i,c in enumerate(colors) if c == target]\n        if not verts:\n            return colors[:], False\n        order = sorted(verts, key=lambda i: (-saturation_degree(colors, i), -len(adj[i]), i))\n        nb = colors[:]\n        palette = [c for c in sorted(set(nb)) if c != target]\n        for i in order:\n            best_c = None\n            best_v = 10**9\n            best_deg = 10**9\n            for c in palette:\n                # compute conflicts if i recolored to c\n                v_i = 0\n                for j in adj[i]:\n                    if nb[j] == c:\n                        v_i += 1\n                if v_i < best_v or (v_i == best_v and saturation_degree(nb, i) < best_deg):\n                    best_v = v_i\n                    best_deg = saturation_degree(nb, i)\n                    best_c = c\n            if best_c is None:\n                return colors[:], False\n            nb[i] = best_c\n            # if we created a conflict, abort\n            for (u,v) in edges:\n                if nb[u-1] == nb[v-1]:\n                    return colors[:], False\n        # success if feasible and color removed\n        if max(nb) < k:\n            return canonicalize(nb), True\n        return colors[:], False\n\n    colors = repair(solution)\n    # do not canonicalize internally to preserve structure; canonicalize only on return\n    viol, deg = conflicts_and_deg(colors)\n\n    if viol > 0:\n        # Infeasible phase: choose hard vertex by (conflict deg, saturation, degree, index)\n        scores = [ (deg[i], saturation_degree(colors, i), len(adj[i]), -i) for i in range(n) ]\n        worst = max(range(n), key=lambda i: scores[i])\n        new_color = min_conflict_color_repair(colors, worst)\n        nb = colors[:]\n        nb[worst] = new_color\n        # If still conflicted at worst, try a Kempe swap with the most frequent neighbor color\n        v_before = sum(1 for j in adj[worst] if colors[j] == colors[worst])\n        v_after = sum(1 for j in adj[worst] if nb[j] == nb[worst])\n        if v_after >= v_before and len(set(colors)) >= 2:\n            neigh_colors = [colors[j] for j in adj[worst]]\n            if neigh_colors:\n                # pick most common neighbor color distinct from current\n                curc = colors[worst]\n                freq = {}\n                for c in neigh_colors:\n                    if c != curc:\n                        freq[c] = freq.get(c, 0) + 1\n                if freq:\n                    b = max(freq, key=freq.get)\n                    a = curc\n                    nb2 = kempe_chain_swap(colors, a, b, worst)\n                    colors_ret = canonicalize(nb2)\n                    return colors_ret, (\"Heuristic\", \"KempeRepair\")\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt to reduce k by color class elimination, else Kempe diversify\n        nb1, ok = try_color_class_elimination(colors)\n        if ok:\n            return nb1, (\"Intensify\", \"ColorClassElimination\")\n        # Kempe chain between two random colors on random seed\n        palette = sorted(set(colors))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            nb2 = kempe_chain_swap(colors, a, b, seed)\n            return canonicalize(nb2), (\"Diversify\", \"KempeSwap\")\n        # Fallback: random tweak within palette\n        idx = random.randrange(n)\n        pal = sorted(set(colors)) or [1]\n        if len(pal) > 1 and colors[idx] in pal:\n            pal = [c for c in pal if c != colors[idx]]\n        nb = colors[:]\n        nb[idx] = random.choice(pal or [colors[idx]])\n        return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Multi-step Kempe-chain based shake with occasional recolor within current palette\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_chain_swap(colors, a, b, seed):\n        if colors[seed] not in (a, b):\n            return colors[:]\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    colors = canonicalize(repair(solution))\n    steps = 7\n    for _ in range(steps):\n        palette = sorted(set(colors)) or [1]\n        if len(palette) >= 2 and random.random() < 0.8:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            colors = canonicalize(kempe_chain_swap(colors, a, b, seed))\n        else:\n            # Local recolor within current palette or extend by +1 with small prob to escape\n            idx = random.randrange(n)\n            pal = palette[:]\n            if random.random() < 0.15:\n                pal = pal + [max(palette)+1]\n            if len(pal) > 1 and colors[idx] in pal:\n                pal = [c for c in pal if c != colors[idx]]\n            colors[idx] = random.choice(pal or [colors[idx]])\n            colors = canonicalize(colors)\n    return colors\n","Resultados":[[1,1,2,3,1,1,3,2,2],3000,[1,1,2,1,1,3,3,2,2],3000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.004733419}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    if not colors:\n        return 10**12\n    k = max(colors)\n\n    # Count edge violations and per-vertex conflict degrees\n    conflict_deg = [0]*n\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    # Stronger tie-breaker: sum of squared conflict degrees\n    weighted_conflicts = sum(d*d for d in conflict_deg)\n\n    # Lexicographic fitness: feasibility -> minimize k -> minimize conflict structure\n    fitness = violations * 1_000_000 + k * 1_000 + weighted_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    # Build adjacency list for efficient local checks\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts_and_deg(colors):\n        viol = 0\n        deg = [0]*n\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                deg[u-1] += 1\n                deg[v-1] += 1\n        return viol, deg\n\n    def saturation_degree(colors, i):\n        return len({colors[j] for j in adj[i]})\n\n    def min_conflict_color_repair(colors, i):\n        # restrict to existing colors only in infeasible phase\n        palette = sorted(set(colors))\n        best_c = colors[i]\n        best_tuple = (10**9, 10**9, 10**9)\n        for c in palette:\n            if c == colors[i] and len(palette) > 1:\n                continue\n            tmp_c = colors[i]\n            # delta evaluate: count conflicts at i only\n            viol_i = 0\n            for nb in adj[i]:\n                if colors[nb] == c:\n                    viol_i += 1\n            # tie-break by neighbor availability: prefer colors that reduce conflicts and increase neighbor diversity\n            k_tmp = len(set(colors))\n            score = (viol_i, -saturation_degree(colors, i), k_tmp)\n            if score < best_tuple:\n                best_tuple = score\n                best_c = c\n        return best_c\n\n    def kempe_chain_swap(colors, a, b, seed):\n        # BFS on subgraph induced by colors a and b, swap within the connected component of seed\n        if colors[seed] not in (a, b):\n            return colors[:]\n        target = colors[seed]\n        other = b if target == a else a\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    def try_color_class_elimination(colors):\n        # Attempt to eliminate the highest color label greedily\n        k = max(colors)\n        target = k\n        verts = [i for i,c in enumerate(colors) if c == target]\n        if not verts:\n            return colors[:], False\n        order = sorted(verts, key=lambda i: (-saturation_degree(colors, i), -len(adj[i]), i))\n        nb = colors[:]\n        palette = [c for c in sorted(set(nb)) if c != target]\n        for i in order:\n            best_c = None\n            best_v = 10**9\n            best_deg = 10**9\n            for c in palette:\n                # compute conflicts if i recolored to c\n                v_i = 0\n                for j in adj[i]:\n                    if nb[j] == c:\n                        v_i += 1\n                if v_i < best_v or (v_i == best_v and saturation_degree(nb, i) < best_deg):\n                    best_v = v_i\n                    best_deg = saturation_degree(nb, i)\n                    best_c = c\n            if best_c is None:\n                return colors[:], False\n            nb[i] = best_c\n            # if we created a conflict, abort\n            for (u,v) in edges:\n                if nb[u-1] == nb[v-1]:\n                    return colors[:], False\n        # success if feasible and color removed\n        if max(nb) < k:\n            return canonicalize(nb), True\n        return colors[:], False\n\n    colors = repair(solution)\n    # do not canonicalize internally to preserve structure; canonicalize only on return\n    viol, deg = conflicts_and_deg(colors)\n\n    if viol > 0:\n        # Infeasible phase: choose hard vertex by (conflict deg, saturation, degree, index)\n        scores = [ (deg[i], saturation_degree(colors, i), len(adj[i]), -i) for i in range(n) ]\n        worst = max(range(n), key=lambda i: scores[i])\n        new_color = min_conflict_color_repair(colors, worst)\n        nb = colors[:]\n        nb[worst] = new_color\n        # If still conflicted at worst, try a Kempe swap with the most frequent neighbor color\n        v_before = sum(1 for j in adj[worst] if colors[j] == colors[worst])\n        v_after = sum(1 for j in adj[worst] if nb[j] == nb[worst])\n        if v_after >= v_before and len(set(colors)) >= 2:\n            neigh_colors = [colors[j] for j in adj[worst]]\n            if neigh_colors:\n                # pick most common neighbor color distinct from current\n                curc = colors[worst]\n                freq = {}\n                for c in neigh_colors:\n                    if c != curc:\n                        freq[c] = freq.get(c, 0) + 1\n                if freq:\n                    b = max(freq, key=freq.get)\n                    a = curc\n                    nb2 = kempe_chain_swap(colors, a, b, worst)\n                    colors_ret = canonicalize(nb2)\n                    return colors_ret, (\"Heuristic\", \"KempeRepair\")\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt to reduce k by color class elimination, else Kempe diversify\n        nb1, ok = try_color_class_elimination(colors)\n        if ok:\n            return nb1, (\"Intensify\", \"ColorClassElimination\")\n        # Kempe chain between two random colors on random seed\n        palette = sorted(set(colors))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            nb2 = kempe_chain_swap(colors, a, b, seed)\n            return canonicalize(nb2), (\"Diversify\", \"KempeSwap\")\n        # Fallback: random tweak within palette\n        idx = random.randrange(n)\n        pal = sorted(set(colors)) or [1]\n        if len(pal) > 1 and colors[idx] in pal:\n            pal = [c for c in pal if c != colors[idx]]\n        nb = colors[:]\n        nb[idx] = random.choice(pal or [colors[idx]])\n        return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Multi-step Kempe-chain based shake with occasional recolor within current palette\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_chain_swap(colors, a, b, seed):\n        if colors[seed] not in (a, b):\n            return colors[:]\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    colors = canonicalize(repair(solution))\n    steps = 7\n    for _ in range(steps):\n        palette = sorted(set(colors)) or [1]\n        if len(palette) >= 2 and random.random() < 0.8:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            colors = canonicalize(kempe_chain_swap(colors, a, b, seed))\n        else:\n            # Local recolor within current palette or extend by +1 with small prob to escape\n            idx = random.randrange(n)\n            pal = palette[:]\n            if random.random() < 0.15:\n                pal = pal + [max(palette)+1]\n            if len(pal) > 1 and colors[idx] in pal:\n                pal = [c for c in pal if c != colors[idx]]\n            colors[idx] = random.choice(pal or [colors[idx]])\n            colors = canonicalize(colors)\n    return colors\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002116626}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST_INT_9_CONTIGUOUS_COLORS. Encoding: solution is a list of 9 positive integers [c1..c9]. Feasible iff labels are contiguous {1..k} with k=max(list), and for every edge (u,v) colors differ. Objective: minimize k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**6\n    # Type and basic checks\n    if not isinstance(solution, list):\n        return PENALTY + 1\n    if len(solution) != 9:\n        return PENALTY + 2\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY + 3\n    if len(solution) == 0:\n        return PENALTY + 4\n    if min(solution) < 1:\n        return PENALTY + 5\n    k = max(solution)\n    if k > 9:\n        return PENALTY + 6\n    # Contiguity check: labels must be exactly {1..k}\n    uniq = set(solution)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY + 7\n    # Edge set (1-based indexing)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY + 1000 + conflicts\n    # Feasible: cost is k (minimize)\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor: mutates the provided solution list.\n    # Returns metadata (NB_Type, Movement_Type) only.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    def normalize(sol):\n        # Relabel to contiguous {1..k} preserving partition\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping.get(sol[i], 1)\n\n    n = len(solution)\n    # Choose move type\n    if random.random() < 0.6:\n        # Recolor one vertex to an existing or new label (<=9), then normalize\n        i = random.randrange(n)\n        current = solution[i]\n        uniq = sorted(set(solution))\n        m = len(uniq)\n        choices = [c for c in uniq if c != current]\n        if random.random() < 0.2 and m < 9:\n            choices.append(m + 1)\n        if not choices:\n            # Fallback to a valid alternate color\n            new_c = 1 if current != 1 else 2\n        else:\n            new_c = random.choice(choices)\n        solution[i] = new_c\n        normalize(solution)\n        return (\"NB_Local\", \"Recolor-One\")\n    else:\n        # Swap two color labels globally (symmetry move), then normalize\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # If only one label exists, attempt to introduce a second\n            i = random.randrange(n)\n            solution[i] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a new, perturbed solution list (does not modify the input reference).\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1] * 9\n    sol = list(solution)\n\n    def normalize(sol_):\n        uniq = sorted(set(sol_))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol_)):\n            sol_[i] = mapping.get(sol_[i], 1)\n\n    # Apply multiple random recolors and optional label merges\/splits\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(9)\n        uniq = sorted(set(sol))\n        m = len(uniq)\n        # Allow move within 1..min(m+1,9)\n        candidate = random.randint(1, min(m + 1, 9))\n        if candidate == sol[i] and m > 1:\n            pool = [c for c in range(1, m + 1) if c != sol[i]]\n            if not pool and m < 9:\n                pool = [m + 1]\n            if pool:\n                candidate = random.choice(pool)\n        sol[i] = candidate\n        normalize(sol)\n\n    # Occasionally merge two labels to encourage k-reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])  # avoid always merging into smallest\n        b = random.choice([x for x in uniq if x != a])\n        for idx in range(len(sol)):\n            if sol[idx] == a:\n                sol[idx] = b\n        normalize(sol)\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000571}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST_INT_9_CONTIGUOUS_COLORS. Encoding: solution is a list of 9 positive integers [c1..c9]. Feasible iff labels are contiguous {1..k} with k=max(list), and for every edge (u,v) colors differ. Objective: minimize k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**6\n    # Type and basic checks\n    if not isinstance(solution, list):\n        return PENALTY + 1\n    if len(solution) != 9:\n        return PENALTY + 2\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY + 3\n    if len(solution) == 0:\n        return PENALTY + 4\n    if min(solution) < 1:\n        return PENALTY + 5\n    k = max(solution)\n    if k > 9:\n        return PENALTY + 6\n    # Contiguity check: labels must be exactly {1..k}\n    uniq = set(solution)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY + 7\n    # Edge set (1-based indexing)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY + 1000 + conflicts\n    # Feasible: cost is k (minimize)\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor: mutates the provided solution list.\n    # Returns metadata (NB_Type, Movement_Type) only.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    def normalize(sol):\n        # Relabel to contiguous {1..k} preserving partition\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping.get(sol[i], 1)\n\n    n = len(solution)\n    # Choose move type\n    if random.random() < 0.6:\n        # Recolor one vertex to an existing or new label (<=9), then normalize\n        i = random.randrange(n)\n        current = solution[i]\n        uniq = sorted(set(solution))\n        m = len(uniq)\n        choices = [c for c in uniq if c != current]\n        if random.random() < 0.2 and m < 9:\n            choices.append(m + 1)\n        if not choices:\n            # Fallback to a valid alternate color\n            new_c = 1 if current != 1 else 2\n        else:\n            new_c = random.choice(choices)\n        solution[i] = new_c\n        normalize(solution)\n        return (\"NB_Local\", \"Recolor-One\")\n    else:\n        # Swap two color labels globally (symmetry move), then normalize\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # If only one label exists, attempt to introduce a second\n            i = random.randrange(n)\n            solution[i] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a new, perturbed solution list (does not modify the input reference).\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1] * 9\n    sol = list(solution)\n\n    def normalize(sol_):\n        uniq = sorted(set(sol_))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol_)):\n            sol_[i] = mapping.get(sol_[i], 1)\n\n    # Apply multiple random recolors and optional label merges\/splits\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(9)\n        uniq = sorted(set(sol))\n        m = len(uniq)\n        # Allow move within 1..min(m+1,9)\n        candidate = random.randint(1, min(m + 1, 9))\n        if candidate == sol[i] and m > 1:\n            pool = [c for c in range(1, m + 1) if c != sol[i]]\n            if not pool and m < 9:\n                pool = [m + 1]\n            if pool:\n                candidate = random.choice(pool)\n        sol[i] = candidate\n        normalize(sol)\n\n    # Occasionally merge two labels to encourage k-reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])  # avoid always merging into smallest\n        b = random.choice([x for x in uniq if x != a])\n        for idx in range(len(sol)):\n            if sol[idx] == a:\n                sol[idx] = b\n        normalize(sol)\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000151}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST_INT_9_CONTIGUOUS_COLORS. Encoding: solution is a list of 9 positive integers [c1..c9]. Feasible iff labels are contiguous {1..k} with k=max(list), and for every edge (u,v) colors differ. Objective: minimize k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**6\n    # Type and basic checks\n    if not isinstance(solution, list):\n        return PENALTY + 1\n    if len(solution) != 9:\n        return PENALTY + 2\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY + 3\n    if len(solution) == 0:\n        return PENALTY + 4\n    if min(solution) < 1:\n        return PENALTY + 5\n    k = max(solution)\n    if k > 9:\n        return PENALTY + 6\n    # Contiguity check: labels must be exactly {1..k}\n    uniq = set(solution)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY + 7\n    # Edge set (1-based indexing)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY + 1000 + conflicts\n    # Feasible: cost is k (minimize)\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor: mutates the provided solution list.\n    # Returns metadata (NB_Type, Movement_Type) only.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    def normalize(sol):\n        # Relabel to contiguous {1..k} preserving partition\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping.get(sol[i], 1)\n\n    n = len(solution)\n    # Choose move type\n    if random.random() < 0.6:\n        # Recolor one vertex to an existing or new label (<=9), then normalize\n        i = random.randrange(n)\n        current = solution[i]\n        uniq = sorted(set(solution))\n        m = len(uniq)\n        choices = [c for c in uniq if c != current]\n        if random.random() < 0.2 and m < 9:\n            choices.append(m + 1)\n        if not choices:\n            # Fallback to a valid alternate color\n            new_c = 1 if current != 1 else 2\n        else:\n            new_c = random.choice(choices)\n        solution[i] = new_c\n        normalize(solution)\n        return (\"NB_Local\", \"Recolor-One\")\n    else:\n        # Swap two color labels globally (symmetry move), then normalize\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # If only one label exists, attempt to introduce a second\n            i = random.randrange(n)\n            solution[i] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a new, perturbed solution list (does not modify the input reference).\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1] * 9\n    sol = list(solution)\n\n    def normalize(sol_):\n        uniq = sorted(set(sol_))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol_)):\n            sol_[i] = mapping.get(sol_[i], 1)\n\n    # Apply multiple random recolors and optional label merges\/splits\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(9)\n        uniq = sorted(set(sol))\n        m = len(uniq)\n        # Allow move within 1..min(m+1,9)\n        candidate = random.randint(1, min(m + 1, 9))\n        if candidate == sol[i] and m > 1:\n            pool = [c for c in range(1, m + 1) if c != sol[i]]\n            if not pool and m < 9:\n                pool = [m + 1]\n            if pool:\n                candidate = random.choice(pool)\n        sol[i] = candidate\n        normalize(sol)\n\n    # Occasionally merge two labels to encourage k-reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])  # avoid always merging into smallest\n        b = random.choice([x for x in uniq if x != a])\n        for idx in range(len(sol)):\n            if sol[idx] == a:\n                sol[idx] = b\n        normalize(sol)\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000095}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"STRING: space-separated 9 positive integers, encoding vertex colors c1..c9 in contiguous domain {1..k}. Example: \"1 1 2 1 1 3 3 2 2\". Feasible iff all labels are integers >=1, contiguous {1..k} with k=max, and for every edge (u,v) in E colors differ.","Evaluacion":"import re\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost; lower is better. Lexicographic via cost = conflicts*20 + k.\n    # Robust parser: accepts list[int] or string of ints.\n    PENALTY_BASE = 1000\n    # Edge set with 1-based vertices\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    # Contiguity check {1..k}\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    # Cost: conflicts dominate; minimal k within zero-conflict region\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor on list[int]. If non-list provided, return error metadata.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    # Problem data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    # Compute current conflicts and conflicting vertices\n    conf_vertices = [i for i in range(n) if conflicts_of_vertex(solution, i) > 0]\n\n    move_roll = random.random()\n    if conf_vertices and move_roll < 0.8:\n        # Conflict-driven recolor of the most conflicting vertex\n        i = max(conf_vertices, key=lambda x: conflicts_of_vertex(solution, x))\n        current_k = max(solution)\n        # Candidate colors: 1..current_k, avoid introducing new color unless all fail\n        best_color = solution[i]\n        best_conf = 10**9\n        # Evaluate each candidate color (excluding current first)\n        candidates = list(range(1, current_k + 1))\n        if solution[i] in candidates:\n            candidates.remove(solution[i])\n        # Try existing colors\n        for c in candidates:\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n                if conf == 0:\n                    # Prefer zero-conflict immediately\n                    break\n            solution[i] = tmp\n        # If no improvement and still conflicts, optionally try introducing color current_k+1 (bounded by 9)\n        if best_conf > 0 and current_k < 9:\n            c = current_k + 1\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n            solution[i] = tmp\n        solution[i] = best_color\n        normalize(solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One\")\n    elif move_roll < 0.95:\n        # Symmetry move: swap two labels globally (if >=2 labels)\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # Introduce second label to escape uniform state\n            j = random.randrange(n)\n            solution[j] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n    else:\n        # Pairwise color exchange on two vertices (not a global swap)\n        i, j = random.sample(range(n), 2)\n        solution[i], solution[j] = solution[j], solution[i]\n        normalize(solution)\n        return (\"NB_Local\", \"Swap-Vertices-Colors\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution; accepts list[int] or string. Preserves type when possible.\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = [int(x) for x in sol.replace(',', ' ').split()]\n            return parts, 'str'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    # Problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1]*9\n    sol = list(sol)\n    normalize(sol)\n\n    # Determine vertices by conflict priority\n    conflict_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(9)]\n    conflict_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Random-kick on top p vertices\n    p = random.randint(2, 4)\n    targets = [i for i, _ in conflict_scores[:p]]\n    current_k = max(sol)\n    for i in targets:\n        # Try a random existing color different from current; 20% chance allow k+1 (<=9)\n        candidates = [c for c in range(1, current_k + 1) if c != sol[i]]\n        if random.random() < 0.2 and current_k < 9:\n            candidates.append(current_k + 1)\n        if candidates:\n            sol[i] = random.choice(candidates)\n    normalize(sol)\n\n    # Color-class shake: choose a color and reassign ~40% of its vertices\n    uniq = sorted(set(sol))\n    if uniq:\n        c = random.choice(uniq)\n        idxs = [i for i in range(9) if sol[i] == c]\n        if idxs:\n            m = max(1, int(0.4 * len(idxs)))\n            pick = random.sample(idxs, m)\n            current_k = max(sol)\n            for i in pick:\n                pool = [x for x in range(1, current_k + 1) if x != sol[i]]\n                if not pool and current_k < 9:\n                    pool = [current_k + 1]\n                if pool:\n                    sol[i] = random.choice(pool)\n    normalize(sol)\n\n    # Forced merge attempt with 50% chance to encourage k reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])\n        b = random.choice([x for x in uniq if x != a])\n        for i in range(9):\n            if sol[i] == a:\n                sol[i] = b\n        normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001568259}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"STRING: space-separated 9 positive integers, encoding vertex colors c1..c9 in contiguous domain {1..k}. Example: \"1 1 2 1 1 3 3 2 2\". Feasible iff all labels are integers >=1, contiguous {1..k} with k=max, and for every edge (u,v) in E colors differ.","Evaluacion":"import re\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost; lower is better. Lexicographic via cost = conflicts*20 + k.\n    # Robust parser: accepts list[int] or string of ints.\n    PENALTY_BASE = 1000\n    # Edge set with 1-based vertices\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    # Contiguity check {1..k}\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    # Cost: conflicts dominate; minimal k within zero-conflict region\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor on list[int]. If non-list provided, return error metadata.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    # Problem data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    # Compute current conflicts and conflicting vertices\n    conf_vertices = [i for i in range(n) if conflicts_of_vertex(solution, i) > 0]\n\n    move_roll = random.random()\n    if conf_vertices and move_roll < 0.8:\n        # Conflict-driven recolor of the most conflicting vertex\n        i = max(conf_vertices, key=lambda x: conflicts_of_vertex(solution, x))\n        current_k = max(solution)\n        # Candidate colors: 1..current_k, avoid introducing new color unless all fail\n        best_color = solution[i]\n        best_conf = 10**9\n        # Evaluate each candidate color (excluding current first)\n        candidates = list(range(1, current_k + 1))\n        if solution[i] in candidates:\n            candidates.remove(solution[i])\n        # Try existing colors\n        for c in candidates:\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n                if conf == 0:\n                    # Prefer zero-conflict immediately\n                    break\n            solution[i] = tmp\n        # If no improvement and still conflicts, optionally try introducing color current_k+1 (bounded by 9)\n        if best_conf > 0 and current_k < 9:\n            c = current_k + 1\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n            solution[i] = tmp\n        solution[i] = best_color\n        normalize(solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One\")\n    elif move_roll < 0.95:\n        # Symmetry move: swap two labels globally (if >=2 labels)\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # Introduce second label to escape uniform state\n            j = random.randrange(n)\n            solution[j] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n    else:\n        # Pairwise color exchange on two vertices (not a global swap)\n        i, j = random.sample(range(n), 2)\n        solution[i], solution[j] = solution[j], solution[i]\n        normalize(solution)\n        return (\"NB_Local\", \"Swap-Vertices-Colors\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution; accepts list[int] or string. Preserves type when possible.\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = [int(x) for x in sol.replace(',', ' ').split()]\n            return parts, 'str'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    # Problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1]*9\n    sol = list(sol)\n    normalize(sol)\n\n    # Determine vertices by conflict priority\n    conflict_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(9)]\n    conflict_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Random-kick on top p vertices\n    p = random.randint(2, 4)\n    targets = [i for i, _ in conflict_scores[:p]]\n    current_k = max(sol)\n    for i in targets:\n        # Try a random existing color different from current; 20% chance allow k+1 (<=9)\n        candidates = [c for c in range(1, current_k + 1) if c != sol[i]]\n        if random.random() < 0.2 and current_k < 9:\n            candidates.append(current_k + 1)\n        if candidates:\n            sol[i] = random.choice(candidates)\n    normalize(sol)\n\n    # Color-class shake: choose a color and reassign ~40% of its vertices\n    uniq = sorted(set(sol))\n    if uniq:\n        c = random.choice(uniq)\n        idxs = [i for i in range(9) if sol[i] == c]\n        if idxs:\n            m = max(1, int(0.4 * len(idxs)))\n            pick = random.sample(idxs, m)\n            current_k = max(sol)\n            for i in pick:\n                pool = [x for x in range(1, current_k + 1) if x != sol[i]]\n                if not pool and current_k < 9:\n                    pool = [current_k + 1]\n                if pool:\n                    sol[i] = random.choice(pool)\n    normalize(sol)\n\n    # Forced merge attempt with 50% chance to encourage k reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])\n        b = random.choice([x for x in uniq if x != a])\n        for i in range(9):\n            if sol[i] == a:\n                sol[i] = b\n        normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001355657}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"STRING: space-separated 9 positive integers, encoding vertex colors c1..c9 in contiguous domain {1..k}. Example: \"1 1 2 1 1 3 3 2 2\". Feasible iff all labels are integers >=1, contiguous {1..k} with k=max, and for every edge (u,v) in E colors differ.","Evaluacion":"import re\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost; lower is better. Lexicographic via cost = conflicts*20 + k.\n    # Robust parser: accepts list[int] or string of ints.\n    PENALTY_BASE = 1000\n    # Edge set with 1-based vertices\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    # Contiguity check {1..k}\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    # Cost: conflicts dominate; minimal k within zero-conflict region\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor on list[int]. If non-list provided, return error metadata.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    # Problem data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    # Compute current conflicts and conflicting vertices\n    conf_vertices = [i for i in range(n) if conflicts_of_vertex(solution, i) > 0]\n\n    move_roll = random.random()\n    if conf_vertices and move_roll < 0.8:\n        # Conflict-driven recolor of the most conflicting vertex\n        i = max(conf_vertices, key=lambda x: conflicts_of_vertex(solution, x))\n        current_k = max(solution)\n        # Candidate colors: 1..current_k, avoid introducing new color unless all fail\n        best_color = solution[i]\n        best_conf = 10**9\n        # Evaluate each candidate color (excluding current first)\n        candidates = list(range(1, current_k + 1))\n        if solution[i] in candidates:\n            candidates.remove(solution[i])\n        # Try existing colors\n        for c in candidates:\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n                if conf == 0:\n                    # Prefer zero-conflict immediately\n                    break\n            solution[i] = tmp\n        # If no improvement and still conflicts, optionally try introducing color current_k+1 (bounded by 9)\n        if best_conf > 0 and current_k < 9:\n            c = current_k + 1\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n            solution[i] = tmp\n        solution[i] = best_color\n        normalize(solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One\")\n    elif move_roll < 0.95:\n        # Symmetry move: swap two labels globally (if >=2 labels)\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # Introduce second label to escape uniform state\n            j = random.randrange(n)\n            solution[j] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n    else:\n        # Pairwise color exchange on two vertices (not a global swap)\n        i, j = random.sample(range(n), 2)\n        solution[i], solution[j] = solution[j], solution[i]\n        normalize(solution)\n        return (\"NB_Local\", \"Swap-Vertices-Colors\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution; accepts list[int] or string. Preserves type when possible.\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = [int(x) for x in sol.replace(',', ' ').split()]\n            return parts, 'str'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    # Problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1]*9\n    sol = list(sol)\n    normalize(sol)\n\n    # Determine vertices by conflict priority\n    conflict_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(9)]\n    conflict_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Random-kick on top p vertices\n    p = random.randint(2, 4)\n    targets = [i for i, _ in conflict_scores[:p]]\n    current_k = max(sol)\n    for i in targets:\n        # Try a random existing color different from current; 20% chance allow k+1 (<=9)\n        candidates = [c for c in range(1, current_k + 1) if c != sol[i]]\n        if random.random() < 0.2 and current_k < 9:\n            candidates.append(current_k + 1)\n        if candidates:\n            sol[i] = random.choice(candidates)\n    normalize(sol)\n\n    # Color-class shake: choose a color and reassign ~40% of its vertices\n    uniq = sorted(set(sol))\n    if uniq:\n        c = random.choice(uniq)\n        idxs = [i for i in range(9) if sol[i] == c]\n        if idxs:\n            m = max(1, int(0.4 * len(idxs)))\n            pick = random.sample(idxs, m)\n            current_k = max(sol)\n            for i in pick:\n                pool = [x for x in range(1, current_k + 1) if x != sol[i]]\n                if not pool and current_k < 9:\n                    pool = [current_k + 1]\n                if pool:\n                    sol[i] = random.choice(pool)\n    normalize(sol)\n\n    # Forced merge attempt with 50% chance to encourage k reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])\n        b = random.choice([x for x in uniq if x != a])\n        for i in range(9):\n            if sol[i] == a:\n                sol[i] = b\n        normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001277916}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors c1..c9 with contiguous domain {1..k}. Example feasible solution: \"1 1 2 1 1 3 3 2 2\".","Evaluacion":"import re\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input: in-place operation on list[int] of length 9\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def try_reduce_k(sol):\n        # Greedy attempt to remove the highest color class entirely\n        k = max(sol)\n        if k <= 1:\n            return False\n        target = k\n        changed = False\n        moved_any = True\n        # Attempt multiple passes to relocate vertices of 'target'\n        while moved_any:\n            moved_any = False\n            idxs = [i for i, c in enumerate(sol) if c == target]\n            if not idxs:\n                break\n            for i in idxs:\n                for c in range(1, target):\n                    if all(sol[j] != c for j in adj[i]):\n                        sol[i] = c\n                        moved_any = True\n                        changed = True\n                        break\n        if all(c != target for c in sol):\n            before = set(sol)\n            normalize_if_labelset_changed(before, sol)\n            return True\n        return changed\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        ca = sol[seed]\n        cb = b if ca == a else a\n        # BFS on subgraph induced by colors {a,b}\n        seen = set()\n        stack = [seed]\n        seen.add(seed)\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        # swap a<->b on the component 'seen'\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Begin move selection\n    k = max(solution)\n    tot_conf = total_conflicts(solution)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor with global conflict delta evaluation\n        conf_scores = [(i, conflicts_of_vertex(solution, i)) for i in range(n)]\n        # pick a most conflicting vertex; tie-break by higher degree to be more impactful\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        i = max(cand_vertices, key=lambda x: len(adj[x]))\n        current_k = max(solution)\n        best_color = solution[i]\n        best_total = tot_conf\n        colors = list(range(1, current_k + 1))\n        if solution[i] in colors:\n            colors.remove(solution[i])\n        # allow k+1 occasionally to escape dead-ends\n        if current_k < 9:\n            colors.append(current_k + 1)\n        before_set = set(solution)\n        original = solution[i]\n        for c in colors:\n            solution[i] = c\n            cand_total = total_conflicts(solution)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n                if best_total == 0:\n                    # can't do better than zero conflicts\n                    pass\n        solution[i] = best_color\n        normalize_if_labelset_changed(before_set, solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try k-reduction often; otherwise perform Kempe chain to diversify while preserving feasibility\n        move_roll = random.random()\n        if move_roll < 0.7:\n            before_k = max(solution)\n            reduced = try_reduce_k(solution)\n            after_k = max(solution)\n            if reduced and after_k < before_k:\n                return (\"NB_K_Reduction\", \"Greedy-Merge-Highest-Color\")\n            # If not reduced, try to move one vertex from highest color to a feasible lower color\n            target = max(solution)\n            idxs = [i for i, c in enumerate(solution) if c == target]\n            random.shuffle(idxs)\n            for i in idxs:\n                for c in range(1, target):\n                    if all(solution[j] != c for j in adj[i]):\n                        before = set(solution)\n                        solution[i] = c\n                        normalize_if_labelset_changed(before, solution)\n                        return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n            # fall through to diversification if nothing applied\n        # Kempe-chain interchange (feasibility-preserving)\n        kempe_chain_flip(solution)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nimport re\n\n\ndef perturb_solution(solution):\n    # Parse and preserve type\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums], 'str'\n        return [1] * 9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Kempe diversifications (2-3 times)\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n\n    # 2) Random-kick on top conflict vertices (if any conflicts exist)\n    confs = [conflicts_of_vertex(sol, i) for i in range(n)]\n    idxs = list(range(n))\n    idxs.sort(key=lambda i: confs[i], reverse=True)\n    top_p = max(2, min(4, len(idxs)))\n    picks = idxs[:top_p]\n    k = max(sol)\n    for i in picks:\n        # choose a different color; 25% chance allow k+1 (<=9)\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.25 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Forced partial merge attempt of highest color to encourage k drop\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to run target heuristic: name 're' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002480531}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors c1..c9 with contiguous domain {1..k}. Example feasible solution: \"1 1 2 1 1 3 3 2 2\".","Evaluacion":"import re\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input: in-place operation on list[int] of length 9\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def try_reduce_k(sol):\n        # Greedy attempt to remove the highest color class entirely\n        k = max(sol)\n        if k <= 1:\n            return False\n        target = k\n        changed = False\n        moved_any = True\n        # Attempt multiple passes to relocate vertices of 'target'\n        while moved_any:\n            moved_any = False\n            idxs = [i for i, c in enumerate(sol) if c == target]\n            if not idxs:\n                break\n            for i in idxs:\n                for c in range(1, target):\n                    if all(sol[j] != c for j in adj[i]):\n                        sol[i] = c\n                        moved_any = True\n                        changed = True\n                        break\n        if all(c != target for c in sol):\n            before = set(sol)\n            normalize_if_labelset_changed(before, sol)\n            return True\n        return changed\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        ca = sol[seed]\n        cb = b if ca == a else a\n        # BFS on subgraph induced by colors {a,b}\n        seen = set()\n        stack = [seed]\n        seen.add(seed)\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        # swap a<->b on the component 'seen'\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Begin move selection\n    k = max(solution)\n    tot_conf = total_conflicts(solution)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor with global conflict delta evaluation\n        conf_scores = [(i, conflicts_of_vertex(solution, i)) for i in range(n)]\n        # pick a most conflicting vertex; tie-break by higher degree to be more impactful\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        i = max(cand_vertices, key=lambda x: len(adj[x]))\n        current_k = max(solution)\n        best_color = solution[i]\n        best_total = tot_conf\n        colors = list(range(1, current_k + 1))\n        if solution[i] in colors:\n            colors.remove(solution[i])\n        # allow k+1 occasionally to escape dead-ends\n        if current_k < 9:\n            colors.append(current_k + 1)\n        before_set = set(solution)\n        original = solution[i]\n        for c in colors:\n            solution[i] = c\n            cand_total = total_conflicts(solution)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n                if best_total == 0:\n                    # can't do better than zero conflicts\n                    pass\n        solution[i] = best_color\n        normalize_if_labelset_changed(before_set, solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try k-reduction often; otherwise perform Kempe chain to diversify while preserving feasibility\n        move_roll = random.random()\n        if move_roll < 0.7:\n            before_k = max(solution)\n            reduced = try_reduce_k(solution)\n            after_k = max(solution)\n            if reduced and after_k < before_k:\n                return (\"NB_K_Reduction\", \"Greedy-Merge-Highest-Color\")\n            # If not reduced, try to move one vertex from highest color to a feasible lower color\n            target = max(solution)\n            idxs = [i for i, c in enumerate(solution) if c == target]\n            random.shuffle(idxs)\n            for i in idxs:\n                for c in range(1, target):\n                    if all(solution[j] != c for j in adj[i]):\n                        before = set(solution)\n                        solution[i] = c\n                        normalize_if_labelset_changed(before, solution)\n                        return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n            # fall through to diversification if nothing applied\n        # Kempe-chain interchange (feasibility-preserving)\n        kempe_chain_flip(solution)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nimport re\n\n\ndef perturb_solution(solution):\n    # Parse and preserve type\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums], 'str'\n        return [1] * 9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Kempe diversifications (2-3 times)\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n\n    # 2) Random-kick on top conflict vertices (if any conflicts exist)\n    confs = [conflicts_of_vertex(sol, i) for i in range(n)]\n    idxs = list(range(n))\n    idxs.sort(key=lambda i: confs[i], reverse=True)\n    top_p = max(2, min(4, len(idxs)))\n    picks = idxs[:top_p]\n    k = max(sol)\n    for i in picks:\n        # choose a different color; 25% chance allow k+1 (<=9)\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.25 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Forced partial merge attempt of highest color to encourage k drop\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to run target heuristic: name 're' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002074946}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors c1..c9 with contiguous domain {1..k}. Example feasible solution: \"1 1 2 1 1 3 3 2 2\".","Evaluacion":"import re\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input: in-place operation on list[int] of length 9\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def try_reduce_k(sol):\n        # Greedy attempt to remove the highest color class entirely\n        k = max(sol)\n        if k <= 1:\n            return False\n        target = k\n        changed = False\n        moved_any = True\n        # Attempt multiple passes to relocate vertices of 'target'\n        while moved_any:\n            moved_any = False\n            idxs = [i for i, c in enumerate(sol) if c == target]\n            if not idxs:\n                break\n            for i in idxs:\n                for c in range(1, target):\n                    if all(sol[j] != c for j in adj[i]):\n                        sol[i] = c\n                        moved_any = True\n                        changed = True\n                        break\n        if all(c != target for c in sol):\n            before = set(sol)\n            normalize_if_labelset_changed(before, sol)\n            return True\n        return changed\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        ca = sol[seed]\n        cb = b if ca == a else a\n        # BFS on subgraph induced by colors {a,b}\n        seen = set()\n        stack = [seed]\n        seen.add(seed)\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        # swap a<->b on the component 'seen'\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Begin move selection\n    k = max(solution)\n    tot_conf = total_conflicts(solution)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor with global conflict delta evaluation\n        conf_scores = [(i, conflicts_of_vertex(solution, i)) for i in range(n)]\n        # pick a most conflicting vertex; tie-break by higher degree to be more impactful\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        i = max(cand_vertices, key=lambda x: len(adj[x]))\n        current_k = max(solution)\n        best_color = solution[i]\n        best_total = tot_conf\n        colors = list(range(1, current_k + 1))\n        if solution[i] in colors:\n            colors.remove(solution[i])\n        # allow k+1 occasionally to escape dead-ends\n        if current_k < 9:\n            colors.append(current_k + 1)\n        before_set = set(solution)\n        original = solution[i]\n        for c in colors:\n            solution[i] = c\n            cand_total = total_conflicts(solution)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n                if best_total == 0:\n                    # can't do better than zero conflicts\n                    pass\n        solution[i] = best_color\n        normalize_if_labelset_changed(before_set, solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try k-reduction often; otherwise perform Kempe chain to diversify while preserving feasibility\n        move_roll = random.random()\n        if move_roll < 0.7:\n            before_k = max(solution)\n            reduced = try_reduce_k(solution)\n            after_k = max(solution)\n            if reduced and after_k < before_k:\n                return (\"NB_K_Reduction\", \"Greedy-Merge-Highest-Color\")\n            # If not reduced, try to move one vertex from highest color to a feasible lower color\n            target = max(solution)\n            idxs = [i for i, c in enumerate(solution) if c == target]\n            random.shuffle(idxs)\n            for i in idxs:\n                for c in range(1, target):\n                    if all(solution[j] != c for j in adj[i]):\n                        before = set(solution)\n                        solution[i] = c\n                        normalize_if_labelset_changed(before, solution)\n                        return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n            # fall through to diversification if nothing applied\n        # Kempe-chain interchange (feasibility-preserving)\n        kempe_chain_flip(solution)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nimport re\n\n\ndef perturb_solution(solution):\n    # Parse and preserve type\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums], 'str'\n        return [1] * 9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Kempe diversifications (2-3 times)\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n\n    # 2) Random-kick on top conflict vertices (if any conflicts exist)\n    confs = [conflicts_of_vertex(sol, i) for i in range(n)]\n    idxs = list(range(n))\n    idxs.sort(key=lambda i: confs[i], reverse=True)\n    top_p = max(2, min(4, len(idxs)))\n    picks = idxs[:top_p]\n    k = max(sol)\n    for i in picks:\n        # choose a different color; 25% chance allow k+1 (<=9)\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.25 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Forced partial merge attempt of highest color to encourage k drop\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001868493}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors for vertices 1..9 with contiguous labels {1..k}. Example: \"2 2 1 2 2 3 3 1 1\".","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> int:\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts]\n            except Exception:\n                return None\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This neighborhood operates in-place on list[int] of length 9.\n    # If a string is provided, it performs no change to the input and only returns move metadata.\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_list_valid(sol):\n        return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) for x in sol)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def total_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol: List[int], i: int) -> int:\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol: List[int]) -> bool:\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        # Bias towards involving highest color to promote k-reduction\n        mx = max(uniq)\n        if len(uniq) >= 2 and random.random() < 0.7 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # If input is a list, we operate in place. If not, we only return move info.\n    if not is_list_valid(solution):\n        return (\"NB_NoOp\", \"Invalid-Or-NonList-Input\")\n\n    # Begin move selection on a copy, then commit to original to reduce partial side effects if aborted\n    sol = solution  # operate in-place as required by API\n    k = max(sol)\n    tot_conf = total_conflicts(sol)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor: pick a most conflicting vertex and recolor to minimize global conflicts.\n        conf_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(n)]\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        # tie-break: prefer vertices from highest color class, then higher degree\n        highest_class = max(sol)\n        cand_vertices.sort(key=lambda i: ((sol[i] != highest_class), -len(adj[i])))\n        i = cand_vertices[0]\n        current_k = max(sol)\n        best_color = sol[i]\n        best_total = tot_conf\n        colors = [c for c in range(1, current_k + 1) if c != sol[i]]\n        # Allow k+1 only if it strictly reduces conflicts\n        allow_extra = current_k < 9\n        before_set = set(sol)\n        original = sol[i]\n        for c in colors + ([current_k + 1] if allow_extra else []):\n            sol[i] = c\n            cand_total = total_conflicts(sol)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n        sol[i] = best_color\n        normalize_if_labelset_changed(before_set, sol)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try reduce k greedily, else diversify via Kempe chains\n        # Attempt to reassign vertices in highest color class to lower colors\n        target = k\n        idxs = [i for i, c in enumerate(sol) if c == target]\n        random.shuffle(idxs)\n        moved = False\n        for i in idxs:\n            for c in range(1, target):\n                if all(sol[j] != c for j in adj[i]):\n                    before_set = set(sol)\n                    sol[i] = c\n                    moved = True\n                    normalize_if_labelset_changed(before_set, sol)\n                    break\n            if moved:\n                break\n        if moved:\n            return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n        # Else perform a Kempe chain flip to diversify while preserving feasibility\n        kempe_chain_flip(sol)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Returns a perturbed solution preserving input type (list or str).\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts], 'str'\n            except Exception:\n                return [1]*9, 'list'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    def normalize(sol: List[int]):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def kempe_chain_flip(sol: List[int]):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        mx = max(uniq)\n        # Bias 0.6 to include highest color to encourage k reduction\n        if random.random() < 0.6 and len(uniq) >= 2 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Perform 2-3 Kempe chain flips for diversification\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n    normalize(sol)\n\n    # 2) Random recolor kicks on up to 3 vertices (allow k+1 with small probability)\n    k = max(sol)\n    picks = list(range(n))\n    random.shuffle(picks)\n    picks = picks[:3]\n    for i in picks:\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.2 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Attempt partial merge of highest color into lower ones\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002210488}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors for vertices 1..9 with contiguous labels {1..k}. Example: \"2 2 1 2 2 3 3 1 1\".","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> int:\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts]\n            except Exception:\n                return None\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This neighborhood operates in-place on list[int] of length 9.\n    # If a string is provided, it performs no change to the input and only returns move metadata.\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_list_valid(sol):\n        return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) for x in sol)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def total_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol: List[int], i: int) -> int:\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol: List[int]) -> bool:\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        # Bias towards involving highest color to promote k-reduction\n        mx = max(uniq)\n        if len(uniq) >= 2 and random.random() < 0.7 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # If input is a list, we operate in place. If not, we only return move info.\n    if not is_list_valid(solution):\n        return (\"NB_NoOp\", \"Invalid-Or-NonList-Input\")\n\n    # Begin move selection on a copy, then commit to original to reduce partial side effects if aborted\n    sol = solution  # operate in-place as required by API\n    k = max(sol)\n    tot_conf = total_conflicts(sol)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor: pick a most conflicting vertex and recolor to minimize global conflicts.\n        conf_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(n)]\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        # tie-break: prefer vertices from highest color class, then higher degree\n        highest_class = max(sol)\n        cand_vertices.sort(key=lambda i: ((sol[i] != highest_class), -len(adj[i])))\n        i = cand_vertices[0]\n        current_k = max(sol)\n        best_color = sol[i]\n        best_total = tot_conf\n        colors = [c for c in range(1, current_k + 1) if c != sol[i]]\n        # Allow k+1 only if it strictly reduces conflicts\n        allow_extra = current_k < 9\n        before_set = set(sol)\n        original = sol[i]\n        for c in colors + ([current_k + 1] if allow_extra else []):\n            sol[i] = c\n            cand_total = total_conflicts(sol)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n        sol[i] = best_color\n        normalize_if_labelset_changed(before_set, sol)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try reduce k greedily, else diversify via Kempe chains\n        # Attempt to reassign vertices in highest color class to lower colors\n        target = k\n        idxs = [i for i, c in enumerate(sol) if c == target]\n        random.shuffle(idxs)\n        moved = False\n        for i in idxs:\n            for c in range(1, target):\n                if all(sol[j] != c for j in adj[i]):\n                    before_set = set(sol)\n                    sol[i] = c\n                    moved = True\n                    normalize_if_labelset_changed(before_set, sol)\n                    break\n            if moved:\n                break\n        if moved:\n            return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n        # Else perform a Kempe chain flip to diversify while preserving feasibility\n        kempe_chain_flip(sol)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Returns a perturbed solution preserving input type (list or str).\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts], 'str'\n            except Exception:\n                return [1]*9, 'list'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    def normalize(sol: List[int]):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def kempe_chain_flip(sol: List[int]):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        mx = max(uniq)\n        # Bias 0.6 to include highest color to encourage k reduction\n        if random.random() < 0.6 and len(uniq) >= 2 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Perform 2-3 Kempe chain flips for diversification\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n    normalize(sol)\n\n    # 2) Random recolor kicks on up to 3 vertices (allow k+1 with small probability)\n    k = max(sol)\n    picks = list(range(n))\n    random.shuffle(picks)\n    picks = picks[:3]\n    for i in picks:\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.2 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Attempt partial merge of highest color into lower ones\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002172567}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors for vertices 1..9 with contiguous labels {1..k}. Example: \"2 2 1 2 2 3 3 1 1\".","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> int:\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts]\n            except Exception:\n                return None\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This neighborhood operates in-place on list[int] of length 9.\n    # If a string is provided, it performs no change to the input and only returns move metadata.\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_list_valid(sol):\n        return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) for x in sol)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def total_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol: List[int], i: int) -> int:\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol: List[int]) -> bool:\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        # Bias towards involving highest color to promote k-reduction\n        mx = max(uniq)\n        if len(uniq) >= 2 and random.random() < 0.7 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # If input is a list, we operate in place. If not, we only return move info.\n    if not is_list_valid(solution):\n        return (\"NB_NoOp\", \"Invalid-Or-NonList-Input\")\n\n    # Begin move selection on a copy, then commit to original to reduce partial side effects if aborted\n    sol = solution  # operate in-place as required by API\n    k = max(sol)\n    tot_conf = total_conflicts(sol)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor: pick a most conflicting vertex and recolor to minimize global conflicts.\n        conf_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(n)]\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        # tie-break: prefer vertices from highest color class, then higher degree\n        highest_class = max(sol)\n        cand_vertices.sort(key=lambda i: ((sol[i] != highest_class), -len(adj[i])))\n        i = cand_vertices[0]\n        current_k = max(sol)\n        best_color = sol[i]\n        best_total = tot_conf\n        colors = [c for c in range(1, current_k + 1) if c != sol[i]]\n        # Allow k+1 only if it strictly reduces conflicts\n        allow_extra = current_k < 9\n        before_set = set(sol)\n        original = sol[i]\n        for c in colors + ([current_k + 1] if allow_extra else []):\n            sol[i] = c\n            cand_total = total_conflicts(sol)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n        sol[i] = best_color\n        normalize_if_labelset_changed(before_set, sol)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try reduce k greedily, else diversify via Kempe chains\n        # Attempt to reassign vertices in highest color class to lower colors\n        target = k\n        idxs = [i for i, c in enumerate(sol) if c == target]\n        random.shuffle(idxs)\n        moved = False\n        for i in idxs:\n            for c in range(1, target):\n                if all(sol[j] != c for j in adj[i]):\n                    before_set = set(sol)\n                    sol[i] = c\n                    moved = True\n                    normalize_if_labelset_changed(before_set, sol)\n                    break\n            if moved:\n                break\n        if moved:\n            return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n        # Else perform a Kempe chain flip to diversify while preserving feasibility\n        kempe_chain_flip(sol)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Returns a perturbed solution preserving input type (list or str).\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts], 'str'\n            except Exception:\n                return [1]*9, 'list'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    def normalize(sol: List[int]):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def kempe_chain_flip(sol: List[int]):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        mx = max(uniq)\n        # Bias 0.6 to include highest color to encourage k reduction\n        if random.random() < 0.6 and len(uniq) >= 2 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Perform 2-3 Kempe chain flips for diversification\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n    normalize(sol)\n\n    # 2) Random recolor kicks on up to 3 vertices (allow k+1 with small probability)\n    k = max(sol)\n    picks = list(range(n))\n    random.shuffle(picks)\n    picks = picks[:3]\n    for i in picks:\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.2 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Attempt partial merge of highest color into lower ones\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001969504}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 (1-based colors, arbitrary labels). Example: [1,1,3,1,1,2,2,3,3].","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain\/integrality\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a trivial neighbour to remain robust\n        base = [1]*9\n        return (base, \"reset\")\n    n = 9\n    cur = solution[:]\n    # Graph definition\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency for quick checks\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n    max_color = max(cur) if cur else 1\n    # Strategy: if conflicts exist, target one endpoint; else diversify by recoloring a random vertex\n    if conflicts:\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        # Choose a color different from all neighbors; allow introducing a new color at most +1 of current max\n        neighbor_colors = {cur[w-1] for w in adj[target]}\n        palette = list(set(range(1, max_color+1)) - neighbor_colors)\n        if not palette:\n            palette = [max_color+1]\n        new_color = random.choice(palette)\n        cur[target-1] = new_color\n        return (cur, \"conflict_recolor\")\n    else:\n        # No conflicts: attempt to reduce colors by reassigning a vertex to an existing color if safe; otherwise jitter\n        order = list(range(1, n+1))\n        random.shuffle(order)\n        moved = False\n        for v in order:\n            old = cur[v-1]\n            # Try to map to a lower color label first\n            trial_colors = list(range(1, max_color+1))\n            random.shuffle(trial_colors)\n            for c in trial_colors:\n                if c == old:\n                    continue\n                ok = True\n                for w in adj[v]:\n                    if cur[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved:\n            # Mild jitter: recolor a random vertex to a random color in [1..max_color]\n            v = random.randint(1, n)\n            c = random.randint(1, max_color)\n            cur[v-1] = c\n        return (cur, \"feasible_relabel\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: probabilistically reassign a subset of vertices and optionally relabel colors\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Initialize random feasible-ish seed (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n    n = 9\n    s = solution[:]\n    # With some probability, apply a random permutation of color labels to escape symmetry\n    colors = sorted(set(s))\n    if colors:\n        if random.random() < 0.5:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[i] for i, c in enumerate(colors)}\n            s = [mapping[c] for c in s]\n    # Randomly pick m vertices (m in [2..4]) and reassign colors in [1..max_color+1]\n    max_color = max(s) if s else 1\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        s[i] = random.randint(1, max_color + 1)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0008947109}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 (1-based colors, arbitrary labels). Example: [1,1,3,1,1,2,2,3,3].","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain\/integrality\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a trivial neighbour to remain robust\n        base = [1]*9\n        return (base, \"reset\")\n    n = 9\n    cur = solution[:]\n    # Graph definition\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency for quick checks\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n    max_color = max(cur) if cur else 1\n    # Strategy: if conflicts exist, target one endpoint; else diversify by recoloring a random vertex\n    if conflicts:\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        # Choose a color different from all neighbors; allow introducing a new color at most +1 of current max\n        neighbor_colors = {cur[w-1] for w in adj[target]}\n        palette = list(set(range(1, max_color+1)) - neighbor_colors)\n        if not palette:\n            palette = [max_color+1]\n        new_color = random.choice(palette)\n        cur[target-1] = new_color\n        return (cur, \"conflict_recolor\")\n    else:\n        # No conflicts: attempt to reduce colors by reassigning a vertex to an existing color if safe; otherwise jitter\n        order = list(range(1, n+1))\n        random.shuffle(order)\n        moved = False\n        for v in order:\n            old = cur[v-1]\n            # Try to map to a lower color label first\n            trial_colors = list(range(1, max_color+1))\n            random.shuffle(trial_colors)\n            for c in trial_colors:\n                if c == old:\n                    continue\n                ok = True\n                for w in adj[v]:\n                    if cur[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved:\n            # Mild jitter: recolor a random vertex to a random color in [1..max_color]\n            v = random.randint(1, n)\n            c = random.randint(1, max_color)\n            cur[v-1] = c\n        return (cur, \"feasible_relabel\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: probabilistically reassign a subset of vertices and optionally relabel colors\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Initialize random feasible-ish seed (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n    n = 9\n    s = solution[:]\n    # With some probability, apply a random permutation of color labels to escape symmetry\n    colors = sorted(set(s))\n    if colors:\n        if random.random() < 0.5:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[i] for i, c in enumerate(colors)}\n            s = [mapping[c] for c in s]\n    # Randomly pick m vertices (m in [2..4]) and reassign colors in [1..max_color+1]\n    max_color = max(s) if s else 1\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        s[i] = random.randint(1, max_color + 1)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000717199}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 (1-based colors, arbitrary labels). Example: [1,1,3,1,1,2,2,3,3].","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain\/integrality\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a trivial neighbour to remain robust\n        base = [1]*9\n        return (base, \"reset\")\n    n = 9\n    cur = solution[:]\n    # Graph definition\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency for quick checks\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n    max_color = max(cur) if cur else 1\n    # Strategy: if conflicts exist, target one endpoint; else diversify by recoloring a random vertex\n    if conflicts:\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        # Choose a color different from all neighbors; allow introducing a new color at most +1 of current max\n        neighbor_colors = {cur[w-1] for w in adj[target]}\n        palette = list(set(range(1, max_color+1)) - neighbor_colors)\n        if not palette:\n            palette = [max_color+1]\n        new_color = random.choice(palette)\n        cur[target-1] = new_color\n        return (cur, \"conflict_recolor\")\n    else:\n        # No conflicts: attempt to reduce colors by reassigning a vertex to an existing color if safe; otherwise jitter\n        order = list(range(1, n+1))\n        random.shuffle(order)\n        moved = False\n        for v in order:\n            old = cur[v-1]\n            # Try to map to a lower color label first\n            trial_colors = list(range(1, max_color+1))\n            random.shuffle(trial_colors)\n            for c in trial_colors:\n                if c == old:\n                    continue\n                ok = True\n                for w in adj[v]:\n                    if cur[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved:\n            # Mild jitter: recolor a random vertex to a random color in [1..max_color]\n            v = random.randint(1, n)\n            c = random.randint(1, max_color)\n            cur[v-1] = c\n        return (cur, \"feasible_relabel\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: probabilistically reassign a subset of vertices and optionally relabel colors\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Initialize random feasible-ish seed (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n    n = 9\n    s = solution[:]\n    # With some probability, apply a random permutation of color labels to escape symmetry\n    colors = sorted(set(s))\n    if colors:\n        if random.random() < 0.5:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[i] for i, c in enumerate(colors)}\n            s = [mapping[c] for c in s]\n    # Randomly pick m vertices (m in [2..4]) and reassign colors in [1..max_color+1]\n    max_color = max(s) if s else 1\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        s[i] = random.randint(1, max_color + 1)\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000697859}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k} and k minimized.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = normalize_colors(solution[:])\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        target_color = sol[v-1]\n        if target_color not in (color_a, color_b):\n            return sol[:]\n        keep = set([color_a, color_b])\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting vertex, try best existing color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        best_sol = None\n        best_score = None\n        used_colors = list(range(1, k+1))\n        random.shuffle(used_colors)\n        for c in used_colors:\n            if c == cur[target-1]:\n                continue\n            if feasible_recolor(cur, target, c):\n                trial = cur[:]\n                trial[target-1] = c\n                sc = count_conflicts(trial)\n                if best_score is None or sc < best_score:\n                    best_score = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n        # If no direct recolor reduces conflicts, attempt a Kempe-chain swap between two existing colors\n        c_a = cur[target-1]\n        # Pick an alternative color present in the palette\n        alt_colors = [c for c in range(1, k+1) if c != c_a]\n        if not alt_colors:\n            return (cur, \"noop\")\n        c_b = random.choice(alt_colors)\n        swapped = kempe_swap(cur, target, c_a, c_b)\n        return (normalize_colors(swapped), \"kempe_swap_conflict\")\n    else:\n        # Feasible: try to reduce number of colors by eliminating the highest label\n        if k > 1:\n            target_color = k\n            vertices = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            random.shuffle(vertices)\n            reduced = cur[:]\n            success = True\n            for v in vertices:\n                # Try to move v to any lower color without conflicts\n                moved = False\n                palette = list(range(1, target_color))\n                random.shuffle(palette)\n                for c in palette:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (normalize_colors(reduced), \"color_drop\")\n        # If not reduced, apply a small Kempe swap to diversify keeping k constant\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        # choose a different color within current palette\n        choices = [c for c in range(1, k+1) if c != c_a]\n        if not choices:\n            return (cur, \"noop\")\n        c_b = random.choice(choices)\n        swapped = kempe_swap(cur, v, c_a, c_b)\n        swapped = normalize_colors(swapped)\n        return (swapped, \"kempe_swap_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = set([color_a, color_b])\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # With probability, relabel colors by a random permutation to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Perform several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        # choose a different existing color to swap with\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment of a few vertices to existing colors (no new colors)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        # Try up to 2 attempts to pick a different color within existing palette\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Resultados":[[1,1,2,1,1,3,3,2,2],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002324633}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k} and k minimized.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = normalize_colors(solution[:])\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        target_color = sol[v-1]\n        if target_color not in (color_a, color_b):\n            return sol[:]\n        keep = set([color_a, color_b])\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting vertex, try best existing color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        best_sol = None\n        best_score = None\n        used_colors = list(range(1, k+1))\n        random.shuffle(used_colors)\n        for c in used_colors:\n            if c == cur[target-1]:\n                continue\n            if feasible_recolor(cur, target, c):\n                trial = cur[:]\n                trial[target-1] = c\n                sc = count_conflicts(trial)\n                if best_score is None or sc < best_score:\n                    best_score = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n        # If no direct recolor reduces conflicts, attempt a Kempe-chain swap between two existing colors\n        c_a = cur[target-1]\n        # Pick an alternative color present in the palette\n        alt_colors = [c for c in range(1, k+1) if c != c_a]\n        if not alt_colors:\n            return (cur, \"noop\")\n        c_b = random.choice(alt_colors)\n        swapped = kempe_swap(cur, target, c_a, c_b)\n        return (normalize_colors(swapped), \"kempe_swap_conflict\")\n    else:\n        # Feasible: try to reduce number of colors by eliminating the highest label\n        if k > 1:\n            target_color = k\n            vertices = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            random.shuffle(vertices)\n            reduced = cur[:]\n            success = True\n            for v in vertices:\n                # Try to move v to any lower color without conflicts\n                moved = False\n                palette = list(range(1, target_color))\n                random.shuffle(palette)\n                for c in palette:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (normalize_colors(reduced), \"color_drop\")\n        # If not reduced, apply a small Kempe swap to diversify keeping k constant\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        # choose a different color within current palette\n        choices = [c for c in range(1, k+1) if c != c_a]\n        if not choices:\n            return (cur, \"noop\")\n        c_b = random.choice(choices)\n        swapped = kempe_swap(cur, v, c_a, c_b)\n        swapped = normalize_colors(swapped)\n        return (swapped, \"kempe_swap_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = set([color_a, color_b])\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # With probability, relabel colors by a random permutation to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Perform several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        # choose a different existing color to swap with\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment of a few vertices to existing colors (no new colors)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        # Try up to 2 attempts to pick a different color within existing palette\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Resultados":[[1,1,1,2,1,1,2,2,1],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003193345}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k} and k minimized.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = normalize_colors(solution[:])\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        target_color = sol[v-1]\n        if target_color not in (color_a, color_b):\n            return sol[:]\n        keep = set([color_a, color_b])\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting vertex, try best existing color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        best_sol = None\n        best_score = None\n        used_colors = list(range(1, k+1))\n        random.shuffle(used_colors)\n        for c in used_colors:\n            if c == cur[target-1]:\n                continue\n            if feasible_recolor(cur, target, c):\n                trial = cur[:]\n                trial[target-1] = c\n                sc = count_conflicts(trial)\n                if best_score is None or sc < best_score:\n                    best_score = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n        # If no direct recolor reduces conflicts, attempt a Kempe-chain swap between two existing colors\n        c_a = cur[target-1]\n        # Pick an alternative color present in the palette\n        alt_colors = [c for c in range(1, k+1) if c != c_a]\n        if not alt_colors:\n            return (cur, \"noop\")\n        c_b = random.choice(alt_colors)\n        swapped = kempe_swap(cur, target, c_a, c_b)\n        return (normalize_colors(swapped), \"kempe_swap_conflict\")\n    else:\n        # Feasible: try to reduce number of colors by eliminating the highest label\n        if k > 1:\n            target_color = k\n            vertices = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            random.shuffle(vertices)\n            reduced = cur[:]\n            success = True\n            for v in vertices:\n                # Try to move v to any lower color without conflicts\n                moved = False\n                palette = list(range(1, target_color))\n                random.shuffle(palette)\n                for c in palette:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (normalize_colors(reduced), \"color_drop\")\n        # If not reduced, apply a small Kempe swap to diversify keeping k constant\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        # choose a different color within current palette\n        choices = [c for c in range(1, k+1) if c != c_a]\n        if not choices:\n            return (cur, \"noop\")\n        c_b = random.choice(choices)\n        swapped = kempe_swap(cur, v, c_a, c_b)\n        swapped = normalize_colors(swapped)\n        return (swapped, \"kempe_swap_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = set([color_a, color_b])\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # With probability, relabel colors by a random permutation to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Perform several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        # choose a different existing color to swap with\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment of a few vertices to existing colors (no new colors)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        # Try up to 2 attempts to pick a different color within existing palette\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001206066}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden. Output example: [1,1,2,1,1,3,3,2,2].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed recolor: choose most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_conflicts = count_conflicts(cur)\n        best_sol = None\n        best_conf = None\n        palette = list(range(1, max(k, 2)+1))  # ensure at least 2 to allow a move\n        random.shuffle(palette)\n        for c in palette:\n            if c == cur[worst_v-1]:\n                continue\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = count_conflicts(trial)\n                if sc <= current_conflicts and (best_conf is None or sc < best_conf):\n                    best_conf = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (best_sol, \"conflict_recolor\")\n        # Try a gated Kempe swap that does not increase conflicts\n        alt_colors = [c for c in range(1, k+1) if c != cur[worst_v-1]]\n        if alt_colors:\n            c_b = random.choice(alt_colors)\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if count_conflicts(swapped) <= current_conflicts:\n                return (swapped, \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            # Order by saturation degree (distinct neighbor colors desc)\n            def sat_deg(v):\n                return len({cur[w-1] for w in adj[v]})\n            verts.sort(key=sat_deg, reverse=True)\n            reduced = cur[:]\n            success = True\n            for v in verts:\n                # Try to move v to a lower color without conflicts\n                candidates = list(range(1, target_color))\n                random.shuffle(candidates)\n                moved = False\n                for c in candidates:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                reduced = normalize_colors(reduced)\n                return (reduced, \"color_drop\")\n        # If not reduced, diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (trial, \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if count_conflicts(swapped) == 0:\n                return (swapped, \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment within existing palette (may introduce few conflicts)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Resultados":[[2,2,3,2,2,1,1,3,3],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002618266}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden. Output example: [1,1,2,1,1,3,3,2,2].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed recolor: choose most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_conflicts = count_conflicts(cur)\n        best_sol = None\n        best_conf = None\n        palette = list(range(1, max(k, 2)+1))  # ensure at least 2 to allow a move\n        random.shuffle(palette)\n        for c in palette:\n            if c == cur[worst_v-1]:\n                continue\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = count_conflicts(trial)\n                if sc <= current_conflicts and (best_conf is None or sc < best_conf):\n                    best_conf = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (best_sol, \"conflict_recolor\")\n        # Try a gated Kempe swap that does not increase conflicts\n        alt_colors = [c for c in range(1, k+1) if c != cur[worst_v-1]]\n        if alt_colors:\n            c_b = random.choice(alt_colors)\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if count_conflicts(swapped) <= current_conflicts:\n                return (swapped, \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            # Order by saturation degree (distinct neighbor colors desc)\n            def sat_deg(v):\n                return len({cur[w-1] for w in adj[v]})\n            verts.sort(key=sat_deg, reverse=True)\n            reduced = cur[:]\n            success = True\n            for v in verts:\n                # Try to move v to a lower color without conflicts\n                candidates = list(range(1, target_color))\n                random.shuffle(candidates)\n                moved = False\n                for c in candidates:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                reduced = normalize_colors(reduced)\n                return (reduced, \"color_drop\")\n        # If not reduced, diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (trial, \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if count_conflicts(swapped) == 0:\n                return (swapped, \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment within existing palette (may introduce few conflicts)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Resultados":[[1,2,2,2,2,1,1,2,1],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003531528}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden. Output example: [1,1,2,1,1,3,3,2,2].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed recolor: choose most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_conflicts = count_conflicts(cur)\n        best_sol = None\n        best_conf = None\n        palette = list(range(1, max(k, 2)+1))  # ensure at least 2 to allow a move\n        random.shuffle(palette)\n        for c in palette:\n            if c == cur[worst_v-1]:\n                continue\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = count_conflicts(trial)\n                if sc <= current_conflicts and (best_conf is None or sc < best_conf):\n                    best_conf = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (best_sol, \"conflict_recolor\")\n        # Try a gated Kempe swap that does not increase conflicts\n        alt_colors = [c for c in range(1, k+1) if c != cur[worst_v-1]]\n        if alt_colors:\n            c_b = random.choice(alt_colors)\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if count_conflicts(swapped) <= current_conflicts:\n                return (swapped, \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            # Order by saturation degree (distinct neighbor colors desc)\n            def sat_deg(v):\n                return len({cur[w-1] for w in adj[v]})\n            verts.sort(key=sat_deg, reverse=True)\n            reduced = cur[:]\n            success = True\n            for v in verts:\n                # Try to move v to a lower color without conflicts\n                candidates = list(range(1, target_color))\n                random.shuffle(candidates)\n                moved = False\n                for c in candidates:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                reduced = normalize_colors(reduced)\n                return (reduced, \"color_drop\")\n        # If not reduced, diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (trial, \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if count_conflicts(swapped) == 0:\n                return (swapped, \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment within existing palette (may introduce few conflicts)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002136989}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts:\n        # Composite score to guide search within equal-conflict plateaus\n        return 10**8 * conflicts + k\n    # Feasible: number of distinct colors (lower is better)\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def score(sol):\n        c = conflict_count(sol)\n        if c:\n            return 10**8 * c + len(set(sol))\n        return len(set(sol))\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed move: pick most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_score = score(cur)\n\n        # Attempt recolor to least frequent feasible color in neighborhood\n        neigh_colors = {}\n        for w in adj[worst_v]:\n            c = cur[w-1]\n            neigh_colors[c] = neigh_colors.get(c, 0) + 1\n        palette = list(range(1, max(k, 2)+1))\n        palette = [c for c in palette if c != cur[worst_v-1]]\n        palette.sort(key=lambda c: neigh_colors.get(c, 0))  # least frequent first\n        best_sol = None\n        best_sc = None\n        for c in palette:\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = score(trial)\n                if sc <= current_score and (best_sc is None or sc < best_sc):\n                    best_sc = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n\n        # If recolor failed, try a biased Kempe swap with color minimizing neighbor frequency\n        if palette:\n            # pick color with min frequency among neighbors\n            c_b = min(palette, key=lambda c: neigh_colors.get(c, 0))\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if score(swapped) <= current_score:\n                return (normalize_colors(swapped), \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k with multi-pass reassignment\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            if verts:\n                reduced = cur[:]\n                changed = True\n                attempt_limit = 3\n                attempts = 0\n                while attempts < attempt_limit and verts:\n                    attempts += 1\n                    progress = False\n                    for v in list(verts):\n                        # Try least-constraining feasible color in 1..target_color-1\n                        cand = list(range(1, target_color))\n                        # order by conflicts that would be introduced (LCV heuristic)\n                        def clash_count(color):\n                            cnt = 0\n                            for w in adj[v]:\n                                if reduced[w-1] == color:\n                                    cnt += 1\n                            return cnt\n                        cand.sort(key=clash_count)\n                        moved = False\n                        for c in cand:\n                            if feasible_recolor(reduced, v, c):\n                                reduced[v-1] = c\n                                verts.remove(v)\n                                progress = True\n                                moved = True\n                                break\n                        if not moved:\n                            continue\n                    if not progress:\n                        break\n                if not verts:\n                    reduced = normalize_colors(reduced)\n                    return (reduced, \"color_drop\")\n        # Diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (normalize_colors(trial), \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility if possible\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if conflict_count(swapped) == 0:\n                return (normalize_colors(swapped), \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.7:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 4 if k <= 3 else 6\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Reassign a subset of vertices in the highest color to random lower colors (may add few conflicts)\n    k = max(s)\n    high_idxs = [i for i, c in enumerate(s) if c == k]\n    if high_idxs:\n        m = max(1, min(len(high_idxs), 2))\n        for i in random.sample(high_idxs, m):\n            if k > 1:\n                s[i] = random.randint(1, k-1)\n    s = normalize_colors(s)\n    return s\n","Resultados":[[1,1,2,1,1,3,3,2,2],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003766161}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts:\n        # Composite score to guide search within equal-conflict plateaus\n        return 10**8 * conflicts + k\n    # Feasible: number of distinct colors (lower is better)\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def score(sol):\n        c = conflict_count(sol)\n        if c:\n            return 10**8 * c + len(set(sol))\n        return len(set(sol))\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed move: pick most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_score = score(cur)\n\n        # Attempt recolor to least frequent feasible color in neighborhood\n        neigh_colors = {}\n        for w in adj[worst_v]:\n            c = cur[w-1]\n            neigh_colors[c] = neigh_colors.get(c, 0) + 1\n        palette = list(range(1, max(k, 2)+1))\n        palette = [c for c in palette if c != cur[worst_v-1]]\n        palette.sort(key=lambda c: neigh_colors.get(c, 0))  # least frequent first\n        best_sol = None\n        best_sc = None\n        for c in palette:\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = score(trial)\n                if sc <= current_score and (best_sc is None or sc < best_sc):\n                    best_sc = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n\n        # If recolor failed, try a biased Kempe swap with color minimizing neighbor frequency\n        if palette:\n            # pick color with min frequency among neighbors\n            c_b = min(palette, key=lambda c: neigh_colors.get(c, 0))\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if score(swapped) <= current_score:\n                return (normalize_colors(swapped), \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k with multi-pass reassignment\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            if verts:\n                reduced = cur[:]\n                changed = True\n                attempt_limit = 3\n                attempts = 0\n                while attempts < attempt_limit and verts:\n                    attempts += 1\n                    progress = False\n                    for v in list(verts):\n                        # Try least-constraining feasible color in 1..target_color-1\n                        cand = list(range(1, target_color))\n                        # order by conflicts that would be introduced (LCV heuristic)\n                        def clash_count(color):\n                            cnt = 0\n                            for w in adj[v]:\n                                if reduced[w-1] == color:\n                                    cnt += 1\n                            return cnt\n                        cand.sort(key=clash_count)\n                        moved = False\n                        for c in cand:\n                            if feasible_recolor(reduced, v, c):\n                                reduced[v-1] = c\n                                verts.remove(v)\n                                progress = True\n                                moved = True\n                                break\n                        if not moved:\n                            continue\n                    if not progress:\n                        break\n                if not verts:\n                    reduced = normalize_colors(reduced)\n                    return (reduced, \"color_drop\")\n        # Diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (normalize_colors(trial), \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility if possible\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if conflict_count(swapped) == 0:\n                return (normalize_colors(swapped), \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.7:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 4 if k <= 3 else 6\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Reassign a subset of vertices in the highest color to random lower colors (may add few conflicts)\n    k = max(s)\n    high_idxs = [i for i, c in enumerate(s) if c == k]\n    if high_idxs:\n        m = max(1, min(len(high_idxs), 2))\n        for i in random.sample(high_idxs, m):\n            if k > 1:\n                s[i] = random.randint(1, k-1)\n    s = normalize_colors(s)\n    return s\n","Resultados":[[1,1,1,1,1,1,2,1,1],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.004031624}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts:\n        # Composite score to guide search within equal-conflict plateaus\n        return 10**8 * conflicts + k\n    # Feasible: number of distinct colors (lower is better)\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def score(sol):\n        c = conflict_count(sol)\n        if c:\n            return 10**8 * c + len(set(sol))\n        return len(set(sol))\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed move: pick most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_score = score(cur)\n\n        # Attempt recolor to least frequent feasible color in neighborhood\n        neigh_colors = {}\n        for w in adj[worst_v]:\n            c = cur[w-1]\n            neigh_colors[c] = neigh_colors.get(c, 0) + 1\n        palette = list(range(1, max(k, 2)+1))\n        palette = [c for c in palette if c != cur[worst_v-1]]\n        palette.sort(key=lambda c: neigh_colors.get(c, 0))  # least frequent first\n        best_sol = None\n        best_sc = None\n        for c in palette:\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = score(trial)\n                if sc <= current_score and (best_sc is None or sc < best_sc):\n                    best_sc = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n\n        # If recolor failed, try a biased Kempe swap with color minimizing neighbor frequency\n        if palette:\n            # pick color with min frequency among neighbors\n            c_b = min(palette, key=lambda c: neigh_colors.get(c, 0))\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if score(swapped) <= current_score:\n                return (normalize_colors(swapped), \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k with multi-pass reassignment\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            if verts:\n                reduced = cur[:]\n                changed = True\n                attempt_limit = 3\n                attempts = 0\n                while attempts < attempt_limit and verts:\n                    attempts += 1\n                    progress = False\n                    for v in list(verts):\n                        # Try least-constraining feasible color in 1..target_color-1\n                        cand = list(range(1, target_color))\n                        # order by conflicts that would be introduced (LCV heuristic)\n                        def clash_count(color):\n                            cnt = 0\n                            for w in adj[v]:\n                                if reduced[w-1] == color:\n                                    cnt += 1\n                            return cnt\n                        cand.sort(key=clash_count)\n                        moved = False\n                        for c in cand:\n                            if feasible_recolor(reduced, v, c):\n                                reduced[v-1] = c\n                                verts.remove(v)\n                                progress = True\n                                moved = True\n                                break\n                        if not moved:\n                            continue\n                    if not progress:\n                        break\n                if not verts:\n                    reduced = normalize_colors(reduced)\n                    return (reduced, \"color_drop\")\n        # Diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (normalize_colors(trial), \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility if possible\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if conflict_count(swapped) == 0:\n                return (normalize_colors(swapped), \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.7:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 4 if k <= 3 else 6\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Reassign a subset of vertices in the highest color to random lower colors (may add few conflicts)\n    k = max(s)\n    high_idxs = [i for i, c in enumerate(s) if c == k]\n    if high_idxs:\n        m = max(1, min(len(high_idxs), 2))\n        for i in random.sample(high_idxs, m):\n            if k > 1:\n                s[i] = random.randint(1, k-1)\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001526881}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST length=9 of positive integers: solution[i] = color assigned to vertex i+1; colors are 1..k with k unrestricted (k inferred from max color in list).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**4\n    # Basic checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed vertices)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Build adjacency\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Triangle check (lower bound omega)\n    omega = 2\n    for i in range(1, n+1):\n        for j in adj[i]:\n            if j <= i:\n                continue\n            for k in adj[i]:\n                if k <= j:\n                    continue\n                if j in adj[k]:\n                    omega = 3\n                    break\n            if omega == 3:\n                break\n        if omega == 3:\n            break\n    # Exact chromatic number via backtracking (n=9)\n    order = list(range(1, n+1))\n    order.sort(key=lambda v: len(adj[v]), reverse=True)\n    colors = [0] * (n + 1)\n\n    def can_color(v, c):\n        for nb in adj[v]:\n            if colors[nb] == c:\n                return False\n        return True\n\n    def search_k(k, idx):\n        if idx == n:\n            return True\n        v = order[idx]\n        forbidden = set(colors[nb] for nb in adj[v] if colors[nb] != 0)\n        for c in range(1, k + 1):\n            if c not in forbidden and can_color(v, c):\n                colors[v] = c\n                if search_k(k, idx + 1):\n                    return True\n                colors[v] = 0\n        return False\n\n    def chromatic_number():\n        for k in range(omega, n + 1):\n            for i in range(1, n + 1):\n                colors[i] = 0\n            if search_k(k, 0):\n                return k\n        return n\n\n    chi = chromatic_number()\n    used = len(set(solution))\n    return used + max(0, used - chi)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> Tuple[str, str]:\n    \"\"\"\n    Returns a neighbor solution along with (NB_Type, Movement_Type) tags.\n    Output: (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    \"\"\"\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return the same solution if invalid; still provide tags\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    def conflict_count(sol):\n        edges = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        es = set()\n        for (u,v) in edges:\n            a = u if u < v else v\n            b = v if u < v else u\n            es.add((a,b))\n        cnt = 0\n        for (u,v) in es:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    n = 9\n    cur = solution[:]\n    max_color = max(cur)\n\n    # Choose move type: recolor or swap\n    if random.random() < 0.6:\n        # Recolor one vertex to a color minimizing conflicts (tie-broken randomly)\n        v = random.randrange(n)\n        candidate_colors = list(range(1, max_color + 2))  # allow introducing a new color\n        random.shuffle(candidate_colors)\n        best_sol = None\n        best_conf = None\n        for c in candidate_colors:\n            if c == cur[v]:\n                continue\n            trial = cur[:]\n            trial[v] = c\n            conf = conflict_count(trial)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best_sol = trial\n        if best_sol is None:\n            best_sol = cur\n        return best_sol, \"NB_Recolor\", \"SingleVertex\"\n    else:\n        # Swap colors of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        nei = cur[:]\n        nei[i], nei[j] = nei[j], nei[i]\n        return nei, \"NB_Swap\", \"Pairwise\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n    n = 9\n    s = solution[:]\n    max_color = max(s)\n    # Apply a series of random recolors; allow expanding palette temporarily\n    steps = 3\n    for _ in range(steps):\n        v = random.randrange(n)\n        new_c = random.randint(1, max_color + 2)\n        s[v] = new_c\n        max_color = max(max_color, new_c)\n    # Optional palette contraction: relabel colors to a compact 1..k mapping\n    palette = sorted(set(s))\n    remap = {c: i + 1 for i, c in enumerate(palette)}\n    s = [remap[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00152212}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST length=9 of positive integers: solution[i] = color assigned to vertex i+1; colors are 1..k with k unrestricted (k inferred from max color in list).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**4\n    # Basic checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed vertices)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Build adjacency\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Triangle check (lower bound omega)\n    omega = 2\n    for i in range(1, n+1):\n        for j in adj[i]:\n            if j <= i:\n                continue\n            for k in adj[i]:\n                if k <= j:\n                    continue\n                if j in adj[k]:\n                    omega = 3\n                    break\n            if omega == 3:\n                break\n        if omega == 3:\n            break\n    # Exact chromatic number via backtracking (n=9)\n    order = list(range(1, n+1))\n    order.sort(key=lambda v: len(adj[v]), reverse=True)\n    colors = [0] * (n + 1)\n\n    def can_color(v, c):\n        for nb in adj[v]:\n            if colors[nb] == c:\n                return False\n        return True\n\n    def search_k(k, idx):\n        if idx == n:\n            return True\n        v = order[idx]\n        forbidden = set(colors[nb] for nb in adj[v] if colors[nb] != 0)\n        for c in range(1, k + 1):\n            if c not in forbidden and can_color(v, c):\n                colors[v] = c\n                if search_k(k, idx + 1):\n                    return True\n                colors[v] = 0\n        return False\n\n    def chromatic_number():\n        for k in range(omega, n + 1):\n            for i in range(1, n + 1):\n                colors[i] = 0\n            if search_k(k, 0):\n                return k\n        return n\n\n    chi = chromatic_number()\n    used = len(set(solution))\n    return used + max(0, used - chi)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> Tuple[str, str]:\n    \"\"\"\n    Returns a neighbor solution along with (NB_Type, Movement_Type) tags.\n    Output: (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    \"\"\"\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return the same solution if invalid; still provide tags\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    def conflict_count(sol):\n        edges = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        es = set()\n        for (u,v) in edges:\n            a = u if u < v else v\n            b = v if u < v else u\n            es.add((a,b))\n        cnt = 0\n        for (u,v) in es:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    n = 9\n    cur = solution[:]\n    max_color = max(cur)\n\n    # Choose move type: recolor or swap\n    if random.random() < 0.6:\n        # Recolor one vertex to a color minimizing conflicts (tie-broken randomly)\n        v = random.randrange(n)\n        candidate_colors = list(range(1, max_color + 2))  # allow introducing a new color\n        random.shuffle(candidate_colors)\n        best_sol = None\n        best_conf = None\n        for c in candidate_colors:\n            if c == cur[v]:\n                continue\n            trial = cur[:]\n            trial[v] = c\n            conf = conflict_count(trial)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best_sol = trial\n        if best_sol is None:\n            best_sol = cur\n        return best_sol, \"NB_Recolor\", \"SingleVertex\"\n    else:\n        # Swap colors of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        nei = cur[:]\n        nei[i], nei[j] = nei[j], nei[i]\n        return nei, \"NB_Swap\", \"Pairwise\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n    n = 9\n    s = solution[:]\n    max_color = max(s)\n    # Apply a series of random recolors; allow expanding palette temporarily\n    steps = 3\n    for _ in range(steps):\n        v = random.randrange(n)\n        new_c = random.randint(1, max_color + 2)\n        s[v] = new_c\n        max_color = max(max_color, new_c)\n    # Optional palette contraction: relabel colors to a compact 1..k mapping\n    palette = sorted(set(s))\n    remap = {c: i + 1 for i, c in enumerate(palette)}\n    s = [remap[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001251956}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST length=9 of positive integers: solution[i] = color assigned to vertex i+1; colors are 1..k with k unrestricted (k inferred from max color in list).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**4\n    # Basic checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed vertices)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Build adjacency\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Triangle check (lower bound omega)\n    omega = 2\n    for i in range(1, n+1):\n        for j in adj[i]:\n            if j <= i:\n                continue\n            for k in adj[i]:\n                if k <= j:\n                    continue\n                if j in adj[k]:\n                    omega = 3\n                    break\n            if omega == 3:\n                break\n        if omega == 3:\n            break\n    # Exact chromatic number via backtracking (n=9)\n    order = list(range(1, n+1))\n    order.sort(key=lambda v: len(adj[v]), reverse=True)\n    colors = [0] * (n + 1)\n\n    def can_color(v, c):\n        for nb in adj[v]:\n            if colors[nb] == c:\n                return False\n        return True\n\n    def search_k(k, idx):\n        if idx == n:\n            return True\n        v = order[idx]\n        forbidden = set(colors[nb] for nb in adj[v] if colors[nb] != 0)\n        for c in range(1, k + 1):\n            if c not in forbidden and can_color(v, c):\n                colors[v] = c\n                if search_k(k, idx + 1):\n                    return True\n                colors[v] = 0\n        return False\n\n    def chromatic_number():\n        for k in range(omega, n + 1):\n            for i in range(1, n + 1):\n                colors[i] = 0\n            if search_k(k, 0):\n                return k\n        return n\n\n    chi = chromatic_number()\n    used = len(set(solution))\n    return used + max(0, used - chi)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> Tuple[str, str]:\n    \"\"\"\n    Returns a neighbor solution along with (NB_Type, Movement_Type) tags.\n    Output: (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    \"\"\"\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return the same solution if invalid; still provide tags\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    def conflict_count(sol):\n        edges = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        es = set()\n        for (u,v) in edges:\n            a = u if u < v else v\n            b = v if u < v else u\n            es.add((a,b))\n        cnt = 0\n        for (u,v) in es:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    n = 9\n    cur = solution[:]\n    max_color = max(cur)\n\n    # Choose move type: recolor or swap\n    if random.random() < 0.6:\n        # Recolor one vertex to a color minimizing conflicts (tie-broken randomly)\n        v = random.randrange(n)\n        candidate_colors = list(range(1, max_color + 2))  # allow introducing a new color\n        random.shuffle(candidate_colors)\n        best_sol = None\n        best_conf = None\n        for c in candidate_colors:\n            if c == cur[v]:\n                continue\n            trial = cur[:]\n            trial[v] = c\n            conf = conflict_count(trial)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best_sol = trial\n        if best_sol is None:\n            best_sol = cur\n        return best_sol, \"NB_Recolor\", \"SingleVertex\"\n    else:\n        # Swap colors of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        nei = cur[:]\n        nei[i], nei[j] = nei[j], nei[i]\n        return nei, \"NB_Swap\", \"Pairwise\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n    n = 9\n    s = solution[:]\n    max_color = max(s)\n    # Apply a series of random recolors; allow expanding palette temporarily\n    steps = 3\n    for _ in range(steps):\n        v = random.randrange(n)\n        new_c = random.randint(1, max_color + 2)\n        s[v] = new_c\n        max_color = max(max_color, new_c)\n    # Optional palette contraction: relabel colors to a compact 1..k mapping\n    palette = sorted(set(s))\n    remap = {c: i + 1 for i, c in enumerate(palette)}\n    s = [remap[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001193806}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color of vertex i+1 for i=0..8; length=9; colors are positive integers; no other encoding.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**5\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty dominates; add small tie breaker by used colors\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Feasible: minimize number of used colors\n    used = len(set(solution))\n    return used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {NB_Recolor, NB_Kempe, NB_ClassSwap, NB_ColorDrop, NB_InvalidPassthrough}\n    Movement_Type in {SingleVertex, Chain, ClassPair, Palette, None}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    # Graph data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        # Pick conflicted vertex if any, else high-degree vertex\n        bad = conflict_vertices(sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            # Highest degree, tie-broken randomly\n            v = max(range(1, n+1), key=lambda u: (len(adj[u]), random.random()))\n        cur = sol[:]\n        max_color = max(cur)\n        # Candidate colors: existing palette only (avoid color explosion) unless conflicts exist\n        candidate_colors = list(sorted(set(cur)))\n        if bad and random.random() < 0.2:\n            candidate_colors.append(max_color + 1)\n        random.shuffle(candidate_colors)\n        best = cur\n        best_score = None\n        for c in candidate_colors:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Compute conflict delta locally\n            conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    conf += 1\n            # Add small tie-breaker to reduce colors\n            used = len(set(trial))\n            score = (conf, used, random.random())\n            if best_score is None or score < best_score:\n                best_score = score\n                best = trial\n        return compact_palette(best), \"NB_Recolor\", \"SingleVertex\"\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Pick target color different from c1; prefer neighbor colors\n        nb_colors = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_colors:\n            palette = sorted(set(cur))\n            if len(palette) == 1:\n                return cur, \"NB_Kempe\", \"Chain\"\n            nb_colors = [random.choice([c for c in palette if c != c1])]\n        c2 = random.choice(nb_colors)\n        # BFS to collect Kempe chain for colors {c1,c2}\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on the chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return compact_palette(cur), \"NB_Kempe\", \"Chain\"\n\n    def class_swap(sol):\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) < 2:\n            return cur, \"NB_ClassSwap\", \"ClassPair\"\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n        return compact_palette(cur), \"NB_ClassSwap\", \"ClassPair\"\n\n    def color_drop(sol):\n        # Try to eliminate a color by greedily recoloring its vertices\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, \"NB_ColorDrop\", \"Palette\"\n        target = random.choice(palette)\n        other = [c for c in palette if c != target]\n        random.shuffle(other)\n        ok = True\n        for v in [i+1 for i,c in enumerate(cur) if c == target]:\n            placed = False\n            random.shuffle(other)\n            for c in other:\n                conflict = False\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                ok = False\n                break\n        if ok:\n            return compact_palette(cur), \"NB_ColorDrop\", \"Palette\"\n        else:\n            return sol[:], \"NB_ColorDrop\", \"Palette\"\n\n    moves = []\n    # Prefer recolor\/Kempe when conflicts exist; else attempt color drop\n    if conflict_vertices(solution):\n        moves.extend([guided_recolor, kempe_chain_move])\n        if random.random() < 0.3:\n            moves.append(class_swap)\n    else:\n        moves.extend([color_drop, guided_recolor, kempe_chain_move, class_swap])\n    move = random.choice(moves)\n    neigh, nb_type, mv = move(solution)\n    return compact_palette(neigh), nb_type, mv\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def kempe(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    s = solution[:]\n    # Intensity: 2-5 Kempe chains and 1 class swap attempt; finalize with palette compaction\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        s = kempe(s)\n    # Class swap attempt\n    palette = sorted(set(s))\n    if len(palette) >= 2 and random.random() < 0.8:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n    s = compact_palette(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001772084}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color of vertex i+1 for i=0..8; length=9; colors are positive integers; no other encoding.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**5\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty dominates; add small tie breaker by used colors\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Feasible: minimize number of used colors\n    used = len(set(solution))\n    return used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {NB_Recolor, NB_Kempe, NB_ClassSwap, NB_ColorDrop, NB_InvalidPassthrough}\n    Movement_Type in {SingleVertex, Chain, ClassPair, Palette, None}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    # Graph data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        # Pick conflicted vertex if any, else high-degree vertex\n        bad = conflict_vertices(sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            # Highest degree, tie-broken randomly\n            v = max(range(1, n+1), key=lambda u: (len(adj[u]), random.random()))\n        cur = sol[:]\n        max_color = max(cur)\n        # Candidate colors: existing palette only (avoid color explosion) unless conflicts exist\n        candidate_colors = list(sorted(set(cur)))\n        if bad and random.random() < 0.2:\n            candidate_colors.append(max_color + 1)\n        random.shuffle(candidate_colors)\n        best = cur\n        best_score = None\n        for c in candidate_colors:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Compute conflict delta locally\n            conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    conf += 1\n            # Add small tie-breaker to reduce colors\n            used = len(set(trial))\n            score = (conf, used, random.random())\n            if best_score is None or score < best_score:\n                best_score = score\n                best = trial\n        return compact_palette(best), \"NB_Recolor\", \"SingleVertex\"\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Pick target color different from c1; prefer neighbor colors\n        nb_colors = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_colors:\n            palette = sorted(set(cur))\n            if len(palette) == 1:\n                return cur, \"NB_Kempe\", \"Chain\"\n            nb_colors = [random.choice([c for c in palette if c != c1])]\n        c2 = random.choice(nb_colors)\n        # BFS to collect Kempe chain for colors {c1,c2}\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on the chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return compact_palette(cur), \"NB_Kempe\", \"Chain\"\n\n    def class_swap(sol):\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) < 2:\n            return cur, \"NB_ClassSwap\", \"ClassPair\"\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n        return compact_palette(cur), \"NB_ClassSwap\", \"ClassPair\"\n\n    def color_drop(sol):\n        # Try to eliminate a color by greedily recoloring its vertices\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, \"NB_ColorDrop\", \"Palette\"\n        target = random.choice(palette)\n        other = [c for c in palette if c != target]\n        random.shuffle(other)\n        ok = True\n        for v in [i+1 for i,c in enumerate(cur) if c == target]:\n            placed = False\n            random.shuffle(other)\n            for c in other:\n                conflict = False\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                ok = False\n                break\n        if ok:\n            return compact_palette(cur), \"NB_ColorDrop\", \"Palette\"\n        else:\n            return sol[:], \"NB_ColorDrop\", \"Palette\"\n\n    moves = []\n    # Prefer recolor\/Kempe when conflicts exist; else attempt color drop\n    if conflict_vertices(solution):\n        moves.extend([guided_recolor, kempe_chain_move])\n        if random.random() < 0.3:\n            moves.append(class_swap)\n    else:\n        moves.extend([color_drop, guided_recolor, kempe_chain_move, class_swap])\n    move = random.choice(moves)\n    neigh, nb_type, mv = move(solution)\n    return compact_palette(neigh), nb_type, mv\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def kempe(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    s = solution[:]\n    # Intensity: 2-5 Kempe chains and 1 class swap attempt; finalize with palette compaction\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        s = kempe(s)\n    # Class swap attempt\n    palette = sorted(set(s))\n    if len(palette) >= 2 and random.random() < 0.8:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n    s = compact_palette(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00154643}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color of vertex i+1 for i=0..8; length=9; colors are positive integers; no other encoding.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**5\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty dominates; add small tie breaker by used colors\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Feasible: minimize number of used colors\n    used = len(set(solution))\n    return used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {NB_Recolor, NB_Kempe, NB_ClassSwap, NB_ColorDrop, NB_InvalidPassthrough}\n    Movement_Type in {SingleVertex, Chain, ClassPair, Palette, None}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    # Graph data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        # Pick conflicted vertex if any, else high-degree vertex\n        bad = conflict_vertices(sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            # Highest degree, tie-broken randomly\n            v = max(range(1, n+1), key=lambda u: (len(adj[u]), random.random()))\n        cur = sol[:]\n        max_color = max(cur)\n        # Candidate colors: existing palette only (avoid color explosion) unless conflicts exist\n        candidate_colors = list(sorted(set(cur)))\n        if bad and random.random() < 0.2:\n            candidate_colors.append(max_color + 1)\n        random.shuffle(candidate_colors)\n        best = cur\n        best_score = None\n        for c in candidate_colors:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Compute conflict delta locally\n            conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    conf += 1\n            # Add small tie-breaker to reduce colors\n            used = len(set(trial))\n            score = (conf, used, random.random())\n            if best_score is None or score < best_score:\n                best_score = score\n                best = trial\n        return compact_palette(best), \"NB_Recolor\", \"SingleVertex\"\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Pick target color different from c1; prefer neighbor colors\n        nb_colors = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_colors:\n            palette = sorted(set(cur))\n            if len(palette) == 1:\n                return cur, \"NB_Kempe\", \"Chain\"\n            nb_colors = [random.choice([c for c in palette if c != c1])]\n        c2 = random.choice(nb_colors)\n        # BFS to collect Kempe chain for colors {c1,c2}\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on the chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return compact_palette(cur), \"NB_Kempe\", \"Chain\"\n\n    def class_swap(sol):\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) < 2:\n            return cur, \"NB_ClassSwap\", \"ClassPair\"\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n        return compact_palette(cur), \"NB_ClassSwap\", \"ClassPair\"\n\n    def color_drop(sol):\n        # Try to eliminate a color by greedily recoloring its vertices\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, \"NB_ColorDrop\", \"Palette\"\n        target = random.choice(palette)\n        other = [c for c in palette if c != target]\n        random.shuffle(other)\n        ok = True\n        for v in [i+1 for i,c in enumerate(cur) if c == target]:\n            placed = False\n            random.shuffle(other)\n            for c in other:\n                conflict = False\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                ok = False\n                break\n        if ok:\n            return compact_palette(cur), \"NB_ColorDrop\", \"Palette\"\n        else:\n            return sol[:], \"NB_ColorDrop\", \"Palette\"\n\n    moves = []\n    # Prefer recolor\/Kempe when conflicts exist; else attempt color drop\n    if conflict_vertices(solution):\n        moves.extend([guided_recolor, kempe_chain_move])\n        if random.random() < 0.3:\n            moves.append(class_swap)\n    else:\n        moves.extend([color_drop, guided_recolor, kempe_chain_move, class_swap])\n    move = random.choice(moves)\n    neigh, nb_type, mv = move(solution)\n    return compact_palette(neigh), nb_type, mv\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def kempe(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    s = solution[:]\n    # Intensity: 2-5 Kempe chains and 1 class swap attempt; finalize with palette compaction\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        s = kempe(s)\n    # Class swap attempt\n    palette = sorted(set(s))\n    if len(palette) >= 2 and random.random() < 0.8:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n    s = compact_palette(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001442109}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color (positive int) of vertex i+1 for i=0..8; length=9; colors are labels, not compacted automatically.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    # Weight >= 100 ensures any conflict worse than any color count decrease\n    CONFLICT_WEIGHT = 100\n    return conflicts * CONFLICT_WEIGHT + used","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a 2-tuple: (neighbor_solution, meta_dict)\n    meta_dict contains keys: {'NB_Type': str, 'Movement_Type': str}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def guided_recolor(sol):\n        # DSATUR-ish: pick a vertex (prefer conflicted; else highest saturation\/degree)\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Compute saturation (distinct neighbor colors)\n        def sat(u):\n            return len({cur[v-1] for v in adj[u]})\n        v = max(cand_vertices, key=lambda u: (sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        # Candidate colors: try existing colors first, then at most one new color\n        nb_cols = {cur[nb-1] for nb in adj[v]}\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        # Allow new color only if all neighbor colors block current palette\n        if len(nb_cols) >= len(used_palette) - (1 if cur[v-1] in used_palette else 0):\n            candidates.append(max(used_palette) + 1)\n        random.shuffle(candidates)\n        best = cur\n        best_key = None\n        for c in candidates:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Local conflict count at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if best_key is None or key < best_key:\n                best_key = key\n                best = trial\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        # Seed vertex prefers conflicted; else random\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Choose c2 among neighbor colors that currently conflict most with v\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        # bias to highest frequency\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        # Collect (c1,c2)-Kempe chain via DFS\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                # Check if assigning c to v creates conflict\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection: prioritize reducing conflicts; otherwise try to reduce colors\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Targeted recolor of 1-2 random vertices to diversify\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s","Resultados":[[9,9,3,9,12,11,5,8,3],6,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.003020999}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color (positive int) of vertex i+1 for i=0..8; length=9; colors are labels, not compacted automatically.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    # Weight >= 100 ensures any conflict worse than any color count decrease\n    CONFLICT_WEIGHT = 100\n    return conflicts * CONFLICT_WEIGHT + used","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a 2-tuple: (neighbor_solution, meta_dict)\n    meta_dict contains keys: {'NB_Type': str, 'Movement_Type': str}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def guided_recolor(sol):\n        # DSATUR-ish: pick a vertex (prefer conflicted; else highest saturation\/degree)\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Compute saturation (distinct neighbor colors)\n        def sat(u):\n            return len({cur[v-1] for v in adj[u]})\n        v = max(cand_vertices, key=lambda u: (sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        # Candidate colors: try existing colors first, then at most one new color\n        nb_cols = {cur[nb-1] for nb in adj[v]}\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        # Allow new color only if all neighbor colors block current palette\n        if len(nb_cols) >= len(used_palette) - (1 if cur[v-1] in used_palette else 0):\n            candidates.append(max(used_palette) + 1)\n        random.shuffle(candidates)\n        best = cur\n        best_key = None\n        for c in candidates:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Local conflict count at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if best_key is None or key < best_key:\n                best_key = key\n                best = trial\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        # Seed vertex prefers conflicted; else random\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Choose c2 among neighbor colors that currently conflict most with v\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        # bias to highest frequency\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        # Collect (c1,c2)-Kempe chain via DFS\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                # Check if assigning c to v creates conflict\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection: prioritize reducing conflicts; otherwise try to reduce colors\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Targeted recolor of 1-2 random vertices to diversify\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s","Resultados":[[38,38,32,38,38,37,37,27,32],4,[1,1,2,1,1,3,3,2,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00381616}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color (positive int) of vertex i+1 for i=0..8; length=9; colors are labels, not compacted automatically.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    # Weight >= 100 ensures any conflict worse than any color count decrease\n    CONFLICT_WEIGHT = 100\n    return conflicts * CONFLICT_WEIGHT + used","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a 2-tuple: (neighbor_solution, meta_dict)\n    meta_dict contains keys: {'NB_Type': str, 'Movement_Type': str}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def guided_recolor(sol):\n        # DSATUR-ish: pick a vertex (prefer conflicted; else highest saturation\/degree)\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Compute saturation (distinct neighbor colors)\n        def sat(u):\n            return len({cur[v-1] for v in adj[u]})\n        v = max(cand_vertices, key=lambda u: (sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        # Candidate colors: try existing colors first, then at most one new color\n        nb_cols = {cur[nb-1] for nb in adj[v]}\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        # Allow new color only if all neighbor colors block current palette\n        if len(nb_cols) >= len(used_palette) - (1 if cur[v-1] in used_palette else 0):\n            candidates.append(max(used_palette) + 1)\n        random.shuffle(candidates)\n        best = cur\n        best_key = None\n        for c in candidates:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Local conflict count at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if best_key is None or key < best_key:\n                best_key = key\n                best = trial\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        # Seed vertex prefers conflicted; else random\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Choose c2 among neighbor colors that currently conflict most with v\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        # bias to highest frequency\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        # Collect (c1,c2)-Kempe chain via DFS\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                # Check if assigning c to v creates conflict\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection: prioritize reducing conflicts; otherwise try to reduce colors\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Targeted recolor of 1-2 random vertices to diversify\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001983556}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_POSITIVE_INTS: solution[i] gives color of vertex (i+1); length=9; colors are labels (not auto-compacted).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    CONFLICT_WEIGHT = 1000\n    return conflicts * CONFLICT_WEIGHT + used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts_for_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Priority: (#conflicts at v, saturation, degree)\n        def sat(u):\n            return len({cur[w-1] for w in adj[u]})\n        def confdeg(u):\n            return local_conflicts_for_vertex(cur, u)\n        v = max(cand_vertices, key=lambda u: (confdeg(u), sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        nb_cols = {cur[w-1] for w in adj[v]}\n        # Try existing colors first\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        best = cur\n        best_key = (10**9, 10**9)\n        for c in candidates:\n            trial = cur[:]\n            trial[v-1] = c\n            # Evaluate local conflicts at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if key < best_key:\n                best_key = key\n                best = trial\n        # Consider introducing a new color only if conflicts remain and all existing colors are blocked\n        if best_key[0] > 0 and len(nb_cols) >= len(used_palette):\n            c_new = max(used_palette) + 1\n            trial = cur[:]\n            trial[v-1] = c_new\n            key = (0, len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        after = cur[:]\n        for x in chain:\n            after[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        # Accept if it does not worsen (conflicts, used)\n        def score(solx):\n            # fast local eval: count conflicts and used\n            confl = 0\n            for (u,v) in edges:\n                if solx[u-1] == solx[v-1]:\n                    confl += 1\n            return (confl, len(set(solx)))\n        if score(after) <= score(cur):\n            return after, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment; keep partial successes\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        # Sort by degree desc to place hard vertices first\n        verts.sort(key=lambda v: len(adj[v]), reverse=True)\n        moved_any = False\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    moved_any = True\n                    break\n        if moved_any and target not in set(cur):\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # Apply 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Recolor 1-2 random vertices with non-conflicting colors, allowing one new color as last resort\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s\n","Resultados":[[4,4,1,4,4,2,2,1,1],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00310373}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_POSITIVE_INTS: solution[i] gives color of vertex (i+1); length=9; colors are labels (not auto-compacted).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    CONFLICT_WEIGHT = 1000\n    return conflicts * CONFLICT_WEIGHT + used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts_for_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Priority: (#conflicts at v, saturation, degree)\n        def sat(u):\n            return len({cur[w-1] for w in adj[u]})\n        def confdeg(u):\n            return local_conflicts_for_vertex(cur, u)\n        v = max(cand_vertices, key=lambda u: (confdeg(u), sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        nb_cols = {cur[w-1] for w in adj[v]}\n        # Try existing colors first\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        best = cur\n        best_key = (10**9, 10**9)\n        for c in candidates:\n            trial = cur[:]\n            trial[v-1] = c\n            # Evaluate local conflicts at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if key < best_key:\n                best_key = key\n                best = trial\n        # Consider introducing a new color only if conflicts remain and all existing colors are blocked\n        if best_key[0] > 0 and len(nb_cols) >= len(used_palette):\n            c_new = max(used_palette) + 1\n            trial = cur[:]\n            trial[v-1] = c_new\n            key = (0, len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        after = cur[:]\n        for x in chain:\n            after[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        # Accept if it does not worsen (conflicts, used)\n        def score(solx):\n            # fast local eval: count conflicts and used\n            confl = 0\n            for (u,v) in edges:\n                if solx[u-1] == solx[v-1]:\n                    confl += 1\n            return (confl, len(set(solx)))\n        if score(after) <= score(cur):\n            return after, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment; keep partial successes\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        # Sort by degree desc to place hard vertices first\n        verts.sort(key=lambda v: len(adj[v]), reverse=True)\n        moved_any = False\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    moved_any = True\n                    break\n        if moved_any and target not in set(cur):\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # Apply 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Recolor 1-2 random vertices with non-conflicting colors, allowing one new color as last resort\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s\n","Resultados":[[34,29,36,34,31,33,29,36,31],3,[1,1,2,1,1,3,3,2,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003375994}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_POSITIVE_INTS: solution[i] gives color of vertex (i+1); length=9; colors are labels (not auto-compacted).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    CONFLICT_WEIGHT = 1000\n    return conflicts * CONFLICT_WEIGHT + used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts_for_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Priority: (#conflicts at v, saturation, degree)\n        def sat(u):\n            return len({cur[w-1] for w in adj[u]})\n        def confdeg(u):\n            return local_conflicts_for_vertex(cur, u)\n        v = max(cand_vertices, key=lambda u: (confdeg(u), sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        nb_cols = {cur[w-1] for w in adj[v]}\n        # Try existing colors first\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        best = cur\n        best_key = (10**9, 10**9)\n        for c in candidates:\n            trial = cur[:]\n            trial[v-1] = c\n            # Evaluate local conflicts at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if key < best_key:\n                best_key = key\n                best = trial\n        # Consider introducing a new color only if conflicts remain and all existing colors are blocked\n        if best_key[0] > 0 and len(nb_cols) >= len(used_palette):\n            c_new = max(used_palette) + 1\n            trial = cur[:]\n            trial[v-1] = c_new\n            key = (0, len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        after = cur[:]\n        for x in chain:\n            after[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        # Accept if it does not worsen (conflicts, used)\n        def score(solx):\n            # fast local eval: count conflicts and used\n            confl = 0\n            for (u,v) in edges:\n                if solx[u-1] == solx[v-1]:\n                    confl += 1\n            return (confl, len(set(solx)))\n        if score(after) <= score(cur):\n            return after, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment; keep partial successes\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        # Sort by degree desc to place hard vertices first\n        verts.sort(key=lambda v: len(adj[v]), reverse=True)\n        moved_any = False\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    moved_any = True\n                    break\n        if moved_any and target not in set(cur):\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # Apply 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Recolor 1-2 random vertices with non-conflicting colors, allowing one new color as last resort\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00156341}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING length=9; solution = [a1,...,a9] with ai in {1,...,k}, k = max(solution); labels must be contiguous 1..k and each used at least once.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    PENALTY_BASE = 10**6\n\n    def basic_check(sol: List[int]) -> Tuple[bool, int]:\n        if not isinstance(sol, list):\n            return False, PENALTY_BASE + 10\n        if len(sol) != 9:\n            return False, PENALTY_BASE + 20 + abs(len(sol) - 9)\n        for x in sol:\n            if not isinstance(x, int):\n                return False, PENALTY_BASE + 30\n            if x <= 0:\n                return False, PENALTY_BASE + 40\n        k = max(sol)\n        labels = set(sol)\n        if labels != set(range(1, k + 1)):\n            missing = len(set(range(1, k + 1)) - labels)\n            extra = len([x for x in sol if x > k])\n            return False, PENALTY_BASE + 50 + 100 * missing + 1000 * extra\n        edges_local = [\n            (1,2),(1,7),(1,9),\n            (2,3),(2,6),(2,7),(2,8),\n            (3,4),\n            (4,6),(4,7),(4,8),(4,9),\n            (5,7),(5,8),(5,9),\n            (7,9),\n            (8,9)\n        ]\n        for (u, v) in edges_local:\n            if sol[u - 1] == sol[v - 1]:\n                return False, PENALTY_BASE + 60\n        return True, 0\n\n    ok, pen = basic_check(solution)\n    if not ok:\n        return pen\n\n    # Build graph\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),\n        (8,9)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n    adj = [set() for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Clique lower bound omega\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            ui = nodes[i]\n            for j in range(i + 1, len(nodes)):\n                vj = nodes[j]\n                if vj not in adj[ui]:\n                    return False\n        return True\n\n    omega = 1\n    idxs = list(range(n))\n\n    def combs(arr: List[int], r: int, start: int, cur: List[int], out: List[List[int]]):\n        if len(cur) == r:\n            out.append(cur[:])\n            return\n        for i in range(start, len(arr)):\n            cur.append(arr[i])\n            combs(arr, r, i + 1, cur, out)\n            cur.pop()\n\n    for r in range(2, n + 1):\n        tmp: List[List[int]] = []\n        combs(idxs, r, 0, [], tmp)\n        found = False\n        for nodes in tmp:\n            if is_clique(nodes):\n                omega = r\n                found = True\n        if not found and r > omega:\n            break\n\n    # Backtracking feasibility for given k\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda x: -deg[x])\n\n    def can_color(k: int) -> bool:\n        colors = [-1] * n\n\n        def bt(i: int) -> bool:\n            if i == n:\n                return True\n            u = order[i]\n            forbidden = {colors[v] for v in adj[u] if colors[v] != -1}\n            for c in range(k):\n                if c not in forbidden:\n                    colors[u] = c\n                    if bt(i + 1):\n                        return True\n                    colors[u] = -1\n            colors[u] = -1\n            return False\n\n        return bt(0)\n\n    chi = None\n    k_try = max(omega, 1)\n    while True:\n        if can_color(k_try):\n            chi = k_try\n            break\n        k_try += 1\n\n    k_given = max(solution)\n    if k_given == chi:\n        return chi\n    return PENALTY_BASE + abs(k_given - chi)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # Work on a copy\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        # Ensure length; if invalid, reset to trivial feasible pattern (1..3 repeated)\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    # Single-vertex recolor neighbor\n    idx = random.randrange(9)\n    k = max(sol)\n    # Allow recolor to any in [1..k] or occasionally introduce k+1 to escape\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        # ensure different color\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n\n    # Relabel to maintain contiguity 1..k'\n    sol = relabel_contiguous(sol)\n\n    return (\"RandomSingleRecolor\", \"RecolorVertex\"), sol  # Note: returns (NB_Type, Movement_Type) as first element, neighbor solution as second\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    k = max(sol)\n\n    if random.random() < 0.5 and k >= 2:\n        # Swap two color labels globally\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        # Multi-vertex random recolors (2 to 4 vertices)\n        times = random.randint(2, 4)\n        for _ in range(times):\n            idx = random.randrange(9)\n            k = max(sol)\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                if choices:\n                    new_color = random.choice(choices)\n                else:\n                    new_color = sol[idx]\n            sol[idx] = new_color\n\n    sol = relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001781103}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING length=9; solution = [a1,...,a9] with ai in {1,...,k}, k = max(solution); labels must be contiguous 1..k and each used at least once.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    PENALTY_BASE = 10**6\n\n    def basic_check(sol: List[int]) -> Tuple[bool, int]:\n        if not isinstance(sol, list):\n            return False, PENALTY_BASE + 10\n        if len(sol) != 9:\n            return False, PENALTY_BASE + 20 + abs(len(sol) - 9)\n        for x in sol:\n            if not isinstance(x, int):\n                return False, PENALTY_BASE + 30\n            if x <= 0:\n                return False, PENALTY_BASE + 40\n        k = max(sol)\n        labels = set(sol)\n        if labels != set(range(1, k + 1)):\n            missing = len(set(range(1, k + 1)) - labels)\n            extra = len([x for x in sol if x > k])\n            return False, PENALTY_BASE + 50 + 100 * missing + 1000 * extra\n        edges_local = [\n            (1,2),(1,7),(1,9),\n            (2,3),(2,6),(2,7),(2,8),\n            (3,4),\n            (4,6),(4,7),(4,8),(4,9),\n            (5,7),(5,8),(5,9),\n            (7,9),\n            (8,9)\n        ]\n        for (u, v) in edges_local:\n            if sol[u - 1] == sol[v - 1]:\n                return False, PENALTY_BASE + 60\n        return True, 0\n\n    ok, pen = basic_check(solution)\n    if not ok:\n        return pen\n\n    # Build graph\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),\n        (8,9)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n    adj = [set() for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Clique lower bound omega\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            ui = nodes[i]\n            for j in range(i + 1, len(nodes)):\n                vj = nodes[j]\n                if vj not in adj[ui]:\n                    return False\n        return True\n\n    omega = 1\n    idxs = list(range(n))\n\n    def combs(arr: List[int], r: int, start: int, cur: List[int], out: List[List[int]]):\n        if len(cur) == r:\n            out.append(cur[:])\n            return\n        for i in range(start, len(arr)):\n            cur.append(arr[i])\n            combs(arr, r, i + 1, cur, out)\n            cur.pop()\n\n    for r in range(2, n + 1):\n        tmp: List[List[int]] = []\n        combs(idxs, r, 0, [], tmp)\n        found = False\n        for nodes in tmp:\n            if is_clique(nodes):\n                omega = r\n                found = True\n        if not found and r > omega:\n            break\n\n    # Backtracking feasibility for given k\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda x: -deg[x])\n\n    def can_color(k: int) -> bool:\n        colors = [-1] * n\n\n        def bt(i: int) -> bool:\n            if i == n:\n                return True\n            u = order[i]\n            forbidden = {colors[v] for v in adj[u] if colors[v] != -1}\n            for c in range(k):\n                if c not in forbidden:\n                    colors[u] = c\n                    if bt(i + 1):\n                        return True\n                    colors[u] = -1\n            colors[u] = -1\n            return False\n\n        return bt(0)\n\n    chi = None\n    k_try = max(omega, 1)\n    while True:\n        if can_color(k_try):\n            chi = k_try\n            break\n        k_try += 1\n\n    k_given = max(solution)\n    if k_given == chi:\n        return chi\n    return PENALTY_BASE + abs(k_given - chi)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # Work on a copy\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        # Ensure length; if invalid, reset to trivial feasible pattern (1..3 repeated)\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    # Single-vertex recolor neighbor\n    idx = random.randrange(9)\n    k = max(sol)\n    # Allow recolor to any in [1..k] or occasionally introduce k+1 to escape\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        # ensure different color\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n\n    # Relabel to maintain contiguity 1..k'\n    sol = relabel_contiguous(sol)\n\n    return (\"RandomSingleRecolor\", \"RecolorVertex\"), sol  # Note: returns (NB_Type, Movement_Type) as first element, neighbor solution as second\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    k = max(sol)\n\n    if random.random() < 0.5 and k >= 2:\n        # Swap two color labels globally\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        # Multi-vertex random recolors (2 to 4 vertices)\n        times = random.randint(2, 4)\n        for _ in range(times):\n            idx = random.randrange(9)\n            k = max(sol)\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                if choices:\n                    new_color = random.choice(choices)\n                else:\n                    new_color = sol[idx]\n            sol[idx] = new_color\n\n    sol = relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001466449}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING length=9; solution = [a1,...,a9] with ai in {1,...,k}, k = max(solution); labels must be contiguous 1..k and each used at least once.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    PENALTY_BASE = 10**6\n\n    def basic_check(sol: List[int]) -> Tuple[bool, int]:\n        if not isinstance(sol, list):\n            return False, PENALTY_BASE + 10\n        if len(sol) != 9:\n            return False, PENALTY_BASE + 20 + abs(len(sol) - 9)\n        for x in sol:\n            if not isinstance(x, int):\n                return False, PENALTY_BASE + 30\n            if x <= 0:\n                return False, PENALTY_BASE + 40\n        k = max(sol)\n        labels = set(sol)\n        if labels != set(range(1, k + 1)):\n            missing = len(set(range(1, k + 1)) - labels)\n            extra = len([x for x in sol if x > k])\n            return False, PENALTY_BASE + 50 + 100 * missing + 1000 * extra\n        edges_local = [\n            (1,2),(1,7),(1,9),\n            (2,3),(2,6),(2,7),(2,8),\n            (3,4),\n            (4,6),(4,7),(4,8),(4,9),\n            (5,7),(5,8),(5,9),\n            (7,9),\n            (8,9)\n        ]\n        for (u, v) in edges_local:\n            if sol[u - 1] == sol[v - 1]:\n                return False, PENALTY_BASE + 60\n        return True, 0\n\n    ok, pen = basic_check(solution)\n    if not ok:\n        return pen\n\n    # Build graph\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),\n        (8,9)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n    adj = [set() for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Clique lower bound omega\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            ui = nodes[i]\n            for j in range(i + 1, len(nodes)):\n                vj = nodes[j]\n                if vj not in adj[ui]:\n                    return False\n        return True\n\n    omega = 1\n    idxs = list(range(n))\n\n    def combs(arr: List[int], r: int, start: int, cur: List[int], out: List[List[int]]):\n        if len(cur) == r:\n            out.append(cur[:])\n            return\n        for i in range(start, len(arr)):\n            cur.append(arr[i])\n            combs(arr, r, i + 1, cur, out)\n            cur.pop()\n\n    for r in range(2, n + 1):\n        tmp: List[List[int]] = []\n        combs(idxs, r, 0, [], tmp)\n        found = False\n        for nodes in tmp:\n            if is_clique(nodes):\n                omega = r\n                found = True\n        if not found and r > omega:\n            break\n\n    # Backtracking feasibility for given k\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda x: -deg[x])\n\n    def can_color(k: int) -> bool:\n        colors = [-1] * n\n\n        def bt(i: int) -> bool:\n            if i == n:\n                return True\n            u = order[i]\n            forbidden = {colors[v] for v in adj[u] if colors[v] != -1}\n            for c in range(k):\n                if c not in forbidden:\n                    colors[u] = c\n                    if bt(i + 1):\n                        return True\n                    colors[u] = -1\n            colors[u] = -1\n            return False\n\n        return bt(0)\n\n    chi = None\n    k_try = max(omega, 1)\n    while True:\n        if can_color(k_try):\n            chi = k_try\n            break\n        k_try += 1\n\n    k_given = max(solution)\n    if k_given == chi:\n        return chi\n    return PENALTY_BASE + abs(k_given - chi)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # Work on a copy\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        # Ensure length; if invalid, reset to trivial feasible pattern (1..3 repeated)\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    # Single-vertex recolor neighbor\n    idx = random.randrange(9)\n    k = max(sol)\n    # Allow recolor to any in [1..k] or occasionally introduce k+1 to escape\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        # ensure different color\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n\n    # Relabel to maintain contiguity 1..k'\n    sol = relabel_contiguous(sol)\n\n    return (\"RandomSingleRecolor\", \"RecolorVertex\"), sol  # Note: returns (NB_Type, Movement_Type) as first element, neighbor solution as second\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    k = max(sol)\n\n    if random.random() < 0.5 and k >= 2:\n        # Swap two color labels globally\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        # Multi-vertex random recolors (2 to 4 vertices)\n        times = random.randint(2, 4)\n        for _ in range(times):\n            idx = random.randrange(9)\n            k = max(sol)\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                if choices:\n                    new_color = random.choice(choices)\n                else:\n                    new_color = sol[idx]\n            sol[idx] = new_color\n\n    sol = relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001226546}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust, gradient-preserving evaluator for graph coloring on fixed 9-vertex graph\n    # Score semantics (minimize):\n    # - If feasible (no edge conflicts, labels contiguous 1..k): return k\n    # - If infeasible: 1e9 + conflicts*1e6 + label_gaps*1e3 + k\n    # This preserves gradient towards feasibility and then towards fewer colors.\n    BASE_PENALTY = 10**9\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + 10**7\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + 10**7 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + 10**7 + 1\n        if x <= 0:\n            return BASE_PENALTY + 10**7 + 2\n    k = max(solution)\n    # Contiguity check: labels must be exactly 1..k with each used\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            # Should not happen due to k = max(solution), keep safe\n            return BASE_PENALTY + 10**7 + 3\n    label_gaps = 0\n    for c in range(1, k + 1):\n        if freq[c] == 0:\n            label_gaps += 1\n    # Graph definition (0-based indices)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Count conflicts (monochromatic edges)\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    # Feasible: minimize k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a 3-tuple: (nb_type:str, move_type:str, neighbor_solution:list[int])\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    # Ensure proper base solution\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        # Fallback reasonable seed\n        sol = [1,3,2,1,1,2,2,2,3]\n    n = 9\n    idx = random.randrange(n)\n    k = max(1, max(sol))\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return (\"RandomSingleRecolor\", \"RecolorVertex\", sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, multi-edit perturbation with optional global color swap\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        sol = [1,3,2,1,1,2,2,2,3]\n    k = max(1, max(sol))\n    if random.random() < 0.5 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        edits = random.randint(2, 4)\n        n = 9\n        for _ in range(edits):\n            idx = random.randrange(n)\n            k = max(1, max(sol))\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                new_color = random.choice(choices) if choices else sol[idx]\n            sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00000642}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust, gradient-preserving evaluator for graph coloring on fixed 9-vertex graph\n    # Score semantics (minimize):\n    # - If feasible (no edge conflicts, labels contiguous 1..k): return k\n    # - If infeasible: 1e9 + conflicts*1e6 + label_gaps*1e3 + k\n    # This preserves gradient towards feasibility and then towards fewer colors.\n    BASE_PENALTY = 10**9\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + 10**7\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + 10**7 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + 10**7 + 1\n        if x <= 0:\n            return BASE_PENALTY + 10**7 + 2\n    k = max(solution)\n    # Contiguity check: labels must be exactly 1..k with each used\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            # Should not happen due to k = max(solution), keep safe\n            return BASE_PENALTY + 10**7 + 3\n    label_gaps = 0\n    for c in range(1, k + 1):\n        if freq[c] == 0:\n            label_gaps += 1\n    # Graph definition (0-based indices)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Count conflicts (monochromatic edges)\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    # Feasible: minimize k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a 3-tuple: (nb_type:str, move_type:str, neighbor_solution:list[int])\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    # Ensure proper base solution\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        # Fallback reasonable seed\n        sol = [1,3,2,1,1,2,2,2,3]\n    n = 9\n    idx = random.randrange(n)\n    k = max(1, max(sol))\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return (\"RandomSingleRecolor\", \"RecolorVertex\", sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, multi-edit perturbation with optional global color swap\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        sol = [1,3,2,1,1,2,2,2,3]\n    k = max(1, max(sol))\n    if random.random() < 0.5 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        edits = random.randint(2, 4)\n        n = 9\n        for _ in range(edits):\n            idx = random.randrange(n)\n            k = max(1, max(sol))\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                new_color = random.choice(choices) if choices else sol[idx]\n            sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00000152}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust, gradient-preserving evaluator for graph coloring on fixed 9-vertex graph\n    # Score semantics (minimize):\n    # - If feasible (no edge conflicts, labels contiguous 1..k): return k\n    # - If infeasible: 1e9 + conflicts*1e6 + label_gaps*1e3 + k\n    # This preserves gradient towards feasibility and then towards fewer colors.\n    BASE_PENALTY = 10**9\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + 10**7\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + 10**7 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + 10**7 + 1\n        if x <= 0:\n            return BASE_PENALTY + 10**7 + 2\n    k = max(solution)\n    # Contiguity check: labels must be exactly 1..k with each used\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            # Should not happen due to k = max(solution), keep safe\n            return BASE_PENALTY + 10**7 + 3\n    label_gaps = 0\n    for c in range(1, k + 1):\n        if freq[c] == 0:\n            label_gaps += 1\n    # Graph definition (0-based indices)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Count conflicts (monochromatic edges)\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    # Feasible: minimize k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a 3-tuple: (nb_type:str, move_type:str, neighbor_solution:list[int])\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    # Ensure proper base solution\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        # Fallback reasonable seed\n        sol = [1,3,2,1,1,2,2,2,3]\n    n = 9\n    idx = random.randrange(n)\n    k = max(1, max(sol))\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return (\"RandomSingleRecolor\", \"RecolorVertex\", sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, multi-edit perturbation with optional global color swap\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        sol = [1,3,2,1,1,2,2,2,3]\n    k = max(1, max(sol))\n    if random.random() < 0.5 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        edits = random.randint(2, 4)\n        n = 9\n        for _ in range(edits):\n            idx = random.randrange(n)\n            k = max(1, max(sol))\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                new_color = random.choice(choices) if choices else sol[idx]\n            sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00000124}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    k = max(solution)\n    # Contiguity check 1..k all used at least once\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            return BASE_PENALTY + STRUCT_PENALTY + 3\n    label_gaps = sum(1 for c in range(1, k + 1) if freq[c] == 0)\n    # Graph edges (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (nb_type:str, move_type:str, neighbor_solution:list[int])\n    # Internal graph (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        # Feasible 3-color seed\n        return [1,3,2,1,1,2,2,2,3]\n    def compute_conflicts(sol):\n        cset = set()\n        for (u, v) in edges0:\n            if sol[u] == sol[v]:\n                cset.add(u); cset.add(v)\n        return cset\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    conflict_vertices = list(compute_conflicts(sol))\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    if random.random() < 0.2 and k >= 2:\n        # occasional color-class swap diversification\n        a, b = random.sample(range(1, k + 1), 2)\n        new_sol = [b if x == a else a if x == b else x for x in new_sol]\n        move_type = \"SwapColors({},{})\".format(a, b)\n        nb_type = \"ColorClassSwap\"\n    else:\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Try best existing color for v (greedy min local conflicts)\n        # Build adjacency list for quick conflict eval\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        current = new_sol[v]\n        best_color = current\n        best_conf = 10**9\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                # usually skip no-op\n                continue\n            tmpc = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmpc += 1\n            if tmpc < best_conf:\n                best_conf = tmpc\n                best_color = c\n                if best_conf == 0:\n                    break\n        # Consider adding a new color only if conflicts exist and it helps\n        if conflict_vertices and random.random() < 0.1:\n            best_color = k + 1\n        new_sol[v] = best_color\n    # Ensure positivity and length preserved\n    if len(new_sol) != n:\n        new_sol = valid_or_seed(None)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (nb_type, move_type, new_sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger multi-edit perturbation using Kempe-chain swaps and random recolors\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def kempe_chain_swap(sol, start_v, a, b):\n        # BFS over subgraph induced by colors a and b starting at start_v\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        target_colors = {a, b}\n        q = deque([start_v])\n        comp = set([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target_colors and u not in comp:\n                    comp.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            # random recolor a few vertices\n            edits = random.randint(1, 3)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n    # Sanity: ensure all entries valid\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00159671}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    k = max(solution)\n    # Contiguity check 1..k all used at least once\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            return BASE_PENALTY + STRUCT_PENALTY + 3\n    label_gaps = sum(1 for c in range(1, k + 1) if freq[c] == 0)\n    # Graph edges (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (nb_type:str, move_type:str, neighbor_solution:list[int])\n    # Internal graph (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        # Feasible 3-color seed\n        return [1,3,2,1,1,2,2,2,3]\n    def compute_conflicts(sol):\n        cset = set()\n        for (u, v) in edges0:\n            if sol[u] == sol[v]:\n                cset.add(u); cset.add(v)\n        return cset\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    conflict_vertices = list(compute_conflicts(sol))\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    if random.random() < 0.2 and k >= 2:\n        # occasional color-class swap diversification\n        a, b = random.sample(range(1, k + 1), 2)\n        new_sol = [b if x == a else a if x == b else x for x in new_sol]\n        move_type = \"SwapColors({},{})\".format(a, b)\n        nb_type = \"ColorClassSwap\"\n    else:\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Try best existing color for v (greedy min local conflicts)\n        # Build adjacency list for quick conflict eval\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        current = new_sol[v]\n        best_color = current\n        best_conf = 10**9\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                # usually skip no-op\n                continue\n            tmpc = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmpc += 1\n            if tmpc < best_conf:\n                best_conf = tmpc\n                best_color = c\n                if best_conf == 0:\n                    break\n        # Consider adding a new color only if conflicts exist and it helps\n        if conflict_vertices and random.random() < 0.1:\n            best_color = k + 1\n        new_sol[v] = best_color\n    # Ensure positivity and length preserved\n    if len(new_sol) != n:\n        new_sol = valid_or_seed(None)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (nb_type, move_type, new_sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger multi-edit perturbation using Kempe-chain swaps and random recolors\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def kempe_chain_swap(sol, start_v, a, b):\n        # BFS over subgraph induced by colors a and b starting at start_v\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        target_colors = {a, b}\n        q = deque([start_v])\n        comp = set([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target_colors and u not in comp:\n                    comp.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            # random recolor a few vertices\n            edits = random.randint(1, 3)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n    # Sanity: ensure all entries valid\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001183895}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    k = max(solution)\n    # Contiguity check 1..k all used at least once\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            return BASE_PENALTY + STRUCT_PENALTY + 3\n    label_gaps = sum(1 for c in range(1, k + 1) if freq[c] == 0)\n    # Graph edges (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (nb_type:str, move_type:str, neighbor_solution:list[int])\n    # Internal graph (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        # Feasible 3-color seed\n        return [1,3,2,1,1,2,2,2,3]\n    def compute_conflicts(sol):\n        cset = set()\n        for (u, v) in edges0:\n            if sol[u] == sol[v]:\n                cset.add(u); cset.add(v)\n        return cset\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    conflict_vertices = list(compute_conflicts(sol))\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    if random.random() < 0.2 and k >= 2:\n        # occasional color-class swap diversification\n        a, b = random.sample(range(1, k + 1), 2)\n        new_sol = [b if x == a else a if x == b else x for x in new_sol]\n        move_type = \"SwapColors({},{})\".format(a, b)\n        nb_type = \"ColorClassSwap\"\n    else:\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Try best existing color for v (greedy min local conflicts)\n        # Build adjacency list for quick conflict eval\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        current = new_sol[v]\n        best_color = current\n        best_conf = 10**9\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                # usually skip no-op\n                continue\n            tmpc = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmpc += 1\n            if tmpc < best_conf:\n                best_conf = tmpc\n                best_color = c\n                if best_conf == 0:\n                    break\n        # Consider adding a new color only if conflicts exist and it helps\n        if conflict_vertices and random.random() < 0.1:\n            best_color = k + 1\n        new_sol[v] = best_color\n    # Ensure positivity and length preserved\n    if len(new_sol) != n:\n        new_sol = valid_or_seed(None)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (nb_type, move_type, new_sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger multi-edit perturbation using Kempe-chain swaps and random recolors\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def kempe_chain_swap(sol, start_v, a, b):\n        # BFS over subgraph induced by colors a and b starting at start_v\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        target_colors = {a, b}\n        q = deque([start_v])\n        comp = set([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target_colors and u not in comp:\n                    comp.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            # random recolor a few vertices\n            edits = random.randint(1, 3)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n    # Sanity: ensure all entries valid\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001002893}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns fitness (lower is better). 3-color feasible => 3.\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    # Internal helpers and data (embedded to avoid external\/global deps)\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    # Structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    # Normalize labels to contiguous 1..k to avoid artificial gaps\n    sol = compress_labels(solution)\n    k = max(sol)\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize conflicts heavily; break ties by k\n        return BASE_PENALTY + conflicts * (10**6) + k\n    # Feasible: objective is k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    # Embeds graph data and uses normalization to maintain contiguity.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency once per call\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def vertex_conflicts(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def saturation_degree(sol, v):\n        colors = set()\n        for u in adj[v]:\n            colors.add(sol[u])\n        return len(colors)\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Identify conflict set and metrics\n    conflict_vertices = [v for v in range(n) if vertex_conflicts(sol, v) > 0]\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    # Diversification: occasional color-class swap\n    if random.random() < 0.15 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if new_sol[i] == a:\n                new_sol[i] = b\n            elif new_sol[i] == b:\n                new_sol[i] = a\n        move_type = f\"SwapColors({a},{b})\"\n        nb_type = \"ColorClassSwap\"\n    else:\n        # Select vertex: prefer max conflicts, tie-break by saturation degree\n        if conflict_vertices:\n            v = max(conflict_vertices, key=lambda x: (vertex_conflicts(sol, x), saturation_degree(sol, x), random.random()))\n        else:\n            v = max(range(n), key=lambda x: (saturation_degree(sol, x), random.random()))\n        current = new_sol[v]\n        best_color = current\n        best_score = 10**9\n        # Try existing colors 1..k (minimize local conflicts for v)\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                continue\n            tmp = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmp += 1\n            if tmp < best_score:\n                best_score = tmp\n                best_color = c\n                if best_score == 0:\n                    break\n        # Only consider introducing a new color if all existing colors cause conflicts for this vertex\n        if best_score > 0:\n            # small chance to try k+1 to escape local minima\n            if random.random() < 0.05:\n                best_color = k + 1\n        new_sol[v] = best_color\n    # Normalize and sanitize\n    new_sol = compress_labels(new_sol)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (new_sol, (nb_type, move_type))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong multi-edit perturbation with Kempe-chain swaps + random recolors; maintains contiguity via normalization.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def kempe_chain_swap(sol, start_v, a, b):\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        target = {a, b}\n        seen = set([start_v])\n        q = deque([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target and u not in seen:\n                    seen.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in seen:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Apply 2-4 perturbation steps\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            edits = random.randint(2, 4)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n        sol = compress_labels(sol)\n        k = max(sol)\n    # Final normalization and sanitation\n    sol = compress_labels(sol)\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Resultados":[[1,2,3,4,1,3,3,3,5],5,[1,3,2,1,1,2,2,2,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002887207}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns fitness (lower is better). 3-color feasible => 3.\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    # Internal helpers and data (embedded to avoid external\/global deps)\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    # Structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    # Normalize labels to contiguous 1..k to avoid artificial gaps\n    sol = compress_labels(solution)\n    k = max(sol)\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize conflicts heavily; break ties by k\n        return BASE_PENALTY + conflicts * (10**6) + k\n    # Feasible: objective is k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    # Embeds graph data and uses normalization to maintain contiguity.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency once per call\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def vertex_conflicts(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def saturation_degree(sol, v):\n        colors = set()\n        for u in adj[v]:\n            colors.add(sol[u])\n        return len(colors)\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Identify conflict set and metrics\n    conflict_vertices = [v for v in range(n) if vertex_conflicts(sol, v) > 0]\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    # Diversification: occasional color-class swap\n    if random.random() < 0.15 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if new_sol[i] == a:\n                new_sol[i] = b\n            elif new_sol[i] == b:\n                new_sol[i] = a\n        move_type = f\"SwapColors({a},{b})\"\n        nb_type = \"ColorClassSwap\"\n    else:\n        # Select vertex: prefer max conflicts, tie-break by saturation degree\n        if conflict_vertices:\n            v = max(conflict_vertices, key=lambda x: (vertex_conflicts(sol, x), saturation_degree(sol, x), random.random()))\n        else:\n            v = max(range(n), key=lambda x: (saturation_degree(sol, x), random.random()))\n        current = new_sol[v]\n        best_color = current\n        best_score = 10**9\n        # Try existing colors 1..k (minimize local conflicts for v)\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                continue\n            tmp = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmp += 1\n            if tmp < best_score:\n                best_score = tmp\n                best_color = c\n                if best_score == 0:\n                    break\n        # Only consider introducing a new color if all existing colors cause conflicts for this vertex\n        if best_score > 0:\n            # small chance to try k+1 to escape local minima\n            if random.random() < 0.05:\n                best_color = k + 1\n        new_sol[v] = best_color\n    # Normalize and sanitize\n    new_sol = compress_labels(new_sol)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (new_sol, (nb_type, move_type))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong multi-edit perturbation with Kempe-chain swaps + random recolors; maintains contiguity via normalization.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def kempe_chain_swap(sol, start_v, a, b):\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        target = {a, b}\n        seen = set([start_v])\n        q = deque([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target and u not in seen:\n                    seen.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in seen:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Apply 2-4 perturbation steps\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            edits = random.randint(2, 4)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n        sol = compress_labels(sol)\n        k = max(sol)\n    # Final normalization and sanitation\n    sol = compress_labels(sol)\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Resultados":[[1,2,3,2,2,4,3,5,4],3,[1,3,2,1,1,2,2,2,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002776625}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns fitness (lower is better). 3-color feasible => 3.\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    # Internal helpers and data (embedded to avoid external\/global deps)\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    # Structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    # Normalize labels to contiguous 1..k to avoid artificial gaps\n    sol = compress_labels(solution)\n    k = max(sol)\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize conflicts heavily; break ties by k\n        return BASE_PENALTY + conflicts * (10**6) + k\n    # Feasible: objective is k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    # Embeds graph data and uses normalization to maintain contiguity.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency once per call\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def vertex_conflicts(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def saturation_degree(sol, v):\n        colors = set()\n        for u in adj[v]:\n            colors.add(sol[u])\n        return len(colors)\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Identify conflict set and metrics\n    conflict_vertices = [v for v in range(n) if vertex_conflicts(sol, v) > 0]\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    # Diversification: occasional color-class swap\n    if random.random() < 0.15 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if new_sol[i] == a:\n                new_sol[i] = b\n            elif new_sol[i] == b:\n                new_sol[i] = a\n        move_type = f\"SwapColors({a},{b})\"\n        nb_type = \"ColorClassSwap\"\n    else:\n        # Select vertex: prefer max conflicts, tie-break by saturation degree\n        if conflict_vertices:\n            v = max(conflict_vertices, key=lambda x: (vertex_conflicts(sol, x), saturation_degree(sol, x), random.random()))\n        else:\n            v = max(range(n), key=lambda x: (saturation_degree(sol, x), random.random()))\n        current = new_sol[v]\n        best_color = current\n        best_score = 10**9\n        # Try existing colors 1..k (minimize local conflicts for v)\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                continue\n            tmp = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmp += 1\n            if tmp < best_score:\n                best_score = tmp\n                best_color = c\n                if best_score == 0:\n                    break\n        # Only consider introducing a new color if all existing colors cause conflicts for this vertex\n        if best_score > 0:\n            # small chance to try k+1 to escape local minima\n            if random.random() < 0.05:\n                best_color = k + 1\n        new_sol[v] = best_color\n    # Normalize and sanitize\n    new_sol = compress_labels(new_sol)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (new_sol, (nb_type, move_type))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong multi-edit perturbation with Kempe-chain swaps + random recolors; maintains contiguity via normalization.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def kempe_chain_swap(sol, start_v, a, b):\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        target = {a, b}\n        seen = set([start_v])\n        q = deque([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target and u not in seen:\n                    seen.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in seen:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Apply 2-4 perturbation steps\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            edits = random.randint(2, 4)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n        sol = compress_labels(sol)\n        k = max(sol)\n    # Final normalization and sanitation\n    sol = compress_labels(sol)\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001212486}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9 of positive integers; solution[i] is color of vertex i+1.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    if not isinstance(solution, list):\n        return 10000\n    n = 9\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\n\ndef _graph_edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _valid_colors_for_vertex(solution: List[int], v: int) -> List[int]:\n    # v is 1-based\n    n = 9\n    neighbor_colors = set()\n    for (u, w) in _graph_edges():\n        if u == v:\n            neighbor_colors.add(solution[w-1])\n        elif w == v:\n            neighbor_colors.add(solution[u-1])\n    used = set(solution)\n    # Try existing colors first, excluding neighbor colors\n    candidates = [c for c in used if c not in neighbor_colors]\n    if not candidates:\n        # introduce a new color if necessary\n        maxc = max(used) if used else 0\n        candidates = [maxc + 1]\n    return candidates\n\n\ndef _random_recolor(solution: List[int]) -> List[int]:\n    n = 9\n    idx = random.randrange(n)\n    v = idx + 1\n    candidates = _valid_colors_for_vertex(solution, v)\n    current = solution[idx]\n    # Prefer a different color if available\n    choices = [c for c in candidates if c != current] or candidates\n    new_color = random.choice(choices)\n    new_sol = solution[:]\n    new_sol[idx] = new_color\n    return new_sol\n\n\ndef _swap_colors(solution: List[int]) -> List[int]:\n    colors = list(set(solution))\n    if len(colors) < 2:\n        return _random_recolor(solution)\n    a, b = random.sample(colors, 2)\n    return [b if x == a else a if x == b else x for x in solution]\n\n\ndef _reduce_palette(solution: List[int]) -> List[int]:\n    # Attempt to reassign a color class to reduce number of colors\n    colors = sorted(set(solution))\n    if len(colors) <= 1:\n        return solution[:]\n    high = colors[-1]\n    candidates_vertices = [i for i, c in enumerate(solution) if c == high]\n    new_sol = solution[:]\n    for idx in candidates_vertices:\n        v = idx + 1\n        candidates = _valid_colors_for_vertex(new_sol, v)\n        # Prefer lower colors\n        candidates = sorted(candidates)\n        if candidates:\n            new_sol[idx] = candidates[0]\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-ish solution if malformed\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb = _random_recolor(sol)\n        return (nb, \"Recolor\", \"SingleVertex\")\n    elif move_pick < 0.8:\n        nb = _swap_colors(sol)\n        return (nb, \"SwapColors\", \"PaletteRelabel\")\n    else:\n        nb = _reduce_palette(sol)\n        return (nb, \"GreedyReduce\", \"ClassReassign\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef _edges_for_perturb():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _feasible_recolor_seq(sol: List[int], steps: int) -> List[int]:\n    n = 9\n    for _ in range(steps):\n        i = random.randrange(n)\n        v = i + 1\n        neighbor_colors = set()\n        for (u, w) in _edges_for_perturb():\n            if u == v:\n                neighbor_colors.add(sol[w-1])\n            elif w == v:\n                neighbor_colors.add(sol[u-1])\n        palette = list(set(sol))\n        if len(palette) < 1:\n            palette = [1]\n        # Ensure at least one option by allowing a new color if blocked\n        options = [c for c in palette if c not in neighbor_colors]\n        if not options:\n            options = [max(palette)+1]\n        # Prefer to change color\n        current = sol[i]\n        choices = [c for c in options if c != current] or options\n        sol[i] = random.choice(choices)\n    return sol\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors plus occasional palette relabel\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    steps = max(3, len(sol)\/\/3)\n    sol = _feasible_recolor_seq(sol, steps)\n    # With probability 0.5, relabel two colors to diversify\n    if random.random() < 0.5 and len(set(sol)) >= 2:\n        a, b = random.sample(list(set(sol)), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001241276}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9 of positive integers; solution[i] is color of vertex i+1.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    if not isinstance(solution, list):\n        return 10000\n    n = 9\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\n\ndef _graph_edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _valid_colors_for_vertex(solution: List[int], v: int) -> List[int]:\n    # v is 1-based\n    n = 9\n    neighbor_colors = set()\n    for (u, w) in _graph_edges():\n        if u == v:\n            neighbor_colors.add(solution[w-1])\n        elif w == v:\n            neighbor_colors.add(solution[u-1])\n    used = set(solution)\n    # Try existing colors first, excluding neighbor colors\n    candidates = [c for c in used if c not in neighbor_colors]\n    if not candidates:\n        # introduce a new color if necessary\n        maxc = max(used) if used else 0\n        candidates = [maxc + 1]\n    return candidates\n\n\ndef _random_recolor(solution: List[int]) -> List[int]:\n    n = 9\n    idx = random.randrange(n)\n    v = idx + 1\n    candidates = _valid_colors_for_vertex(solution, v)\n    current = solution[idx]\n    # Prefer a different color if available\n    choices = [c for c in candidates if c != current] or candidates\n    new_color = random.choice(choices)\n    new_sol = solution[:]\n    new_sol[idx] = new_color\n    return new_sol\n\n\ndef _swap_colors(solution: List[int]) -> List[int]:\n    colors = list(set(solution))\n    if len(colors) < 2:\n        return _random_recolor(solution)\n    a, b = random.sample(colors, 2)\n    return [b if x == a else a if x == b else x for x in solution]\n\n\ndef _reduce_palette(solution: List[int]) -> List[int]:\n    # Attempt to reassign a color class to reduce number of colors\n    colors = sorted(set(solution))\n    if len(colors) <= 1:\n        return solution[:]\n    high = colors[-1]\n    candidates_vertices = [i for i, c in enumerate(solution) if c == high]\n    new_sol = solution[:]\n    for idx in candidates_vertices:\n        v = idx + 1\n        candidates = _valid_colors_for_vertex(new_sol, v)\n        # Prefer lower colors\n        candidates = sorted(candidates)\n        if candidates:\n            new_sol[idx] = candidates[0]\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-ish solution if malformed\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb = _random_recolor(sol)\n        return (nb, \"Recolor\", \"SingleVertex\")\n    elif move_pick < 0.8:\n        nb = _swap_colors(sol)\n        return (nb, \"SwapColors\", \"PaletteRelabel\")\n    else:\n        nb = _reduce_palette(sol)\n        return (nb, \"GreedyReduce\", \"ClassReassign\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef _edges_for_perturb():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _feasible_recolor_seq(sol: List[int], steps: int) -> List[int]:\n    n = 9\n    for _ in range(steps):\n        i = random.randrange(n)\n        v = i + 1\n        neighbor_colors = set()\n        for (u, w) in _edges_for_perturb():\n            if u == v:\n                neighbor_colors.add(sol[w-1])\n            elif w == v:\n                neighbor_colors.add(sol[u-1])\n        palette = list(set(sol))\n        if len(palette) < 1:\n            palette = [1]\n        # Ensure at least one option by allowing a new color if blocked\n        options = [c for c in palette if c not in neighbor_colors]\n        if not options:\n            options = [max(palette)+1]\n        # Prefer to change color\n        current = sol[i]\n        choices = [c for c in options if c != current] or options\n        sol[i] = random.choice(choices)\n    return sol\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors plus occasional palette relabel\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    steps = max(3, len(sol)\/\/3)\n    sol = _feasible_recolor_seq(sol, steps)\n    # With probability 0.5, relabel two colors to diversify\n    if random.random() < 0.5 and len(set(sol)) >= 2:\n        a, b = random.sample(list(set(sol)), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001324757}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9 of positive integers; solution[i] is color of vertex i+1.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    if not isinstance(solution, list):\n        return 10000\n    n = 9\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\n\ndef _graph_edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _valid_colors_for_vertex(solution: List[int], v: int) -> List[int]:\n    # v is 1-based\n    n = 9\n    neighbor_colors = set()\n    for (u, w) in _graph_edges():\n        if u == v:\n            neighbor_colors.add(solution[w-1])\n        elif w == v:\n            neighbor_colors.add(solution[u-1])\n    used = set(solution)\n    # Try existing colors first, excluding neighbor colors\n    candidates = [c for c in used if c not in neighbor_colors]\n    if not candidates:\n        # introduce a new color if necessary\n        maxc = max(used) if used else 0\n        candidates = [maxc + 1]\n    return candidates\n\n\ndef _random_recolor(solution: List[int]) -> List[int]:\n    n = 9\n    idx = random.randrange(n)\n    v = idx + 1\n    candidates = _valid_colors_for_vertex(solution, v)\n    current = solution[idx]\n    # Prefer a different color if available\n    choices = [c for c in candidates if c != current] or candidates\n    new_color = random.choice(choices)\n    new_sol = solution[:]\n    new_sol[idx] = new_color\n    return new_sol\n\n\ndef _swap_colors(solution: List[int]) -> List[int]:\n    colors = list(set(solution))\n    if len(colors) < 2:\n        return _random_recolor(solution)\n    a, b = random.sample(colors, 2)\n    return [b if x == a else a if x == b else x for x in solution]\n\n\ndef _reduce_palette(solution: List[int]) -> List[int]:\n    # Attempt to reassign a color class to reduce number of colors\n    colors = sorted(set(solution))\n    if len(colors) <= 1:\n        return solution[:]\n    high = colors[-1]\n    candidates_vertices = [i for i, c in enumerate(solution) if c == high]\n    new_sol = solution[:]\n    for idx in candidates_vertices:\n        v = idx + 1\n        candidates = _valid_colors_for_vertex(new_sol, v)\n        # Prefer lower colors\n        candidates = sorted(candidates)\n        if candidates:\n            new_sol[idx] = candidates[0]\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-ish solution if malformed\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb = _random_recolor(sol)\n        return (nb, \"Recolor\", \"SingleVertex\")\n    elif move_pick < 0.8:\n        nb = _swap_colors(sol)\n        return (nb, \"SwapColors\", \"PaletteRelabel\")\n    else:\n        nb = _reduce_palette(sol)\n        return (nb, \"GreedyReduce\", \"ClassReassign\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef _edges_for_perturb():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _feasible_recolor_seq(sol: List[int], steps: int) -> List[int]:\n    n = 9\n    for _ in range(steps):\n        i = random.randrange(n)\n        v = i + 1\n        neighbor_colors = set()\n        for (u, w) in _edges_for_perturb():\n            if u == v:\n                neighbor_colors.add(sol[w-1])\n            elif w == v:\n                neighbor_colors.add(sol[u-1])\n        palette = list(set(sol))\n        if len(palette) < 1:\n            palette = [1]\n        # Ensure at least one option by allowing a new color if blocked\n        options = [c for c in palette if c not in neighbor_colors]\n        if not options:\n            options = [max(palette)+1]\n        # Prefer to change color\n        current = sol[i]\n        choices = [c for c in options if c != current] or options\n        sol[i] = random.choice(choices)\n    return sol\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors plus occasional palette relabel\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    steps = max(3, len(sol)\/\/3)\n    sol = _feasible_recolor_seq(sol, steps)\n    # With probability 0.5, relabel two colors to diversify\n    if random.random() < 0.5 and len(set(sol)) >= 2:\n        a, b = random.sample(list(set(sol)), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000988582}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import random, math\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    # Heavy penalties for malformed or conflicting assignments\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import random, math\n\n# Helper utilities fully local to avoid globals\n\ndef _edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adjacency():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canonical_relabel(sol):\n    # Relabel colors by first appearance to 1..k to reduce symmetry\n    mapping = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        out.append(mapping[c])\n    return out\n\ndef _is_conflict_free(sol):\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            return False\n    return True\n\ndef _used_colors(sol):\n    return sorted(set(sol))\n\ndef _dsatur_initial():\n    # DSATUR heuristic to build a low-color feasible solution\n    n = 9\n    adj = _adjacency()\n    colors = [0]*n\n    sat = [0]*n\n    uncolored = set(range(1,n+1))\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    while uncolored:\n        # pick vertex with max saturation, break ties by degree\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        forbid = neighbor_colors[v]\n        c = 1\n        while c in forbid:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canonical_relabel(colors)\n\ndef _valid_colors_for_vertex(sol, v, forbid_new_color=True):\n    # v is 1-based\n    adj = _adjacency()\n    neighbor_cols = set(sol[n-1] for n in adj[v])\n    used = set(sol)\n    candidates = [c for c in used if c not in neighbor_cols]\n    if not candidates and not forbid_new_color:\n        candidates = [max(used)+1]\n    return candidates\n\ndef _steepest_recolor(sol):\n    # Choose a vertex (prefer high conflicts \/ high degree) and assign best feasible color\n    n = 9\n    adj = _adjacency()\n    # conflict score per vertex\n    conf = [0]*n\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            conf[u-1] += 1\n            conf[v-1] += 1\n    # pick target\n    if any(conf):\n        v = max(range(1,n+1), key=lambda x: (conf[x-1], len(adj[x])))\n    else:\n        # intensification toward palette reduction: pick vertex in highest color class\n        colors = sorted(_used_colors(sol))\n        v = 1\n        if colors:\n            high = colors[-1]\n            # pick a vertex in the highest color class with largest degree\n            candidates = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(candidates, key=lambda x: len(adj[x]))\n    candidates = _valid_colors_for_vertex(sol, v, forbid_new_color=True)\n    if not candidates:\n        return sol[:]  # no move that avoids adding colors\n    # try to minimize conflicts and palette size\n    best = None\n    best_tuple = None\n    for c in sorted(candidates):\n        if c == sol[v-1]:\n            continue\n        trial = sol[:]\n        trial[v-1] = c\n        # score tuple: (conflicts, palette_size, color_value)\n        conflicts = 0\n        for u,w in _edges():\n            if trial[u-1] == trial[w-1]:\n                conflicts += 1\n        score = (conflicts, len(set(trial)), c)\n        if best is None or score < best_tuple:\n            best = trial\n            best_tuple = score\n    if best is None:\n        return sol[:]\n    return _canonical_relabel(best)\n\ndef _swap_palette(sol):\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    nb = [b if x == a else a if x == b else x for x in sol]\n    return _canonical_relabel(nb)\n\ndef _kempe_chain_swap(sol):\n    # Basic Kempe chain between two colors to escape plateaus\n    adj = _adjacency()\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    # pick start vertex with color a or b\n    candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n    if not candidates:\n        return sol[:]\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    pair = {a, b}\n    while stack:\n        v = stack.pop()\n        if v in target_set:\n            continue\n        target_set.add(v)\n        for w in adj[v]:\n            if sol[w-1] in pair:\n                stack.append(w)\n    nb = sol[:]\n    for v in target_set:\n        nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n    return _canonical_relabel(nb)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_initial()\n    else:\n        base = _canonical_relabel(solution)\n    r = random.random()\n    if r < 0.55:\n        nb = _steepest_recolor(base)\n        move_t, move_s = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = _kempe_chain_swap(base)\n        move_t, move_s = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = _swap_palette(base)\n        move_t, move_s = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, move_t, move_s)\n","Perturbacion":"import random, math\n\ndef _edges_p():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adj_p():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges_p():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canon(sol):\n    m = {}\n    k = 1\n    out = []\n    for c in sol:\n        if c not in m:\n            m[c] = k\n            k += 1\n        out.append(m[c])\n    return out\n\ndef _dsatur_seed():\n    n = 9\n    adj = _adj_p()\n    colors = [0]*n\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    uncolored = set(range(1,n+1))\n    while uncolored:\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        c = 1\n        while c in neighbor_colors[v]:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canon(colors)\n\ndef _random_feasible_recolor(sol):\n    # recolor a random vertex without introducing a new color\n    adj = _adj_p()\n    n = 9\n    i = random.randrange(n)\n    v = i+1\n    neighbor_cols = set(sol[w-1] for w in adj[v])\n    palette = list(set(sol))\n    options = [c for c in palette if c not in neighbor_cols]\n    if not options:\n        return sol[:]\n    cur = sol[i]\n    choices = [c for c in options if c != cur] or options\n    nb = sol[:]\n    nb[i] = random.choice(choices)\n    return _canon(nb)\n\ndef _palette_merge_attempt(sol, retries=3):\n    # Try to eliminate highest color by reassigning its vertices greedily with randomized order\n    colors = sorted(set(sol))\n    if len(colors) <= 1:\n        return sol[:]\n    high = colors[-1]\n    vertices = [i for i,c in enumerate(sol) if c == high]\n    if not vertices:\n        return sol[:]\n    order = vertices[:]\n    random.shuffle(order)\n    nb = sol[:]\n    adj = _adj_p()\n    for idx in order:\n        v = idx+1\n        neighbor_cols = set(nb[w-1] for w in adj[v])\n        candidates = [c for c in colors if c != high and c not in neighbor_cols]\n        if not candidates:\n            return sol[:]  # abort merge\n        nb[idx] = random.choice(candidates)\n    return _canon(nb)\n\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification: sequence of feasible recolors, optional Kempe-like relabel, and palette merge attempts\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_seed()\n    else:\n        base = _canon(solution)\n    steps = max(3, len(base)\/\/2)\n    cur = base\n    for _ in range(steps):\n        cur = _random_feasible_recolor(cur)\n    # swap two colors with 0.5 probability\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = _canon([b if x==a else a if x==b else x for x in cur])\n    # attempt palette merge\n    if random.random() < 0.6:\n        cand = _palette_merge_attempt(cur)\n        cur = cand\n    return cur\n","Resultados":"Failed to run target heuristic: _edges() takes 0 positional arguments but 1 was given.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002040286}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import random, math\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    # Heavy penalties for malformed or conflicting assignments\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import random, math\n\n# Helper utilities fully local to avoid globals\n\ndef _edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adjacency():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canonical_relabel(sol):\n    # Relabel colors by first appearance to 1..k to reduce symmetry\n    mapping = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        out.append(mapping[c])\n    return out\n\ndef _is_conflict_free(sol):\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            return False\n    return True\n\ndef _used_colors(sol):\n    return sorted(set(sol))\n\ndef _dsatur_initial():\n    # DSATUR heuristic to build a low-color feasible solution\n    n = 9\n    adj = _adjacency()\n    colors = [0]*n\n    sat = [0]*n\n    uncolored = set(range(1,n+1))\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    while uncolored:\n        # pick vertex with max saturation, break ties by degree\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        forbid = neighbor_colors[v]\n        c = 1\n        while c in forbid:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canonical_relabel(colors)\n\ndef _valid_colors_for_vertex(sol, v, forbid_new_color=True):\n    # v is 1-based\n    adj = _adjacency()\n    neighbor_cols = set(sol[n-1] for n in adj[v])\n    used = set(sol)\n    candidates = [c for c in used if c not in neighbor_cols]\n    if not candidates and not forbid_new_color:\n        candidates = [max(used)+1]\n    return candidates\n\ndef _steepest_recolor(sol):\n    # Choose a vertex (prefer high conflicts \/ high degree) and assign best feasible color\n    n = 9\n    adj = _adjacency()\n    # conflict score per vertex\n    conf = [0]*n\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            conf[u-1] += 1\n            conf[v-1] += 1\n    # pick target\n    if any(conf):\n        v = max(range(1,n+1), key=lambda x: (conf[x-1], len(adj[x])))\n    else:\n        # intensification toward palette reduction: pick vertex in highest color class\n        colors = sorted(_used_colors(sol))\n        v = 1\n        if colors:\n            high = colors[-1]\n            # pick a vertex in the highest color class with largest degree\n            candidates = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(candidates, key=lambda x: len(adj[x]))\n    candidates = _valid_colors_for_vertex(sol, v, forbid_new_color=True)\n    if not candidates:\n        return sol[:]  # no move that avoids adding colors\n    # try to minimize conflicts and palette size\n    best = None\n    best_tuple = None\n    for c in sorted(candidates):\n        if c == sol[v-1]:\n            continue\n        trial = sol[:]\n        trial[v-1] = c\n        # score tuple: (conflicts, palette_size, color_value)\n        conflicts = 0\n        for u,w in _edges():\n            if trial[u-1] == trial[w-1]:\n                conflicts += 1\n        score = (conflicts, len(set(trial)), c)\n        if best is None or score < best_tuple:\n            best = trial\n            best_tuple = score\n    if best is None:\n        return sol[:]\n    return _canonical_relabel(best)\n\ndef _swap_palette(sol):\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    nb = [b if x == a else a if x == b else x for x in sol]\n    return _canonical_relabel(nb)\n\ndef _kempe_chain_swap(sol):\n    # Basic Kempe chain between two colors to escape plateaus\n    adj = _adjacency()\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    # pick start vertex with color a or b\n    candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n    if not candidates:\n        return sol[:]\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    pair = {a, b}\n    while stack:\n        v = stack.pop()\n        if v in target_set:\n            continue\n        target_set.add(v)\n        for w in adj[v]:\n            if sol[w-1] in pair:\n                stack.append(w)\n    nb = sol[:]\n    for v in target_set:\n        nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n    return _canonical_relabel(nb)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_initial()\n    else:\n        base = _canonical_relabel(solution)\n    r = random.random()\n    if r < 0.55:\n        nb = _steepest_recolor(base)\n        move_t, move_s = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = _kempe_chain_swap(base)\n        move_t, move_s = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = _swap_palette(base)\n        move_t, move_s = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, move_t, move_s)\n","Perturbacion":"import random, math\n\ndef _edges_p():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adj_p():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges_p():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canon(sol):\n    m = {}\n    k = 1\n    out = []\n    for c in sol:\n        if c not in m:\n            m[c] = k\n            k += 1\n        out.append(m[c])\n    return out\n\ndef _dsatur_seed():\n    n = 9\n    adj = _adj_p()\n    colors = [0]*n\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    uncolored = set(range(1,n+1))\n    while uncolored:\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        c = 1\n        while c in neighbor_colors[v]:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canon(colors)\n\ndef _random_feasible_recolor(sol):\n    # recolor a random vertex without introducing a new color\n    adj = _adj_p()\n    n = 9\n    i = random.randrange(n)\n    v = i+1\n    neighbor_cols = set(sol[w-1] for w in adj[v])\n    palette = list(set(sol))\n    options = [c for c in palette if c not in neighbor_cols]\n    if not options:\n        return sol[:]\n    cur = sol[i]\n    choices = [c for c in options if c != cur] or options\n    nb = sol[:]\n    nb[i] = random.choice(choices)\n    return _canon(nb)\n\ndef _palette_merge_attempt(sol, retries=3):\n    # Try to eliminate highest color by reassigning its vertices greedily with randomized order\n    colors = sorted(set(sol))\n    if len(colors) <= 1:\n        return sol[:]\n    high = colors[-1]\n    vertices = [i for i,c in enumerate(sol) if c == high]\n    if not vertices:\n        return sol[:]\n    order = vertices[:]\n    random.shuffle(order)\n    nb = sol[:]\n    adj = _adj_p()\n    for idx in order:\n        v = idx+1\n        neighbor_cols = set(nb[w-1] for w in adj[v])\n        candidates = [c for c in colors if c != high and c not in neighbor_cols]\n        if not candidates:\n            return sol[:]  # abort merge\n        nb[idx] = random.choice(candidates)\n    return _canon(nb)\n\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification: sequence of feasible recolors, optional Kempe-like relabel, and palette merge attempts\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_seed()\n    else:\n        base = _canon(solution)\n    steps = max(3, len(base)\/\/2)\n    cur = base\n    for _ in range(steps):\n        cur = _random_feasible_recolor(cur)\n    # swap two colors with 0.5 probability\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = _canon([b if x==a else a if x==b else x for x in cur])\n    # attempt palette merge\n    if random.random() < 0.6:\n        cand = _palette_merge_attempt(cur)\n        cur = cand\n    return cur\n","Resultados":"Failed to run target heuristic: _edges() takes 0 positional arguments but 1 was given.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00153592}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import random, math\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    # Heavy penalties for malformed or conflicting assignments\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import random, math\n\n# Helper utilities fully local to avoid globals\n\ndef _edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adjacency():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canonical_relabel(sol):\n    # Relabel colors by first appearance to 1..k to reduce symmetry\n    mapping = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        out.append(mapping[c])\n    return out\n\ndef _is_conflict_free(sol):\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            return False\n    return True\n\ndef _used_colors(sol):\n    return sorted(set(sol))\n\ndef _dsatur_initial():\n    # DSATUR heuristic to build a low-color feasible solution\n    n = 9\n    adj = _adjacency()\n    colors = [0]*n\n    sat = [0]*n\n    uncolored = set(range(1,n+1))\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    while uncolored:\n        # pick vertex with max saturation, break ties by degree\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        forbid = neighbor_colors[v]\n        c = 1\n        while c in forbid:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canonical_relabel(colors)\n\ndef _valid_colors_for_vertex(sol, v, forbid_new_color=True):\n    # v is 1-based\n    adj = _adjacency()\n    neighbor_cols = set(sol[n-1] for n in adj[v])\n    used = set(sol)\n    candidates = [c for c in used if c not in neighbor_cols]\n    if not candidates and not forbid_new_color:\n        candidates = [max(used)+1]\n    return candidates\n\ndef _steepest_recolor(sol):\n    # Choose a vertex (prefer high conflicts \/ high degree) and assign best feasible color\n    n = 9\n    adj = _adjacency()\n    # conflict score per vertex\n    conf = [0]*n\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            conf[u-1] += 1\n            conf[v-1] += 1\n    # pick target\n    if any(conf):\n        v = max(range(1,n+1), key=lambda x: (conf[x-1], len(adj[x])))\n    else:\n        # intensification toward palette reduction: pick vertex in highest color class\n        colors = sorted(_used_colors(sol))\n        v = 1\n        if colors:\n            high = colors[-1]\n            # pick a vertex in the highest color class with largest degree\n            candidates = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(candidates, key=lambda x: len(adj[x]))\n    candidates = _valid_colors_for_vertex(sol, v, forbid_new_color=True)\n    if not candidates:\n        return sol[:]  # no move that avoids adding colors\n    # try to minimize conflicts and palette size\n    best = None\n    best_tuple = None\n    for c in sorted(candidates):\n        if c == sol[v-1]:\n            continue\n        trial = sol[:]\n        trial[v-1] = c\n        # score tuple: (conflicts, palette_size, color_value)\n        conflicts = 0\n        for u,w in _edges():\n            if trial[u-1] == trial[w-1]:\n                conflicts += 1\n        score = (conflicts, len(set(trial)), c)\n        if best is None or score < best_tuple:\n            best = trial\n            best_tuple = score\n    if best is None:\n        return sol[:]\n    return _canonical_relabel(best)\n\ndef _swap_palette(sol):\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    nb = [b if x == a else a if x == b else x for x in sol]\n    return _canonical_relabel(nb)\n\ndef _kempe_chain_swap(sol):\n    # Basic Kempe chain between two colors to escape plateaus\n    adj = _adjacency()\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    # pick start vertex with color a or b\n    candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n    if not candidates:\n        return sol[:]\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    pair = {a, b}\n    while stack:\n        v = stack.pop()\n        if v in target_set:\n            continue\n        target_set.add(v)\n        for w in adj[v]:\n            if sol[w-1] in pair:\n                stack.append(w)\n    nb = sol[:]\n    for v in target_set:\n        nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n    return _canonical_relabel(nb)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_initial()\n    else:\n        base = _canonical_relabel(solution)\n    r = random.random()\n    if r < 0.55:\n        nb = _steepest_recolor(base)\n        move_t, move_s = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = _kempe_chain_swap(base)\n        move_t, move_s = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = _swap_palette(base)\n        move_t, move_s = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, move_t, move_s)\n","Perturbacion":"import random, math\n\ndef _edges_p():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adj_p():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges_p():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canon(sol):\n    m = {}\n    k = 1\n    out = []\n    for c in sol:\n        if c not in m:\n            m[c] = k\n            k += 1\n        out.append(m[c])\n    return out\n\ndef _dsatur_seed():\n    n = 9\n    adj = _adj_p()\n    colors = [0]*n\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    uncolored = set(range(1,n+1))\n    while uncolored:\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        c = 1\n        while c in neighbor_colors[v]:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canon(colors)\n\ndef _random_feasible_recolor(sol):\n    # recolor a random vertex without introducing a new color\n    adj = _adj_p()\n    n = 9\n    i = random.randrange(n)\n    v = i+1\n    neighbor_cols = set(sol[w-1] for w in adj[v])\n    palette = list(set(sol))\n    options = [c for c in palette if c not in neighbor_cols]\n    if not options:\n        return sol[:]\n    cur = sol[i]\n    choices = [c for c in options if c != cur] or options\n    nb = sol[:]\n    nb[i] = random.choice(choices)\n    return _canon(nb)\n\ndef _palette_merge_attempt(sol, retries=3):\n    # Try to eliminate highest color by reassigning its vertices greedily with randomized order\n    colors = sorted(set(sol))\n    if len(colors) <= 1:\n        return sol[:]\n    high = colors[-1]\n    vertices = [i for i,c in enumerate(sol) if c == high]\n    if not vertices:\n        return sol[:]\n    order = vertices[:]\n    random.shuffle(order)\n    nb = sol[:]\n    adj = _adj_p()\n    for idx in order:\n        v = idx+1\n        neighbor_cols = set(nb[w-1] for w in adj[v])\n        candidates = [c for c in colors if c != high and c not in neighbor_cols]\n        if not candidates:\n            return sol[:]  # abort merge\n        nb[idx] = random.choice(candidates)\n    return _canon(nb)\n\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification: sequence of feasible recolors, optional Kempe-like relabel, and palette merge attempts\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_seed()\n    else:\n        base = _canon(solution)\n    steps = max(3, len(base)\/\/2)\n    cur = base\n    for _ in range(steps):\n        cur = _random_feasible_recolor(cur)\n    # swap two colors with 0.5 probability\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = _canon([b if x==a else a if x==b else x for x in cur])\n    # attempt palette merge\n    if random.random() < 0.6:\n        cand = _palette_merge_attempt(cur)\n        cur = cand\n    return cur\n","Resultados":"Failed to run target heuristic: _edges() takes 0 positional arguments but 1 was given.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001526969}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Internal graph data and helpers\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def conflicts(sol):\n        cnt = 0\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def used_colors(sol):\n        return sorted(set(sol))\n\n    def valid_colors_for_vertex(sol, v):\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        return [c for c in set(sol) if c not in neighbor_cols]\n\n    def recolor_steepest(sol):\n        n = 9\n        conf = [0]*n\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n        if any(conf):\n            v = max(range(1,n+1), key=lambda x: (conf[x-1], len(ADJ[x])))\n        else:\n            cols = used_colors(sol)\n            high = cols[-1] if cols else 1\n            cand = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (conflicts(sol), len(set(sol)), sol[v-1])\n        for c in sorted(set(sol)):\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (conflicts(trial), len(set(trial)), c)\n            if key < best_key:\n                best = trial\n                best_key = key\n        return canon(best)\n\n    def kempe_chain_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        start_candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not start_candidates:\n            return sol[:]\n        start = random.choice(start_candidates)\n        stack = [start]\n        seen = set()\n        pair = {a,b}\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in pair and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return canon(nb)\n\n    def palette_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        return canon([b if x==a else a if x==b else x for x in sol])\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    base = canon(solution) if sol_ok else dsatur_seed()\n\n    r = random.random()\n    if r < 0.55:\n        nb = recolor_steepest(base)\n        mt, ms = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = kempe_chain_swap(base)\n        mt, ms = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = palette_swap(base)\n        mt, ms = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, mt, ms)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification preserving feasibility when possible\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def random_feasible_recolor(sol):\n        n = 9\n        i = random.randrange(n)\n        v = i+1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return canon(nb)\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        vertices = [i for i,c in enumerate(sol) if c == high]\n        if not vertices:\n            return sol[:]\n        order = vertices[:]\n        random.shuffle(order)\n        nb = sol[:]\n        for idx in order:\n            v = idx+1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    cur = canon(solution) if sol_ok else dsatur_seed()\n\n    steps = max(3, len(cur)\/\/2)\n    for _ in range(steps):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = canon([b if x==a else a if x==b else x for x in cur])\n    if random.random() < 0.6:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001977655}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Internal graph data and helpers\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def conflicts(sol):\n        cnt = 0\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def used_colors(sol):\n        return sorted(set(sol))\n\n    def valid_colors_for_vertex(sol, v):\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        return [c for c in set(sol) if c not in neighbor_cols]\n\n    def recolor_steepest(sol):\n        n = 9\n        conf = [0]*n\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n        if any(conf):\n            v = max(range(1,n+1), key=lambda x: (conf[x-1], len(ADJ[x])))\n        else:\n            cols = used_colors(sol)\n            high = cols[-1] if cols else 1\n            cand = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (conflicts(sol), len(set(sol)), sol[v-1])\n        for c in sorted(set(sol)):\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (conflicts(trial), len(set(trial)), c)\n            if key < best_key:\n                best = trial\n                best_key = key\n        return canon(best)\n\n    def kempe_chain_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        start_candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not start_candidates:\n            return sol[:]\n        start = random.choice(start_candidates)\n        stack = [start]\n        seen = set()\n        pair = {a,b}\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in pair and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return canon(nb)\n\n    def palette_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        return canon([b if x==a else a if x==b else x for x in sol])\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    base = canon(solution) if sol_ok else dsatur_seed()\n\n    r = random.random()\n    if r < 0.55:\n        nb = recolor_steepest(base)\n        mt, ms = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = kempe_chain_swap(base)\n        mt, ms = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = palette_swap(base)\n        mt, ms = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, mt, ms)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification preserving feasibility when possible\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def random_feasible_recolor(sol):\n        n = 9\n        i = random.randrange(n)\n        v = i+1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return canon(nb)\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        vertices = [i for i,c in enumerate(sol) if c == high]\n        if not vertices:\n            return sol[:]\n        order = vertices[:]\n        random.shuffle(order)\n        nb = sol[:]\n        for idx in order:\n            v = idx+1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    cur = canon(solution) if sol_ok else dsatur_seed()\n\n    steps = max(3, len(cur)\/\/2)\n    for _ in range(steps):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = canon([b if x==a else a if x==b else x for x in cur])\n    if random.random() < 0.6:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00236745}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Internal graph data and helpers\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def conflicts(sol):\n        cnt = 0\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def used_colors(sol):\n        return sorted(set(sol))\n\n    def valid_colors_for_vertex(sol, v):\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        return [c for c in set(sol) if c not in neighbor_cols]\n\n    def recolor_steepest(sol):\n        n = 9\n        conf = [0]*n\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n        if any(conf):\n            v = max(range(1,n+1), key=lambda x: (conf[x-1], len(ADJ[x])))\n        else:\n            cols = used_colors(sol)\n            high = cols[-1] if cols else 1\n            cand = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (conflicts(sol), len(set(sol)), sol[v-1])\n        for c in sorted(set(sol)):\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (conflicts(trial), len(set(trial)), c)\n            if key < best_key:\n                best = trial\n                best_key = key\n        return canon(best)\n\n    def kempe_chain_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        start_candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not start_candidates:\n            return sol[:]\n        start = random.choice(start_candidates)\n        stack = [start]\n        seen = set()\n        pair = {a,b}\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in pair and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return canon(nb)\n\n    def palette_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        return canon([b if x==a else a if x==b else x for x in sol])\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    base = canon(solution) if sol_ok else dsatur_seed()\n\n    r = random.random()\n    if r < 0.55:\n        nb = recolor_steepest(base)\n        mt, ms = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = kempe_chain_swap(base)\n        mt, ms = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = palette_swap(base)\n        mt, ms = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, mt, ms)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification preserving feasibility when possible\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def random_feasible_recolor(sol):\n        n = 9\n        i = random.randrange(n)\n        v = i+1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return canon(nb)\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        vertices = [i for i,c in enumerate(sol) if c == high]\n        if not vertices:\n            return sol[:]\n        order = vertices[:]\n        random.shuffle(order)\n        nb = sol[:]\n        for idx in order:\n            v = idx+1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    cur = canon(solution) if sol_ok else dsatur_seed()\n\n    steps = max(3, len(cur)\/\/2)\n    for _ in range(steps):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = canon([b if x==a else a if x==b else x for x in cur])\n    if random.random() < 0.6:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002497772}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is a positive int color for vertex (i+1).","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10000\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        # Renumber colors to 1..k in order of first appearance\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def recolor_conflict_steepest(sol):\n        # Choose vertex with max conflicts; try recolors from existing palette minimizing conflicts\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            v = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            # No conflicts: target highest color class to potentially reduce palette later\n            cols_sorted = sorted(set(sol))\n            target = cols_sorted[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == target]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (count_conflicts(sol), len(set(sol)))\n        palette = sorted(set(sol))\n        for c in palette:\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (count_conflicts(trial), len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best\n\n    def color_elimination_attempt(sol):\n        # Try to eliminate the highest color class by relocating its vertices to lower feasible colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        order = verts[:]\n        random.shuffle(order)\n        nb = sol[:]\n        success = True\n        for idx in order:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c < high and c not in neighbor_cols]\n            if not candidates:\n                success = False\n                break\n            nb[idx] = random.choice(candidates)\n        if success:\n            # Drop the now-empty highest color and canonicalize\n            return canon(nb)\n        return sol[:]\n\n    def kempe_chain_biased(sol):\n        # Pick two colors biased toward highest color or conflict-heavy vertex\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        # Bias start vertex\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            start = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            high = colors[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == high]\n            start = random.choice(cand) if cand else random.randint(1, N)\n        # Pick partner color\n        a = sol[start-1]\n        b = random.choice([c for c in colors if c != a])\n        # Build Kempe chain component containing start in subgraph induced by colors {a,b}\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    # Input repair\/normalization\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    base = solution[:] if sol_ok else dsatur_seed()\n\n    # Decide neighborhood based on state\n    confs = count_conflicts(base)\n    kcols = len(set(base))\n    r = random.random()\n    if confs > 0:\n        if r < 0.7:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"SteepestConflicts\")\n        else:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChain\")\n    else:\n        # Feasible: push palette reduction moves more often\n        if r < 0.55:\n            nb = color_elimination_attempt(base)\n            return (nb, \"ColorElim\", \"GreedyHighestDrop\")\n        elif r < 0.85:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChainFeasible\")\n        else:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"TargetHighClass\")\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Diversification with controlled strength: Kempe kicks + random feasible recolors + optional palette merge\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def kempe_kick(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        a, b = random.sample(colors, 2)\n        # choose a random start among vertices colored a or b\n        cand = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not cand:\n            return sol[:]\n        start = random.choice(cand)\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    def random_feasible_recolor(sol):\n        i = random.randrange(N)\n        v = i + 1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return nb\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        nb = sol[:]\n        random.shuffle(verts)\n        for idx in verts:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    cur = solution[:] if sol_ok else dsatur_seed()\n\n    # Strength parameters\n    k_kicks = 2 + (1 if random.random() < 0.5 else 0)\n    k_recolors = 3\n\n    for _ in range(k_kicks):\n        cur = kempe_kick(cur)\n    for _ in range(k_recolors):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002425871}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is a positive int color for vertex (i+1).","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10000\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        # Renumber colors to 1..k in order of first appearance\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def recolor_conflict_steepest(sol):\n        # Choose vertex with max conflicts; try recolors from existing palette minimizing conflicts\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            v = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            # No conflicts: target highest color class to potentially reduce palette later\n            cols_sorted = sorted(set(sol))\n            target = cols_sorted[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == target]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (count_conflicts(sol), len(set(sol)))\n        palette = sorted(set(sol))\n        for c in palette:\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (count_conflicts(trial), len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best\n\n    def color_elimination_attempt(sol):\n        # Try to eliminate the highest color class by relocating its vertices to lower feasible colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        order = verts[:]\n        random.shuffle(order)\n        nb = sol[:]\n        success = True\n        for idx in order:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c < high and c not in neighbor_cols]\n            if not candidates:\n                success = False\n                break\n            nb[idx] = random.choice(candidates)\n        if success:\n            # Drop the now-empty highest color and canonicalize\n            return canon(nb)\n        return sol[:]\n\n    def kempe_chain_biased(sol):\n        # Pick two colors biased toward highest color or conflict-heavy vertex\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        # Bias start vertex\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            start = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            high = colors[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == high]\n            start = random.choice(cand) if cand else random.randint(1, N)\n        # Pick partner color\n        a = sol[start-1]\n        b = random.choice([c for c in colors if c != a])\n        # Build Kempe chain component containing start in subgraph induced by colors {a,b}\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    # Input repair\/normalization\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    base = solution[:] if sol_ok else dsatur_seed()\n\n    # Decide neighborhood based on state\n    confs = count_conflicts(base)\n    kcols = len(set(base))\n    r = random.random()\n    if confs > 0:\n        if r < 0.7:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"SteepestConflicts\")\n        else:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChain\")\n    else:\n        # Feasible: push palette reduction moves more often\n        if r < 0.55:\n            nb = color_elimination_attempt(base)\n            return (nb, \"ColorElim\", \"GreedyHighestDrop\")\n        elif r < 0.85:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChainFeasible\")\n        else:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"TargetHighClass\")\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Diversification with controlled strength: Kempe kicks + random feasible recolors + optional palette merge\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def kempe_kick(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        a, b = random.sample(colors, 2)\n        # choose a random start among vertices colored a or b\n        cand = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not cand:\n            return sol[:]\n        start = random.choice(cand)\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    def random_feasible_recolor(sol):\n        i = random.randrange(N)\n        v = i + 1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return nb\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        nb = sol[:]\n        random.shuffle(verts)\n        for idx in verts:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    cur = solution[:] if sol_ok else dsatur_seed()\n\n    # Strength parameters\n    k_kicks = 2 + (1 if random.random() < 0.5 else 0)\n    k_recolors = 3\n\n    for _ in range(k_kicks):\n        cur = kempe_kick(cur)\n    for _ in range(k_recolors):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002527242}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is a positive int color for vertex (i+1).","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10000\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        # Renumber colors to 1..k in order of first appearance\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def recolor_conflict_steepest(sol):\n        # Choose vertex with max conflicts; try recolors from existing palette minimizing conflicts\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            v = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            # No conflicts: target highest color class to potentially reduce palette later\n            cols_sorted = sorted(set(sol))\n            target = cols_sorted[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == target]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (count_conflicts(sol), len(set(sol)))\n        palette = sorted(set(sol))\n        for c in palette:\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (count_conflicts(trial), len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best\n\n    def color_elimination_attempt(sol):\n        # Try to eliminate the highest color class by relocating its vertices to lower feasible colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        order = verts[:]\n        random.shuffle(order)\n        nb = sol[:]\n        success = True\n        for idx in order:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c < high and c not in neighbor_cols]\n            if not candidates:\n                success = False\n                break\n            nb[idx] = random.choice(candidates)\n        if success:\n            # Drop the now-empty highest color and canonicalize\n            return canon(nb)\n        return sol[:]\n\n    def kempe_chain_biased(sol):\n        # Pick two colors biased toward highest color or conflict-heavy vertex\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        # Bias start vertex\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            start = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            high = colors[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == high]\n            start = random.choice(cand) if cand else random.randint(1, N)\n        # Pick partner color\n        a = sol[start-1]\n        b = random.choice([c for c in colors if c != a])\n        # Build Kempe chain component containing start in subgraph induced by colors {a,b}\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    # Input repair\/normalization\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    base = solution[:] if sol_ok else dsatur_seed()\n\n    # Decide neighborhood based on state\n    confs = count_conflicts(base)\n    kcols = len(set(base))\n    r = random.random()\n    if confs > 0:\n        if r < 0.7:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"SteepestConflicts\")\n        else:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChain\")\n    else:\n        # Feasible: push palette reduction moves more often\n        if r < 0.55:\n            nb = color_elimination_attempt(base)\n            return (nb, \"ColorElim\", \"GreedyHighestDrop\")\n        elif r < 0.85:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChainFeasible\")\n        else:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"TargetHighClass\")\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Diversification with controlled strength: Kempe kicks + random feasible recolors + optional palette merge\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def kempe_kick(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        a, b = random.sample(colors, 2)\n        # choose a random start among vertices colored a or b\n        cand = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not cand:\n            return sol[:]\n        start = random.choice(cand)\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    def random_feasible_recolor(sol):\n        i = random.randrange(N)\n        v = i + 1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return nb\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        nb = sol[:]\n        random.shuffle(verts)\n        for idx in verts:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    cur = solution[:] if sol_ok else dsatur_seed()\n\n    # Strength parameters\n    k_kicks = 2 + (1 if random.random() < 0.5 else 0)\n    k_recolors = 3\n\n    for _ in range(k_kicks):\n        cur = kempe_kick(cur)\n    for _ in range(k_recolors):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001851183}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS: solution is a list of 9 positive integers [c1,..,c9], where ci is the color (room ID) of vertex i. Labels are arbitrary; evaluation compacts labels internally.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and length\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Compact colors to consecutive integers starting at 1\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    violations = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            violations += 1\n    colors_used = len(mapping)\n    return violations*1000000 + colors_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"RECOLOR\",\"SWAP_COLORS\"}; Movement_Type describes granularity\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    sol = _compact_labels(solution)\n    n = len(sol)\n    max_col = max(sol)\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # RECOLOR 1 vertex to an existing or new color (at most max_col+1)\n        i = random.randrange(n)\n        # candidate colors: 1..max_col (+ maybe new color)\n        candidates = list(range(1, max_col+2))\n        candidates.remove(sol[i])\n        sol[i] = random.choice(candidates)\n        return sol, \"RECOLOR\", \"1-change\"\n    else:\n        # SWAP_COLORS: pick two distinct color labels present and swap them\n        colors_present = list(sorted(set(sol)))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            i = random.randrange(n)\n            candidates = list(range(1, max_col+2))\n            candidates.remove(sol[i])\n            sol[i] = random.choice(candidates)\n            return sol, \"RECOLOR\", \"1-change\"\n        a, b = random.sample(colors_present, 2)\n        for idx in range(n):\n            if sol[idx] == a:\n                sol[idx] = b\n            elif sol[idx] == b:\n                sol[idx] = a\n        return sol, \"SWAP_COLORS\", \"label-swap\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: recolor k random vertices; k in {2,3,4}\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = solution[:]\n    # compact labels first to normalize\n    mapping = {}\n    next_color = 1\n    for i, x in enumerate(sol):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        sol[i] = mapping[x]\n    n = len(sol)\n    max_col = max(sol)\n    k = random.choice([2,3,4])\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        # allow assignment among 1..max_col+1\n        new_cands = list(range(1, max_col+2))\n        if sol[i] in new_cands:\n            new_cands.remove(sol[i])\n        sol[i] = random.choice(new_cands)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00074471}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS: solution is a list of 9 positive integers [c1,..,c9], where ci is the color (room ID) of vertex i. Labels are arbitrary; evaluation compacts labels internally.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and length\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Compact colors to consecutive integers starting at 1\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    violations = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            violations += 1\n    colors_used = len(mapping)\n    return violations*1000000 + colors_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"RECOLOR\",\"SWAP_COLORS\"}; Movement_Type describes granularity\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    sol = _compact_labels(solution)\n    n = len(sol)\n    max_col = max(sol)\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # RECOLOR 1 vertex to an existing or new color (at most max_col+1)\n        i = random.randrange(n)\n        # candidate colors: 1..max_col (+ maybe new color)\n        candidates = list(range(1, max_col+2))\n        candidates.remove(sol[i])\n        sol[i] = random.choice(candidates)\n        return sol, \"RECOLOR\", \"1-change\"\n    else:\n        # SWAP_COLORS: pick two distinct color labels present and swap them\n        colors_present = list(sorted(set(sol)))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            i = random.randrange(n)\n            candidates = list(range(1, max_col+2))\n            candidates.remove(sol[i])\n            sol[i] = random.choice(candidates)\n            return sol, \"RECOLOR\", \"1-change\"\n        a, b = random.sample(colors_present, 2)\n        for idx in range(n):\n            if sol[idx] == a:\n                sol[idx] = b\n            elif sol[idx] == b:\n                sol[idx] = a\n        return sol, \"SWAP_COLORS\", \"label-swap\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: recolor k random vertices; k in {2,3,4}\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = solution[:]\n    # compact labels first to normalize\n    mapping = {}\n    next_color = 1\n    for i, x in enumerate(sol):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        sol[i] = mapping[x]\n    n = len(sol)\n    max_col = max(sol)\n    k = random.choice([2,3,4])\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        # allow assignment among 1..max_col+1\n        new_cands = list(range(1, max_col+2))\n        if sol[i] in new_cands:\n            new_cands.remove(sol[i])\n        sol[i] = random.choice(new_cands)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000599917}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS: solution is a list of 9 positive integers [c1,..,c9], where ci is the color (room ID) of vertex i. Labels are arbitrary; evaluation compacts labels internally.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and length\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Compact colors to consecutive integers starting at 1\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    violations = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            violations += 1\n    colors_used = len(mapping)\n    return violations*1000000 + colors_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"RECOLOR\",\"SWAP_COLORS\"}; Movement_Type describes granularity\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    sol = _compact_labels(solution)\n    n = len(sol)\n    max_col = max(sol)\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # RECOLOR 1 vertex to an existing or new color (at most max_col+1)\n        i = random.randrange(n)\n        # candidate colors: 1..max_col (+ maybe new color)\n        candidates = list(range(1, max_col+2))\n        candidates.remove(sol[i])\n        sol[i] = random.choice(candidates)\n        return sol, \"RECOLOR\", \"1-change\"\n    else:\n        # SWAP_COLORS: pick two distinct color labels present and swap them\n        colors_present = list(sorted(set(sol)))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            i = random.randrange(n)\n            candidates = list(range(1, max_col+2))\n            candidates.remove(sol[i])\n            sol[i] = random.choice(candidates)\n            return sol, \"RECOLOR\", \"1-change\"\n        a, b = random.sample(colors_present, 2)\n        for idx in range(n):\n            if sol[idx] == a:\n                sol[idx] = b\n            elif sol[idx] == b:\n                sol[idx] = a\n        return sol, \"SWAP_COLORS\", \"label-swap\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: recolor k random vertices; k in {2,3,4}\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = solution[:]\n    # compact labels first to normalize\n    mapping = {}\n    next_color = 1\n    for i, x in enumerate(sol):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        sol[i] = mapping[x]\n    n = len(sol)\n    max_col = max(sol)\n    k = random.choice([2,3,4])\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        # allow assignment among 1..max_col+1\n        new_cands = list(range(1, max_col+2))\n        if sol[i] in new_cands:\n            new_cands.remove(sol[i])\n        sol[i] = random.choice(new_cands)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000572238}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Early exit on first violation; penalty dominates\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            return 1000000 + colors_used\n    return colors_used\n","Vecindad":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    adj = _adjacency()\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR\", \"feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR\", \"new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR\", \"conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    adj = _adjacency()\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP\", \"kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    target_set.add(start)\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE\", \"component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol):\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    adj = _adjacency()\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # If not feasible, try the reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in _adjacency()[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        # build component in {a,b}\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001517003}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Early exit on first violation; penalty dominates\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            return 1000000 + colors_used\n    return colors_used\n","Vecindad":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    adj = _adjacency()\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR\", \"feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR\", \"new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR\", \"conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    adj = _adjacency()\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP\", \"kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    target_set.add(start)\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE\", \"component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol):\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    adj = _adjacency()\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # If not feasible, try the reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in _adjacency()[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        # build component in {a,b}\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001248838}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Early exit on first violation; penalty dominates\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            return 1000000 + colors_used\n    return colors_used\n","Vecindad":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    adj = _adjacency()\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR\", \"feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR\", \"new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR\", \"conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    adj = _adjacency()\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP\", \"kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    target_set.add(start)\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE\", \"component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol):\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    adj = _adjacency()\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # If not feasible, try the reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in _adjacency()[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        # build component in {a,b}\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001180118}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then colors\n    return conflicts * 1000.0 + float(colors_used)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR|conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set([start])\n    stack = [start]\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE|component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Try reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol, adj)\n\n# Public API\n# Must return (new_solution, move_tag) as 2-tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    adj = _adjacency()\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution, adj)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution, adj)\n    else:\n        return _merge_colors_move(solution, adj)\n","Perturbacion":"import random\nfrom typing import List\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001496612}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then colors\n    return conflicts * 1000.0 + float(colors_used)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR|conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set([start])\n    stack = [start]\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE|component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Try reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol, adj)\n\n# Public API\n# Must return (new_solution, move_tag) as 2-tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    adj = _adjacency()\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution, adj)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution, adj)\n    else:\n        return _merge_colors_move(solution, adj)\n","Perturbacion":"import random\nfrom typing import List\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001195437}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then colors\n    return conflicts * 1000.0 + float(colors_used)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR|conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set([start])\n    stack = [start]\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE|component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Try reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol, adj)\n\n# Public API\n# Must return (new_solution, move_tag) as 2-tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    adj = _adjacency()\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution, adj)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution, adj)\n    else:\n        return _merge_colors_move(solution, adj)\n","Perturbacion":"import random\nfrom typing import List\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001204728}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helper: canonicalize labels to 1..m preserving relative class mapping\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != N:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    sol = _compact_labels(solution)\n    # Count colors\n    colors_used = len(set(sol))\n    # Count conflicts\n    conflicts = 0\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic: conflicts first (dominates), then colors used\n    SCALE = 1000.0  # must exceed maximal colors used (<= N=9)\n    return conflicts * SCALE + float(colors_used)\n","Vecindad":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Moves\ndef _recolor_move(sol):\n    sol = _compact_labels(list(sol))\n    max_col = max(sol)\n    # Bias pick towards conflicted vertices\n    conflicted = _conflict_vertices(sol)\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        i = random.randrange(N)\n    v = i + 1\n    used_by_neigh = {sol[u-1] for u in ADJ[v]}\n    # Prefer feasible recolor using existing palette\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible\"\n    # Allow new color only if conflicts persist\n    if conflicted and random.random() < 0.15:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # Fallback: conflict-tolerant recolor to a different existing color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    sol[i] = random.choice(candidates) if candidates else 1\n    return sol, \"RECOLOR|fallback\"\n\ndef _kempe_chain_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    # Prefer color pairs appearing on conflict edges\n    pair_counts = {}\n    for u, v in EDGES:\n        cu, cv = sol[u-1], sol[v-1]\n        if cu == cv:\n            continue\n        a, b = sorted((cu, cv))\n        pair_counts[(a, b)] = pair_counts.get((a, b), 0) + 1\n    if pair_counts:\n        (a, b) = random.choices(list(pair_counts.keys()), weights=list(pair_counts.values()))[0]\n    else:\n        a, b = random.sample(colors, 2)\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    comp = set([start])\n    stack = [start]\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in ADJ[v]:\n            j = u - 1\n            if (sol[j] == a or sol[j] == b) and (j not in comp):\n                comp.add(j)\n                stack.append(j)\n    for j in comp:\n        sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol), \"KEMPE|swap\"\n\ndef _merge_colors_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    # Try multiple pairs for a feasible full merge\n    pairs = [(a, b) for idx, a in enumerate(colors) for b in colors[idx+1:]]\n    random.shuffle(pairs)\n    for a, b in pairs:\n        # Try merge a -> b\n        ok = True\n        a_vertices = [i for i, c in enumerate(sol) if c == a]\n        for i in a_vertices:\n            v = i + 1\n            if any(sol[u-1] == b for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in a_vertices:\n                sol[i] = b\n            return _compact_labels(sol), \"MERGE|a->b\"\n        # Try merge b -> a\n        ok = True\n        b_vertices = [i for i, c in enumerate(sol) if c == b]\n        for i in b_vertices:\n            v = i + 1\n            if any(sol[u-1] == a for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in b_vertices:\n                sol[i] = a\n            return _compact_labels(sol), \"MERGE|b->a\"\n    # Fallback to recolor if no merge possible\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, move_tag)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    r = random.random()\n    if r < 0.5:\n        return _recolor_move(solution)\n    elif r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Stronger shake: conflict-proportional multi-recolor + one Kempe swap + random relabel shuffle\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(list(solution))\n    max_col = max(sol)\n    conflicted = _conflict_vertices(sol)\n    k = max(3, min(N, (len(conflicted) if conflicted else 3)))\n    idxs = random.sample(range(N), k)\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in ADJ[v]}\n        feasible = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if feasible:\n            sol[i] = random.choice(feasible)\n        else:\n            # occasionally introduce a new color to escape deep basins\n            if random.random() < 0.25:\n                max_col += 1\n                sol[i] = max_col\n            else:\n                choices = [c for c in range(1, max_col+1) if c != sol[i]]\n                if choices:\n                    sol[i] = random.choice(choices)\n    # One Kempe chain swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in ADJ[v]:\n                    j = u - 1\n                    if (sol[j] == a or sol[j] == b) and (j not in comp):\n                        comp.add(j)\n                        stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    # Random relabel shuffle to diversify label identities without changing partition\n    mapping = {c: c for c in sorted(set(sol))}\n    new_labels = list(mapping.keys())\n    random.shuffle(new_labels)\n    remap = {old: new for old, new in zip(mapping.keys(), new_labels)}\n    sol = [remap[c] for c in sol]\n    return _compact_labels(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001703753}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helper: canonicalize labels to 1..m preserving relative class mapping\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != N:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    sol = _compact_labels(solution)\n    # Count colors\n    colors_used = len(set(sol))\n    # Count conflicts\n    conflicts = 0\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic: conflicts first (dominates), then colors used\n    SCALE = 1000.0  # must exceed maximal colors used (<= N=9)\n    return conflicts * SCALE + float(colors_used)\n","Vecindad":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Moves\ndef _recolor_move(sol):\n    sol = _compact_labels(list(sol))\n    max_col = max(sol)\n    # Bias pick towards conflicted vertices\n    conflicted = _conflict_vertices(sol)\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        i = random.randrange(N)\n    v = i + 1\n    used_by_neigh = {sol[u-1] for u in ADJ[v]}\n    # Prefer feasible recolor using existing palette\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible\"\n    # Allow new color only if conflicts persist\n    if conflicted and random.random() < 0.15:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # Fallback: conflict-tolerant recolor to a different existing color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    sol[i] = random.choice(candidates) if candidates else 1\n    return sol, \"RECOLOR|fallback\"\n\ndef _kempe_chain_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    # Prefer color pairs appearing on conflict edges\n    pair_counts = {}\n    for u, v in EDGES:\n        cu, cv = sol[u-1], sol[v-1]\n        if cu == cv:\n            continue\n        a, b = sorted((cu, cv))\n        pair_counts[(a, b)] = pair_counts.get((a, b), 0) + 1\n    if pair_counts:\n        (a, b) = random.choices(list(pair_counts.keys()), weights=list(pair_counts.values()))[0]\n    else:\n        a, b = random.sample(colors, 2)\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    comp = set([start])\n    stack = [start]\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in ADJ[v]:\n            j = u - 1\n            if (sol[j] == a or sol[j] == b) and (j not in comp):\n                comp.add(j)\n                stack.append(j)\n    for j in comp:\n        sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol), \"KEMPE|swap\"\n\ndef _merge_colors_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    # Try multiple pairs for a feasible full merge\n    pairs = [(a, b) for idx, a in enumerate(colors) for b in colors[idx+1:]]\n    random.shuffle(pairs)\n    for a, b in pairs:\n        # Try merge a -> b\n        ok = True\n        a_vertices = [i for i, c in enumerate(sol) if c == a]\n        for i in a_vertices:\n            v = i + 1\n            if any(sol[u-1] == b for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in a_vertices:\n                sol[i] = b\n            return _compact_labels(sol), \"MERGE|a->b\"\n        # Try merge b -> a\n        ok = True\n        b_vertices = [i for i, c in enumerate(sol) if c == b]\n        for i in b_vertices:\n            v = i + 1\n            if any(sol[u-1] == a for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in b_vertices:\n                sol[i] = a\n            return _compact_labels(sol), \"MERGE|b->a\"\n    # Fallback to recolor if no merge possible\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, move_tag)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    r = random.random()\n    if r < 0.5:\n        return _recolor_move(solution)\n    elif r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Stronger shake: conflict-proportional multi-recolor + one Kempe swap + random relabel shuffle\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(list(solution))\n    max_col = max(sol)\n    conflicted = _conflict_vertices(sol)\n    k = max(3, min(N, (len(conflicted) if conflicted else 3)))\n    idxs = random.sample(range(N), k)\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in ADJ[v]}\n        feasible = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if feasible:\n            sol[i] = random.choice(feasible)\n        else:\n            # occasionally introduce a new color to escape deep basins\n            if random.random() < 0.25:\n                max_col += 1\n                sol[i] = max_col\n            else:\n                choices = [c for c in range(1, max_col+1) if c != sol[i]]\n                if choices:\n                    sol[i] = random.choice(choices)\n    # One Kempe chain swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in ADJ[v]:\n                    j = u - 1\n                    if (sol[j] == a or sol[j] == b) and (j not in comp):\n                        comp.add(j)\n                        stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    # Random relabel shuffle to diversify label identities without changing partition\n    mapping = {c: c for c in sorted(set(sol))}\n    new_labels = list(mapping.keys())\n    random.shuffle(new_labels)\n    remap = {old: new for old, new in zip(mapping.keys(), new_labels)}\n    sol = [remap[c] for c in sol]\n    return _compact_labels(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002058919}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helper: canonicalize labels to 1..m preserving relative class mapping\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != N:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    sol = _compact_labels(solution)\n    # Count colors\n    colors_used = len(set(sol))\n    # Count conflicts\n    conflicts = 0\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic: conflicts first (dominates), then colors used\n    SCALE = 1000.0  # must exceed maximal colors used (<= N=9)\n    return conflicts * SCALE + float(colors_used)\n","Vecindad":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Moves\ndef _recolor_move(sol):\n    sol = _compact_labels(list(sol))\n    max_col = max(sol)\n    # Bias pick towards conflicted vertices\n    conflicted = _conflict_vertices(sol)\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        i = random.randrange(N)\n    v = i + 1\n    used_by_neigh = {sol[u-1] for u in ADJ[v]}\n    # Prefer feasible recolor using existing palette\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible\"\n    # Allow new color only if conflicts persist\n    if conflicted and random.random() < 0.15:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # Fallback: conflict-tolerant recolor to a different existing color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    sol[i] = random.choice(candidates) if candidates else 1\n    return sol, \"RECOLOR|fallback\"\n\ndef _kempe_chain_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    # Prefer color pairs appearing on conflict edges\n    pair_counts = {}\n    for u, v in EDGES:\n        cu, cv = sol[u-1], sol[v-1]\n        if cu == cv:\n            continue\n        a, b = sorted((cu, cv))\n        pair_counts[(a, b)] = pair_counts.get((a, b), 0) + 1\n    if pair_counts:\n        (a, b) = random.choices(list(pair_counts.keys()), weights=list(pair_counts.values()))[0]\n    else:\n        a, b = random.sample(colors, 2)\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    comp = set([start])\n    stack = [start]\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in ADJ[v]:\n            j = u - 1\n            if (sol[j] == a or sol[j] == b) and (j not in comp):\n                comp.add(j)\n                stack.append(j)\n    for j in comp:\n        sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol), \"KEMPE|swap\"\n\ndef _merge_colors_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    # Try multiple pairs for a feasible full merge\n    pairs = [(a, b) for idx, a in enumerate(colors) for b in colors[idx+1:]]\n    random.shuffle(pairs)\n    for a, b in pairs:\n        # Try merge a -> b\n        ok = True\n        a_vertices = [i for i, c in enumerate(sol) if c == a]\n        for i in a_vertices:\n            v = i + 1\n            if any(sol[u-1] == b for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in a_vertices:\n                sol[i] = b\n            return _compact_labels(sol), \"MERGE|a->b\"\n        # Try merge b -> a\n        ok = True\n        b_vertices = [i for i, c in enumerate(sol) if c == b]\n        for i in b_vertices:\n            v = i + 1\n            if any(sol[u-1] == a for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in b_vertices:\n                sol[i] = a\n            return _compact_labels(sol), \"MERGE|b->a\"\n    # Fallback to recolor if no merge possible\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, move_tag)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    r = random.random()\n    if r < 0.5:\n        return _recolor_move(solution)\n    elif r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Stronger shake: conflict-proportional multi-recolor + one Kempe swap + random relabel shuffle\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(list(solution))\n    max_col = max(sol)\n    conflicted = _conflict_vertices(sol)\n    k = max(3, min(N, (len(conflicted) if conflicted else 3)))\n    idxs = random.sample(range(N), k)\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in ADJ[v]}\n        feasible = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if feasible:\n            sol[i] = random.choice(feasible)\n        else:\n            # occasionally introduce a new color to escape deep basins\n            if random.random() < 0.25:\n                max_col += 1\n                sol[i] = max_col\n            else:\n                choices = [c for c in range(1, max_col+1) if c != sol[i]]\n                if choices:\n                    sol[i] = random.choice(choices)\n    # One Kempe chain swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in ADJ[v]:\n                    j = u - 1\n                    if (sol[j] == a or sol[j] == b) and (j not in comp):\n                        comp.add(j)\n                        stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    # Random relabel shuffle to diversify label identities without changing partition\n    mapping = {c: c for c in sorted(set(sol))}\n    new_labels = list(mapping.keys())\n    random.shuffle(new_labels)\n    remap = {old: new for old, new in zip(mapping.keys(), new_labels)}\n    sol = [remap[c] for c in sol]\n    return _compact_labels(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00145728}
