{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, unique, 1..24)\n    if not isinstance(solution, list):\n        return float(\"inf\")\n    if not all(isinstance(i, int) for i in solution):\n        return float(\"inf\")\n    if len(solution) != len(set(solution)):\n        return float(\"inf\")\n    if any(i < 1 or i > 24 for i in solution):\n        return float(\"inf\")\n    if any(a >= b for a, b in zip(solution, solution[1:])):\n        return float(\"inf\")\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Capacity check and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        vi = v[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float(\"inf\")\n        total_value += vi\n    # Return negative for minimization-based SA (best = lesser cost)\n    return float(-total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def repair_and_sort(sol):\n        sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n        sol = sorted(set(sol))\n        return sol\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def make_feasible(sol):\n        sol = repair_and_sort(sol)\n        # Remove items with worst value-to-weight ratio first until feasible\n        while True:\n            tw = weight_of(sol)\n            if tw <= cap or not sol:\n                break\n            worst = min(sol, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            sol.remove(worst)\n        return sol\n\n    current = list(solution)\n    move_type = None\n\n    present = set(current)\n    absent = [i for i in range(1, 25) if i not in present]\n\n    if not current and absent:\n        move_type = \"add\"\n        base_w = 0\n        feas_abs = [i for i in absent if base_w + w[i - 1] <= cap]\n        if feas_abs:\n            choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current.append(choice)\n    else:\n        r = random.random()\n        if r < 0.34 and absent:\n            move_type = \"add\"\n            base_w = weight_of(current)\n            feas_abs = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas_abs:\n                choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                current.append(choice)\n        elif r < 0.67 and current:\n            move_type = \"remove\"\n            rem = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current.remove(rem)\n        else:\n            move_type = \"swap\"\n            if current and absent:\n                rem = random.choice(current)\n                base = weight_of([i for i in current if i != rem])\n                feas_add = [i for i in absent if base + w[i - 1] <= cap]\n                if feas_add:\n                    add = max(feas_add, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                    current.remove(rem)\n                    current.append(add)\n            elif current:\n                # fallback to remove if no absent\n                rem = random.choice(current)\n                current.remove(rem)\n            elif absent:\n                add_any = random.choice(absent)\n                current.append(add_any)\n\n    current = repair_and_sort(current)\n    current = make_feasible(current)\n\n    solution[:] = current\n    return (\"INDEX_LIST\", move_type if move_type is not None else \"noop\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def repair_and_sort(sol):\n        sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n        sol = sorted(set(sol))\n        return sol\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def make_feasible(sol):\n        sol = repair_and_sort(sol)\n        while True:\n            tw = weight_of(sol)\n            if tw <= cap or not sol:\n                break\n            # remove worst ratio item first\n            worst = min(sol, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            sol.remove(worst)\n        return sol\n\n    cur = list(solution)\n    k = max(2, len(cur) \/\/ 3)\n    for _ in range(k):\n        present = set(cur)\n        absent = [i for i in range(1, 25) if i not in present]\n        move = random.random()\n        if move < 0.4 and absent:\n            base_w = weight_of(cur)\n            feas = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas:\n                # add a random feasible item biased by good ratio\n                best = max(feas, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                cur.append(best)\n        elif move < 0.8 and cur:\n            rem = random.choice(cur)\n            cur.remove(rem)\n        else:\n            if cur and absent:\n                rem = random.choice(cur)\n                base = weight_of([i for i in cur if i != rem])\n                feas_add = [i for i in absent if base + w[i - 1] <= cap]\n                if feas_add:\n                    add = random.choice(feas_add)\n                    cur.remove(rem)\n                    cur.append(add)\n    cur = repair_and_sort(cur)\n    cur = make_feasible(cur)\n    solution[:] = cur\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, unique, 1..24)\n    if not isinstance(solution, list):\n        return float(\"inf\")\n    if not all(isinstance(i, int) for i in solution):\n        return float(\"inf\")\n    if len(solution) != len(set(solution)):\n        return float(\"inf\")\n    if any(i < 1 or i > 24 for i in solution):\n        return float(\"inf\")\n    if any(a >= b for a, b in zip(solution, solution[1:])):\n        return float(\"inf\")\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Capacity check and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        vi = v[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float(\"inf\")\n        total_value += vi\n    # Negative cost convention for maximization\n    return float(-total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def insert_sorted(sol, item):\n        # Maintain strictly increasing order without duplicates\n        if item in sol:\n            return sol\n        # Binary insertion\n        lo, hi = 0, len(sol)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if sol[mid] < item:\n                lo = mid + 1\n            else:\n                hi = mid\n        sol.insert(lo, item)\n        return sol\n\n    def feasible_add(base_sol, item):\n        return weight_of(base_sol) + w[item - 1] <= cap\n\n    current = list(solution)\n    # ensure canonical form\n    current = sorted(set(i for i in current if isinstance(i, int) and 1 <= i <= 24))\n\n    present = set(current)\n    absent = [i for i in range(1, 25) if i not in present]\n\n    move_type = \"noop\"\n\n    if not current and absent:\n        # start by adding best ratio feasible item\n        feas_abs = [i for i in absent if w[i - 1] <= cap]\n        if feas_abs:\n            choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current = insert_sorted(current, choice)\n            move_type = \"add\"\n    else:\n        r = random.random()\n        if r < 0.34 and absent:\n            # add: choose best ratio among feasible absent\n            base_w = weight_of(current)\n            feas_abs = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas_abs:\n                choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                current = insert_sorted(current, choice)\n                move_type = \"add\"\n        elif r < 0.67 and current:\n            # remove: choose worst ratio in current\n            rem = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current.remove(rem)\n            move_type = \"remove\"\n        else:\n            # swap: remove one, add one best-ratio feasible\n            if current and absent:\n                # choose removal as worst ratio to free capacity\n                rem = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                base = [i for i in current if i != rem]\n                base_w = weight_of(base)\n                feas_add = [i for i in absent if base_w + w[i - 1] <= cap]\n                if feas_add:\n                    add = max(feas_add, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                    current = base\n                    current = insert_sorted(current, add)\n                    move_type = \"swap\"\n            elif current:\n                # fallback to remove\n                rem = random.choice(current)\n                current.remove(rem)\n                move_type = \"remove\"\n            elif absent:\n                # fallback to add any feasible\n                feas_abs = [i for i in absent if w[i - 1] <= cap]\n                if feas_abs:\n                    add = random.choice(feas_abs)\n                    current = insert_sorted(current, add)\n                    move_type = \"add\"\n\n    # final canonicalization and feasibility check (should already be feasible)\n    # ensure capacity not exceeded; if exceeded due to unforeseen path, drop worst ratios until feasible\n    while weight_of(current) > cap and current:\n        worst = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n        current.remove(worst)\n        move_type = \"repair_drop\"\n\n    # in-place update for downstream solvers expecting mutation\n    solution[:] = current\n    return (\"INDEX_LIST\", move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def insert_sorted(sol, item):\n        if item in sol:\n            return sol\n        lo, hi = 0, len(sol)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if sol[mid] < item:\n                lo = mid + 1\n            else:\n                hi = mid\n        sol.insert(lo, item)\n        return sol\n\n    cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= 24))\n\n    # number of atomic moves\n    k = max(3, len(cur) \/\/ 2)\n    for _ in range(k):\n        present = set(cur)\n        absent = [i for i in range(1, 25) if i not in present]\n        move = random.random()\n        if move < 0.33 and absent:\n            # biased add by good ratio if feasible\n            base_w = weight_of(cur)\n            feas = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas:\n                pick = max(feas, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                cur = insert_sorted(cur, pick)\n        elif move < 0.66 and cur:\n            # remove random item\n            rem = random.choice(cur)\n            cur.remove(rem)\n        else:\n            # swap random remove with feasible random add\n            if cur:\n                rem = random.choice(cur)\n                base = [i for i in cur if i != rem]\n                base_w = weight_of(base)\n                absent2 = [i for i in range(1, 25) if i not in set(base)]\n                feas_add = [i for i in absent2 if base_w + w[i - 1] <= cap]\n                if feas_add:\n                    add = random.choice(feas_add)\n                    cur = base\n                    cur = insert_sorted(cur, add)\n\n    # repair if needed: drop low ratio items until feasible\n    while weight_of(cur) > cap and cur:\n        worst = min(cur, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n        cur.remove(worst)\n\n    # write back in place\n    solution[:] = cur\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, unique, 1..24)\n    if not isinstance(solution, list):\n        return float(\"inf\")\n    if not all(isinstance(i, int) for i in solution):\n        return float(\"inf\")\n    if len(solution) != len(set(solution)):\n        return float(\"inf\")\n    if any(i < 1 or i > 24 for i in solution):\n        return float(\"inf\")\n    if any(a >= b for a, b in zip(solution, solution[1:])):\n        return float(\"inf\")\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Capacity check and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        vi = v[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float(\"inf\")\n        total_value += vi\n    # Negative cost convention for maximization\n    return float(-total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def insert_sorted(sol, item):\n        if item in sol:\n            return sol[:]\n        lo, hi = 0, len(sol)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if sol[mid] < item:\n                lo = mid + 1\n            else:\n                hi = mid\n        new_sol = sol[:]\n        new_sol.insert(lo, item)\n        return new_sol\n\n    def canonical(sol):\n        return sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= 24))\n\n    def repair_feasible(sol):\n        cur = sol[:]\n        while weight_of(cur) > cap and cur:\n            worst = min(cur, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], i))\n            cur.remove(worst)\n        return cur\n\n    cur = canonical(solution)\n    base_w = weight_of(cur)\n    present = set(cur)\n    absent = [i for i in range(1, 25) if i not in present]\n\n    move_type = \"noop\"\n    r = random.random()\n\n    if not cur:\n        # add best ratio feasible item deterministically (stable tie-break)\n        feas_abs = [i for i in absent if w[i - 1] <= cap]\n        if feas_abs:\n            choice = max(\n                feas_abs,\n                key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], -i),\n            )\n            new_sol = insert_sorted(cur, choice)\n            return (new_sol, \"add_init\")\n        return (cur, move_type)\n\n    # Choose move type: add \/ remove \/ swap \/ 2-2 exchange\n    if r < 0.30 and absent:\n        # Add best ratio feasible\n        feas_abs = [i for i in absent if base_w + w[i - 1] <= cap]\n        if feas_abs:\n            choice = max(\n                feas_abs,\n                key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], -i),\n            )\n            new_sol = insert_sorted(cur, choice)\n            return (new_sol, \"add\")\n    elif r < 0.60 and cur:\n        # Remove worst ratio\n        rem = min(cur, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], i))\n        new_sol = [i for i in cur if i != rem]\n        return (new_sol, \"remove\")\n    elif r < 0.85 and cur and absent:\n        # 1-1 swap: remove worst, add best feasible\n        rem = min(cur, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], i))\n        base = [i for i in cur if i != rem]\n        base_w2 = weight_of(base)\n        feas_add = [i for i in range(1, 25) if i not in set(base) and base_w2 + w[i - 1] <= cap]\n        if feas_add:\n            add = max(feas_add, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], -i))\n            new_sol = insert_sorted(base, add)\n            return (new_sol, \"swap_1_1\")\n    else:\n        # 2-2 exchange (fallback repairs if infeasible)\n        if len(cur) >= 2:\n            rem_items = random.sample(cur, 2)\n            base = [i for i in cur if i not in set(rem_items)]\n            base_w2 = weight_of(base)\n            # candidate adds from absent\n            present2 = set(base)\n            abs2 = [i for i in range(1, 25) if i not in present2]\n            # try pick two adds greedily by ratio subject to capacity\n            cand = sorted(abs2, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], -i), reverse=True)\n            new_sol = base[:]\n            cur_w = base_w2\n            added = 0\n            for it in cand:\n                if cur_w + w[it - 1] <= cap and added < 2:\n                    new_sol = insert_sorted(new_sol, it)\n                    cur_w += w[it - 1]\n                    added += 1\n            new_sol = repair_feasible(new_sol)\n            if new_sol != cur:\n                return (new_sol, \"swap_2_2\")\n\n    # default: return current unchanged if no move applied\n    return (cur, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def insert_sorted(sol, item):\n        if item in sol:\n            return sol[:]\n        lo, hi = 0, len(sol)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if sol[mid] < item:\n                lo = mid + 1\n            else:\n                hi = mid\n        new_sol = sol[:]\n        new_sol.insert(lo, item)\n        return new_sol\n\n    cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= 24))\n\n    if not cur:\n        # seed with a feasible greedy insert\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], -i), reverse=True)\n        new_sol = []\n        cur_w = 0\n        for it in items:\n            if cur_w + w[it - 1] <= cap:\n                new_sol = insert_sorted(new_sol, it)\n                cur_w += w[it - 1]\n        return new_sol\n\n    # Determine intensity (remove t items)\n    t = max(2, min(5, len(cur) \/\/ 3))\n    to_remove = random.sample(cur, k=min(t, len(cur)))\n    base = [i for i in cur if i not in set(to_remove)]\n    base_w = weight_of(base)\n\n    # Reinsert: mix greedy-best and random among feasible\n    absent = [i for i in range(1, 25) if i not in set(base)]\n    # Shuffle with bias by ratio\n    absent.sort(key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], -i), reverse=True)\n    new_sol = base[:]\n    cur_w = base_w\n    for it in absent:\n        if cur_w + w[it - 1] <= cap and random.random() < 0.85:\n            new_sol = insert_sorted(new_sol, it)\n            cur_w += w[it - 1]\n        elif cur_w + w[it - 1] <= cap and random.random() < 0.25:\n            new_sol = insert_sorted(new_sol, it)\n            cur_w += w[it - 1]\n\n    # Final repair (if any drift)\n    while weight_of(new_sol) > cap and new_sol:\n        worst = min(new_sol, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1], i))\n        new_sol.remove(worst)\n\n    return new_sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST.1BASED.UNIQUE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to MINIMIZE: feasible => negative total value (higher value => more negative => better);\n    # infeasible => large positive penalty.\n    # Problem data (1-based indexing with leading None for alignment)\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        overflow = total_cost - B\n        return 10**6 * overflow  # Dominates any feasible score while providing gradient\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Neighborhood with add\/remove\/swap (1-1, 1-2, 2-1) and feasibility repair.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Sanitize input: valid, unique, within domain\n    sol = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n    sol = list(dict.fromkeys(sol))\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    current_cost = total_cost(sol)\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    move_type = \"noop\"\n    r = random.random()\n\n    # Add\n    if r < 0.33 and not_in:\n        feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n        if feasible_adds:\n            # Biased selection: sample among top-k by value-to-cost ratio\n            feasible_adds.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n            k = min(5, len(feasible_adds))\n            i = random.choice(feasible_adds[:k])\n            sol.append(i)\n            move_type = \"add\"\n        else:\n            # fallback: remove worst ratio to make room, then add best feasible\n            if sol:\n                sol.sort(key=lambda j: (values[j] \/ costs[j], values[j]))  # worst first\n                removed = sol.pop(0)\n                current_cost = total_cost(sol)\n                not_in = [i for i in range(1, n + 1) if i not in set(sol)]\n                feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n                if feasible_adds:\n                    feasible_adds.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                    i = random.choice(feasible_adds[: min(5, len(feasible_adds))])\n                    sol.append(i)\n                    move_type = f\"remove({removed})->add\"\n                else:\n                    move_type = \"remove_only\"\n\n    # Swap 1-1 or 1-2 or 2-1\n    elif r < 0.75 and sol:\n        choice = random.random()\n        in_set = set(sol)\n        not_in = [i for i in range(1, n + 1) if i not in in_set]\n        if not_in:\n            if choice < 0.5:\n                # 1-1 swap\n                j = random.choice(sol)\n                cand = [i for i in not_in if current_cost - costs[j] + costs[i] <= B]\n                if cand:\n                    # prefer higher ratio\n                    cand.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                    i = random.choice(cand[: min(5, len(cand))])\n                    sol.remove(j)\n                    sol.append(i)\n                    move_type = \"swap1-1\"\n                else:\n                    # fallback remove worst\n                    sol.sort(key=lambda x: (values[x] \/ costs[x], values[x]))\n                    rem = sol.pop(0)\n                    move_type = f\"remove({rem})_fallback\"\n            elif choice < 0.75 and len(sol) >= 1:\n                # 1-2 swap: remove one, add up to two\n                j = random.choice(sol)\n                remaining_cost = current_cost - costs[j]\n                cand = [i for i in not_in]\n                # Greedy add up to two best by ratio within capacity\n                cand.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                new_items = []\n                cost_acc = remaining_cost\n                for i in cand:\n                    if len(new_items) == 2:\n                        break\n                    if cost_acc + costs[i] <= B:\n                        new_items.append(i)\n                        cost_acc += costs[i]\n                if new_items:\n                    sol.remove(j)\n                    for i in new_items:\n                        sol.append(i)\n                    move_type = \"swap1-2\"\n                else:\n                    move_type = \"noop\"\n            else:\n                # 2-1 swap: remove two, add one\n                if len(sol) >= 2:\n                    js = random.sample(sol, 2)\n                    rem_cost = current_cost - costs[js[0]] - costs[js[1]]\n                    cand = [i for i in not_in if rem_cost + costs[i] <= B]\n                    if cand:\n                        cand.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                        i = random.choice(cand[: min(5, len(cand))])\n                        sol.remove(js[0]); sol.remove(js[1])\n                        sol.append(i)\n                        move_type = \"swap2-1\"\n                    else:\n                        move_type = \"noop\"\n        else:\n            # no candidate to swap in -> remove\n            sol.sort(key=lambda x: (values[x] \/ costs[x], values[x]))\n            if sol:\n                rem = sol.pop(0)\n                move_type = f\"remove({rem})_noAdds\"\n\n    # Remove\n    else:\n        if sol:\n            # remove worst ratio item\n            sol.sort(key=lambda j: (values[j] \/ costs[j], values[j]))\n            rem = sol.pop(0)\n            move_type = f\"remove({rem})\"\n        else:\n            # add best single by ratio that fits from empty\n            best = None\n            best_r = -1.0\n            for i in range(1, n + 1):\n                if costs[i] <= B:\n                    rati = values[i] \/ costs[i]\n                    if rati > best_r:\n                        best_r = rati\n                        best = i\n            if best is not None:\n                sol = [best]\n                move_type = \"add_from_empty\"\n            else:\n                move_type = \"noop\"\n\n    # Repair if infeasible (should be rare)\n    def repair(lst):\n        while total_cost(lst) > B and lst:\n            # remove worst ratio first\n            lst.sort(key=lambda j: (values[j] \/ costs[j], values[j]))\n            lst.pop(0)\n        # deduplicate and keep within domain\n        return list(dict.fromkeys([x for x in lst if 1 <= x <= n]))\n\n    sol = repair(sol)\n\n    return sol, move_type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: k toggles, greedy repair (remove worst ratio), then greedy refill (best ratio)\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    sol = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n    sol = list(dict.fromkeys(sol))\n\n    k = 4 + random.randint(0, 3)\n    for _ in range(k):\n        i = random.randint(1, n)\n        if i in sol:\n            sol.remove(i)\n        else:\n            sol.append(i)\n\n    def total_cost(lst):\n        return sum(costs[j] for j in lst)\n\n    # Greedy repair: remove worst value-to-cost ratio until feasible\n    while total_cost(sol) > B and sol:\n        sol.sort(key=lambda j: (values[j] \/ costs[j], values[j]))\n        sol.pop(0)\n\n    # Greedy refill: try to add high-ratio items while capacity allows\n    in_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in in_set]\n    candidates.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n    cur_cost = total_cost(sol)\n    for i in candidates:\n        if cur_cost + costs[i] <= B:\n            sol.append(i)\n            cur_cost += costs[i]\n\n    sol = list(dict.fromkeys([x for x in sol if 1 <= x <= n]))\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST.1BASED.UNIQUE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Minimization fitness: feasible -> negative total value (more negative is better),\n    # infeasible -> positive penalty proportional to overflow.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Type and domain checks without mutating the input solution.\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        overflow = total_cost - B\n        return 10_000 * overflow  # softer than 1e6, still strongly penalizes infeasibility\n\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_type). Does not sanitize or mutate invalid inputs; if invalid, echoes input.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Validate minimally; if invalid, return as-is with a marker\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1 or x > n) for x in solution) or len(set(solution)) != len(solution):\n        return solution, \"invalid_input\"\n\n    # Work on a copy\n    sol = solution[:]\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    current_cost = total_cost(sol)\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    move_type = \"noop\"\n\n    # With small probability, do an unbiased random move to increase diversity\n    if random.random() < 0.10:\n        if random.random() < 0.5 and sol:\n            # random remove\n            j = random.choice(sol)\n            sol.remove(j)\n            move_type = \"rand_remove\"\n        else:\n            # random add if feasible\n            if not_in:\n                random.shuffle(not_in)\n                for i in not_in:\n                    if current_cost + costs[i] <= B:\n                        sol.append(i)\n                        move_type = \"rand_add\"\n                        break\n        return sol, move_type\n\n    r = random.random()\n\n    # Add move\n    if r < 0.33 and not_in:\n        feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n        if feasible_adds:\n            feasible_adds.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n            k = min(5, len(feasible_adds))\n            i = random.choice(feasible_adds[:k])\n            sol.append(i)\n            move_type = \"add\"\n            return sol, move_type\n        # Try to make room: remove a low-ratio then add best feasible\n        if sol:\n            sol.sort(key=lambda j: (ratio(j), values[j]))\n            removed = sol.pop(0)\n            current_cost = total_cost(sol)\n            in_set = set(sol)\n            not_in = [i for i in range(1, n + 1) if i not in in_set]\n            feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n            if feasible_adds:\n                feasible_adds.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                i = random.choice(feasible_adds[: min(5, len(feasible_adds))])\n                sol.append(i)\n                move_type = f\"remove({removed})->add\"\n            else:\n                move_type = \"remove_only\"\n        return sol, move_type\n\n    # Swap move (1-1, 1-2, 2-1)\n    if r < 0.75 and sol:\n        choice = random.random()\n        current_cost = total_cost(sol)\n        in_set = set(sol)\n        not_in = [i for i in range(1, n + 1) if i not in in_set]\n        if not_in:\n            if choice < 0.5:\n                # 1-1 swap\n                j = random.choice(sol)\n                cand = [i for i in not_in if current_cost - costs[j] + costs[i] <= B]\n                if cand:\n                    cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                    i = random.choice(cand[: min(5, len(cand))])\n                    sol.remove(j)\n                    sol.append(i)\n                    move_type = \"swap1-1\"\n                else:\n                    move_type = \"noop\"\n                return sol, move_type\n            elif choice < 0.75 and len(sol) >= 1:\n                # 1-2 swap: remove one, add up to two greedily\n                j = random.choice(sol)\n                rem_cost = current_cost - costs[j]\n                cand = not_in[:]\n                cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                new_items = []\n                acc = rem_cost\n                for i in cand:\n                    if len(new_items) == 2:\n                        break\n                    if acc + costs[i] <= B:\n                        new_items.append(i)\n                        acc += costs[i]\n                if new_items:\n                    sol.remove(j)\n                    sol.extend(new_items)\n                    move_type = \"swap1-2\"\n                else:\n                    move_type = \"noop\"\n                return sol, move_type\n            else:\n                # 2-1 swap\n                if len(sol) >= 2:\n                    j1, j2 = random.sample(sol, 2)\n                    rem_cost = current_cost - costs[j1] - costs[j2]\n                    cand = [i for i in not_in if rem_cost + costs[i] <= B]\n                    if cand:\n                        cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                        i = random.choice(cand[: min(5, len(cand))])\n                        sol.remove(j1)\n                        sol.remove(j2)\n                        sol.append(i)\n                        move_type = \"swap2-1\"\n                    else:\n                        move_type = \"noop\"\n                    return sol, move_type\n        # No candidate to swap in: remove worst\n        sol.sort(key=lambda x: (ratio(x), values[x]))\n        if sol:\n            rem = sol.pop(0)\n            move_type = f\"remove({rem})_noAdds\"\n        else:\n            move_type = \"noop\"\n        return sol, move_type\n\n    # Remove move\n    if sol:\n        sol.sort(key=lambda j: (ratio(j), values[j]))\n        rem = sol.pop(0)\n        move_type = f\"remove({rem})\"\n    else:\n        # From empty: add best feasible by ratio\n        best = None\n        best_r = -1.0\n        for i in range(1, n + 1):\n            if costs[i] <= B:\n                rati = values[i] \/ costs[i]\n                if rati > best_r:\n                    best_r = rati\n                    best = i\n        if best is not None:\n            sol = [best]\n            move_type = \"add_from_empty\"\n        else:\n            move_type = \"noop\"\n\n    return sol, move_type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # k-shake: remove k lowest-ratio items, then greedy refill by ratio. Keeps uniqueness and feasibility.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Validate minimally; if invalid, return as-is\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1 or x > n) for x in solution):\n        return solution\n    sol = list(dict.fromkeys(solution))\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    # Choose k in {2,3,4}\n    k = 2 + random.randint(0, 2)\n\n    # Remove up to k lowest-ratio items\n    if sol:\n        ranked = sorted(sol, key=lambda i: (ratio(i), values[i]))\n        to_remove = ranked[: min(k, len(ranked))]\n        sol = [i for i in sol if i not in set(to_remove)]\n\n    # Greedy repair if any infeasibility (should not happen here but safe)\n    while total_cost(sol) > B and sol:\n        sol.sort(key=lambda j: (ratio(j), values[j]))\n        sol.pop(0)\n\n    # Greedy refill by ratio\n    in_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in in_set]\n    candidates.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n    cur_cost = total_cost(sol)\n    for i in candidates:\n        c = costs[i]\n        if cur_cost + c <= B:\n            sol.append(i)\n            cur_cost += c\n\n    # Ensure uniqueness and domain\n    sol = list(dict.fromkeys([x for x in sol if 1 <= x <= n]))\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST.1BASED.UNIQUE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Minimization fitness: feasible -> negative total value (more negative is better),\n    # infeasible -> positive penalty proportional to overflow.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Type and domain checks without mutating the input solution.\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        overflow = total_cost - B\n        return 10_000 * overflow\n\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator that maintains feasibility and uniqueness; returns (neighbor_solution, move_type)\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    def repair_to_feasible(lst):\n        # Enforce domain, uniqueness, and capacity with greedy-by-ratio keeping as many of current picks as possible by priority\n        base = [x for x in lst if isinstance(x, int) and 1 <= x <= n]\n        # Deduplicate preserving order\n        seen = set()\n        base = [x for x in base if (x not in seen and not seen.add(x))]\n        # Start from the items in base, but reselect them by descending ratio to fit capacity\n        ranked = sorted(base, key=lambda i: (ratio(i), values[i]), reverse=True)\n        cur = []\n        cur_cost = 0\n        for i in ranked:\n            c = costs[i]\n            if cur_cost + c <= B:\n                cur.append(i)\n                cur_cost += c\n        return cur, cur_cost\n\n    # Validate and repair\n    if not isinstance(solution, list):\n        sol, cur_cost = [], 0\n    else:\n        sol, cur_cost = repair_to_feasible(solution)\n\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    # With small probability, perform a random kick move under feasibility\n    if random.random() < 0.08:\n        move_type = \"rand_kick\"\n        k = 1 + (0 if not sol else random.randint(0, min(2, len(sol)-1)))\n        # remove up to k lowest ratio\n        if sol:\n            worst = sorted(sol, key=lambda i: (ratio(i), values[i]))[:k]\n            for j in worst:\n                sol.remove(j)\n                cur_cost -= costs[j]\n        in_set = set(sol)\n        not_in = [i for i in range(1, n + 1) if i not in in_set]\n        random.shuffle(not_in)\n        for i in not_in:\n            if cur_cost + costs[i] <= B:\n                sol.append(i)\n                cur_cost += costs[i]\n        return sol, move_type\n\n    r = random.random()\n\n    # Try add best feasible\n    if r < 0.33:\n        feasible_adds = [i for i in not_in if cur_cost + costs[i] <= B]\n        if feasible_adds:\n            # pick among top-k by ratio, break ties with value\n            feasible_adds.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n            i = random.choice(feasible_adds[: min(5, len(feasible_adds))])\n            sol.append(i)\n            cur_cost += costs[i]\n            return sol, \"add\"\n        # Make room: remove one worst then add best feasible\n        if sol:\n            sol.sort(key=lambda j: (ratio(j), values[j]))\n            removed = sol.pop(0)\n            cur_cost -= costs[removed]\n            feasible_adds = [i for i in range(1, n + 1) if i not in set(sol) and cur_cost + costs[i] <= B]\n            if feasible_adds:\n                feasible_adds.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                i = feasible_adds[0]\n                sol.append(i)\n                cur_cost += costs[i]\n                return sol, f\"remove({removed})->add\"\n            return sol, f\"remove_only({removed})\"\n        return sol, \"noop\"\n\n    # Swap-based moves\n    if r < 0.78 and sol:\n        in_set = set(sol)\n        not_in = [i for i in range(1, n + 1) if i not in in_set]\n        choice = random.random()\n        if choice < 0.5 and not_in:\n            # 1-1 swap\n            j = random.choice(sol)\n            cand = [i for i in not_in if cur_cost - costs[j] + costs[i] <= B]\n            if cand:\n                cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                i = random.choice(cand[: min(5, len(cand))])\n                sol.remove(j)\n                cur_cost -= costs[j]\n                sol.append(i)\n                cur_cost += costs[i]\n                return sol, \"swap1-1\"\n            return sol, \"noop\"\n        elif choice < 0.75 and not_in:\n            # 1-2 swap\n            if len(sol) >= 1:\n                j = random.choice(sol)\n                rem_cost = cur_cost - costs[j]\n                cand = sorted(not_in, key=lambda i: (ratio(i), values[i]), reverse=True)\n                add_list = []\n                acc = rem_cost\n                for i in cand:\n                    if len(add_list) == 2:\n                        break\n                    if acc + costs[i] <= B:\n                        add_list.append(i)\n                        acc += costs[i]\n                if add_list:\n                    sol.remove(j)\n                    cur_cost = rem_cost\n                    for i in add_list:\n                        sol.append(i)\n                        cur_cost += costs[i]\n                    return sol, \"swap1-2\"\n                return sol, \"noop\"\n            return sol, \"noop\"\n        else:\n            # 2-1 swap\n            if len(sol) >= 2 and not_in:\n                j1, j2 = random.sample(sol, 2)\n                rem_cost = cur_cost - costs[j1] - costs[j2]\n                cand = [i for i in not_in if rem_cost + costs[i] <= B]\n                if cand:\n                    cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                    i = random.choice(cand[: min(5, len(cand))])\n                    sol.remove(j1)\n                    sol.remove(j2)\n                    cur_cost = rem_cost\n                    sol.append(i)\n                    cur_cost += costs[i]\n                    return sol, \"swap2-1\"\n                return sol, \"noop\"\n            return sol, \"noop\"\n\n    # Remove worst item\n    if sol:\n        sol.sort(key=lambda j: (ratio(j), values[j]))\n        rem = sol.pop(0)\n        return sol, f\"remove({rem})\"\n\n    # From empty: add best by ratio\n    best = None\n    best_r = -1.0\n    for i in range(1, n + 1):\n        if costs[i] <= B:\n            rati = values[i] \/ costs[i]\n            if rati > best_r:\n                best_r = rati\n                best = i\n    if best is not None:\n        return [best], \"add_from_empty\"\n    return [], \"noop\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Structured perturbation: remove t worst by Lagrangian score, then greedy refill by ratio\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        # domain + uniqueness\n        base = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n        seen = set()\n        sol = [x for x in base if (x not in seen and not seen.add(x))]\n\n    # ensure feasibility via greedy by ratio on current set\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    # Trim if over capacity\n    while total_cost(sol) > B and sol:\n        sol.sort(key=lambda j: (ratio(j), values[j]))\n        sol.pop(0)\n\n    # Lagrangian score with random lambda to diversify\n    lam = random.uniform(0.02, 0.08)\n    def lag_score(i):\n        return values[i] - lam * costs[i]\n\n    # choose t in {2,3,4}\n    t = 2 + random.randint(0, 2)\n    if sol:\n        worst = sorted(sol, key=lambda i: (lag_score(i), values[i]))[: min(t, len(sol))]\n        rem_set = set(worst)\n        sol = [i for i in sol if i not in rem_set]\n\n    # Greedy refill by ratio\n    cur_cost = total_cost(sol)\n    in_set = set(sol)\n    cand = [i for i in range(1, n + 1) if i not in in_set]\n    cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n    for i in cand:\n        c = costs[i]\n        if cur_cost + c <= B:\n            sol.append(i)\n            cur_cost += c\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns scalar cost to MINIMIZE (lower is better).\n    # Feasible: cost = -revenue + tiny_lexicographic_tie_breaker\n    # Infeasible\/invalid: large positive penalty (scaled modestly to avoid numeric issues).\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    if not isinstance(solution, list):\n        return 1e9\n\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e9\n        if idx < 1 or idx > n:\n            return 1e9\n        if idx in seen:\n            return 1e9\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-breaker encoded as tiny additive term (smaller is better)\n        base = n + 1\n        seq = sorted(solution)\n        code = 0\n        for x in seq:\n            code = code * base + x\n        denom = (base ** len(seq)) if len(seq) > 0 else 1\n        code_scaled = code \/ denom\n        epsilon = 1e-6\n        return -float(revenue) + epsilon * code_scaled\n\n    # Infeasible: modest penalty proportional to overflow\n    overflow = weight - capacity\n    return 1e7 + float(overflow)","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Capacity-aware neighbor for INDEX_LIST. Modifies solution in-place and returns markers.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        s = sorted({idx for idx in sol if isinstance(idx, int) and 1 <= idx <= n})\n        return s\n\n    def total_w_r(idx_set):\n        w = 0\n        r = 0\n        for idx in idx_set:\n            i0 = idx - 1\n            w += gallons[i0]\n            r += prices[i0]\n        return w, r\n\n    def repair(idx_set):\n        # Drop least valuable density items until feasible\n        w, _ = total_w_r(idx_set)\n        if w <= capacity:\n            return idx_set\n        items = list(idx_set)\n        # sort by ascending value density then price, then reverse lex to prefer lexicographically smaller kept set\n        items.sort(key=lambda j: (prices[j-1]\/max(1, gallons[j-1]), prices[j-1]))\n        k = 0\n        while w > capacity and k < len(items):\n            j = items[k]\n            w -= gallons[j-1]\n            idx_set.discard(j)\n            k += 1\n        return idx_set\n\n    # sanitize input and work on its canonical sorted form\n    cur = set(sanitize(solution))\n\n    all_items = set(range(1, n + 1))\n    in_set = cur\n    out_set = all_items - in_set\n\n    moves = []\n    if out_set:\n        moves.append(\"add\")\n    if in_set:\n        moves.append(\"drop\")\n    if in_set and out_set:\n        moves.append(\"swap\")\n        moves.append(\"two_for_one\")\n        moves.append(\"one_for_two\")\n\n    if not moves:\n        # Reset to a random singleton\n        pick = random.randint(1, n)\n        solution[:] = [pick]\n        return (\"INDEX_LIST\", \"reset\")\n\n    move = random.choice(moves)\n\n    if move == \"add\":\n        # Prefer feasible adds by best value density\n        best = None\n        best_score = -1.0\n        cur_w, _ = total_w_r(in_set)\n        for c in out_set:\n            w = gallons[c-1]\n            if cur_w + w <= capacity:\n                score = prices[c-1] \/ max(1, w)\n                if score > best_score:\n                    best_score = score\n                    best = c\n        if best is None:\n            # no feasible add; fallback to swap attempt\n            move = \"swap\"\n        else:\n            in_set.add(best)\n\n    if move == \"drop\":\n        # Drop lowest density item\n        if in_set:\n            drop_item = min(in_set, key=lambda j: (prices[j-1]\/max(1, gallons[j-1]), prices[j-1]))\n            in_set.discard(drop_item)\n\n    if move == \"swap\":\n        if in_set and out_set:\n            # try a random improving swap with quick trials\n            trials = 10\n            cur_w, cur_r = total_w_r(in_set)\n            done = False\n            for _ in range(trials):\n                a = random.choice(tuple(in_set))\n                b = random.choice(tuple(out_set))\n                new_w = cur_w - gallons[a-1] + gallons[b-1]\n                new_r = cur_r - prices[a-1] + prices[b-1]\n                if new_w <= capacity and new_r >= cur_r:\n                    in_set.discard(a)\n                    in_set.add(b)\n                    done = True\n                    break\n            if not done:\n                # fallback: execute a random swap and repair\n                a = random.choice(tuple(in_set))\n                b = random.choice(tuple(out_set))\n                in_set.discard(a)\n                in_set.add(b)\n\n    if move == \"two_for_one\":\n        if len(in_set) >= 2 and out_set:\n            a, b = random.sample(tuple(in_set), 2)\n            c = random.choice(tuple(out_set))\n            # choose the better of two random pairs if capacity allows; otherwise perform then repair\n            cand = set(in_set)\n            cand.discard(a)\n            cand.discard(b)\n            cand.add(c)\n            in_set = cand\n\n    if move == \"one_for_two\":\n        if in_set and len(out_set) >= 2:\n            a = random.choice(tuple(in_set))\n            b, c = random.sample(tuple(out_set), 2)\n            cand = set(in_set)\n            cand.discard(a)\n            cand.add(b)\n            cand.add(c)\n            in_set = cand\n\n    # Repair any infeasibility\n    in_set = repair(in_set)\n\n    # Canonical write-back\n    solution[:] = sorted(in_set)\n    return (\"INDEX_LIST\", move)","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a new perturbed INDEX_LIST solution with capacity-aware repair.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        return sorted({idx for idx in sol if isinstance(idx, int) and 1 <= idx <= n})\n\n    def total_w(idx_set):\n        return sum(gallons[i-1] for i in idx_set)\n\n    def repair(idx_set):\n        # Drop lowest density items until feasible\n        while total_w(idx_set) > capacity and idx_set:\n            drop = min(idx_set, key=lambda j: (prices[j-1]\/max(1, gallons[j-1]), prices[j-1]))\n            idx_set.discard(drop)\n        return idx_set\n\n    base = set(sanitize(solution))\n    if not base:\n        base.add(random.randint(1, n))\n\n    k = random.randint(3, 7)\n    S = set(base)\n    for _ in range(k):\n        all_items = set(range(1, n + 1))\n        out_set = list(all_items - S)\n        in_set = list(S)\n        moves = []\n        if out_set:\n            moves.append(\"add\")\n        if in_set:\n            moves.append(\"drop\")\n        if in_set and out_set:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = random.choice(moves)\n        if mv == \"add\":\n            S.add(random.choice(out_set))\n        elif mv == \"drop\":\n            S.discard(random.choice(in_set))\n        else:\n            a = random.choice(in_set)\n            b = random.choice(out_set)\n            if a != b:\n                S.discard(a)\n                S.add(b)\n        S = repair(S)\n\n    return sorted(S)","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns scalar cost to MINIMIZE (lower is better).\n    # Feasible: cost = -revenue + tiny_lexicographic_tie_breaker\n    # Infeasible\/invalid: large positive penalty (scaled modestly to avoid numeric issues).\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1e9\n\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e9\n        if idx < 1 or idx > n:\n            return 1e9\n        if idx in seen:\n            return 1e9\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-breaker encoded as tiny additive term (smaller is better)\n        base = n + 1\n        seq = sorted(solution)\n        code = 0\n        for x in seq:\n            code = code * base + x\n        denom = (base ** len(seq)) if len(seq) > 0 else 1\n        code_scaled = code \/ denom\n        epsilon = 1e-6\n        return -float(revenue) + epsilon * code_scaled\n\n    # Infeasible: modest penalty proportional to overflow\n    overflow = weight - capacity\n    return 1e7 + float(overflow)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improving 1-add\/1-drop\/1-swap neighbor for INDEX_LIST with exact cost deltas.\n    # Modifies solution in-place to maintain canonical sorted unique INDEX_LIST.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def eval_cost(idx_list):\n        # Local evaluator identical to EVAL_CODE logic\n        # Returns high penalty for invalid structures\n        if not isinstance(idx_list, list):\n            return 1e9\n        seen = set()\n        revenue = 0\n        weight = 0\n        for idx in idx_list:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return 1e9\n            seen.add(idx)\n            i0 = idx - 1\n            revenue += prices[i0]\n            weight += gallons[i0]\n        if weight <= capacity:\n            base = n + 1\n            seq = sorted(idx_list)\n            code = 0\n            for x in seq:\n                code = code * base + x\n            denom = (base ** len(seq)) if len(seq) > 0 else 1\n            code_scaled = code \/ denom\n            epsilon = 1e-6\n            return -float(revenue) + epsilon * code_scaled\n        return 1e7 + float(weight - capacity)\n\n    # Sanitize and canonicalize input\n    if not isinstance(solution, list):\n        solution[:] = []\n        return (\"INDEX_LIST\", \"none\")\n    cur_set = {idx for idx in solution if isinstance(idx, int) and 1 <= idx <= n}\n    cur_list = sorted(cur_set)\n    solution[:] = cur_list\n\n    # Compute current stats\n    cur_cost = eval_cost(solution)\n    # If infeasible or invalid, exit early; neighbor should not propagate invalid state\n    if cur_cost >= 1e7:\n        # Make feasible by greedy drop of lowest price until within capacity\n        w = sum(gallons[i-1] for i in solution)\n        s = set(solution)\n        while w > capacity and s:\n            # drop with smallest price; tie by larger index drop last to preserve lex-min\n            drop = min(s, key=lambda j: (prices[j-1], j))\n            s.discard(drop)\n            w -= gallons[drop-1]\n        new_list = sorted(s)\n        solution[:] = new_list\n        return (\"INDEX_LIST\", \"repair\")\n\n    in_set = set(solution)\n    out_set = set(range(1, n + 1)) - in_set\n    cur_weight = sum(gallons[i-1] for i in solution)\n\n    best_move = (\"none\", None, None)  # (type, a, b)\n    best_cost = cur_cost\n\n    # 1) Try all feasible adds\n    for b in out_set:\n        w_new = cur_weight + gallons[b-1]\n        if w_new <= capacity:\n            new_list = sorted(in_set | {b})\n            c = eval_cost(new_list)\n            if c < best_cost - 1e-12:\n                best_cost = c\n                best_move = (\"add\", None, b)\n\n    # 2) Try all drops\n    for a in in_set:\n        new_list = sorted(in_set - {a})\n        c = eval_cost(new_list)\n        if c < best_cost - 1e-12:\n            best_cost = c\n            best_move = (\"drop\", a, None)\n\n    # 3) Try all feasible swaps\n    for a in in_set:\n        wa = gallons[a-1]\n        for b in out_set:\n            w_new = cur_weight - wa + gallons[b-1]\n            if w_new <= capacity:\n                new_set = set(in_set)\n                new_set.discard(a)\n                new_set.add(b)\n                new_list = sorted(new_set)\n                c = eval_cost(new_list)\n                if c < best_cost - 1e-12:\n                    best_cost = c\n                    best_move = (\"swap\", a, b)\n\n    # Apply best move if any\n    move_type, a, b = best_move\n    if move_type == \"add\":\n        in_set.add(b)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"add\")\n    elif move_type == \"drop\":\n        in_set.discard(a)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"drop\")\n    elif move_type == \"swap\":\n        in_set.discard(a)\n        in_set.add(b)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"swap\")\n\n    # No improving move\n    return (\"INDEX_LIST\", \"none\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Controlled diversification: remove r lowest-price items, then greedy refill by highest price with lex tie-break.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Sanitize to canonical sorted unique list\n    if not isinstance(solution, list):\n        base = []\n    else:\n        base = sorted({idx for idx in solution if isinstance(idx, int) and 1 <= idx <= n})\n\n    rng = random.Random()\n    if not base:\n        base = [rng.randint(1, n)]\n\n    S = set(base)\n\n    # Remove r items with lowest price (tie by largest index first to preserve lex-min on keeps)\n    r = rng.randint(1, 3)\n    if len(S) > 0:\n        drops = sorted(list(S), key=lambda j: (prices[j-1], -j))[:min(r, len(S))]\n        for d in drops:\n            S.discard(d)\n\n    # Greedy refill by highest price, tie by smaller index, respecting capacity\n    def total_w(idx_set):\n        return sum(gallons[i-1] for i in idx_set)\n\n    cur_w = total_w(S)\n    candidates = sorted([j for j in range(1, n + 1) if j not in S], key=lambda j: (-prices[j-1], j))\n    for j in candidates:\n        wj = gallons[j-1]\n        if cur_w + wj <= capacity:\n            S.add(j)\n            cur_w += wj\n\n    return sorted(S)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost to minimize (lower is better). Feasible cost = -revenue + tiny_lexicographic_tie_breaker.\n    # Infeasible\/invalid => large positive penalty.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n    EPS = 1e-9\n\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1e9\n\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e9\n        if idx < 1 or idx > n:\n            return 1e9\n        if idx in seen:\n            return 1e9\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-breaker encoded as tiny additive term\n        base = n + 1\n        seq = sorted(solution)\n        code = 0\n        for x in seq:\n            code = code * base + x\n        denom = (base ** len(seq)) if len(seq) > 0 else 1\n        code_scaled = code \/ denom\n        return -float(revenue) + EPS * code_scaled\n\n    # Infeasible: modest penalty proportional to overflow\n    overflow = weight - capacity\n    return 1e7 + float(overflow)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improving 1-add\/1-drop\/1-swap neighbor for INDEX_LIST.\n    # Mutates solution in-place, maintaining canonical sorted unique INDEX_LIST.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    EPS = 1e-12\n\n    def eval_cost(idx_list):\n        # Local evaluator consistent with EVAL_CODE\n        if not isinstance(idx_list, list):\n            return 1e9\n        seen = set()\n        revenue = 0\n        weight = 0\n        for idx in idx_list:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return 1e9\n            seen.add(idx)\n            i0 = idx - 1\n            revenue += prices[i0]\n            weight += gallons[i0]\n        if weight <= capacity:\n            base = n + 1\n            seq = sorted(idx_list)\n            code = 0\n            for x in seq:\n                code = code * base + x\n            denom = (base ** len(seq)) if len(seq) > 0 else 1\n            code_scaled = code \/ denom\n            return -float(revenue) + 1e-9 * code_scaled\n        return 1e7 + float(weight - capacity)\n\n    # Canonicalize input to sorted unique valid indices\n    if not isinstance(solution, list):\n        solution[:] = []  # if it's not a list, this will raise; guard by resetting below\n        # Fallback to empty list\n        solution = []\n    cur_set = {idx for idx in solution if isinstance(idx, int) and 1 <= idx <= n}\n    cur_list = sorted(cur_set)\n    solution[:] = cur_list\n\n    # Compute current stats\n    cur_weight = sum(gallons[i-1] for i in solution)\n\n    # If infeasible or invalid, repair by dropping least damaging items until feasible\n    if cur_weight > capacity:\n        S = set(solution)\n        # Drop items with smallest value density p\/w; tie by larger index to preserve lexicographic minimality\n        while S and sum(gallons[i-1] for i in S) > capacity:\n            drop = min(S, key=lambda j: (prices[j-1] \/ gallons[j-1], -j))\n            S.discard(drop)\n        solution[:] = sorted(S)\n        return (\"INDEX_LIST\", \"repair\")\n\n    cur_cost = eval_cost(solution)\n\n    in_set = set(solution)\n    out_set = set(range(1, n + 1)) - in_set\n\n    best_move = (\"none\", None, None)  # (type, a, b)\n    best_cost = cur_cost\n\n    # Helper to evaluate a candidate without side effects\n    def cost_of(new_set):\n        return eval_cost(sorted(new_set))\n\n    # 1) Try feasible adds\n    for b in out_set:\n        if cur_weight + gallons[b-1] <= capacity:\n            new_set = in_set | {b}\n            c = cost_of(new_set)\n            if c < best_cost - EPS:\n                best_cost = c\n                best_move = (\"add\", None, b)\n\n    # 2) Try drops\n    for a in in_set:\n        new_set = set(in_set)\n        new_set.discard(a)\n        c = cost_of(new_set)\n        if c < best_cost - EPS:\n            best_cost = c\n            best_move = (\"drop\", a, None)\n\n    # 3) Try feasible swaps\n    for a in in_set:\n        wa = gallons[a-1]\n        for b in out_set:\n            wb = gallons[b-1]\n            if cur_weight - wa + wb <= capacity:\n                new_set = set(in_set)\n                new_set.discard(a)\n                new_set.add(b)\n                c = cost_of(new_set)\n                if c < best_cost - EPS:\n                    best_cost = c\n                    best_move = (\"swap\", a, b)\n\n    # Apply best move if any\n    move_type, a, b = best_move\n    if move_type == \"add\":\n        in_set.add(b)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"add\")\n    elif move_type == \"drop\":\n        in_set.discard(a)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"drop\")\n    elif move_type == \"swap\":\n        in_set.discard(a)\n        in_set.add(b)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"swap\")\n\n    # No improving move\n    return (\"INDEX_LIST\", \"none\")\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Diversification: drop r items with lowest value density, then greedy refill by highest value density.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    rng = random.Random()\n\n    # Canonicalize base\n    if not isinstance(solution, list):\n        base = []\n    else:\n        base = sorted({idx for idx in solution if isinstance(idx, int) and 1 <= idx <= n})\n\n    S = set(base)\n    if not S:\n        # Seed with a random single item\n        S.add(rng.randint(1, n))\n\n    # 1) Randomly select r in [1,3] and drop r items with lowest value density (p\/w), tie by larger index\n    r = rng.randint(1, 3)\n    if S:\n        drops = sorted(list(S), key=lambda j: (prices[j-1] \/ gallons[j-1], -j))[:min(r, len(S))]\n        for d in drops:\n            S.discard(d)\n\n    # 2) Greedy refill by highest value density within capacity, ties by higher price then smaller index\n    def total_w(idx_set):\n        return sum(gallons[i-1] for i in idx_set)\n\n    cur_w = total_w(S)\n    candidates = [j for j in range(1, n + 1) if j not in S]\n    candidates.sort(key=lambda j: (-prices[j-1] \/ gallons[j-1], -prices[j-1], j))\n\n    for j in candidates:\n        wj = gallons[j-1]\n        if cur_w + wj <= capacity:\n            S.add(j)\n            cur_w += wj\n\n    return sorted(S)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # SOL_TYPE: INDEX_LIST (1-based indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate input type and entries\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Scaled penalty for infeasible solutions; SA expects lower is better\n    if total_time > capacity:\n        over = total_time - capacity\n        # Penalty scale based on avg value density\n        avg_density = sum(values) \/ sum(times)\n        alpha = 10000 * max(avg_density, 1e-6)\n        return alpha * over\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _validate_index_list_1based(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, \"INDEX_LIST\", move)\n    s = _validate_index_list_1based(solution)\n    n = 24\n    in_set = set(s)\n    universe = list(range(1, n + 1))\n    not_in = [i for i in universe if i not in in_set]\n    # Choose move type with simple balancing\n    if len(s) == 0:\n        move = \"add\"\n    elif len(s) == n:\n        move = random.choice([\"remove\", \"swap\"])\n    else:\n        move = random.choice([\"add\", \"remove\", \"swap\", \"two_swap\"])  # include 2-exchange\n    new_s = s[:]\n    if move == \"add\":\n        if not_in:\n            new_item = random.choice(not_in)\n            if new_item not in in_set:\n                new_s.append(new_item)\n    elif move == \"remove\":\n        if new_s:\n            idx = random.randrange(len(new_s))\n            del new_s[idx]\n    elif move == \"swap\":\n        if new_s and not_in:\n            pos = random.randrange(len(new_s))\n            new_item = random.choice(not_in)\n            new_s[pos] = new_item\n    else:  # two_swap\n        if new_s and len(new_s) >= 1 and len(not_in) >= 1:\n            k = min(2, len(new_s))\n            # remove up to 2\n            for _ in range(k):\n                if not new_s:\n                    break\n                del new_s[random.randrange(len(new_s))]\n            # add up to 2\n            for _ in range(k):\n                cand_pool = [i for i in universe if i not in new_s]\n                if not cand_pool:\n                    break\n                new_s.append(random.choice(cand_pool))\n    # finalize uniqueness without sorting to preserve some order semantics\n    seen = set()\n    compact = []\n    for x in new_s:\n        if x not in seen:\n            if 1 <= x <= n:\n                seen.add(x)\n                compact.append(x)\n    return (compact, \"INDEX_LIST\", move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _sanitize_index_list(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef perturb_solution(solution):\n    s = _sanitize_index_list(solution)\n    n = 24\n    universe = list(range(1, n + 1))\n    # number of random edits\n    k = random.randint(4, 8)\n    for _ in range(k):\n        in_set = set(s)\n        not_in = [i for i in universe if i not in in_set]\n        moves = []\n        if not_in:\n            moves.append(\"add\")\n        if s:\n            moves.append(\"remove\")\n        if s and not_in:\n            moves.append(\"swap\")\n        if len(s) >= 2 and len(not_in) >= 2:\n            moves.append(\"two_swap\")\n        if not moves:\n            break\n        m = random.choice(moves)\n        if m == \"add\" and not_in:\n            s.append(random.choice(not_in))\n        elif m == \"remove\" and s:\n            del s[random.randrange(len(s))]\n        elif m == \"swap\" and s and not_in:\n            pos = random.randrange(len(s))\n            s[pos] = random.choice(not_in)\n        elif m == \"two_swap\" and len(s) >= 2 and len(not_in) >= 2:\n            # remove two distinct positions\n            for _ in range(2):\n                if not s:\n                    break\n                del s[random.randrange(len(s))]\n            # add up to two new ones\n            for _ in range(2):\n                cand = [i for i in universe if i not in s]\n                if not cand:\n                    break\n                s.append(random.choice(cand))\n        # deduplicate while keeping order\n        seen = set()\n        tmp = []\n        for x in s:\n            if x not in seen and 1 <= x <= n:\n                seen.add(x)\n                tmp.append(x)\n        s = tmp\n    return s\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # SOL_TYPE: INDEX_LIST (1-based indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate and normalize input\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Lower-is-better cost. Feasible => negative objective, Infeasible => positive penalty.\n    if total_time > capacity:\n        over = total_time - capacity\n        # Calibrated linear+quadratic penalty based on typical value scale\n        avg_v = sum(values) \/ len(values)\n        lam = max(1.0, 0.5 * avg_v)  # ~8-12 here\n        return lam * over + 0.01 * (over ** 2)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _validate_index_list_1based(solution) -> List[int]:\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in s):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef _total_time(indices: List[int]) -> int:\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    return sum(times[i-1] for i in indices)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"INDEX_LIST\", move)\n    s = _validate_index_list_1based(solution)\n    n = 24\n    universe = list(range(1, n + 1))\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Precompute feasibility slack\n    cur_time = _total_time(s)\n    slack = capacity - cur_time\n    in_set = set(s)\n    not_in = [i for i in universe if i not in in_set]\n    # Adaptive move probabilities\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if s:\n        moves.append(\"remove\")\n    if s and not_in:\n        moves.append(\"swap\")\n        moves.append(\"one_one\")  # targeted 1-1 exchange\n    # Capacity-aware preference: if slack < 0 prefer remove\/one_one\n    def pick_move():\n        if not moves:\n            return None\n        if slack < 0:\n            prefs = [m for m in moves if m in (\"remove\", \"one_one\")]\n            if prefs:\n                return random.choice(prefs)\n        elif slack < 60:  # small slack: prefer one_one\n            prefs = [m for m in moves if m in (\"one_one\", \"remove\")]\n            if prefs:\n                return random.choice(prefs)\n        # otherwise free to add\/swap\n        return random.choice(moves)\n    # Try a few times to ensure a net change\n    for _ in range(12):\n        move = pick_move()\n        if move is None:\n            break\n        new_s = list(s)\n        if move == \"add\" and not_in:\n            # Prefer items that fit slack\n            fit = [i for i in not_in if times[i-1] <= max(0, slack)]\n            cand = fit if fit else not_in\n            new_item = random.choice(cand)\n            new_s.append(new_item)\n        elif move == \"remove\" and new_s:\n            del new_s[random.randrange(len(new_s))]\n        elif move == \"swap\" and new_s and not_in:\n            pos = random.randrange(len(new_s))\n            new_item = random.choice(not_in)\n            new_s[pos] = new_item\n        elif move == \"one_one\" and new_s and not_in:\n            # choose out and in guided by density improvement\n            values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n            times_l = times\n            best = None\n            for _trial in range(8):\n                if not new_s or not not_in:\n                    break\n                out_pos = random.randrange(len(new_s))\n                out = new_s[out_pos]\n                inn = random.choice(not_in)\n                dtime = times_l[inn-1] - times_l[out-1]\n                dval = values[inn-1] - values[out-1]\n                # favor non-worsening density and capacity respect\n                feasible = (cur_time + dtime) <= capacity\n                score = (2 * dval) - abs(dtime) - (0 if feasible else 50)\n                if best is None or score > best[0]:\n                    best = (score, out_pos, inn)\n            if best is not None:\n                _, out_pos, inn = best\n                new_s[out_pos] = inn\n        # Deduplicate preserving order and bounds\n        seen = set()\n        compact = []\n        for x in new_s:\n            if 1 <= x <= n and x not in seen:\n                seen.add(x)\n                compact.append(x)\n        if compact != s:\n            return (compact, \"INDEX_LIST\", move)\n    # Fallback: if no change generated, random single add\/remove\n    if not_in:\n        return (s + [random.choice(not_in)], \"INDEX_LIST\", \"add\")\n    elif s:\n        ns = list(s)\n        del ns[random.randrange(len(ns))]\n        return (ns, \"INDEX_LIST\", \"remove\")\n    else:\n        return ([], \"INDEX_LIST\", \"noop\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _sanitize_index_list(solution) -> List[int]:\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in s):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef perturb_solution(solution):\n    # Strong perturbation: k in [4,8] random edits with set-consistency\n    s = _sanitize_index_list(solution)\n    n = 24\n    universe = list(range(1, n + 1))\n    k = random.randint(4, 8)\n    for _ in range(k):\n        in_set = set(s)\n        not_in = [i for i in universe if i not in in_set]\n        moves = []\n        if not_in:\n            moves.append(\"add\")\n        if s:\n            moves.append(\"remove\")\n        if s and not_in:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        m = random.choice(moves)\n        if m == \"add\" and not_in:\n            s.append(random.choice(not_in))\n        elif m == \"remove\" and s:\n            del s[random.randrange(len(s))]\n        elif m == \"swap\" and s and not_in:\n            pos = random.randrange(len(s))\n            s[pos] = random.choice(not_in)\n        # Deduplicate and bound-check while keeping order\n        seen = set()\n        tmp = []\n        for x in s:\n            if 1 <= x <= n and x not in seen:\n                seen.add(x)\n                tmp.append(x)\n        s = tmp\n    return s\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # SOL_TYPE: INDEX_LIST (1-based indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Parse\/validate\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Lower-is-better cost. Feasible => negative objective, Infeasible => positive penalty.\n    if total_time > capacity:\n        over = total_time - capacity\n        lam = max(values) + 1  # strict dominance of feasibility\n        return float(lam * over)\n    return -float(total_value)\n","Vecindad":"import math\nimport random\n\n\ndef _validate_index_list(solution):\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in s):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\n\ndef _normalize_sorted_unique(lst):\n    seen = set()\n    out = []\n    for x in sorted(lst):\n        if 1 <= x <= 24 and x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"INDEX_LIST\", move)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    s = _validate_index_list(solution)\n    n = 24\n    universe = list(range(1, n + 1))\n    in_set = set(s)\n    not_in = [i for i in universe if i not in in_set]\n\n    cur_time = sum(times[i-1] for i in s)\n\n    # Candidate move types available\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if s:\n        moves.append(\"remove\")\n    if s and not_in:\n        moves.append(\"swap\")\n        moves.append(\"one_one\")\n        moves.append(\"one_two\")\n        moves.append(\"two_one\")\n\n    if not moves:\n        return ([], \"INDEX_LIST\", \"idle\")\n\n    # Capacity-aware move preference\n    slack = capacity - cur_time\n    def pick_move():\n        if slack < 0:\n            prefs = [m for m in moves if m in (\"remove\", \"one_one\", \"two_one\")]\n            if prefs:\n                return random.choice(prefs)\n        elif slack < 80:\n            prefs = [m for m in moves if m in (\"one_one\", \"remove\", \"two_one\")]\n            if prefs:\n                return random.choice(prefs)\n        return random.choice(moves)\n\n    for _ in range(16):\n        move = pick_move()\n        new_s = list(s)\n        if move == \"add\" and not_in:\n            # Greedy-biased add by highest value\/time that fits; else random\n            candidates = [i for i in not_in if times[i-1] <= max(0, slack)]\n            if candidates:\n                candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n                new_s.append(candidates[0])\n            else:\n                new_s.append(random.choice(not_in))\n        elif move == \"remove\" and new_s:\n            # Remove worst value\/time first with small randomness\n            worst = sorted(new_s, key=lambda i: (values[i-1]\/times[i-1], values[i-1]))[0]\n            if random.random() < 0.8:\n                new_s.remove(worst)\n            else:\n                del new_s[random.randrange(len(new_s))]\n        elif move == \"swap\" and new_s and not_in:\n            out = random.choice(new_s)\n            inn = random.choice(not_in)\n            # Prefer feasible improving swaps\n            dt = times[inn-1] - times[out-1]\n            dv = values[inn-1] - values[out-1]\n            if cur_time + dt <= capacity and dv < 0 and random.random() < 0.7:\n                # discourage worsening feasible swap; pick better inn by ratio\n                not_in_sorted = sorted(not_in, key=lambda i: (values[i-1]-values[out-1])\/(times[i-1]-times[out-1] if times[i-1]!=times[out-1] else 1e-9), reverse=True)\n                inn = not_in_sorted[0]\n            pos = new_s.index(out)\n            new_s[pos] = inn\n        elif move == \"one_one\" and new_s and not_in:\n            # Best-improving feasible 1-1 exchange by delta value under capacity\n            best = None\n            for out in new_s:\n                base_t = cur_time - times[out-1]\n                for inn in not_in:\n                    t = base_t + times[inn-1]\n                    if t <= capacity:\n                        dv = values[inn-1] - values[out-1]\n                        if best is None or dv > best[0] or (dv == best[0] and times[inn-1] < times[out-1]):\n                            best = (dv, out, inn)\n            if best is not None and best[0] > 0:\n                _, out, inn = best\n                pos = new_s.index(out)\n                new_s[pos] = inn\n            else:\n                # fallback random swap\n                pos = random.randrange(len(new_s))\n                new_s[pos] = random.choice(not_in)\n        elif move == \"one_two\" and new_s and len(not_in) >= 2:\n            # Replace one item with two if feasible and beneficial\n            out = random.choice(new_s)\n            base_t = cur_time - times[out-1]\n            best = None\n            for i in range(len(not_in)):\n                for j in range(i+1, len(not_in)):\n                    a, b = not_in[i], not_in[j]\n                    t = base_t + times[a-1] + times[b-1]\n                    if t <= capacity:\n                        dv = values[a-1] + values[b-1] - values[out-1]\n                        if best is None or dv > best[0]:\n                            best = (dv, out, a, b)\n            if best is not None and best[0] > 0:\n                _, out, a, b = best\n                new_s = [k for k in new_s if k != out] + [a, b]\n        elif move == \"two_one\" and len(new_s) >= 2 and not_in:\n            # Replace two items with one better item if beneficial or to repair capacity\n            best = None\n            for i in range(len(new_s)):\n                for j in range(i+1, len(new_s)):\n                    out1, out2 = new_s[i], new_s[j]\n                    base_t = cur_time - times[out1-1] - times[out2-1]\n                    for inn in not_in:\n                        t = base_t + times[inn-1]\n                        if t <= capacity:\n                            dv = values[inn-1] - (values[out1-1] + values[out2-1])\n                            if best is None or dv > best[0]:\n                                best = (dv, out1, out2, inn)\n            if best is not None and best[0] > 0:\n                _, a, b, inn = best\n                new_s = [k for k in new_s if k not in (a, b)] + [inn]\n        # Normalize and ensure change\n        new_s = _normalize_sorted_unique(new_s)\n        s_norm = _normalize_sorted_unique(s)\n        if new_s != s_norm:\n            return (new_s, \"INDEX_LIST\", move)\n    # Fallback small random tweak\n    if not_in:\n        fallback = _normalize_sorted_unique(s + [random.choice(not_in)])\n        return (fallback, \"INDEX_LIST\", \"add\")\n    if s:\n        tmp = list(s)\n        del tmp[random.randrange(len(tmp))]\n        return (_normalize_sorted_unique(tmp), \"INDEX_LIST\", \"remove\")\n    return ([], \"INDEX_LIST\", \"idle\")\n","Perturbacion":"import math\nimport random\n\n\ndef _p_validate(solution):\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in s):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    if any(i < 1 or i > 24 for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\n\ndef _normalize_sorted_unique_p(lst):\n    seen = set()\n    out = []\n    for x in sorted(lst):\n        if 1 <= x <= 24 and x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n\n\ndef perturb_solution(solution):\n    # Strong but bounded perturbation: remove r items then greedy refill by ratio\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    s = _p_validate(solution)\n    s = _normalize_sorted_unique_p(s)\n\n    # Remove r items\n    r = 0\n    if len(s) >= 2:\n        r = random.randint(2, min(5, len(s)))\n    elif len(s) == 1:\n        r = 1\n    else:\n        r = 0\n    for _ in range(r):\n        if not s:\n            break\n        # remove lowest value\/time ratio first with slight randomness\n        if random.random() < 0.8:\n            worst = sorted(s, key=lambda i: (values[i-1]\/times[i-1], values[i-1]))[0]\n            s.remove(worst)\n        else:\n            del s[random.randrange(len(s))]\n\n    # Greedy refill by value\/time ratio until capacity reached\n    current_time = sum(times[i-1] for i in s)\n    in_set = set(s)\n    candidates = [i for i in range(1, 25) if i not in in_set]\n    candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        if current_time + times[i-1] <= capacity:\n            s.append(i)\n            current_time += times[i-1]\n\n    return _normalize_sorted_unique_p(s)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST_SORTED: comma-separated 1-based indices of selected items in strictly increasing order (e.g., \"2,8,14,18\"). Empty string \"\" means no items.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a cost to minimize: feasible => -total_value; infeasible\/invalid => large positive penalty.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n    PENALTY = 1e12\n\n    # Robust parse of comma-separated 1-based indices; canonicalizes by sorting and removing duplicates.\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return None\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if k < 1 or k > n:\n                return None\n            if k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return PENALTY\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        if total_w > C:\n            return PENALTY\n        total_v += values[k-1]\n    return -float(total_v)\n","Vecindad":"import random\n\n# Neighborhood on normalized index-list representation; preserves feasibility and normalizes output.\n# Returns (new_solution_str, (\"INDEX_LIST\", movement_type))\n\ndef generate_neighbour(solution):\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        idxs = sorted(set(idxs))\n        return ','.join(str(k) for k in idxs)\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list(solution)\n    if cur is None:\n        # Fallback to best single feasible item by value density\n        density = [(values[i]\/weights[i], i+1) for i in range(n) if weights[i] <= C]\n        if not density:\n            return '', (\"INDEX_LIST\", \"noop\")\n        k = max(density)[1]\n        return str(k), (\"INDEX_LIST\", \"seed\")\n\n    cur_set = set(cur)\n    W = cur_weight(cur)\n\n    # Candidate operations\n    ops = []\n\n    # 1) Add (biased by value density)\n    addable = [k for k in range(1, n+1) if (k not in cur_set and W + weights[k-1] <= C)]\n    if addable:\n        ops.append('add')\n\n    # 2) Remove\n    if cur:\n        ops.append('remove')\n\n    # 3) 1-for-1 swap\n    swap_pairs = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            for add in range(1, n+1):\n                if add in cur_set or add == rem:\n                    continue\n                if Wr + weights[add-1] <= C:\n                    swap_pairs.append((rem, add))\n        if swap_pairs:\n            ops.append('swap')\n\n    # 4) 2-rem 2-add (light) if space allows\n    two_two = []\n    if len(cur) >= 2:\n        cur_list = cur\n        m = len(cur_list)\n        for i in range(m):\n            for j in range(i+1, m):\n                Wrr = W - weights[cur_list[i]-1] - weights[cur_list[j]-1]\n                # try two adds among top-K densities\n                candidates = [k for k in range(1, n+1) if k not in cur_set and k != cur_list[i] and k != cur_list[j]]\n                # rank by density then value\n                ranked = sorted(candidates, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:8]\n                L = len(ranked)\n                for a in range(L):\n                    for b in range(a+1, L):\n                        add1, add2 = ranked[a], ranked[b]\n                        if Wrr + weights[add1-1] + weights[add2-1] <= C:\n                            two_two.append(((cur_list[i], cur_list[j]), (add1, add2)))\n        if two_two:\n            ops.append('2swap')\n\n    if not ops:\n        return pack_str(cur), (\"INDEX_LIST\", \"noop\")\n\n    op = random.choice(ops)\n\n    if op == 'add':\n        # Softmax bias by density\n        dens = [values[k-1]\/weights[k-1] for k in addable]\n        mx = max(dens)\n        probs = []\n        s = 0.0\n        for d in dens:\n            val = math.exp(3.0*(d-mx))\n            probs.append(val)\n            s += val\n        r = random.random()*s\n        acc = 0.0\n        choice = addable[0]\n        for k, p in zip(addable, probs):\n            acc += p\n            if r <= acc:\n                choice = k\n                break\n        new = sorted(cur + [choice])\n        return pack_str(new), (\"INDEX_LIST\", \"add\")\n\n    if op == 'remove':\n        # Remove lowest density item to free capacity with some bias\n        if not cur:\n            return pack_str(cur), (\"INDEX_LIST\", \"noop\")\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1,weights[k-1]), values[k-1]))\n        # choose among bottom 2 with bias\n        pick = ranked[0] if len(ranked) == 1 else random.choice(ranked[:2])\n        new = [x for x in cur if x != pick]\n        return pack_str(new), (\"INDEX_LIST\", \"remove\")\n\n    if op == 'swap':\n        rem, add = random.choice(swap_pairs)\n        new = [x for x in cur if x != rem] + [add]\n        new.sort()\n        return pack_str(new), (\"INDEX_LIST\", \"swap\")\n\n    # 2-for-2 exchange\n    (r1, r2), (a1, a2) = random.choice(two_two)\n    new = [x for x in cur if x not in (r1, r2)] + [a1, a2]\n    new.sort()\n    return pack_str(new), (\"INDEX_LIST\", \"2swap\")\n","Perturbacion":"import random\n\n# Feasibility-preserving perturbation: remove 1-2 low-density items, then greedy refill by density; finalize with quick improvement.\n\ndef perturb_solution(solution: str) -> str:\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and (k not in seen):\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def greedy_fill(current):\n        W = cur_weight(current)\n        cur_set = set(current)\n        items = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if (i+1) not in cur_set]\n        items.sort(reverse=True)\n        for _, _, k in items:\n            w = weights[k-1]\n            if W + w <= C:\n                current.append(k)\n                W += w\n        current.sort()\n        return current\n\n    cur = parse_index_list(solution)\n    # Start from a canonical greedy feasible seed if input invalid\/empty\n    if cur == []:\n        base = []\n        base = greedy_fill(base)\n        cur = base\n\n    # Remove r in {1,2} items with lowest density (or random if fewer)\n    r = 1 if len(cur) < 2 else random.choice((1,2))\n    if cur:\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1,weights[k-1]), values[k-1]))\n        remove_set = set(ranked[:r])\n        cur = [k for k in cur if k not in remove_set]\n        cur.sort()\n\n    # Greedy refill by density\n    cur = greedy_fill(cur)\n\n    # Short local improvement: try single best improving swap-in among top-6 densities\n    W = cur_weight(cur)\n    cur_set = set(cur)\n    candidates = [k for k in range(1, n+1) if k not in cur_set]\n    ranked_add = sorted(candidates, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:6]\n\n    best = cur[:]\n    best_val = sum(values[k-1] for k in best)\n\n    for rem in cur:\n        Wr = W - weights[rem-1]\n        for add in ranked_add:\n            if Wr + weights[add-1] <= C:\n                trial = [x for x in cur if x != rem] + [add]\n                trial.sort()\n                tv = sum(values[k-1] for k in trial)\n                if tv > best_val:\n                    best = trial\n                    best_val = tv\n    return pack_str(best)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST_SORTED: comma-separated 1-based indices in strictly increasing order; \"\" means no items.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a cost to minimize: feasible => -total_value; infeasible\/invalid => large positive penalty.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n    PENALTY = 1e12\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return PENALTY\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        if total_w > C:\n            return PENALTY\n        total_v += values[k-1]\n    return -float(total_v)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood on normalized index-list representation; preserves feasibility.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list(solution)\n    if cur is None:\n        # Seed: best feasible single item by value density\n        candidates = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if weights[i] <= C]\n        if not candidates:\n            return '', (\"INDEX_LIST\", \"seed\")\n        candidates.sort(reverse=True)\n        return str(candidates[0][2]), (\"INDEX_LIST\", \"seed\")\n\n    W = cur_weight(cur)\n    cur_set = set(cur)\n\n    # Build operation sets\n    addable = [k for k in range(1, n+1) if (k not in cur_set and W + weights[k-1] <= C)]\n    ops = []\n    if addable:\n        ops.append('add')\n    if cur:\n        ops.append('remove')\n\n    # 1-for-1 swaps\n    swap_pairs = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            for add in range(1, n+1):\n                if add in cur_set or add == rem:\n                    continue\n                if Wr + weights[add-1] <= C:\n                    swap_pairs.append((rem, add))\n        if swap_pairs:\n            ops.append('swap')\n\n    # 1-for-2 and 2-for-1 exchanges (light diversification)\n    one_for_two = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            cand = [k for k in range(1, n+1) if k not in cur_set and k != rem]\n            ranked = sorted(cand, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:8]\n            L = len(ranked)\n            for a in range(L):\n                for b in range(a+1, L):\n                    if Wr + weights[ranked[a]-1] + weights[ranked[b]-1] <= C:\n                        one_for_two.append((rem, ranked[a], ranked[b]))\n        if one_for_two:\n            ops.append('1for2')\n\n    two_for_one = []\n    if len(cur) >= 2:\n        m = len(cur)\n        for i in range(m):\n            for j in range(i+1, m):\n                Wr = W - weights[cur[i]-1] - weights[cur[j]-1]\n                for add in range(1, n+1):\n                    if add in cur_set:\n                        continue\n                    if Wr + weights[add-1] <= C:\n                        two_for_one.append(((cur[i], cur[j]), add))\n        if two_for_one:\n            ops.append('2for1')\n\n    if not ops:\n        return pack_str(cur), (\"INDEX_LIST\", \"noop\")\n\n    op = random.choice(ops)\n\n    if op == 'add':\n        dens = [values[k-1]\/weights[k-1] for k in addable]\n        mx = max(dens)\n        probs = [math.exp(3.0*(d-mx)) for d in dens]\n        s = sum(probs)\n        r = random.random()*s\n        acc = 0.0\n        choice = addable[-1]\n        for k, p in zip(addable, probs):\n            acc += p\n            if r <= acc:\n                choice = k\n                break\n        new = sorted(cur + [choice])\n        return pack_str(new), (\"INDEX_LIST\", \"add\")\n\n    if op == 'remove':\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1, weights[k-1]), values[k-1]))\n        pick = ranked[0] if len(ranked) == 1 else random.choice(ranked[:2])\n        new = [x for x in cur if x != pick]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"remove\")\n\n    if op == 'swap':\n        rem, add = random.choice(swap_pairs)\n        new = [x for x in cur if x != rem] + [add]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"swap\")\n\n    if op == '1for2':\n        rem, a, b = random.choice(one_for_two)\n        new = [x for x in cur if x != rem] + [a, b]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"1for2\")\n\n    # op == '2for1'\n    (r1, r2), add = random.choice(two_for_one)\n    new = [x for x in cur if x not in (r1, r2)] + [add]\n    return pack_str(sorted(new)), (\"INDEX_LIST\", \"2for1\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution: str) -> str:\n    # Feasibility-preserving perturbation: drop 1-2 low-density items; greedy refill; best-improving single swap.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and (k not in seen):\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def total_value(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    def greedy_fill(current):\n        W = cur_weight(current)\n        cur_set = set(current)\n        items = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if (i+1) not in cur_set]\n        items.sort(reverse=True)\n        for _, _, k in items:\n            w = weights[k-1]\n            if W + w <= C:\n                current.append(k)\n                W += w\n        current.sort()\n        return current\n\n    cur = parse_index_list(solution)\n\n    if cur == []:\n        # deterministic greedy seed\n        base = []\n        base = greedy_fill(base)\n        cur = base\n\n    # Drop 1-2 lowest density items\n    r = 1 if len(cur) < 2 else random.choice((1, 2))\n    if cur:\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1, weights[k-1]), values[k-1]))\n        remove_set = set(ranked[:r])\n        cur = [k for k in cur if k not in remove_set]\n        cur.sort()\n\n    # Greedy refill by density\n    cur = greedy_fill(cur)\n\n    # Single best-improving swap with candidates among top-6 densities not in current\n    W = cur_weight(cur)\n    cur_set = set(cur)\n    candidates = [k for k in range(1, n+1) if k not in cur_set]\n    ranked_add = sorted(candidates, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:6]\n\n    best = cur[:]\n    best_val = total_value(best)\n\n    for rem in cur:\n        Wr = W - weights[rem-1]\n        for add in ranked_add:\n            if Wr + weights[add-1] <= C:\n                trial = [x for x in cur if x != rem] + [add]\n                trial.sort()\n                tv = total_value(trial)\n                if tv > best_val:\n                    best = trial\n                    best_val = tv\n    return pack_str(best)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST_SORTED","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a cost to minimize: feasible => -total_value; infeasible\/invalid => large positive penalty.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n    PENALTY = 1e12\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return PENALTY\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        if total_w > C:\n            return PENALTY\n        total_v += values[k-1]\n    return -float(total_v)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood on normalized index-list representation; preserves feasibility.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list(solution)\n    if cur is None:\n        # Seed: best feasible single item by value density\n        candidates = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if weights[i] <= C]\n        if not candidates:\n            return '', (\"INDEX_LIST\", \"seed\")\n        candidates.sort(reverse=True)\n        return str(candidates[0][2]), (\"INDEX_LIST\", \"seed\")\n\n    W = cur_weight(cur)\n    cur_set = set(cur)\n\n    # Build operation sets\n    addable = [k for k in range(1, n+1) if (k not in cur_set and W + weights[k-1] <= C)]\n    ops = []\n    if addable:\n        ops.append('add')\n    if cur:\n        ops.append('remove')\n\n    # 1-for-1 swaps\n    swap_pairs = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            for add in range(1, n+1):\n                if add in cur_set or add == rem:\n                    continue\n                if Wr + weights[add-1] <= C:\n                    swap_pairs.append((rem, add))\n        if swap_pairs:\n            ops.append('swap')\n\n    # 1-for-2 exchanges\n    one_for_two = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            cand = [k for k in range(1, n+1) if k not in cur_set and k != rem]\n            ranked = sorted(cand, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:8]\n            L = len(ranked)\n            for a in range(L):\n                for b in range(a+1, L):\n                    if Wr + weights[ranked[a]-1] + weights[ranked[b]-1] <= C:\n                        one_for_two.append((rem, ranked[a], ranked[b]))\n        if one_for_two:\n            ops.append('1for2')\n\n    if not ops:\n        return pack_str(cur), (\"INDEX_LIST\", \"noop\")\n\n    op = random.choice(ops)\n\n    if op == 'add':\n        dens = [values[k-1]\/weights[k-1] for k in addable]\n        mx = max(dens)\n        probs = [math.exp(3.0*(d-mx)) for d in dens]\n        s = sum(probs)\n        r = random.random()*s\n        acc = 0.0\n        choice = addable[-1]\n        for k, p in zip(addable, probs):\n            acc += p\n            if r <= acc:\n                choice = k\n                break\n        new = sorted(cur + [choice])\n        return pack_str(new), (\"INDEX_LIST\", \"add\")\n\n    if op == 'remove':\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1, weights[k-1]), values[k-1]))\n        pick = ranked[0]\n        new = [x for x in cur if x != pick]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"remove\")\n\n    if op == 'swap':\n        rem, add = random.choice(swap_pairs)\n        new = [x for x in cur if x != rem] + [add]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"swap\")\n\n    # op == '1for2'\n    rem, a, b = random.choice(one_for_two)\n    new = [x for x in cur if x != rem] + [a, b]\n    return pack_str(sorted(new)), (\"INDEX_LIST\", \"1for2\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution: str) -> str:\n    # Feasibility-preserving perturbation: drop 1-2 low-density items; greedy refill; best-improving single swap.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and (k not in seen):\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def total_value(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    def greedy_fill(current):\n        W = cur_weight(current)\n        cur_set = set(current)\n        items = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if (i+1) not in cur_set]\n        items.sort(reverse=True)\n        for _, _, k in items:\n            w = weights[k-1]\n            if W + w <= C:\n                current.append(k)\n                W += w\n        current.sort()\n        return current\n\n    cur = parse_index_list(solution)\n\n    if cur == []:\n        # deterministic greedy seed\n        base = []\n        base = greedy_fill(base)\n        cur = base\n\n    # Drop 1-2 lowest density items\n    r = 1 if len(cur) < 2 else random.choice((1, 2))\n    if cur:\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1, weights[k-1]), values[k-1]))\n        remove_set = set(ranked[:r])\n        cur = [k for k in cur if k not in remove_set]\n        cur.sort()\n\n    # Greedy refill by density\n    cur = greedy_fill(cur)\n\n    # Single best-improving swap with candidates among top-6 densities not in current\n    W = cur_weight(cur)\n    cur_set = set(cur)\n    candidates = [k for k in range(1, n+1) if k not in cur_set]\n    ranked_add = sorted(candidates, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:6]\n\n    best = cur[:]\n    best_val = total_value(best)\n\n    for rem in cur:\n        Wr = W - weights[rem-1]\n        for add in ranked_add:\n            if Wr + weights[add-1] <= C:\n                trial = [x for x in cur if x != rem] + [add]\n                trial.sort()\n                tv = total_value(trial)\n                if tv > best_val:\n                    best = trial\n                    best_val = tv\n    return pack_str(best)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Type check and sanitize\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    # Minimization score for a maximization problem: negate value\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Sanitize to canonical INDEX_LIST (sorted unique valid ints)\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    n = 24\n    in_set = set(sol)\n    not_in = [i for i in range(1, n+1) if i not in in_set]\n\n    def cost_of(lst):\n        s = 0\n        for i in lst:\n            s += costs[i-1]\n        return s\n\n    current_cost = cost_of(sol)\n    residual = budget - current_cost\n\n    # Precompute ratios for biasing candidate adds\n    ratio = [(i, values[i-1] \/ costs[i-1]) for i in range(1, n+1)]\n    ratio.sort(key=lambda x: x[1], reverse=True)\n\n    # Candidate moves\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if sol:\n        moves.append(\"remove\")\n    if sol and not_in:\n        moves.append(\"swap_1_1\")\n    if len(not_in) >= 2 and sol:\n        moves.append(\"swap_2_1\")\n    if len(sol) >= 2 and not_in:\n        moves.append(\"swap_1_2\")\n\n    if not moves:\n        return (sol, \"none\")\n\n    # Helper to finalize solution (sorted, unique)\n    def finalize(lst):\n        return sorted(set(lst))\n\n    # Attempt multiple times to find a feasible, diverse neighbor\n    for _ in range(64):\n        move = random.choices(moves, weights=[3 if m==\"add\" else 2 if m.startswith(\"swap\") else 1 for m in moves], k=1)[0]\n        new_sol = list(sol)\n        new_in_set = set(new_sol)\n        new_cost = current_cost\n\n        if move == \"add\":\n            # Consider top-k by ratio that fit residual\n            candidates = [i for (i, r) in ratio if i not in new_in_set and costs[i-1] <= residual]\n            if candidates:\n                i = random.choice(candidates[:max(1, min(5, len(candidates)))])\n                new_sol.append(i)\n                new_cost += costs[i-1]\n                if new_cost <= budget:\n                    return (finalize(new_sol), \"add\")\n        elif move == \"remove\":\n            i = random.choice(new_sol)\n            new_sol.remove(i)\n            return (finalize(new_sol), \"remove\")\n        elif move == \"swap_1_1\":\n            out = random.choice(new_sol)\n            ins_candidates = [i for i in not_in if costs[i-1] - costs[out-1] <= residual]\n            if ins_candidates:\n                # bias by ratio\n                ins_candidates.sort(key=lambda i: values[i-1]\/costs[i-1], reverse=True)\n                ins = random.choice(ins_candidates[:max(1, min(5, len(ins_candidates)))])\n                new_sol.remove(out)\n                new_sol.append(ins)\n                new_cost = current_cost - costs[out-1] + costs[ins-1]\n                if new_cost <= budget:\n                    return (finalize(new_sol), \"swap_1_1\")\n        elif move == \"swap_2_1\":\n            if len(new_sol) >= 2:\n                outs = random.sample(new_sol, 2)\n                # pick ins that fits\n                freed = costs[outs[0]-1] + costs[outs[1]-1]\n                ins_fit = [i for i in not_in if costs[i-1] - freed <= residual]\n                if ins_fit:\n                    ins_fit.sort(key=lambda i: values[i-1]\/costs[i-1], reverse=True)\n                    ins = random.choice(ins_fit[:max(1, min(5, len(ins_fit)))])\n                    new_cost = current_cost - freed + costs[ins-1]\n                    if new_cost <= budget:\n                        new_sol = [x for x in new_sol if x not in outs]\n                        new_sol.append(ins)\n                        return (finalize(new_sol), \"swap_2_1\")\n        else:  # swap_1_2\n            out = random.choice(new_sol)\n            # choose two distinct to add\n            add_pool = [i for i in not_in if i != out]\n            if len(add_pool) >= 2:\n                ins_pair = random.sample(add_pool, 2)\n                added_cost = costs[ins_pair[0]-1] + costs[ins_pair[1]-1]\n                new_cost = current_cost - costs[out-1] + added_cost\n                if new_cost <= budget and ins_pair[0] not in new_in_set and ins_pair[1] not in new_in_set:\n                    new_sol.remove(out)\n                    new_sol.extend(ins_pair)\n                    return (finalize(new_sol), \"swap_1_2\")\n\n    # Fallback: remove a random item if any, else return as is\n    if sol:\n        i = random.choice(sol)\n        new_sol = list(sol)\n        new_sol.remove(i)\n        return (finalize(new_sol), \"remove\")\n    return (sol, \"none\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Sanitize input\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    def total_cost(lst):\n        s = 0\n        for i in lst:\n            s += costs[i-1]\n        return s\n\n    # Remove t random items (kick), then greedy refill by value\/weight ratio\n    t = 1 if len(sol) <= 1 else min(3, max(1, len(sol)\/\/2))\n    sol2 = list(sol)\n    if sol2:\n        k = min(t, len(sol2))\n        to_remove = random.sample(sol2, k)\n        for i in to_remove:\n            sol2.remove(i)\n\n    # Greedy refill\n    in_set = set(sol2)\n    candidates = [(i, values[i-1] \/ costs[i-1]) for i in range(1, 25) if i not in in_set]\n    candidates.sort(key=lambda x: x[1], reverse=True)\n\n    cur_cost = total_cost(sol2)\n    for i, _ in candidates:\n        c = costs[i-1]\n        if cur_cost + c <= budget:\n            sol2.append(i)\n            cur_cost += c\n\n    sol2 = sorted(set(sol2))\n    # Ensure feasibility (repair if needed, though greedy preserves it)\n    while total_cost(sol2) > budget and sol2:\n        # drop the lowest value density item\n        sol2.sort(key=lambda i: values[i-1] \/ costs[i-1])\n        sol2.pop(0)\n    return sol2\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Type and content checks\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e12\n        if idx < 1 or idx > 24:\n            return 1e12\n        if idx in seen:\n            return 1e12\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        total_value += v\n\n    # Penalty for budget violation (soft, preserves guidance)\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        # Strong linear penalty; still comparable across infeasible solutions\n        penalty = 1000.0 * over\n        return -float(total_value) + penalty\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Sanitize to canonical INDEX_LIST (sorted, unique, valid)\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= n and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    def cost_of(lst):\n        s = 0\n        for i in lst:\n            s += costs[i - 1]\n        return s\n\n    def value_of(lst):\n        s = 0\n        for i in lst:\n            s += values[i - 1]\n        return s\n\n    current_cost = cost_of(sol)\n    residual = budget - current_cost\n\n    # Precompute value\/weight ratio (local, no global state)\n    ratio = [(i, values[i - 1] \/ costs[i - 1]) for i in range(1, n + 1)]\n    ratio.sort(key=lambda x: x[1], reverse=True)\n\n    # Candidate move set\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if sol:\n        moves.append(\"remove\")\n    if sol and not_in:\n        moves.append(\"swap_1_1\")\n    if len(sol) >= 2 and not_in:\n        moves.append(\"swap_1_2\")\n    if len(not_in) >= 2 and sol:\n        moves.append(\"swap_2_1\")\n\n    if not moves:\n        return (sol, \"none\")\n\n    # Adaptive move weights: prefer removes\/swaps when residual small\n    def move_weights():\n        if residual <= 0:\n            return {\"add\": 0.5, \"remove\": 3.0, \"swap_1_1\": 2.5, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n        elif residual < 30:\n            return {\"add\": 1.0, \"remove\": 2.0, \"swap_1_1\": 2.5, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n        else:\n            return {\"add\": 3.0, \"remove\": 1.0, \"swap_1_1\": 2.0, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n\n    weights_map = move_weights()\n    weights = [weights_map[m] for m in moves]\n\n    def finalize(lst):\n        # maintain canonical order without duplicates\n        return sorted(set(lst))\n\n    # Utility: pick with softmax bias over top-k candidates by ratio\n    def pick_by_ratio(cands, k_cap=6, temp=0.5):\n        if not cands:\n            return None\n        scored = [(i, values[i - 1] \/ costs[i - 1]) for i in cands]\n        scored.sort(key=lambda x: x[1], reverse=True)\n        pool = scored[: max(1, min(k_cap, len(scored)))]\n        # softmax over ratios\n        mx = max(r for _, r in pool)\n        probs = [math.exp((r - mx) \/ max(1e-9, temp)) for _, r in pool]\n        s = sum(probs)\n        r = random.random() * s\n        acc = 0.0\n        for (i, dens), p in zip(pool, probs):\n            acc += p\n            if r <= acc:\n                return i\n        return pool[-1][0]\n\n    # Attempt to construct a feasible diverse neighbor\n    for _ in range(64):\n        move = random.choices(moves, weights=weights, k=1)[0]\n        new_sol = list(sol)\n        new_in = set(new_sol)\n        base_cost = current_cost\n\n        if move == \"add\":\n            feasible_adds = [i for i in not_in if costs[i - 1] <= residual]\n            if feasible_adds:\n                ins = pick_by_ratio(feasible_adds)\n                if ins is not None:\n                    new_sol.append(ins)\n                    if cost_of(new_sol) <= budget:\n                        return (finalize(new_sol), \"add\")\n        elif move == \"remove\":\n            out = random.choice(new_sol)\n            new_sol.remove(out)\n            return (finalize(new_sol), \"remove\")\n        elif move == \"swap_1_1\":\n            out = random.choice(new_sol)\n            freed = costs[out - 1]\n            new_resid = budget - (base_cost - freed)\n            ins_cands = [i for i in not_in if costs[i - 1] <= new_resid]\n            if ins_cands:\n                ins = pick_by_ratio(ins_cands)\n                if ins is not None and ins not in new_in:\n                    new_sol.remove(out)\n                    new_sol.append(ins)\n                    if cost_of(new_sol) <= budget:\n                        return (finalize(new_sol), \"swap_1_1\")\n        elif move == \"swap_1_2\":\n            out = random.choice(new_sol)\n            freed = costs[out - 1]\n            new_resid = budget - (base_cost - freed)\n            add_pool = [i for i in not_in if i != out]\n            if len(add_pool) >= 2:\n                # Try stochastic pair assembly guided by ratio\n                ins1 = pick_by_ratio(add_pool)\n                if ins1 is not None:\n                    add_pool2 = [i for i in add_pool if i != ins1]\n                    # bias second pick as well\n                    ins2 = pick_by_ratio(add_pool2)\n                    if ins2 is not None:\n                        add_cost = costs[ins1 - 1] + costs[ins2 - 1]\n                        if add_cost <= new_resid:\n                            new_sol.remove(out)\n                            new_sol.extend([ins1, ins2])\n                            if cost_of(new_sol) <= budget:\n                                return (finalize(new_sol), \"swap_1_2\")\n        else:  # swap_2_1\n            if len(new_sol) >= 2:\n                outs = random.sample(new_sol, 2)\n                freed = costs[outs[0] - 1] + costs[outs[1] - 1]\n                new_resid = budget - (base_cost - freed)\n                ins_cands = [i for i in not_in if costs[i - 1] <= new_resid]\n                if ins_cands:\n                    ins = pick_by_ratio(ins_cands)\n                    if ins is not None and ins not in new_in:\n                        cand = [x for x in new_sol if x not in outs]\n                        cand.append(ins)\n                        if cost_of(cand) <= budget:\n                            return (finalize(cand), \"swap_2_1\")\n\n    # Fallback: if no feasible neighbor found, remove a random item to ensure movement\n    if sol:\n        i = random.choice(sol)\n        new_sol = list(sol)\n        new_sol.remove(i)\n        return (finalize(new_sol), \"remove\")\n    return (sol, \"none\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Sanitize input to canonical INDEX_LIST\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= n and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    def total_cost(lst):\n        return sum(costs[i - 1] for i in lst)\n\n    # Kick strength proportional to current size (1..3)\n    k = len(sol)\n    t = 1 if k <= 1 else min(3, max(1, k \/\/ 2))\n\n    sol2 = list(sol)\n    if sol2:\n        remove_cnt = min(t, len(sol2))\n        to_remove = random.sample(sol2, remove_cnt)\n        for i in to_remove:\n            sol2.remove(i)\n\n    # Greedy refill by value density\n    in_set = set(sol2)\n    candidates = [(i, values[i - 1] \/ costs[i - 1]) for i in range(1, n + 1) if i not in in_set]\n    candidates.sort(key=lambda x: x[1], reverse=True)\n\n    cur_cost = total_cost(sol2)\n    for i, _ in candidates:\n        c = costs[i - 1]\n        if cur_cost + c <= budget:\n            sol2.append(i)\n            cur_cost += c\n\n    # Ensure feasibility and canonical form\n    sol2 = sorted(set(sol2))\n    while total_cost(sol2) > budget and sol2:\n        sol2.sort(key=lambda i: values[i - 1] \/ costs[i - 1])\n        sol2.pop(0)\n\n    return sol2\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Type and content checks\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e12\n        if idx < 1 or idx > n:\n            return 1e12\n        if idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx - 1]\n        total_value += values[idx - 1]\n\n    # Fitness: minimize (negative value for feasible), soft penalty for infeasible\n    if total_cost <= budget:\n        return -float(total_value)\n    over = float(total_cost - budget)\n    # Adaptive-shaped penalty (less extreme than 1000*over): linear + mild quadratic\n    lam = 20.0\n    penalty = lam * over + (lam \/ budget) * (over ** 2)\n    return -float(total_value) + penalty\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Canonicalize input to INDEX_LIST (sorted unique valid ints)\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= n and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    def cost_of(lst):\n        return sum(costs[i - 1] for i in lst)\n\n    def value_of(lst):\n        return sum(values[i - 1] for i in lst)\n\n    def greedy_fill(lst):\n        # Fill residual capacity by value density\n        in_set = set(lst)\n        rem = budget - cost_of(lst)\n        if rem <= 0:\n            return sorted(set(lst))\n        cands = [(i, values[i - 1] \/ costs[i - 1]) for i in range(1, n + 1) if i not in in_set and costs[i - 1] <= rem]\n        cands.sort(key=lambda x: x[1], reverse=True)\n        filled = list(lst)\n        cur_c = cost_of(filled)\n        for i, _ in cands:\n            ci = costs[i - 1]\n            if cur_c + ci <= budget:\n                filled.append(i)\n                cur_c += ci\n        return sorted(set(filled))\n\n    cur_cost = cost_of(sol)\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    # Available move types\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if sol:\n        moves.append(\"remove\")\n    if sol and not_in:\n        moves.append(\"swap_1_1\")\n    if len(sol) >= 1 and len(not_in) >= 2:\n        moves.append(\"swap_1_2\")\n    if len(sol) >= 2 and len(not_in) >= 1:\n        moves.append(\"swap_2_1\")\n\n    if not moves:\n        return (sol, \"none\")\n\n    # Weights adapt to residual capacity\n    residual = budget - cur_cost\n    if residual <= 0:\n        weights_map = {\"add\": 0.1, \"remove\": 3.0, \"swap_1_1\": 2.5, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n    elif residual < 30:\n        weights_map = {\"add\": 1.0, \"remove\": 2.0, \"swap_1_1\": 2.5, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n    else:\n        weights_map = {\"add\": 3.0, \"remove\": 1.0, \"swap_1_1\": 2.0, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n    move_list = [m for m in moves]\n    weights = [weights_map[m] for m in move_list]\n\n    def pick_by_ratio(cands, k_cap=8, temp=0.7):\n        if not cands:\n            return None\n        scored = [(i, values[i - 1] \/ max(1e-9, costs[i - 1])) for i in cands]\n        scored.sort(key=lambda x: x[1], reverse=True)\n        pool = scored[: max(1, min(k_cap, len(scored)))]\n        mx = max(r for _, r in pool)\n        probs = [math.exp((r - mx) \/ max(1e-9, temp)) for _, r in pool]\n        s = sum(probs)\n        r = random.random() * s\n        acc = 0.0\n        for (i, _), p in zip(pool, probs):\n            acc += p\n            if r <= acc:\n                return i\n        return pool[-1][0]\n\n    # Try multiple attempts to get a feasible-and-filled neighbor\n    attempts = 80\n    for _ in range(attempts):\n        move = random.choices(move_list, weights=weights, k=1)[0]\n        new_sol = list(sol)\n\n        if move == \"add\":\n            feasible_adds = [i for i in not_in if cur_cost + costs[i - 1] <= budget]\n            if feasible_adds:\n                ins = pick_by_ratio(feasible_adds)\n                if ins is not None:\n                    new_sol.append(ins)\n                    new_sol = greedy_fill(new_sol)\n                    return (new_sol, \"add\")\n        elif move == \"remove\":\n            out = random.choice(new_sol)\n            new_sol.remove(out)\n            new_sol = greedy_fill(new_sol)\n            return (new_sol, \"remove\")\n        elif move == \"swap_1_1\":\n            out = random.choice(new_sol)\n            freed = costs[out - 1]\n            feasible_ins = [i for i in not_in if cur_cost - freed + costs[i - 1] <= budget]\n            if feasible_ins:\n                ins = pick_by_ratio(feasible_ins)\n                if ins is not None:\n                    new_sol.remove(out)\n                    new_sol.append(ins)\n                    new_sol = greedy_fill(new_sol)\n                    return (new_sol, \"swap_1_1\")\n        elif move == \"swap_1_2\":\n            out = random.choice(new_sol)\n            freed = costs[out - 1]\n            pool = list(not_in)\n            # try bounded best-pair enumeration by ratio\n            pool_scored = sorted([(i, values[i - 1] \/ costs[i - 1]) for i in pool], key=lambda x: x[1], reverse=True)[:10]\n            picked = None\n            for i_idx in range(len(pool_scored)):\n                for j_idx in range(i_idx + 1, len(pool_scored)):\n                    i = pool_scored[i_idx][0]\n                    j = pool_scored[j_idx][0]\n                    if cur_cost - freed + costs[i - 1] + costs[j - 1] <= budget:\n                        picked = (i, j)\n                        break\n                if picked:\n                    break\n            if picked:\n                i, j = picked\n                new_sol.remove(out)\n                new_sol.extend([i, j])\n                new_sol = greedy_fill(new_sol)\n                return (sorted(set(new_sol)), \"swap_1_2\")\n        else:  # swap_2_1\n            if len(new_sol) >= 2:\n                outs = random.sample(new_sol, 2)\n                freed = costs[outs[0] - 1] + costs[outs[1] - 1]\n                feasible_ins = [i for i in not_in if cur_cost - freed + costs[i - 1] <= budget]\n                if feasible_ins:\n                    ins = pick_by_ratio(feasible_ins)\n                    if ins is not None:\n                        for o in outs:\n                            new_sol.remove(o)\n                        new_sol.append(ins)\n                        new_sol = greedy_fill(new_sol)\n                        return (sorted(set(new_sol)), \"swap_2_1\")\n\n    # Fallback: targeted remove then greedy fill\n    if sol:\n        out = random.choice(sol)\n        new_sol = list(sol)\n        new_sol.remove(out)\n        new_sol = greedy_fill(new_sol)\n        return (new_sol, \"fallback_remove_fill\")\n    return (sol, \"none\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Canonicalize\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= n and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    def total_cost(lst):\n        return sum(costs[i - 1] for i in lst)\n\n    def greedy_repair_and_fill(lst):\n        # If over budget, drop worst density items until feasible\n        s = sorted(set(lst))\n        while total_cost(s) > budget and s:\n            s.sort(key=lambda i: values[i - 1] \/ max(1e-9, costs[i - 1]))\n            s.pop(0)\n        # Then greedily fill by density\n        in_set = set(s)\n        rem = budget - total_cost(s)\n        if rem > 0:\n            cands = [(i, values[i - 1] \/ costs[i - 1]) for i in range(1, n + 1) if i not in in_set and costs[i - 1] <= rem]\n            cands.sort(key=lambda x: x[1], reverse=True)\n            cur = list(s)\n            cur_cost = total_cost(cur)\n            for i, _ in cands:\n                ci = costs[i - 1]\n                if cur_cost + ci <= budget:\n                    cur.append(i)\n                    cur_cost += ci\n            s = sorted(set(cur))\n        return s\n\n    sol2 = list(sol)\n\n    # Kick strength: 2..4 random moves\n    k = 2 + (len(sol2) % 3)  # deterministic given sol size; 2,3,4 cycling\n\n    for _ in range(k):\n        in_set = set(sol2)\n        not_in = [i for i in range(1, n + 1) if i not in in_set]\n        moves = []\n        if not_in:\n            moves.append(\"add\")\n        if sol2:\n            moves.append(\"remove\")\n        if sol2 and not_in:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = random.choice(moves)\n        if mv == \"add\":\n            i = random.choice(not_in)\n            sol2.append(i)\n            sol2 = sorted(set(sol2))\n        elif mv == \"remove\":\n            i = random.choice(sol2)\n            sol2.remove(i)\n        else:\n            out = random.choice(sol2)\n            inn = random.choice(not_in)\n            sol2.remove(out)\n            sol2.append(inn)\n            sol2 = sorted(set(sol2))\n\n    # Repair to feasibility and intensify\n    sol2 = greedy_repair_and_fill(sol2)\n    return sol2\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_0_1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> -total_value, infeasible\/invalid -> large positive penalty\n    PENALTY = 1e6\n    CAP = 9\n    # Values and weights aligned by index 0..23 -> items 1..24\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    if not isinstance(solution, str):\n        return float(PENALTY)\n    if len(solution) != 24:\n        return float(PENALTY)\n    if any(c not in '01' for c in solution):\n        return float(PENALTY)\n    total_w = 0\n    total_v = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_w += w[i]\n            total_v += v[i]\n            if total_w > CAP:\n                return float(PENALTY)\n    return float(-total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbour generator for 0\/1 knapsack (n=24, CAP=9)\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    # Start from a valid string or zero vector\n    if not is_valid_bits(solution):\n        bits = ['0'] * 24\n    else:\n        bits = list(solution)\n\n    # Helper computations\n    def totals(bs):\n        tw = 0\n        tv = 0\n        for i, c in enumerate(bs):\n            if c == '1':\n                tw += w[i]\n                tv += v[i]\n        return tw, tv\n\n    def repair_to_feasible(bs):\n        # If overweight, drop items with lowest value density first; then greedily refill by best ratio\n        bs = bs[:]  # copy\n        tw, tv = totals(bs)\n        if tw > CAP:\n            ones = [i for i, c in enumerate(bs) if c == '1']\n            # sort by (v\/w, -w) ascending -> remove worst density, prefer heavier first on ties\n            order = sorted(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            for idx in order:\n                if tw <= CAP:\n                    break\n                if bs[idx] == '1':\n                    bs[idx] = '0'\n                    tw -= w[idx]\n                    tv -= v[idx]\n        # Greedy refill\n        improved = True\n        while improved:\n            improved = False\n            remaining = CAP - tw\n            zeros = [i for i, c in enumerate(bs) if c == '0' and w[i] <= remaining]\n            if not zeros:\n                break\n            # choose best ratio with value tie-break\n            best = max(zeros, key=lambda i: (v[i] \/ w[i], v[i]))\n            if w[best] <= remaining:\n                bs[best] = '1'\n                tw += w[best]\n                tv += v[best]\n                improved = True\n        return bs\n\n    # Ensure current is feasible baseline\n    bits = repair_to_feasible(bits)\n    cur_w, cur_v = totals(bits)\n\n    move = random.choice([\"add\", \"remove\", \"swap\"])  # all preserve feasibility\n\n    # Prepare candidates and helpers\n    zeros = [i for i, c in enumerate(bits) if c == '0']\n    ones = [i for i, c in enumerate(bits) if c == '1']\n\n    new_bits = bits[:]\n    label = \"noop\"\n\n    if move == \"add\":\n        remaining = CAP - cur_w\n        addables = [i for i in zeros if w[i] <= remaining]\n        if addables:\n            # Biased choice among top-k by ratio\n            ranked = sorted(addables, key=lambda i: (v[i] \/ w[i], v[i]), reverse=True)\n            k = min(3, len(ranked))\n            j = random.choice(ranked[:k])\n            new_bits[j] = '1'\n            dW = w[j]\n            dV = v[j]\n            label = f\"move::add::idx={j+1}::dV={dV}::dW={dW}\"\n        else:\n            # fallback: remove worst if no add possible\n            move = \"remove\"\n\n    if move == \"remove\":\n        if ones:\n            worst = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            new_bits[worst] = '0'\n            dW = -w[worst]\n            dV = -v[worst]\n            label = f\"move::remove::idx={worst+1}::dV={dV}::dW={dW}\"\n        else:\n            # nothing to remove, try add best single if fits\n            remaining = CAP - cur_w\n            addables = [i for i in zeros if w[i] <= remaining]\n            if addables:\n                j = max(addables, key=lambda i: (v[i] \/ w[i], v[i]))\n                new_bits[j] = '1'\n                dW = w[j]\n                dV = v[j]\n                label = f\"move::add::idx={j+1}::dV={dV}::dW={dW}\"\n\n    if move == \"swap\":\n        if ones and zeros:\n            # pick a removal, then best feasible add under remaining\n            i_rem = random.choice(ones)\n            remaining = CAP - (cur_w - w[i_rem])\n            addables = [j for j in zeros if w[j] <= remaining]\n            if addables:\n                j_add = max(addables, key=lambda j: (v[j], v[j] \/ w[j]))\n                new_bits[i_rem] = '0'\n                new_bits[j_add] = '1'\n                dW = -w[i_rem] + w[j_add]\n                dV = -v[i_rem] + v[j_add]\n                label = f\"move::swap::out={i_rem+1}::in={j_add+1}::dV={dV}::dW={dW}\"\n            else:\n                # if no feasible add, just remove worst\n                worst = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n                new_bits[worst] = '0'\n                dW = -w[worst]\n                dV = -v[worst]\n                label = f\"move::remove::idx={worst+1}::dV={dV}::dW={dW}\"\n        else:\n            # fallback to add or remove\n            if zeros:\n                remaining = CAP - cur_w\n                addables = [i for i in zeros if w[i] <= remaining]\n                if addables:\n                    j = max(addables, key=lambda i: (v[i] \/ w[i], v[i]))\n                    new_bits[j] = '1'\n                    dW = w[j]\n                    dV = v[j]\n                    label = f\"move::add::idx={j+1}::dV={dV}::dW={dW}\"\n            elif ones:\n                worst = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n                new_bits[worst] = '0'\n                dW = -w[worst]\n                dV = -v[worst]\n                label = f\"move::remove::idx={worst+1}::dV={dV}::dW={dW}\"\n\n    # Final feasibility repair (should already be feasible)\n    new_bits = repair_to_feasible(new_bits)\n    return (\"\".join(new_bits), label)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong perturbation: drop 2-3 low-contribution items, then greedy refill by ratio\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    if not is_valid_bits(solution):\n        bits = ['0'] * 24\n    else:\n        bits = list(solution)\n\n    def totals(bs):\n        tw = 0\n        tv = 0\n        for i, c in enumerate(bs):\n            if c == '1':\n                tw += w[i]\n                tv += v[i]\n        return tw, tv\n\n    def repair_to_feasible(bs):\n        bs = bs[:]\n        tw, tv = totals(bs)\n        if tw > CAP:\n            ones = [i for i, c in enumerate(bs) if c == '1']\n            order = sorted(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            for idx in order:\n                if tw <= CAP:\n                    break\n                if bs[idx] == '1':\n                    bs[idx] = '0'\n                    tw -= w[idx]\n                    tv -= v[idx]\n        # Greedy refill\n        improved = True\n        while improved:\n            improved = False\n            remaining = CAP - tw\n            zeros = [i for i, c in enumerate(bs) if c == '0' and w[i] <= remaining]\n            if not zeros:\n                break\n            best = max(zeros, key=lambda i: (v[i] \/ w[i], v[i]))\n            if w[best] <= remaining:\n                bs[best] = '1'\n                tw += w[best]\n                tv += v[best]\n                improved = True\n        return bs\n\n    # Ensure feasibility before perturbation\n    bits = repair_to_feasible(bits)\n\n    # Choose drop count based on random depth indicator\n    r = random.choice([2, 3])\n    ones = [i for i, c in enumerate(bits) if c == '1']\n    if ones:\n        # Rank by low contribution (density, then heavier preferred for diversification)\n        ranked = sorted(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n        k = min(r, len(ranked))\n        drop_set = set(random.sample(ranked[:max(1, k)], k))\n        for idx in drop_set:\n            bits[idx] = '0'\n\n    # Random flips on zeros to diversify a bit (bounded)\n    flips = random.randint(1, 2)\n    zeros = [i for i, c in enumerate(bits) if c == '0']\n    for _ in range(flips):\n        if not zeros:\n            break\n        j = random.choice(zeros)\n        zeros.remove(j)\n        bits[j] = '1'\n\n    # Final repair and greedy refill\n    bits = repair_to_feasible(bits)\n    return ''.join(bits)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_0_1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Objective: minimize cost = -total_value (feasible); infeasible -> +inf\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n\n    total_w = 0\n    total_v = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            wi = w[i]\n            vi = v[i]\n            total_w += wi\n            if total_w > CAP:\n                return math.inf\n            total_v += vi\n    return float(-total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_bits, move_label); preserves feasibility with small-step moves\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def totals(bs):\n        tw = 0\n        tv = 0\n        for i, c in enumerate(bs):\n            if c == '1':\n                tw += w[i]\n                tv += v[i]\n        return tw, tv\n\n    def drop_until_feasible(bs):\n        bs = bs[:]\n        tw, _ = totals(bs)\n        if tw <= CAP:\n            return bs\n        ones = [i for i, c in enumerate(bs) if c == '1']\n        # Remove lowest value-density first; heavier first on ties\n        for idx in sorted(ones, key=lambda i: (v[i]\/w[i], -w[i])):\n            if tw <= CAP:\n                break\n            if bs[idx] == '1':\n                bs[idx] = '0'\n                tw -= w[idx]\n        return bs\n\n    if not is_valid_bits(solution):\n        # Construct a simple feasible seed greedily by value\/weight\n        idxs = list(range(24))\n        idxs.sort(key=lambda i: (v[i]\/w[i] if w[i] <= CAP else -1e9, v[i]), reverse=True)\n        bits = ['0'] * 24\n        tw = 0\n        for i in idxs:\n            if w[i] <= CAP - tw:\n                bits[i] = '1'\n                tw += w[i]\n        current = bits\n        label = \"init::greedy\"\n    else:\n        current = list(solution)\n        current = drop_until_feasible(current)\n        label = \"\"\n\n    cur_w, _ = totals(current)\n    zeros = [i for i, c in enumerate(current) if c == '0']\n    ones = [i for i, c in enumerate(current) if c == '1']\n\n    move = random.choice([\"add\", \"remove\", \"swap\", \"add\", \"remove\"])  # slight bias to single-bit moves\n    new_bits = current[:]\n\n    if move == \"add\":\n        remaining = CAP - cur_w\n        addables = [i for i in zeros if w[i] <= remaining]\n        if addables:\n            # epsilon-greedy on ratio\n            addables.sort(key=lambda i: (v[i]\/w[i], v[i]), reverse=True)\n            if random.random() < 0.85:\n                j = addables[0]\n            else:\n                j = random.choice(addables[:min(3, len(addables))])\n            new_bits[j] = '1'\n            label = f\"move:add idx:{j+1} dV:+{v[j]} dW:+{w[j]}\"\n        else:\n            # fallback to remove if cannot add\n            move = \"remove\"\n\n    if move == \"remove\":\n        if ones:\n            # remove worst ratio\n            irem = min(ones, key=lambda i: (v[i]\/w[i], -w[i]))\n            new_bits[irem] = '0'\n            label = f\"move:remove idx:{irem+1} dV:-{v[irem]} dW:-{w[irem]}\"\n        else:\n            label = \"move:noop\"\n\n    if move == \"swap\":\n        if ones and zeros:\n            irem = random.choice(ones)\n            remaining = CAP - (cur_w - w[irem])\n            addables = [j for j in zeros if w[j] <= remaining]\n            if addables:\n                # choose best by ratio then value\n                jadd = max(addables, key=lambda j: (v[j]\/w[j], v[j]))\n                # Only perform if it is not a null swap (i.e., improves value density or value)\n                new_bits[irem] = '0'\n                new_bits[jadd] = '1'\n                dV = -v[irem] + v[jadd]\n                dW = -w[irem] + w[jadd]\n                label = f\"move:swap out:{irem+1} in:{jadd+1} dV:{dV:+d} dW:{dW:+d}\"\n            else:\n                # cannot add after removal -> cancel swap\n                label = \"move:noop\"\n        else:\n            label = \"move:noop\"\n\n    new_bits = drop_until_feasible(new_bits)\n    return (\"\".join(new_bits), label)\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong but controlled perturbation: flip k bits, then drop-only repair\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def drop_until_feasible(bs):\n        bs = bs[:]\n        # Drop lowest density items until within capacity\n        ones = [i for i, c in enumerate(bs) if c == '1']\n        tw = sum(w[i] for i in ones)\n        if tw <= CAP:\n            return bs\n        for idx in sorted(ones, key=lambda i: (v[i]\/w[i], -w[i])):\n            if tw <= CAP:\n                break\n            if bs[idx] == '1':\n                bs[idx] = '0'\n                tw -= w[idx]\n        return bs\n\n    if not is_valid_bits(solution):\n        bits = ['0'] * 24\n    else:\n        bits = list(solution)\n\n    n = len(bits)\n    k = random.choice([2, 3])\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flips = 0\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n        flips += 1\n        if flips >= k:\n            break\n\n    bits = drop_until_feasible(bits)\n    return ''.join(bits)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_0_1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Feasible -> cost = -total_value; infeasible -> +inf (we minimize cost)\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n\n    total_w = 0\n    total_v = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            wi = w[i]\n            vi = v[i]\n            total_w += wi\n            if total_w > CAP:\n                return math.inf\n            total_v += vi\n    return float(-total_v)\n","Vecindad":"import random\nimport itertools\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_bits, move_label); always feasible; excludes items with w>CAP\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        # Fallback to a minimal feasible seed (deterministic pattern using best items under CAP)\n        seed = ['0'] * n\n        # Greedy by value\/weight among items allowed (w<=CAP)\n        idxs = [i for i in range(n) if w[i] <= CAP]\n        idxs.sort(key=lambda i: (v[i] \/ w[i], v[i]), reverse=True)\n        tw = 0\n        for i in idxs:\n            if tw + w[i] <= CAP:\n                seed[i] = '1'\n                tw += w[i]\n        return (\"\".join(seed), \"init=greedy\")\n\n    bits = list(solution)\n\n    # Enforce domain reduction: heavy items cannot be selected; if present, drop them\n    changed = False\n    for i in range(n):\n        if bits[i] == '1' and w[i] > CAP:\n            bits[i] = '0'\n            changed = True\n    if changed:\n        solution = \"\".join(bits)\n\n    ones = [i for i, c in enumerate(bits) if c == '1']\n    zeros = [i for i, c in enumerate(bits) if c == '0' and w[i] <= CAP]\n\n    cur_w = sum(w[i] for i in ones)\n    cur_v = sum(v[i] for i in ones)\n\n    # Helper to compute best 2-item add within capacity\n    def best_pair_add(candidates, capacity):\n        best = None\n        for i, j in itertools.combinations(candidates, 2):\n            tw = w[i] + w[j]\n            if tw <= capacity:\n                tv = v[i] + v[j]\n                if (best is None) or (tv > best[0]):\n                    best = (tv, (i, j))\n        return best\n\n    # Helper: attempt 1-1 swap to improve or diversify within feasibility\n    def try_swap_1_1():\n        if not ones or not zeros:\n            return None\n        # Evaluate potential swaps by delta value; restrict zeros to those that can fit after removing i\n        best = None\n        for irem in ones:\n            rem_cap = CAP - (cur_w - w[irem])\n            cand = [j for j in zeros if w[j] <= rem_cap]\n            for jadd in cand:\n                dV = v[jadd] - v[irem]\n                dW = w[jadd] - w[irem]\n                if (best is None) or (dV > best[0]) or (dV == best[0] and v[jadd] > v[best[2]]):\n                    best = (dV, (irem, jadd), jadd, dW)\n        return best\n\n    # Move selection with capacity-aware probabilities\n    remaining = CAP - cur_w\n    can_add = any(w[j] <= remaining for j in zeros)\n    move_types = []\n    if can_add:\n        move_types += [\"add\"] * 3 + [\"swap1-1\"] * 2 + [\"add2\"]\n    else:\n        move_types += [\"remove\"] * 3 + [\"swap1-1\"] * 2 + [\"swap2-1\"]\n    move = random.choice(move_types)\n\n    new_bits = bits[:]\n    label = \"noop\"\n\n    if move == \"add\" and can_add:\n        # Softmax-like biased pick by value\/weight then value\n        addables = [j for j in zeros if w[j] <= remaining]\n        addables.sort(key=lambda j: (v[j] \/ w[j], v[j]), reverse=True)\n        pick = addables[0] if random.random() < 0.85 else random.choice(addables[:max(1, min(3, len(addables)))])\n        new_bits[pick] = '1'\n        label = f\"move=add;idx={pick+1};dV=+{v[pick]};dW=+{w[pick]}\"\n\n    elif move == \"remove\" and ones:\n        # Remove worst by value density (tie-break heavier first)\n        irem = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n        new_bits[irem] = '0'\n        label = f\"move=remove;idx={irem+1};dV=-{v[irem]};dW=-{w[irem]}\"\n\n    elif move == \"swap1-1\":\n        best = try_swap_1_1()\n        if best is not None and (best[0] >= 0 or random.random() < 0.25):\n            irem, jadd = best[1]\n            new_bits[irem] = '0'\n            new_bits[jadd] = '1'\n            label = f\"move=swap1-1;out={irem+1};in={jadd+1};dV={best[0]:+d}\"\n        elif ones:\n            # fallback: remove\n            irem = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            new_bits[irem] = '0'\n            label = f\"move=remove_fallback;idx={irem+1};dV=-{v[irem]};dW=-{w[irem]}\"\n\n    elif move == \"add2\" and zeros:\n        pair = best_pair_add([j for j in zeros if w[j] <= remaining], remaining)\n        if pair is not None:\n            _, (j1, j2) = pair\n            new_bits[j1] = '1'\n            new_bits[j2] = '1'\n            label = f\"move=add2;in1={j1+1};in2={j2+1};dV=+{v[j1]+v[j2]};dW=+{w[j1]+w[j2]}\"\n        else:\n            # fallback to single add if possible\n            addables = [j for j in zeros if w[j] <= remaining]\n            if addables:\n                j = max(addables, key=lambda j: (v[j] \/ w[j], v[j]))\n                new_bits[j] = '1'\n                label = f\"move=add_fallback;idx={j+1};dV=+{v[j]};dW=+{w[j]}\"\n\n    elif move == \"swap2-1\" and len(ones) >= 2 and zeros:\n        # Remove two, add one best that fits\n        best_move = None\n        for i1, i2 in itertools.combinations(ones, 2):\n            freed = w[i1] + w[i2]\n            rem_cap = CAP - (cur_w - freed)\n            cand = [j for j in zeros if w[j] <= rem_cap]\n            if not cand:\n                continue\n            jadd = max(cand, key=lambda j: (v[j] \/ w[j], v[j]))\n            dV = v[jadd] - (v[i1] + v[i2])\n            if (best_move is None) or (dV > best_move[0]):\n                best_move = (dV, (i1, i2, jadd))\n        if best_move is not None and (best_move[0] >= 0 or random.random() < 0.2):\n            i1, i2, jadd = best_move[1]\n            new_bits[i1] = '0'\n            new_bits[i2] = '0'\n            new_bits[jadd] = '1'\n            label = f\"move=swap2-1;out1={i1+1};out2={i2+1};in={jadd+1};dV={best_move[0]:+d}\"\n        elif ones:\n            # fallback: remove one worst\n            irem = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            new_bits[irem] = '0'\n            label = f\"move=remove_fallback;idx={irem+1};dV=-{v[irem]};dW=-{w[irem]}\"\n\n    # Final feasibility check (should already be feasible); if overweight due to any logic, repair by dropping lowest density\n    ones_new = [i for i, c in enumerate(new_bits) if c == '1']\n    tw = sum(w[i] for i in ones_new)\n    if tw > CAP:\n        # drop to feasibility\n        for idx in sorted(ones_new, key=lambda i: (v[i] \/ w[i], -w[i])):\n            new_bits[idx] = '0'\n            tw -= w[idx]\n            if tw <= CAP:\n                break\n        label = \"repair=drop_low_density\" if label == \"noop\" else label+\";repair=drop_low_density\"\n\n    return (\"\".join(new_bits), label)\n","Perturbacion":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    # Remove r in {2,3} selected items (if available), then exact refill via DP on remaining capacity\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    n = 24\n    bits = ['0'] * n\n    if isinstance(solution, str) and len(solution) == n and all(c in '01' for c in solution):\n        bits = list(solution)\n\n    # Enforce domain reduction: heavy items cannot be selected\n    for i in range(n):\n        if bits[i] == '1' and w[i] > CAP:\n            bits[i] = '0'\n\n    ones = [i for i, c in enumerate(bits) if c == '1']\n    zeros = [i for i, c in enumerate(bits) if c == '0' and w[i] <= CAP]\n\n    # Randomly remove r items from current ones\n    if ones:\n        r = 2 if len(ones) < 3 else random.choice([2, 3])\n        r = min(r, len(ones))\n        remove_idx = random.sample(ones, r)\n        for i in remove_idx:\n            bits[i] = '0'\n\n    # Compute remaining capacity\n    cur_w = sum(w[i] for i, c in enumerate(bits) if c == '1')\n    remaining = max(0, CAP - cur_w)\n\n    # Exact refill via 0\/1 knapsack DP over zeros within remaining capacity\n    candidates = [j for j in range(n) if bits[j] == '0' and w[j] <= remaining]\n    if remaining > 0 and candidates:\n        # dp[c] = (value, chosen_set_bitmask indices mapping via list) - since remaining<=9, we can store choices directly\n        dp = [(0, []) for _ in range(remaining + 1)]\n        for j in candidates:\n            wt = w[j]\n            val = v[j]\n            for cap in range(remaining, wt - 1, -1):\n                prev_val, prev_set = dp[cap - wt]\n                cand_val = prev_val + val\n                if cand_val > dp[cap][0]:\n                    dp[cap] = (cand_val, prev_set + [j])\n        # choose best cap\n        best_cap = max(range(remaining + 1), key=lambda c: dp[c][0])\n        refill_set = dp[best_cap][1]\n        for j in refill_set:\n            bits[j] = '1'\n\n    # Ensure feasibility (should be)\n    # If any overweight due to unforeseen issue, drop lowest density until feasible\n    cur_w2 = sum(w[i] for i, c in enumerate(bits) if c == '1')\n    if cur_w2 > CAP:\n        ones2 = [i for i, c in enumerate(bits) if c == '1']\n        for idx in sorted(ones2, key=lambda i: (v[i] \/ w[i], -w[i])):\n            bits[idx] = '0'\n            cur_w2 -= w[idx]\n            if cur_w2 <= CAP:\n                break\n\n    return ''.join(bits)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"CSV_ASC_UNIQUE_1BASED (solution is a comma-separated string of ascending unique 1-based indices in [1,24], e.g., \"4,8,18\"; empty set as \"\")","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a cost (lower is better). Feasible: cost = -total_value. Infeasible: large positive penalty.\n    # Representation: CSV string of ascending unique 1-based indices in [1,24]. Empty set -> \"\".\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Robust parsing (accept CSV string; tolerate stray spaces; accept empty string)\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            idx_list: List[int] = []\n        else:\n            try:\n                idx_list = [int(tok) for tok in s.split(',') if tok.strip() != \"\"]\n            except Exception:\n                return float(1e15)\n    elif isinstance(solution, list):\n        # Be tolerant if a list is passed; enforce ints only\n        idx_list = []\n        for x in solution:\n            if not isinstance(x, int):\n                return float(1e15)\n            idx_list.append(x)\n    else:\n        return float(1e15)\n\n    # Canonicalize: unique + sorted\n    seen = set()\n    canon = []\n    for i in idx_list:\n        if not isinstance(i, int):\n            return float(1e15)\n        if i < 1 or i > n:\n            return float(1e15)\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    canon.sort()\n\n    total_time = 0\n    total_value = 0\n    for idx in canon:\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_csv, NB_Type, Movement_Type)\n    # Representation: CSV of ascending unique 1-based indices in [1,24]\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            return sorted({int(tok) for tok in s.split(',') if tok.strip() != \"\"})\n        elif isinstance(sol, list):\n            return sorted(set(int(x) for x in sol))\n        else:\n            return []\n\n    def encode_csv(lst: List[int]) -> str:\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst: List[int]) -> int:\n        return sum(times[i] for i in lst)\n\n    def feasible(lst: List[int]) -> bool:\n        return total_time_of(lst) <= capacity and all(1 <= i <= n for i in lst) and len(set(lst)) == len(lst)\n\n    def greedy_repair(lst: List[int]) -> List[int]:\n        # Remove items with worst value\/time ratio until feasible\n        cur = sorted(set(lst))\n        while total_time_of(cur) > capacity and cur:\n            ratios = [(values[i]\/max(1, times[i]), i) for i in cur]\n            ratios.sort()  # worst first\n            cur.remove(ratios[0][1])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n    cur = sorted(set(cur))\n\n    # Precompute remaining capacity\n    cur_time = total_time_of(cur)\n    # Retry a bounded number of times to ensure progress\n    for _ in range(32):\n        move_types = []\n        if len(cur) < n:\n            move_types.append(\"add\")\n        if len(cur) > 0:\n            move_types.append(\"remove\")\n        if 0 < len(cur) < n:\n            move_types.append(\"swap\")\n        # Add a 2-exchange occasionally\n        if len(cur) >= 1 and len(cur) <= n - 1:\n            move_types.append(\"two_exchange\")\n        if not move_types:\n            break\n        move = random.choice(move_types)\n        nxt = cur.copy()\n        if move == \"add\":\n            present = set(nxt)\n            candidates = [i for i in range(1, n+1) if i not in present]\n            if candidates:\n                # Prefer higher value\/time that fits\n                candidates.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                # pick among top-k for diversity\n                pick_pool = candidates[:min(5, len(candidates))]\n                idx = random.choice(pick_pool)\n                if cur_time + times[idx] <= capacity:\n                    nxt.append(idx)\n                else:\n                    # try to repair by ejecting worst items until it fits\n                    nxt.append(idx)\n                    nxt = greedy_repair(nxt)\n        elif move == \"remove\":\n            if nxt:\n                # remove worst ratio item to free capacity\n                ratios = [(values[i]\/max(1, times[i]), i) for i in nxt]\n                ratios.sort()\n                rem = random.choice(ratios[:min(3, len(ratios))])[1]\n                nxt.remove(rem)\n        elif move == \"swap\":\n            if nxt:\n                present = set(nxt)\n                out_item = random.choice(nxt)\n                absent = [i for i in range(1, n+1) if i not in present]\n                if absent:\n                    # try beneficial incoming\n                    absent.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                    in_item = random.choice(absent[:min(5, len(absent))])\n                    nxt.remove(out_item)\n                    nxt.append(in_item)\n                    if not feasible(nxt):\n                        nxt = greedy_repair(nxt)\n        else:  # two_exchange\n            present = set(nxt)\n            if len(nxt) >= 1:\n                out_item = random.choice(nxt)\n                absent = [i for i in range(1, n+1) if i not in present]\n                if absent:\n                    in_item = random.choice(absent)\n                    nxt.remove(out_item)\n                    nxt.append(in_item)\n                    if not feasible(nxt):\n                        nxt = greedy_repair(nxt)\n        nxt = sorted(set(nxt))\n        if nxt != cur:\n            return (encode_csv(nxt), \"Neighbour\", move.capitalize())\n\n    # Deterministic fallback: try best single add that fits; else remove worst if non-empty\n    present = set(cur)\n    best_add = None\n    best_gain = -1\n    for i in range(1, n+1):\n        if i in present:\n            continue\n        if total_time_of(cur) + times[i] <= capacity:\n            gain = values[i]\n            if gain > best_gain:\n                best_gain = gain\n                best_add = i\n    if best_add is not None:\n        nxt = sorted(cur + [best_add])\n        return (encode_csv(nxt), \"Neighbour\", \"Add\")\n    if cur:\n        ratios = [(values[i]\/max(1, times[i]), i) for i in cur]\n        ratios.sort()\n        rem = ratios[0][1]\n        nxt = cur.copy()\n        nxt.remove(rem)\n        return (encode_csv(sorted(nxt)), \"Neighbour\", \"Remove\")\n\n    return (encode_csv(cur), \"None\", \"NoOp\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # K-shake with greedy refill guided by value\/time ratio, followed by repair if needed\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            return sorted({int(tok) for tok in s.split(',') if tok.strip() != \"\"})\n        elif isinstance(sol, list):\n            return sorted(set(int(x) for x in sol))\n        else:\n            return []\n\n    def encode_csv(lst: List[int]) -> str:\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst: List[int]) -> int:\n        return sum(times[i] for i in lst)\n\n    def feasible(lst: List[int]) -> bool:\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst) and all(1 <= i <= n for i in lst)\n\n    def greedy_repair(lst: List[int]) -> List[int]:\n        cur = sorted(set(lst))\n        while total_time_of(cur) > capacity and cur:\n            ratios = [(values[i]\/max(1, times[i]), i) for i in cur]\n            ratios.sort()\n            cur.remove(ratios[0][1])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n\n    # Shake: remove r items (1..min(3,len(cur)))\n    r = 0\n    if cur:\n        r = random.randint(1, min(3, len(cur)))\n        for rem in random.sample(cur, r):\n            if rem in cur:\n                cur.remove(rem)\n\n    # Greedy refill by ratio until no more fit\n    remaining = capacity - total_time_of(cur)\n    present = set(cur)\n    candidates = [i for i in range(1, n+1) if i not in present]\n    candidates.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n    for i in candidates:\n        if times[i] <= remaining:\n            cur.append(i)\n            remaining -= times[i]\n\n    # Final repair (safety)\n    if not feasible(cur):\n        cur = greedy_repair(cur)\n\n    return encode_csv(sorted(set(cur)))\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"CSV_ASC_UNIQUE_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a cost (lower is better). Feasible -> -total_value; Infeasible -> large positive penalty\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Parse CSV representation or tolerant list input\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            idx_list = []\n        else:\n            try:\n                idx_list = [int(tok.strip()) for tok in s.split(',') if tok.strip()]\n            except Exception:\n                return float(1e12)\n    elif isinstance(solution, list):\n        idx_list = []\n        try:\n            for x in solution:\n                idx_list.append(int(x))\n        except Exception:\n            return float(1e12)\n    else:\n        return float(1e12)\n\n    # Canonicalize and validate bounds\/uniqueness\n    seen = set()\n    canon = []\n    for i in idx_list:\n        if i < 1 or i > n:\n            return float(1e12)\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    canon.sort()\n\n    total_time = 0\n    total_value = 0\n    for idx in canon:\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e12)\n        total_value += values[idx]\n\n    return float(-total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_csv, \"Neighbour\", Movement_Type)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            out = []\n            for tok in s.split(','):\n                tok = tok.strip()\n                if not tok:\n                    continue\n                i = int(tok)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        elif isinstance(sol, list):\n            out = []\n            for x in sol:\n                i = int(x)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        else:\n            return []\n\n    def encode_csv(lst):\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst):\n        return sum(times[i] for i in lst)\n\n    def feasible(lst):\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst) and all(1 <= i <= n for i in lst)\n\n    def greedy_repair(lst):\n        cur = sorted(set(lst))\n        if not cur:\n            return cur\n        # remove worst ratio first; break ties by larger time to free capacity faster\n        while total_time_of(cur) > capacity and cur:\n            ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in cur]\n            ratios.sort()  # worst ratio, then larger time\n            cur.remove(ratios[0][2])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n    cur_time = total_time_of(cur)\n\n    # Candidate helper\n    def absent_items(present_set):\n        return [i for i in range(1, n+1) if i not in present_set]\n\n    # Attempt a bounded number of random guided moves\n    for _ in range(32):\n        present = set(cur)\n        moves = []\n        if len(cur) < n:\n            moves.append(\"add\")\n        if len(cur) > 0:\n            moves.append(\"remove\")\n        if 0 < len(cur) < n:\n            moves.append(\"swap\")\n        if len(cur) >= 1 and len(cur) <= n - 1:\n            moves.append(\"two_exchange\")  # remove 1, add 2 or remove 2, add 1\n        if not moves:\n            break\n        move = random.choice(moves)\n        nxt = cur.copy()\n\n        if move == \"add\":\n            cand = absent_items(present)\n            if cand:\n                cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                pick = random.choice(cand[:min(5, len(cand))])\n                nxt.append(pick)\n                nxt = greedy_repair(nxt)\n        elif move == \"remove\":\n            # remove one of the worst ratio items (sampled)\n            if nxt:\n                ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in nxt]\n                ratios.sort()\n                pick = random.choice(ratios[:min(3, len(ratios))])[2]\n                nxt.remove(pick)\n        elif move == \"swap\":\n            if nxt:\n                out_item = random.choice(nxt)\n                cand = absent_items(present)\n                if cand:\n                    cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                    in_item = random.choice(cand[:min(6, len(cand))])\n                    nxt.remove(out_item)\n                    nxt.append(in_item)\n                    nxt = greedy_repair(nxt)\n        else:  # two_exchange (1-2 or 2-1, chosen randomly)\n            if not nxt:\n                continue\n            if random.random() < 0.5 and len(nxt) >= 1:  # 1 -> 2\n                out_item = random.choice(nxt)\n                nxt.remove(out_item)\n                cand = absent_items(set(nxt))\n                cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                # try to add up to two best that fit\n                for i in cand[:min(8, len(cand))]:\n                    nxt.append(i)\n                    if total_time_of(nxt) > capacity:\n                        nxt.pop()\n                nxt = greedy_repair(nxt)\n            else:  # 2 -> 1\n                if len(nxt) >= 2:\n                    outs = random.sample(nxt, 2)\n                    for o in outs:\n                        nxt.remove(o)\n                    cand = absent_items(set(nxt))\n                    cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                    if cand:\n                        nxt.append(cand[0])\n                    nxt = greedy_repair(nxt)\n\n        nxt = sorted(set(nxt))\n        if nxt != cur and feasible(nxt):\n            return (encode_csv(nxt), \"Neighbour\", move.capitalize())\n\n    # Fallback: best single improving add that fits; else best 1-for-1 swap; else remove worst\n    present = set(cur)\n    best_add = None\n    best_gain = -1\n    cur_value = sum(values[i] for i in cur)\n    cur_time = total_time_of(cur)\n\n    # Try add\n    for i in range(1, n+1):\n        if i in present:\n            continue\n        if cur_time + times[i] <= capacity and values[i] > best_gain:\n            best_gain = values[i]\n            best_add = i\n    if best_add is not None:\n        nxt = sorted(cur + [best_add])\n        return (encode_csv(nxt), \"Neighbour\", \"Add\")\n\n    # Try best swap\n    best_delta = -10**9\n    best_pair = None\n    for o in cur:\n        for i in range(1, n+1):\n            if i in present:\n                continue\n            new_time = cur_time - times[o] + times[i]\n            if new_time <= capacity:\n                delta = values[i] - values[o]\n                if delta > best_delta:\n                    best_delta = delta\n                    best_pair = (o, i)\n    if best_pair is not None:\n        o, i = best_pair\n        nxt = cur.copy()\n        nxt.remove(o)\n        nxt.append(i)\n        return (encode_csv(sorted(nxt)), \"Neighbour\", \"Swap\")\n\n    # Remove worst ratio as last resort\n    if cur:\n        ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in cur]\n        ratios.sort()\n        rem = ratios[0][2]\n        nxt = cur.copy()\n        nxt.remove(rem)\n        return (encode_csv(sorted(nxt)), \"Neighbour\", \"Remove\")\n\n    return (encode_csv(cur), \"None\", \"NoOp\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Random k-shake (k in {2,3}) with greedy refill and repair; ensure canonical change if possible\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            out = []\n            for tok in s.split(','):\n                tok = tok.strip()\n                if not tok:\n                    continue\n                i = int(tok)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        elif isinstance(sol, list):\n            out = []\n            for x in sol:\n                i = int(x)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        else:\n            return []\n\n    def encode_csv(lst):\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst):\n        return sum(times[i] for i in lst)\n\n    def feasible(lst):\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst) and all(1 <= i <= n for i in lst)\n\n    def greedy_repair(lst):\n        cur = sorted(set(lst))\n        if not cur:\n            return cur\n        while total_time_of(cur) > capacity and cur:\n            ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in cur]\n            ratios.sort()\n            cur.remove(ratios[0][2])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n    orig = cur.copy()\n\n    # Shake: k random operations from {remove, add, swap}\n    for _ in range(random.choice([2, 3])):\n        present = set(cur)\n        ops = []\n        if cur:\n            ops.append(\"remove\")\n        if len(cur) < n:\n            ops.append(\"add\")\n        if 0 < len(cur) < n:\n            ops.append(\"swap\")\n        if not ops:\n            break\n        op = random.choice(ops)\n        if op == \"remove\" and cur:\n            cur.remove(random.choice(cur))\n        elif op == \"add\" and len(cur) < n:\n            cand = [i for i in range(1, n+1) if i not in present]\n            if cand:\n                cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                cur.append(random.choice(cand[:min(6, len(cand))]))\n        elif op == \"swap\" and cur and len(cur) < n:\n            out = random.choice(cur)\n            cand = [i for i in range(1, n+1) if i not in present]\n            if cand:\n                cur.remove(out)\n                cur.append(random.choice(cand))\n\n    # Greedy refill by value\/time ratio\n    cur = sorted(set(cur))\n    remaining = capacity - total_time_of(cur)\n    present = set(cur)\n    candidates = [i for i in range(1, n+1) if i not in present]\n    candidates.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n    for i in candidates:\n        if times[i] <= remaining:\n            cur.append(i)\n            remaining -= times[i]\n\n    # Repair and finalize\n    if not feasible(cur):\n        cur = greedy_repair(cur)\n\n    cur = sorted(set(cur))\n    if cur == orig:\n        # force a minimal change if possible\n        if cur:\n            cur = cur[1:] if len(cur) > 1 else []\n        else:\n            # add best single that fits\n            best = None\n            best_ratio = -1.0\n            for i in range(1, n+1):\n                if times[i] <= capacity:\n                    r = values[i]\/max(1, times[i])\n                    if r > best_ratio:\n                        best_ratio = r\n                        best = i\n            if best is not None:\n                cur = [best]\n    return encode_csv(cur)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"CSV_ASC_UNIQUE_1BASED","Evaluacion":"import math\nfrom typing import Union, List\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Returns a cost (lower is better). Feasible -> -total_value; Infeasible -> large positive penalty with gradient\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Parse CSV representation or tolerant list input\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            idx_list = []\n        else:\n            try:\n                idx_list = [int(tok.strip()) for tok in s.split(',') if tok.strip()]\n            except Exception:\n                return float(1e6)\n    elif isinstance(solution, list):\n        idx_list = []\n        try:\n            for x in solution:\n                idx_list.append(int(x))\n        except Exception:\n            return float(1e6)\n    else:\n        return float(1e6)\n\n    # Canonicalize and validate bounds\/uniqueness\n    seen = set()\n    canon = []\n    for i in idx_list:\n        if i < 1 or i > n:\n            return float(1e6)\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    canon.sort()\n\n    total_time = 0\n    total_value = 0\n    for idx in canon:\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            overflow = total_time - capacity\n            return float(1e6 + overflow)\n        total_value += values[idx]\n\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic randomness per input for reproducibility\n    rnd = random.Random(hash(str(solution)) & 0xFFFFFFFF)\n\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol) -> List[int]:\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            out = []\n            for tok in s.split(','):\n                tok = tok.strip()\n                if not tok:\n                    continue\n                i = int(tok)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        elif isinstance(sol, list):\n            out = []\n            for x in sol:\n                i = int(x)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        else:\n            return []\n\n    def encode_csv(lst: List[int]) -> str:\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst: List[int]) -> int:\n        return sum(times[i] for i in lst)\n\n    def total_value_of(lst: List[int]) -> int:\n        return sum(values[i] for i in lst)\n\n    def feasible(lst: List[int]) -> bool:\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst) and all(1 <= i <= n for i in lst)\n\n    # Precompute feasible singletons and ratios\n    feasible_items = [i for i in range(1, n+1) if times[i] <= capacity]\n    ratio = [0.0]*(n+1)\n    for i in range(1, n+1):\n        ratio[i] = values[i] \/ max(1, times[i])\n\n    cur = parse_csv(solution)\n    cur_set = set(cur)\n    cur_time = total_time_of(cur)\n    cur_value = total_value_of(cur)\n\n    # 1) Try best improving Add\n    best_add = None\n    best_add_delta = -10**9\n    for i in feasible_items:\n        if i in cur_set:\n            continue\n        if cur_time + times[i] <= capacity:\n            delta = values[i]\n            if delta > best_add_delta:\n                best_add_delta = delta\n                best_add = i\n    if best_add is not None and best_add_delta > 0:\n        nxt = sorted(cur + [best_add])\n        return (encode_csv(nxt), \"Add\")\n\n    # 2) Try best improving 1-for-1 Swap\n    best_pair = None\n    best_swap_delta = -10**9\n    for o in cur:\n        for i in feasible_items:\n            if i in cur_set:\n                continue\n            new_time = cur_time - times[o] + times[i]\n            if new_time <= capacity:\n                delta = values[i] - values[o]\n                if delta > best_swap_delta:\n                    best_swap_delta = delta\n                    best_pair = (o, i)\n    if best_pair is not None and best_swap_delta > 0:\n        o, i = best_pair\n        nxt = cur.copy()\n        nxt.remove(o)\n        nxt.append(i)\n        return (encode_csv(sorted(nxt)), \"Swap\")\n\n    # 3) Try 2-for-1 and 1-for-2 targeted exchanges (value\/time guided)\n    # 3a) 2 -> 1 (drop two, add one) improving\n    best_21 = None\n    best_21_delta = -10**9\n    if len(cur) >= 2:\n        cur_list = cur[:]  # ensure deterministic pair iteration\n        for a_idx in range(len(cur_list)):\n            a = cur_list[a_idx]\n            for b_idx in range(a_idx+1, len(cur_list)):\n                b = cur_list[b_idx]\n                base_time = cur_time - times[a] - times[b]\n                base_value = cur_value - values[a] - values[b]\n                for i in feasible_items:\n                    if i in cur_set or i == a or i == b:\n                        continue\n                    if base_time + times[i] <= capacity:\n                        delta = (base_value + values[i]) - cur_value\n                        if delta > best_21_delta:\n                            best_21_delta = delta\n                            best_21 = (a, b, i)\n    if best_21 is not None and best_21_delta > 0:\n        a, b, i = best_21\n        nxt = cur.copy()\n        nxt.remove(a); nxt.remove(b); nxt.append(i)\n        return (encode_csv(sorted(nxt)), \"TwoForOne\")\n\n    # 3b) 1 -> 2 (drop one, add two) improving\n    best_12 = None\n    best_12_delta = -10**9\n    absent = [i for i in feasible_items if i not in cur_set]\n    # Prefilter top-k by ratio for efficiency\n    absent_sorted = sorted(absent, key=lambda x: (-ratio[x], -values[x]))\n    top_absent = absent_sorted[:min(10, len(absent_sorted))]\n    if len(top_absent) >= 2 and len(cur) >= 1:\n        for o in cur:\n            base_time = cur_time - times[o]\n            base_value = cur_value - values[o]\n            for a_idx in range(len(top_absent)):\n                a = top_absent[a_idx]\n                for b_idx in range(a_idx+1, len(top_absent)):\n                    b = top_absent[b_idx]\n                    new_time = base_time + times[a] + times[b]\n                    if new_time <= capacity:\n                        delta = (base_value + values[a] + values[b]) - cur_value\n                        if delta > best_12_delta:\n                            best_12_delta = delta\n                            best_12 = (o, a, b)\n    if best_12 is not None and best_12_delta > 0:\n        o, a, b = best_12\n        nxt = cur.copy()\n        nxt.remove(o); nxt.append(a); nxt.append(b)\n        return (encode_csv(sorted(nxt)), \"OneForTwo\")\n\n    # 4) If no improving move found, produce a feasible lateral move to diversify\n    moves = []\n    # feasible Add (non-improving)\n    add_cands = [i for i in feasible_items if i not in cur_set and cur_time + times[i] <= capacity]\n    if add_cands:\n        add_cands.sort(key=lambda i: (-ratio[i], -values[i]))\n        pick = add_cands[min(rnd.randrange(len(add_cands)), len(add_cands)-1)]\n        nxt = sorted(cur + [pick])\n        return (encode_csv(nxt), \"Add\")\n    # feasible Swap (non-improving)\n    swap_best = None\n    for o in cur:\n        for i in feasible_items:\n            if i in cur_set:\n                continue\n            if cur_time - times[o] + times[i] <= capacity:\n                swap_best = (o, i)\n                break\n        if swap_best:\n            break\n    if swap_best:\n        o, i = swap_best\n        nxt = cur.copy(); nxt.remove(o); nxt.append(i)\n        return (encode_csv(sorted(nxt)), \"Swap\")\n    # Remove worst ratio to guarantee change if possible\n    if cur:\n        worst = sorted(cur, key=lambda x: (ratio[x], times[x]))[0]\n        nxt = cur.copy(); nxt.remove(worst)\n        return (encode_csv(sorted(nxt)), \"Remove\")\n\n    # No change possible (already empty)\n    return (encode_csv(cur), \"NoOp\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Deterministic shake based on input\n    rnd = random.Random((hash(str(solution)) ^ 0x9E3779B97F4A7C15) & 0xFFFFFFFF)\n\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol) -> List[int]:\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            out = []\n            for tok in s.split(','):\n                tok = tok.strip()\n                if not tok:\n                    continue\n                i = int(tok)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        elif isinstance(sol, list):\n            out = []\n            for x in sol:\n                i = int(x)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        else:\n            return []\n\n    def encode_csv(lst: List[int]) -> str:\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst: List[int]) -> int:\n        return sum(times[i] for i in lst)\n\n    def feasible(lst: List[int]) -> bool:\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst)\n\n    # Greedy refill by ratio\n    def greedy_fill(cur: List[int]) -> List[int]:\n        cur = sorted(set(cur))\n        remain = capacity - total_time_of(cur)\n        present = set(cur)\n        candidates = [i for i in range(1, n+1) if i not in present and times[i] <= remain]\n        candidates.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n        for i in candidates:\n            if times[i] <= remain:\n                cur.append(i)\n                remain -= times[i]\n        return sorted(set(cur))\n\n    cur = parse_csv(solution)\n    orig = cur.copy()\n\n    # k-shake: remove up to k items (k in {1,2,3} bounded by size), then add up to k best by ratio\n    if cur:\n        k = min(len(cur), rnd.choice([1,2,3]))\n        to_remove = rnd.sample(cur, k)\n        for x in to_remove:\n            cur.remove(x)\n    \n    # attempt to add some good candidates\n    ratio = [0.0]*(n+1)\n    for i in range(1, n+1):\n        ratio[i] = values[i] \/ max(1, times[i])\n    present = set(cur)\n    candidates = [i for i in range(1, n+1) if i not in present and times[i] <= capacity]\n    candidates.sort(key=lambda i: (-ratio[i], -values[i]))\n    add_budget = rnd.choice([1,2,3])\n    for i in candidates:\n        if total_time_of(cur) + times[i] <= capacity:\n            cur.append(i)\n            if len([1 for _ in range(1)]) >= 0:  # no-op placeholder to keep structure simple\n                pass\n            add_budget -= 1\n            if add_budget == 0:\n                break\n\n    # Greedy repair\/fill to ensure feasibility and density\n    if not feasible(cur):\n        # drop worst ratio until feasible\n        cur = sorted(set(cur))\n        cur.sort(key=lambda x: (ratio[x], times[x]))\n        while not feasible(cur) and cur:\n            cur.pop(0)\n        cur = sorted(set(cur))\n    cur = greedy_fill(cur)\n\n    # Ensure perturbation actually changes solution\n    if cur == orig:\n        if cur:\n            cur = cur[1:] if len(cur) > 1 else []\n        else:\n            # add best single feasible by ratio\n            best = None; best_r = -1.0\n            for i in range(1, n+1):\n                if times[i] <= capacity:\n                    r = values[i]\/max(1, times[i])\n                    if r > best_r:\n                        best_r = r; best = i\n            if best is not None:\n                cur = [best]\n\n    return encode_csv(cur)\n","Version":2}
