{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties for constraint violations and encoding gaps.\n    # Lower is better. Returns a numeric fitness.\n    def max_int(lst):\n        m = 0\n        for v in lst:\n            if v > m:\n                m = v\n        return m\n    # Graph definition (embedded)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9  # malformed solution\n    PEN_GAP = 10**5   # non-contiguous labels\n    PEN_EDGE = 10**4  # per conflicting edge\n    # Type and length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n    # Base objective (k)\n    k = max_int(solution)\n    fitness = float(k)\n    # Contiguity check: labels must be {1,...,k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge constraint violations\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (\"NB_Type\",\"Movement_Type\"))\n    # Representation: list[int] length 9, colors >=1\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\",\"NOOP\"))\n    s = list(int(x) for x in solution)\n    # Determine current k and allow exploring up to k+1\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)  # ensure at least 2\n    # Pick a random vertex and recolor to a different color in [1..max_color+1]\n    v = random.randint(0, 8)\n    # candidate colors include one extra color to enable escaping plateaus\n    candidate_colors = list(range(1, max_color + 2))\n    try:\n        candidate_colors.remove(s[v])\n    except ValueError:\n        pass\n    s[v] = random.choice(candidate_colors)\n    return (s, (\"RECOLOR\",\"RAND_VERTEX\"))\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolor of a subset and optional relabel compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = list(int(x) for x in solution)\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(3, k)\n    # Randomly choose m positions to modify\n    m = random.randint(2, 4)\n    idxs = list(range(9))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n    for i in idxs:\n        s[i] = random.randint(1, max_color)\n    # Optional relabel to compress colors to contiguous 1..k' while preserving equality groups\n    # Map colors by order of appearance\n    mapping = {}\n    next_label = 1\n    for i in range(9):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        s[i] = mapping[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000669195}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties for constraint violations and encoding gaps.\n    # Lower is better. Returns a numeric fitness.\n    def max_int(lst):\n        m = 0\n        for v in lst:\n            if v > m:\n                m = v\n        return m\n    # Graph definition (embedded)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9  # malformed solution\n    PEN_GAP = 10**5   # non-contiguous labels\n    PEN_EDGE = 10**4  # per conflicting edge\n    # Type and length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n    # Base objective (k)\n    k = max_int(solution)\n    fitness = float(k)\n    # Contiguity check: labels must be {1,...,k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge constraint violations\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (\"NB_Type\",\"Movement_Type\"))\n    # Representation: list[int] length 9, colors >=1\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\",\"NOOP\"))\n    s = list(int(x) for x in solution)\n    # Determine current k and allow exploring up to k+1\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)  # ensure at least 2\n    # Pick a random vertex and recolor to a different color in [1..max_color+1]\n    v = random.randint(0, 8)\n    # candidate colors include one extra color to enable escaping plateaus\n    candidate_colors = list(range(1, max_color + 2))\n    try:\n        candidate_colors.remove(s[v])\n    except ValueError:\n        pass\n    s[v] = random.choice(candidate_colors)\n    return (s, (\"RECOLOR\",\"RAND_VERTEX\"))\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolor of a subset and optional relabel compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = list(int(x) for x in solution)\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(3, k)\n    # Randomly choose m positions to modify\n    m = random.randint(2, 4)\n    idxs = list(range(9))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n    for i in idxs:\n        s[i] = random.randint(1, max_color)\n    # Optional relabel to compress colors to contiguous 1..k' while preserving equality groups\n    # Map colors by order of appearance\n    mapping = {}\n    next_label = 1\n    for i in range(9):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        s[i] = mapping[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000594814}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties for constraint violations and encoding gaps.\n    # Lower is better. Returns a numeric fitness.\n    def max_int(lst):\n        m = 0\n        for v in lst:\n            if v > m:\n                m = v\n        return m\n    # Graph definition (embedded)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9  # malformed solution\n    PEN_GAP = 10**5   # non-contiguous labels\n    PEN_EDGE = 10**4  # per conflicting edge\n    # Type and length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n    # Base objective (k)\n    k = max_int(solution)\n    fitness = float(k)\n    # Contiguity check: labels must be {1,...,k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge constraint violations\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (\"NB_Type\",\"Movement_Type\"))\n    # Representation: list[int] length 9, colors >=1\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\",\"NOOP\"))\n    s = list(int(x) for x in solution)\n    # Determine current k and allow exploring up to k+1\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)  # ensure at least 2\n    # Pick a random vertex and recolor to a different color in [1..max_color+1]\n    v = random.randint(0, 8)\n    # candidate colors include one extra color to enable escaping plateaus\n    candidate_colors = list(range(1, max_color + 2))\n    try:\n        candidate_colors.remove(s[v])\n    except ValueError:\n        pass\n    s[v] = random.choice(candidate_colors)\n    return (s, (\"RECOLOR\",\"RAND_VERTEX\"))\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolor of a subset and optional relabel compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = list(int(x) for x in solution)\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(3, k)\n    # Randomly choose m positions to modify\n    m = random.randint(2, 4)\n    idxs = list(range(9))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n    for i in idxs:\n        s[i] = random.randint(1, max_color)\n    # Optional relabel to compress colors to contiguous 1..k' while preserving equality groups\n    # Map colors by order of appearance\n    mapping = {}\n    next_label = 1\n    for i in range(9):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        s[i] = mapping[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000554513}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties; lower is better\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**5\n    PEN_GAP = 10**3\n\n    # Type\/shape checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks and compute k\n    k = 0\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi != x:\n                return HARD_PEN\n            if xi < 1:\n                return HARD_PEN\n            if xi > k:\n                k = xi\n    except Exception:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recoloring with best-improving color choice\n    # Returns (neighbor_solution, (\"RECOLOR\", movement_detail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    s = [int(x) for x in solution]\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u,v) in edges:\n        ui = u-1; vi = v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Compute per-vertex conflict counts\n    conflicts = [0]*9\n    for (u,v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    conflict_vertices = [i for i,c in enumerate(conflicts) if c > 0]\n    move_type = \"RAND_VERTEX\"\n    if conflict_vertices and random.random() < 0.85:\n        v = random.choice(conflict_vertices)\n        move_type = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n\n    # Determine candidate colors: 1..max(k,2)+1 to allow occasional expansion\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)\n    candidates = list(range(1, max_color + 2))\n    cur = s[v]\n    if cur in candidates:\n        candidates.remove(cur)\n\n    # Evaluate local conflicts for each candidate and pick best (tie-break random)\n    best_c = None\n    best_val = None\n    ties = []\n    for c in candidates:\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if (best_val is None) or (loc < best_val):\n            best_val = loc\n            ties = [c]\n        elif loc == best_val:\n            ties.append(c)\n    if not ties:\n        # fallback random change\n        ties = candidates if candidates else [cur]\n    s[v] = random.choice(ties)\n\n    return (s, (\"RECOLOR\", move_type))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or multi-recolor, followed by normalization\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            xi = int(x)\n            if xi not in remap:\n                remap[xi] = nxt\n                nxt += 1\n            out.append(remap[xi])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = [int(x) for x in solution]\n\n    if random.random() < 0.5:\n        # Kempe-chain swap between two colors\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u,v) in edges:\n            ui = u-1; vi = v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        # choose b != a; if only one color present, introduce 2\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            choices = [c for c in colors_present if c != a]\n            if not choices:\n                choices = [a+1]\n            b = random.choice(choices)\n        # BFS over subgraph induced by colors {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        # swap a<->b on component\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # Multi-vertex recolor with chance to use a new color\n        k = 1\n        for x in s:\n            if x > k:\n                k = x\n        m = random.randint(2, 4)\n        idxs = list(range(9))\n        random.shuffle(idxs)\n        idxs = idxs[:m]\n        for i in idxs:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    # Normalize labels to contiguous 1..k'\n    s = normalize_colors(s)\n    return s\n","Resultados":["[1,2,3,1,2,3,2,1,3]",1000000000,"[1,2,3,1,2,3,2,1,3]",1000000000],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0008017659}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties; lower is better\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**5\n    PEN_GAP = 10**3\n\n    # Type\/shape checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks and compute k\n    k = 0\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi != x:\n                return HARD_PEN\n            if xi < 1:\n                return HARD_PEN\n            if xi > k:\n                k = xi\n    except Exception:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recoloring with best-improving color choice\n    # Returns (neighbor_solution, (\"RECOLOR\", movement_detail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    s = [int(x) for x in solution]\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u,v) in edges:\n        ui = u-1; vi = v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Compute per-vertex conflict counts\n    conflicts = [0]*9\n    for (u,v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    conflict_vertices = [i for i,c in enumerate(conflicts) if c > 0]\n    move_type = \"RAND_VERTEX\"\n    if conflict_vertices and random.random() < 0.85:\n        v = random.choice(conflict_vertices)\n        move_type = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n\n    # Determine candidate colors: 1..max(k,2)+1 to allow occasional expansion\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)\n    candidates = list(range(1, max_color + 2))\n    cur = s[v]\n    if cur in candidates:\n        candidates.remove(cur)\n\n    # Evaluate local conflicts for each candidate and pick best (tie-break random)\n    best_c = None\n    best_val = None\n    ties = []\n    for c in candidates:\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if (best_val is None) or (loc < best_val):\n            best_val = loc\n            ties = [c]\n        elif loc == best_val:\n            ties.append(c)\n    if not ties:\n        # fallback random change\n        ties = candidates if candidates else [cur]\n    s[v] = random.choice(ties)\n\n    return (s, (\"RECOLOR\", move_type))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or multi-recolor, followed by normalization\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            xi = int(x)\n            if xi not in remap:\n                remap[xi] = nxt\n                nxt += 1\n            out.append(remap[xi])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = [int(x) for x in solution]\n\n    if random.random() < 0.5:\n        # Kempe-chain swap between two colors\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u,v) in edges:\n            ui = u-1; vi = v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        # choose b != a; if only one color present, introduce 2\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            choices = [c for c in colors_present if c != a]\n            if not choices:\n                choices = [a+1]\n            b = random.choice(choices)\n        # BFS over subgraph induced by colors {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        # swap a<->b on component\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # Multi-vertex recolor with chance to use a new color\n        k = 1\n        for x in s:\n            if x > k:\n                k = x\n        m = random.randint(2, 4)\n        idxs = list(range(9))\n        random.shuffle(idxs)\n        idxs = idxs[:m]\n        for i in idxs:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    # Normalize labels to contiguous 1..k'\n    s = normalize_colors(s)\n    return s\n","Resultados":["[1,2,3,1,2,3,2,1,3]",1000000000,"[1,2,3,1,2,3,2,1,3]",1000000000],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001034771}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties; lower is better\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**5\n    PEN_GAP = 10**3\n\n    # Type\/shape checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks and compute k\n    k = 0\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi != x:\n                return HARD_PEN\n            if xi < 1:\n                return HARD_PEN\n            if xi > k:\n                k = xi\n    except Exception:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recoloring with best-improving color choice\n    # Returns (neighbor_solution, (\"RECOLOR\", movement_detail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    s = [int(x) for x in solution]\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u,v) in edges:\n        ui = u-1; vi = v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Compute per-vertex conflict counts\n    conflicts = [0]*9\n    for (u,v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    conflict_vertices = [i for i,c in enumerate(conflicts) if c > 0]\n    move_type = \"RAND_VERTEX\"\n    if conflict_vertices and random.random() < 0.85:\n        v = random.choice(conflict_vertices)\n        move_type = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n\n    # Determine candidate colors: 1..max(k,2)+1 to allow occasional expansion\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)\n    candidates = list(range(1, max_color + 2))\n    cur = s[v]\n    if cur in candidates:\n        candidates.remove(cur)\n\n    # Evaluate local conflicts for each candidate and pick best (tie-break random)\n    best_c = None\n    best_val = None\n    ties = []\n    for c in candidates:\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if (best_val is None) or (loc < best_val):\n            best_val = loc\n            ties = [c]\n        elif loc == best_val:\n            ties.append(c)\n    if not ties:\n        # fallback random change\n        ties = candidates if candidates else [cur]\n    s[v] = random.choice(ties)\n\n    return (s, (\"RECOLOR\", move_type))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or multi-recolor, followed by normalization\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            xi = int(x)\n            if xi not in remap:\n                remap[xi] = nxt\n                nxt += 1\n            out.append(remap[xi])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = [int(x) for x in solution]\n\n    if random.random() < 0.5:\n        # Kempe-chain swap between two colors\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u,v) in edges:\n            ui = u-1; vi = v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        # choose b != a; if only one color present, introduce 2\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            choices = [c for c in colors_present if c != a]\n            if not choices:\n                choices = [a+1]\n            b = random.choice(choices)\n        # BFS over subgraph induced by colors {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        # swap a<->b on component\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # Multi-vertex recolor with chance to use a new color\n        k = 1\n        for x in s:\n            if x > k:\n                k = x\n        m = random.randint(2, 4)\n        idxs = list(range(9))\n        random.shuffle(idxs)\n        idxs = idxs[:m]\n        for i in idxs:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    # Normalize labels to contiguous 1..k'\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0008462371}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    B2 = 10**9  # conflicts dominance\n    B1 = 10**6  # contiguity next\n\n    # Basic type\/shape checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n\n    # Coerce to ints and validate domain >=1\n    s = []\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Compute k and contiguity gap\n    S = set(s)\n    k = max(S) if S else 0\n    gaps = 0\n    if not S or min(S) != 1 or max(S) != len(S):\n        gaps = 1\n\n    fitness = conflicts * B2 + gaps * B1 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (MoveCategory, MoveDetail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Coerce to ints\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Per-vertex conflict counts\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n\n    conflicted = [i for i, c in enumerate(vconf) if c > 0]\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Occasionally perform a small Kempe-chain swap as a neighbor\n    if random.random() < 0.15:\n        if not conflicted:\n            start = random.randrange(0, 9)\n        else:\n            start = random.choice(conflicted)\n        a = s[start]\n        # choose b != a from present colors or a+1 if only one color\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        # BFS on {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n        s = normalize_colors(s)\n        return (s, (\"KEMPE\", \"LOCAL_SWAP\"))\n\n    # Otherwise recolor a vertex (best-improving local choice)\n    if conflicted and random.random() < 0.9:\n        v = random.choice(conflicted)\n        mv_detail = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n        mv_detail = \"RANDOM_VERTEX\"\n\n    k = max(s)\n    # Candidate colors restricted to 1..k; allow k+1 only if no improving color exists\n    candidates = list(range(1, k+1))\n\n    # Evaluate local conflicts for each candidate\n    cur = s[v]\n    best_c = cur\n    best_val = 10**9\n    improving_found = False\n    for c in candidates:\n        if c == cur:\n            continue\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if loc < best_val:\n            best_val = loc\n            best_c = c\n    # Current local conflicts\n    cur_loc = sum(1 for nb in adj[v] if s[nb] == cur)\n    if best_val < cur_loc:\n        improving_found = True\n        s[v] = best_c\n    else:\n        # Optionally try k+1 only if it strictly reduces local conflicts\n        new_color = k + 1\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == new_color:\n                loc += 1\n        if loc < cur_loc and random.random() < 0.25:\n            s[v] = new_color\n        else:\n            # fallback: change to a different existing color (tie-breaking by minimal local conflicts)\n            s[v] = best_c if best_c != cur else cur\n\n    s = normalize_colors(s)\n    return (s, (\"RECOLOR\", mv_detail))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or color permutation + multi-shake, then normalize\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return solution\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # 50%: Kempe-chain on random start\n    if random.random() < 0.5:\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u, v) in edges:\n            ui = u - 1; vi = v - 1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # 50%: color permutation + shake top-conflicted vertices\n        # Compute conflicts per vertex\n        vconf = [0]*9\n        for (u, v) in edges:\n            if s[u-1] == s[v-1]:\n                vconf[u-1] += 1\n                vconf[v-1] += 1\n        order = list(range(9))\n        order.sort(key=lambda i: vconf[i], reverse=True)\n        m = random.randint(3, 5)\n        top = order[:m]\n        # Random color permutation\n        colors = sorted(list({c for c in s}))\n        perm = colors[:]\n        random.shuffle(perm)\n        cmap = {c: perm[i] for i, c in enumerate(colors)}\n        s = [cmap[c] for c in s]\n        # Shake: assign random colors within current palette or one extra\n        k = max(s)\n        for i in top:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    s = normalize_colors(s)\n    return s\n","Resultados":["[1,2,3,1,2,3,2,1,3]",1000000000000.0,"[1,2,3,1,2,3,2,1,3]",1000000000000.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00108428}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    B2 = 10**9  # conflicts dominance\n    B1 = 10**6  # contiguity next\n\n    # Basic type\/shape checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n\n    # Coerce to ints and validate domain >=1\n    s = []\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Compute k and contiguity gap\n    S = set(s)\n    k = max(S) if S else 0\n    gaps = 0\n    if not S or min(S) != 1 or max(S) != len(S):\n        gaps = 1\n\n    fitness = conflicts * B2 + gaps * B1 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (MoveCategory, MoveDetail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Coerce to ints\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Per-vertex conflict counts\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n\n    conflicted = [i for i, c in enumerate(vconf) if c > 0]\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Occasionally perform a small Kempe-chain swap as a neighbor\n    if random.random() < 0.15:\n        if not conflicted:\n            start = random.randrange(0, 9)\n        else:\n            start = random.choice(conflicted)\n        a = s[start]\n        # choose b != a from present colors or a+1 if only one color\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        # BFS on {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n        s = normalize_colors(s)\n        return (s, (\"KEMPE\", \"LOCAL_SWAP\"))\n\n    # Otherwise recolor a vertex (best-improving local choice)\n    if conflicted and random.random() < 0.9:\n        v = random.choice(conflicted)\n        mv_detail = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n        mv_detail = \"RANDOM_VERTEX\"\n\n    k = max(s)\n    # Candidate colors restricted to 1..k; allow k+1 only if no improving color exists\n    candidates = list(range(1, k+1))\n\n    # Evaluate local conflicts for each candidate\n    cur = s[v]\n    best_c = cur\n    best_val = 10**9\n    improving_found = False\n    for c in candidates:\n        if c == cur:\n            continue\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if loc < best_val:\n            best_val = loc\n            best_c = c\n    # Current local conflicts\n    cur_loc = sum(1 for nb in adj[v] if s[nb] == cur)\n    if best_val < cur_loc:\n        improving_found = True\n        s[v] = best_c\n    else:\n        # Optionally try k+1 only if it strictly reduces local conflicts\n        new_color = k + 1\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == new_color:\n                loc += 1\n        if loc < cur_loc and random.random() < 0.25:\n            s[v] = new_color\n        else:\n            # fallback: change to a different existing color (tie-breaking by minimal local conflicts)\n            s[v] = best_c if best_c != cur else cur\n\n    s = normalize_colors(s)\n    return (s, (\"RECOLOR\", mv_detail))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or color permutation + multi-shake, then normalize\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return solution\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # 50%: Kempe-chain on random start\n    if random.random() < 0.5:\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u, v) in edges:\n            ui = u - 1; vi = v - 1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # 50%: color permutation + shake top-conflicted vertices\n        # Compute conflicts per vertex\n        vconf = [0]*9\n        for (u, v) in edges:\n            if s[u-1] == s[v-1]:\n                vconf[u-1] += 1\n                vconf[v-1] += 1\n        order = list(range(9))\n        order.sort(key=lambda i: vconf[i], reverse=True)\n        m = random.randint(3, 5)\n        top = order[:m]\n        # Random color permutation\n        colors = sorted(list({c for c in s}))\n        perm = colors[:]\n        random.shuffle(perm)\n        cmap = {c: perm[i] for i, c in enumerate(colors)}\n        s = [cmap[c] for c in s]\n        # Shake: assign random colors within current palette or one extra\n        k = max(s)\n        for i in top:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    s = normalize_colors(s)\n    return s\n","Resultados":["[1,2,3,1,2,3,2,1,3]",1000000000000.0,"[1,2,3,1,2,3,2,1,3]",1000000000000.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001255682}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    B2 = 10**9  # conflicts dominance\n    B1 = 10**6  # contiguity next\n\n    # Basic type\/shape checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n\n    # Coerce to ints and validate domain >=1\n    s = []\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Compute k and contiguity gap\n    S = set(s)\n    k = max(S) if S else 0\n    gaps = 0\n    if not S or min(S) != 1 or max(S) != len(S):\n        gaps = 1\n\n    fitness = conflicts * B2 + gaps * B1 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (MoveCategory, MoveDetail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Coerce to ints\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Per-vertex conflict counts\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n\n    conflicted = [i for i, c in enumerate(vconf) if c > 0]\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Occasionally perform a small Kempe-chain swap as a neighbor\n    if random.random() < 0.15:\n        if not conflicted:\n            start = random.randrange(0, 9)\n        else:\n            start = random.choice(conflicted)\n        a = s[start]\n        # choose b != a from present colors or a+1 if only one color\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        # BFS on {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n        s = normalize_colors(s)\n        return (s, (\"KEMPE\", \"LOCAL_SWAP\"))\n\n    # Otherwise recolor a vertex (best-improving local choice)\n    if conflicted and random.random() < 0.9:\n        v = random.choice(conflicted)\n        mv_detail = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n        mv_detail = \"RANDOM_VERTEX\"\n\n    k = max(s)\n    # Candidate colors restricted to 1..k; allow k+1 only if no improving color exists\n    candidates = list(range(1, k+1))\n\n    # Evaluate local conflicts for each candidate\n    cur = s[v]\n    best_c = cur\n    best_val = 10**9\n    improving_found = False\n    for c in candidates:\n        if c == cur:\n            continue\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if loc < best_val:\n            best_val = loc\n            best_c = c\n    # Current local conflicts\n    cur_loc = sum(1 for nb in adj[v] if s[nb] == cur)\n    if best_val < cur_loc:\n        improving_found = True\n        s[v] = best_c\n    else:\n        # Optionally try k+1 only if it strictly reduces local conflicts\n        new_color = k + 1\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == new_color:\n                loc += 1\n        if loc < cur_loc and random.random() < 0.25:\n            s[v] = new_color\n        else:\n            # fallback: change to a different existing color (tie-breaking by minimal local conflicts)\n            s[v] = best_c if best_c != cur else cur\n\n    s = normalize_colors(s)\n    return (s, (\"RECOLOR\", mv_detail))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or color permutation + multi-shake, then normalize\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return solution\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # 50%: Kempe-chain on random start\n    if random.random() < 0.5:\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u, v) in edges:\n            ui = u - 1; vi = v - 1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # 50%: color permutation + shake top-conflicted vertices\n        # Compute conflicts per vertex\n        vconf = [0]*9\n        for (u, v) in edges:\n            if s[u-1] == s[v-1]:\n                vconf[u-1] += 1\n                vconf[v-1] += 1\n        order = list(range(9))\n        order.sort(key=lambda i: vconf[i], reverse=True)\n        m = random.randint(3, 5)\n        top = order[:m]\n        # Random color permutation\n        colors = sorted(list({c for c in s}))\n        perm = colors[:]\n        random.shuffle(perm)\n        cmap = {c: perm[i] for i, c in enumerate(colors)}\n        s = [cmap[c] for c in s]\n        # Shake: assign random colors within current palette or one extra\n        k = max(s)\n        for i in top:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001152131}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    B2 = 10**9  # conflicts dominance\n    B1 = 10**6  # contiguity guidance\n\n    # Basic type\/shape checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n\n    # Coerce to ints and validate domain >=1\n    s: List[int] = []\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi < 1:\n                return int(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return int(HARD_PEN)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Compute k and exact contiguity gap (enforce labels start at 1 and contiguous)\n    S = set(s)\n    k = max(S) if S else 0\n    # gaps equals missing labels in 1..k, which is k - |S|\n    gaps = k - len(S) if S else 0\n\n    fitness = conflicts * B2 + gaps * B1 + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (MoveCategory, MoveDetail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and coerce\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    if any(x < 1 for x in s):\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Build adjacency (0-indexed)\n    adj: List[List[int]] = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Per-vertex conflict counts\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n    conflicted = [i for i, c in enumerate(vconf) if c > 0]\n\n    def current_k(arr: List[int]) -> int:\n        return max(arr) if arr else 0\n\n    def normalize_reduce_only(arr: List[int]) -> List[int]:\n        # Normalize labels to 1..|S| only if it reduces k (i.e., removes gaps and lowers max label)\n        S = list(dict.fromkeys(arr))  # preserve first-seen order\n        uniq = sorted(set(arr))\n        if not uniq:\n            return arr\n        k_before = max(arr)\n        k_after = len(set(arr))\n        if k_after >= k_before:\n            return arr  # do not change color identities unless k decreases\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Kempe-chain swap operator (biased by conflicts around a start vertex)\n    def kempe_swap(arr: List[int]) -> Tuple[List[int], Tuple[str, str]]:\n        s2 = arr[:]\n        if conflicted:\n            start = max(conflicted, key=lambda i: (vconf[i], len(adj[i]), random.random()))\n        else:\n            start = random.randrange(0, 9)\n        a = s2[start]\n        colors_present = sorted(set(s2))\n        # Choose b != a maximizing neighbor count of color b around start (conflict-biased)\n        cand = [c for c in colors_present if c != a]\n        if not cand:\n            return (s2, (\"KEMPE\", \"NOOP\"))\n        b = max(cand, key=lambda c: sum(1 for nb in adj[start] if s2[nb] == c))\n        # BFS on subgraph induced by colors {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s2[nb] == a or s2[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s2[v] == a:\n                s2[v] = b\n            elif s2[v] == b:\n                s2[v] = a\n        # Reduce k only if possible\n        s2 = normalize_reduce_only(s2)\n        return (s2, (\"KEMPE\", \"LOCAL_SWAP\"))\n\n    # With some probability, try Kempe swap (useful on plateaus)\n    if random.random() < 0.25:\n        s_new, tag = kempe_swap(s)\n        return (s_new, tag)\n\n    # Otherwise, perform a targeted recolor move\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vconf[i], len(adj[i]), random.random()))\n        mv_detail = \"MAX_CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n        mv_detail = \"RANDOM_VERTEX\"\n\n    k = current_k(s)\n    # Candidate colors restricted to existing palette 1..k (do not allow k+1 expansion here)\n    candidates = list(range(1, k+1))\n    cur = s[v]\n\n    # Evaluate local conflicts for each candidate color\n    best_c = cur\n    best_val = 10**9\n    for c in candidates:\n        if c == cur:\n            continue\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if loc < best_val:\n            best_val = loc\n            best_c = c\n\n    # Current local conflicts\n    cur_loc = sum(1 for nb in adj[v] if s[nb] == cur)\n    if best_val < cur_loc:\n        s[v] = best_c\n    else:\n        # If no improving color, perform a side-move to least-conflicting alternative to promote diversification\n        # Break ties randomly among best colors\n        best_colors = []\n        best_val = 10**9\n        for c in candidates:\n            if c == cur:\n                continue\n            loc = 0\n            for nb in adj[v]:\n                if s[nb] == c:\n                    loc += 1\n            if loc < best_val:\n                best_val = loc\n                best_colors = [c]\n            elif loc == best_val:\n                best_colors.append(c)\n        if best_colors:\n            s[v] = random.choice(best_colors)\n        # else remains unchanged\n\n    # Normalize only if k can be reduced\n    s = normalize_reduce_only(s)\n    return (s, (\"RECOLOR\", mv_detail))\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: multiple Kempe swaps + recolor top-conflicted vertices, then conditional normalization\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return solution\n    if any(x < 1 for x in s):\n        return solution\n\n    # Build adjacency (0-indexed)\n    adj: List[List[int]] = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def normalize_reduce_only(arr: List[int]) -> List[int]:\n        uniq = sorted(set(arr))\n        if not uniq:\n            return arr\n        k_before = max(arr)\n        k_after = len(set(arr))\n        if k_after >= k_before:\n            return arr\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Compute conflicts per vertex\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n\n    # 1) Apply 1-2 Kempe swaps starting from highest-conflict vertices\n    num_swaps = 1 + (1 if random.random() < 0.5 else 0)\n    order = list(range(9))\n    order.sort(key=lambda i: (vconf[i], len(adj[i])), reverse=True)\n    colors_present = sorted(set(s))\n\n    for t in range(num_swaps):\n        if not order:\n            break\n        start = order[t % len(order)]\n        a = s[start]\n        cand = [c for c in colors_present if c != a]\n        if not cand:\n            continue\n        # choose b maximizing neighbors of color b at start to disrupt conflicts\n        b = max(cand, key=lambda c: sum(1 for nb in adj[start] if s[nb] == c))\n        # BFS on {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n        colors_present = sorted(set(s))\n\n    # 2) Shake: recolor top-q conflicted vertices randomly within palette\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n    order = list(range(9))\n    order.sort(key=lambda i: (vconf[i], len(adj[i])), reverse=True)\n    q = min(3, len(order))\n    k = max(s) if s else 0\n    if k < 1:\n        k = 1\n    for i in order[:q]:\n        # random recolor within current palette (no palette expansion here)\n        newc = random.randint(1, k)\n        # ensure actual change if possible\n        if k > 1:\n            while newc == s[i]:\n                newc = random.randint(1, k)\n        s[i] = newc\n\n    # Conditional normalization to reduce k when possible\n    s = normalize_reduce_only(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001202089}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    B2 = 10**9  # conflicts dominance\n    B1 = 10**6  # contiguity guidance\n\n    # Basic type\/shape checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n\n    # Coerce to ints and validate domain >=1\n    s: List[int] = []\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi < 1:\n                return int(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return int(HARD_PEN)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Compute k and exact contiguity gap (enforce labels start at 1 and contiguous)\n    S = set(s)\n    k = max(S) if S else 0\n    # gaps equals missing labels in 1..k, which is k - |S|\n    gaps = k - len(S) if S else 0\n\n    fitness = conflicts * B2 + gaps * B1 + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (MoveCategory, MoveDetail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and coerce\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    if any(x < 1 for x in s):\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Build adjacency (0-indexed)\n    adj: List[List[int]] = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Per-vertex conflict counts\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n    conflicted = [i for i, c in enumerate(vconf) if c > 0]\n\n    def current_k(arr: List[int]) -> int:\n        return max(arr) if arr else 0\n\n    def normalize_reduce_only(arr: List[int]) -> List[int]:\n        # Normalize labels to 1..|S| only if it reduces k (i.e., removes gaps and lowers max label)\n        S = list(dict.fromkeys(arr))  # preserve first-seen order\n        uniq = sorted(set(arr))\n        if not uniq:\n            return arr\n        k_before = max(arr)\n        k_after = len(set(arr))\n        if k_after >= k_before:\n            return arr  # do not change color identities unless k decreases\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Kempe-chain swap operator (biased by conflicts around a start vertex)\n    def kempe_swap(arr: List[int]) -> Tuple[List[int], Tuple[str, str]]:\n        s2 = arr[:]\n        if conflicted:\n            start = max(conflicted, key=lambda i: (vconf[i], len(adj[i]), random.random()))\n        else:\n            start = random.randrange(0, 9)\n        a = s2[start]\n        colors_present = sorted(set(s2))\n        # Choose b != a maximizing neighbor count of color b around start (conflict-biased)\n        cand = [c for c in colors_present if c != a]\n        if not cand:\n            return (s2, (\"KEMPE\", \"NOOP\"))\n        b = max(cand, key=lambda c: sum(1 for nb in adj[start] if s2[nb] == c))\n        # BFS on subgraph induced by colors {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s2[nb] == a or s2[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s2[v] == a:\n                s2[v] = b\n            elif s2[v] == b:\n                s2[v] = a\n        # Reduce k only if possible\n        s2 = normalize_reduce_only(s2)\n        return (s2, (\"KEMPE\", \"LOCAL_SWAP\"))\n\n    # With some probability, try Kempe swap (useful on plateaus)\n    if random.random() < 0.25:\n        s_new, tag = kempe_swap(s)\n        return (s_new, tag)\n\n    # Otherwise, perform a targeted recolor move\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vconf[i], len(adj[i]), random.random()))\n        mv_detail = \"MAX_CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n        mv_detail = \"RANDOM_VERTEX\"\n\n    k = current_k(s)\n    # Candidate colors restricted to existing palette 1..k (do not allow k+1 expansion here)\n    candidates = list(range(1, k+1))\n    cur = s[v]\n\n    # Evaluate local conflicts for each candidate color\n    best_c = cur\n    best_val = 10**9\n    for c in candidates:\n        if c == cur:\n            continue\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if loc < best_val:\n            best_val = loc\n            best_c = c\n\n    # Current local conflicts\n    cur_loc = sum(1 for nb in adj[v] if s[nb] == cur)\n    if best_val < cur_loc:\n        s[v] = best_c\n    else:\n        # If no improving color, perform a side-move to least-conflicting alternative to promote diversification\n        # Break ties randomly among best colors\n        best_colors = []\n        best_val = 10**9\n        for c in candidates:\n            if c == cur:\n                continue\n            loc = 0\n            for nb in adj[v]:\n                if s[nb] == c:\n                    loc += 1\n            if loc < best_val:\n                best_val = loc\n                best_colors = [c]\n            elif loc == best_val:\n                best_colors.append(c)\n        if best_colors:\n            s[v] = random.choice(best_colors)\n        # else remains unchanged\n\n    # Normalize only if k can be reduced\n    s = normalize_reduce_only(s)\n    return (s, (\"RECOLOR\", mv_detail))\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: multiple Kempe swaps + recolor top-conflicted vertices, then conditional normalization\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return solution\n    if any(x < 1 for x in s):\n        return solution\n\n    # Build adjacency (0-indexed)\n    adj: List[List[int]] = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def normalize_reduce_only(arr: List[int]) -> List[int]:\n        uniq = sorted(set(arr))\n        if not uniq:\n            return arr\n        k_before = max(arr)\n        k_after = len(set(arr))\n        if k_after >= k_before:\n            return arr\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Compute conflicts per vertex\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n\n    # 1) Apply 1-2 Kempe swaps starting from highest-conflict vertices\n    num_swaps = 1 + (1 if random.random() < 0.5 else 0)\n    order = list(range(9))\n    order.sort(key=lambda i: (vconf[i], len(adj[i])), reverse=True)\n    colors_present = sorted(set(s))\n\n    for t in range(num_swaps):\n        if not order:\n            break\n        start = order[t % len(order)]\n        a = s[start]\n        cand = [c for c in colors_present if c != a]\n        if not cand:\n            continue\n        # choose b maximizing neighbors of color b at start to disrupt conflicts\n        b = max(cand, key=lambda c: sum(1 for nb in adj[start] if s[nb] == c))\n        # BFS on {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n        colors_present = sorted(set(s))\n\n    # 2) Shake: recolor top-q conflicted vertices randomly within palette\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n    order = list(range(9))\n    order.sort(key=lambda i: (vconf[i], len(adj[i])), reverse=True)\n    q = min(3, len(order))\n    k = max(s) if s else 0\n    if k < 1:\n        k = 1\n    for i in order[:q]:\n        # random recolor within current palette (no palette expansion here)\n        newc = random.randint(1, k)\n        # ensure actual change if possible\n        if k > 1:\n            while newc == s[i]:\n                newc = random.randint(1, k)\n        s[i] = newc\n\n    # Conditional normalization to reduce k when possible\n    s = normalize_reduce_only(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001484114}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    B2 = 10**9  # conflicts dominance\n    B1 = 10**6  # contiguity guidance\n\n    # Basic type\/shape checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n\n    # Coerce to ints and validate domain >=1\n    s: List[int] = []\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi < 1:\n                return int(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return int(HARD_PEN)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Compute k and exact contiguity gap (enforce labels start at 1 and contiguous)\n    S = set(s)\n    k = max(S) if S else 0\n    # gaps equals missing labels in 1..k, which is k - |S|\n    gaps = k - len(S) if S else 0\n\n    fitness = conflicts * B2 + gaps * B1 + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (MoveCategory, MoveDetail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and coerce\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    if any(x < 1 for x in s):\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Build adjacency (0-indexed)\n    adj: List[List[int]] = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Per-vertex conflict counts\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n    conflicted = [i for i, c in enumerate(vconf) if c > 0]\n\n    def current_k(arr: List[int]) -> int:\n        return max(arr) if arr else 0\n\n    def normalize_reduce_only(arr: List[int]) -> List[int]:\n        # Normalize labels to 1..|S| only if it reduces k (i.e., removes gaps and lowers max label)\n        S = list(dict.fromkeys(arr))  # preserve first-seen order\n        uniq = sorted(set(arr))\n        if not uniq:\n            return arr\n        k_before = max(arr)\n        k_after = len(set(arr))\n        if k_after >= k_before:\n            return arr  # do not change color identities unless k decreases\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Kempe-chain swap operator (biased by conflicts around a start vertex)\n    def kempe_swap(arr: List[int]) -> Tuple[List[int], Tuple[str, str]]:\n        s2 = arr[:]\n        if conflicted:\n            start = max(conflicted, key=lambda i: (vconf[i], len(adj[i]), random.random()))\n        else:\n            start = random.randrange(0, 9)\n        a = s2[start]\n        colors_present = sorted(set(s2))\n        # Choose b != a maximizing neighbor count of color b around start (conflict-biased)\n        cand = [c for c in colors_present if c != a]\n        if not cand:\n            return (s2, (\"KEMPE\", \"NOOP\"))\n        b = max(cand, key=lambda c: sum(1 for nb in adj[start] if s2[nb] == c))\n        # BFS on subgraph induced by colors {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s2[nb] == a or s2[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s2[v] == a:\n                s2[v] = b\n            elif s2[v] == b:\n                s2[v] = a\n        # Reduce k only if possible\n        s2 = normalize_reduce_only(s2)\n        return (s2, (\"KEMPE\", \"LOCAL_SWAP\"))\n\n    # With some probability, try Kempe swap (useful on plateaus)\n    if random.random() < 0.25:\n        s_new, tag = kempe_swap(s)\n        return (s_new, tag)\n\n    # Otherwise, perform a targeted recolor move\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vconf[i], len(adj[i]), random.random()))\n        mv_detail = \"MAX_CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n        mv_detail = \"RANDOM_VERTEX\"\n\n    k = current_k(s)\n    # Candidate colors restricted to existing palette 1..k (do not allow k+1 expansion here)\n    candidates = list(range(1, k+1))\n    cur = s[v]\n\n    # Evaluate local conflicts for each candidate color\n    best_c = cur\n    best_val = 10**9\n    for c in candidates:\n        if c == cur:\n            continue\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if loc < best_val:\n            best_val = loc\n            best_c = c\n\n    # Current local conflicts\n    cur_loc = sum(1 for nb in adj[v] if s[nb] == cur)\n    if best_val < cur_loc:\n        s[v] = best_c\n    else:\n        # If no improving color, perform a side-move to least-conflicting alternative to promote diversification\n        # Break ties randomly among best colors\n        best_colors = []\n        best_val = 10**9\n        for c in candidates:\n            if c == cur:\n                continue\n            loc = 0\n            for nb in adj[v]:\n                if s[nb] == c:\n                    loc += 1\n            if loc < best_val:\n                best_val = loc\n                best_colors = [c]\n            elif loc == best_val:\n                best_colors.append(c)\n        if best_colors:\n            s[v] = random.choice(best_colors)\n        # else remains unchanged\n\n    # Normalize only if k can be reduced\n    s = normalize_reduce_only(s)\n    return (s, (\"RECOLOR\", mv_detail))\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: multiple Kempe swaps + recolor top-conflicted vertices, then conditional normalization\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return solution\n    if any(x < 1 for x in s):\n        return solution\n\n    # Build adjacency (0-indexed)\n    adj: List[List[int]] = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def normalize_reduce_only(arr: List[int]) -> List[int]:\n        uniq = sorted(set(arr))\n        if not uniq:\n            return arr\n        k_before = max(arr)\n        k_after = len(set(arr))\n        if k_after >= k_before:\n            return arr\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Compute conflicts per vertex\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n\n    # 1) Apply 1-2 Kempe swaps starting from highest-conflict vertices\n    num_swaps = 1 + (1 if random.random() < 0.5 else 0)\n    order = list(range(9))\n    order.sort(key=lambda i: (vconf[i], len(adj[i])), reverse=True)\n    colors_present = sorted(set(s))\n\n    for t in range(num_swaps):\n        if not order:\n            break\n        start = order[t % len(order)]\n        a = s[start]\n        cand = [c for c in colors_present if c != a]\n        if not cand:\n            continue\n        # choose b maximizing neighbors of color b at start to disrupt conflicts\n        b = max(cand, key=lambda c: sum(1 for nb in adj[start] if s[nb] == c))\n        # BFS on {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n        colors_present = sorted(set(s))\n\n    # 2) Shake: recolor top-q conflicted vertices randomly within palette\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n    order = list(range(9))\n    order.sort(key=lambda i: (vconf[i], len(adj[i])), reverse=True)\n    q = min(3, len(order))\n    k = max(s) if s else 0\n    if k < 1:\n        k = 1\n    for i in order[:q]:\n        # random recolor within current palette (no palette expansion here)\n        newc = random.randint(1, k)\n        # ensure actual change if possible\n        if k > 1:\n            while newc == s[i]:\n                newc = random.randint(1, k)\n        s[i] = newc\n\n    # Conditional normalization to reduce k when possible\n    s = normalize_reduce_only(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001490963}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate type\/length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data embedded\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000","Vecindad":"import random, math, copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize random feasible-like vector if malformed\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflicts_of(sol_local):\n        cnt = 0\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    max_color = max(sol) if sol else 1\n\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    conflicted = list(set(conflicted))\n\n    new_sol = sol[:]\n    movement = \"SingleNodeRecolor\"\n    nb_type = \"ConflictDirected\" if conflicted else \"ImprovementDirected\"\n\n    # Choose a target vertex\n    if conflicted:\n        i = random.choice(conflicted) - 1\n    else:\n        # pick a vertex with highest color or random to try reducing colors\n        candidates = [i for i, c in enumerate(new_sol) if c == max_color]\n        i = random.choice(candidates if candidates else list(range(n)))\n\n    # Try colors that minimize conflicts, preferring existing colors, then possibly a new color\n    neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n    try_colors = list(range(1, max_color+1))\n    random.shuffle(try_colors)\n    best_color = new_sol[i]\n    best_score = math.inf\n    # Evaluate conflict count impact per color\n    for color in try_colors:\n        if color == new_sol[i]:\n            # small bias to keep current if equal\n            local = 0.01\n        else:\n            local = 0.0\n        # compute conflicts if i takes this color\n        tmp = new_sol[:]\n        tmp[i] = color\n        score = conflicts_of(tmp) + local\n        if score < best_score:\n            best_score = score\n            best_color = color\n    # If all existing colors lead to conflicts, consider introducing a new color with low probability\n    if best_score > 0 and random.random() < 0.3:\n        best_color = max_color + 1\n        movement = \"IntroduceColor\"\n\n    new_sol[i] = best_color\n\n    # Optional post-step: simple color compaction attempt if no conflicts remain\n    if conflicts_of(new_sol) == 0:\n        # Relabel colors to consecutive 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        for c in new_sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n        new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol, nb_type, movement","Perturbacion":"import random, math, copy\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol) if new_sol else 1\n\n    # Perturb k random positions: mix of recolors and random new color intro\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n        palette = list(range(1, max_color + 1))\n        # 20% chance to allow a new color\n        if random.random() < 0.2:\n            palette.append(max_color + 1)\n        # Prefer colors not present in neighbors\n        non_conflicting = [c for c in palette if c not in neighbor_colors]\n        if non_conflicting:\n            new_sol[i] = random.choice(non_conflicting)\n        else:\n            new_sol[i] = random.choice(palette)\n        max_color = max(max_color, new_sol[i])\n\n    # Canonical relabeling to keep colors compact 1..m\n    mapping = {}\n    next_c = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0006615099}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate type\/length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data embedded\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000","Vecindad":"import random, math, copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize random feasible-like vector if malformed\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflicts_of(sol_local):\n        cnt = 0\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    max_color = max(sol) if sol else 1\n\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    conflicted = list(set(conflicted))\n\n    new_sol = sol[:]\n    movement = \"SingleNodeRecolor\"\n    nb_type = \"ConflictDirected\" if conflicted else \"ImprovementDirected\"\n\n    # Choose a target vertex\n    if conflicted:\n        i = random.choice(conflicted) - 1\n    else:\n        # pick a vertex with highest color or random to try reducing colors\n        candidates = [i for i, c in enumerate(new_sol) if c == max_color]\n        i = random.choice(candidates if candidates else list(range(n)))\n\n    # Try colors that minimize conflicts, preferring existing colors, then possibly a new color\n    neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n    try_colors = list(range(1, max_color+1))\n    random.shuffle(try_colors)\n    best_color = new_sol[i]\n    best_score = math.inf\n    # Evaluate conflict count impact per color\n    for color in try_colors:\n        if color == new_sol[i]:\n            # small bias to keep current if equal\n            local = 0.01\n        else:\n            local = 0.0\n        # compute conflicts if i takes this color\n        tmp = new_sol[:]\n        tmp[i] = color\n        score = conflicts_of(tmp) + local\n        if score < best_score:\n            best_score = score\n            best_color = color\n    # If all existing colors lead to conflicts, consider introducing a new color with low probability\n    if best_score > 0 and random.random() < 0.3:\n        best_color = max_color + 1\n        movement = \"IntroduceColor\"\n\n    new_sol[i] = best_color\n\n    # Optional post-step: simple color compaction attempt if no conflicts remain\n    if conflicts_of(new_sol) == 0:\n        # Relabel colors to consecutive 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        for c in new_sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n        new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol, nb_type, movement","Perturbacion":"import random, math, copy\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol) if new_sol else 1\n\n    # Perturb k random positions: mix of recolors and random new color intro\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n        palette = list(range(1, max_color + 1))\n        # 20% chance to allow a new color\n        if random.random() < 0.2:\n            palette.append(max_color + 1)\n        # Prefer colors not present in neighbors\n        non_conflicting = [c for c in palette if c not in neighbor_colors]\n        if non_conflicting:\n            new_sol[i] = random.choice(non_conflicting)\n        else:\n            new_sol[i] = random.choice(palette)\n        max_color = max(max_color, new_sol[i])\n\n    # Canonical relabeling to keep colors compact 1..m\n    mapping = {}\n    next_c = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0008312321}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate type\/length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data embedded\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000","Vecindad":"import random, math, copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize random feasible-like vector if malformed\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflicts_of(sol_local):\n        cnt = 0\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    max_color = max(sol) if sol else 1\n\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    conflicted = list(set(conflicted))\n\n    new_sol = sol[:]\n    movement = \"SingleNodeRecolor\"\n    nb_type = \"ConflictDirected\" if conflicted else \"ImprovementDirected\"\n\n    # Choose a target vertex\n    if conflicted:\n        i = random.choice(conflicted) - 1\n    else:\n        # pick a vertex with highest color or random to try reducing colors\n        candidates = [i for i, c in enumerate(new_sol) if c == max_color]\n        i = random.choice(candidates if candidates else list(range(n)))\n\n    # Try colors that minimize conflicts, preferring existing colors, then possibly a new color\n    neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n    try_colors = list(range(1, max_color+1))\n    random.shuffle(try_colors)\n    best_color = new_sol[i]\n    best_score = math.inf\n    # Evaluate conflict count impact per color\n    for color in try_colors:\n        if color == new_sol[i]:\n            # small bias to keep current if equal\n            local = 0.01\n        else:\n            local = 0.0\n        # compute conflicts if i takes this color\n        tmp = new_sol[:]\n        tmp[i] = color\n        score = conflicts_of(tmp) + local\n        if score < best_score:\n            best_score = score\n            best_color = color\n    # If all existing colors lead to conflicts, consider introducing a new color with low probability\n    if best_score > 0 and random.random() < 0.3:\n        best_color = max_color + 1\n        movement = \"IntroduceColor\"\n\n    new_sol[i] = best_color\n\n    # Optional post-step: simple color compaction attempt if no conflicts remain\n    if conflicts_of(new_sol) == 0:\n        # Relabel colors to consecutive 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        for c in new_sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n        new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol, nb_type, movement","Perturbacion":"import random, math, copy\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol) if new_sol else 1\n\n    # Perturb k random positions: mix of recolors and random new color intro\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n        palette = list(range(1, max_color + 1))\n        # 20% chance to allow a new color\n        if random.random() < 0.2:\n            palette.append(max_color + 1)\n        # Prefer colors not present in neighbors\n        non_conflicting = [c for c in palette if c not in neighbor_colors]\n        if non_conflicting:\n            new_sol[i] = random.choice(non_conflicting)\n        else:\n            new_sol[i] = random.choice(palette)\n        max_color = max(max_color, new_sol[i])\n\n    # Canonical relabeling to keep colors compact 1..m\n    mapping = {}\n    next_c = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000819543}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation; coerce to positive ints and canonicalize order\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Canonical relabeling to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, max_color):\n        neighbor_colors = {sol_local[j-1] for j in adj[node]}\n        return [c for c in range(1, max_color+1) if c not in neighbor_colors]\n\n    max_color = max(sol) if sol else 1\n    new_sol = sol[:]\n\n    # Decide neighbourhood type: conflict-directed recolor, color-elimination move, or Kempe chain swap\n    conflicted = conflict_vertices(new_sol)\n\n    # 1) If conflicts exist, recolor a conflicted vertex using existing palette to minimize conflicts\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(range(1, max_color+1))\n        random.shuffle(palette)\n        # Prefer colors not used by neighbors; fall back to least-conflicting among existing colors\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Choose color minimizing immediate conflict count around i (delta based)\n            best_c = new_sol[i-1]\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1])\n            for c in palette:\n                if c == new_sol[i-1]:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # No conflicts: attempt color elimination by moving a vertex from max_color to a lower feasible color\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    for i in max_vertices:\n        feas = feasible_colors(i, new_sol, max_color-1) if max_color > 1 else []\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            # If max color class becomes empty, compact palette by relabeling highest color down\n            if all(c != max_color for c in new_sol):\n                # Relabel to 1..m\n                mapping2 = {}\n                next_c2 = 1\n                for c in new_sol:\n                    if c not in mapping2:\n                        mapping2[c] = next_c2\n                        next_c2 += 1\n                new_sol = [mapping2[c] for c in new_sol]\n            return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap between two colors a and b starting from a random vertex\n    i = random.randint(1, n)\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        a = new_sol[i-1]\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        # Build Kempe component containing i using only colors a and b\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        # Swap colors on the component\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # Fallback: simple vertex recolor to any feasible lower color\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol, max_color)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector and canonicalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol)\n\n    # Apply a sequence of kicks: Kempe swaps and class swaps, avoiding introduction of new colors\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move_type = random.random()\n        if move_type < 0.5 and len(set(new_sol)) >= 2:\n            # Kempe swap on random seed and color pair\n            i = random.randint(1, n)\n            colors = list(set(new_sol))\n            a = new_sol[i-1]\n            b_choices = [c for c in colors if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move_type < 0.8:\n            # Random vertex recolor to any feasible existing color (keep palette)\n            i = random.randint(1, n)\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            palette = list(set(new_sol))\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color classes labels to diversify without changing feasibility\n            colors = list(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n        max_color = max(new_sol)\n\n    # Final canonical relabeling to 1..m\n    mapping2 = {}\n    next_c2 = 1\n    for c in new_sol:\n        if c not in mapping2:\n            mapping2[c] = next_c2\n            next_c2 += 1\n    new_sol = [mapping2[c] for c in new_sol]\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000953694}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation; coerce to positive ints and canonicalize order\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Canonical relabeling to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, max_color):\n        neighbor_colors = {sol_local[j-1] for j in adj[node]}\n        return [c for c in range(1, max_color+1) if c not in neighbor_colors]\n\n    max_color = max(sol) if sol else 1\n    new_sol = sol[:]\n\n    # Decide neighbourhood type: conflict-directed recolor, color-elimination move, or Kempe chain swap\n    conflicted = conflict_vertices(new_sol)\n\n    # 1) If conflicts exist, recolor a conflicted vertex using existing palette to minimize conflicts\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(range(1, max_color+1))\n        random.shuffle(palette)\n        # Prefer colors not used by neighbors; fall back to least-conflicting among existing colors\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Choose color minimizing immediate conflict count around i (delta based)\n            best_c = new_sol[i-1]\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1])\n            for c in palette:\n                if c == new_sol[i-1]:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # No conflicts: attempt color elimination by moving a vertex from max_color to a lower feasible color\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    for i in max_vertices:\n        feas = feasible_colors(i, new_sol, max_color-1) if max_color > 1 else []\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            # If max color class becomes empty, compact palette by relabeling highest color down\n            if all(c != max_color for c in new_sol):\n                # Relabel to 1..m\n                mapping2 = {}\n                next_c2 = 1\n                for c in new_sol:\n                    if c not in mapping2:\n                        mapping2[c] = next_c2\n                        next_c2 += 1\n                new_sol = [mapping2[c] for c in new_sol]\n            return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap between two colors a and b starting from a random vertex\n    i = random.randint(1, n)\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        a = new_sol[i-1]\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        # Build Kempe component containing i using only colors a and b\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        # Swap colors on the component\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # Fallback: simple vertex recolor to any feasible lower color\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol, max_color)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector and canonicalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol)\n\n    # Apply a sequence of kicks: Kempe swaps and class swaps, avoiding introduction of new colors\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move_type = random.random()\n        if move_type < 0.5 and len(set(new_sol)) >= 2:\n            # Kempe swap on random seed and color pair\n            i = random.randint(1, n)\n            colors = list(set(new_sol))\n            a = new_sol[i-1]\n            b_choices = [c for c in colors if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move_type < 0.8:\n            # Random vertex recolor to any feasible existing color (keep palette)\n            i = random.randint(1, n)\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            palette = list(set(new_sol))\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color classes labels to diversify without changing feasibility\n            colors = list(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n        max_color = max(new_sol)\n\n    # Final canonical relabeling to 1..m\n    mapping2 = {}\n    next_c2 = 1\n    for c in new_sol:\n        if c not in mapping2:\n            mapping2[c] = next_c2\n            next_c2 += 1\n    new_sol = [mapping2[c] for c in new_sol]\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001251327}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation; coerce to positive ints and canonicalize order\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Canonical relabeling to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, max_color):\n        neighbor_colors = {sol_local[j-1] for j in adj[node]}\n        return [c for c in range(1, max_color+1) if c not in neighbor_colors]\n\n    max_color = max(sol) if sol else 1\n    new_sol = sol[:]\n\n    # Decide neighbourhood type: conflict-directed recolor, color-elimination move, or Kempe chain swap\n    conflicted = conflict_vertices(new_sol)\n\n    # 1) If conflicts exist, recolor a conflicted vertex using existing palette to minimize conflicts\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(range(1, max_color+1))\n        random.shuffle(palette)\n        # Prefer colors not used by neighbors; fall back to least-conflicting among existing colors\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Choose color minimizing immediate conflict count around i (delta based)\n            best_c = new_sol[i-1]\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1])\n            for c in palette:\n                if c == new_sol[i-1]:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # No conflicts: attempt color elimination by moving a vertex from max_color to a lower feasible color\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    for i in max_vertices:\n        feas = feasible_colors(i, new_sol, max_color-1) if max_color > 1 else []\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            # If max color class becomes empty, compact palette by relabeling highest color down\n            if all(c != max_color for c in new_sol):\n                # Relabel to 1..m\n                mapping2 = {}\n                next_c2 = 1\n                for c in new_sol:\n                    if c not in mapping2:\n                        mapping2[c] = next_c2\n                        next_c2 += 1\n                new_sol = [mapping2[c] for c in new_sol]\n            return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap between two colors a and b starting from a random vertex\n    i = random.randint(1, n)\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        a = new_sol[i-1]\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        # Build Kempe component containing i using only colors a and b\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        # Swap colors on the component\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # Fallback: simple vertex recolor to any feasible lower color\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol, max_color)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector and canonicalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol)\n\n    # Apply a sequence of kicks: Kempe swaps and class swaps, avoiding introduction of new colors\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move_type = random.random()\n        if move_type < 0.5 and len(set(new_sol)) >= 2:\n            # Kempe swap on random seed and color pair\n            i = random.randint(1, n)\n            colors = list(set(new_sol))\n            a = new_sol[i-1]\n            b_choices = [c for c in colors if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move_type < 0.8:\n            # Random vertex recolor to any feasible existing color (keep palette)\n            i = random.randint(1, n)\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            palette = list(set(new_sol))\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color classes labels to diversify without changing feasibility\n            colors = list(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n        max_color = max(new_sol)\n\n    # Final canonical relabeling to 1..m\n    mapping2 = {}\n    next_c2 = 1\n    for c in new_sol:\n        if c not in mapping2:\n            mapping2[c] = next_c2\n            next_c2 += 1\n    new_sol = [mapping2[c] for c in new_sol]\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001233478}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate or initialize solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, palette=None):\n        if palette is None:\n            palette = set(sol_local)\n        neigh_cols = {sol_local[j-1] for j in adj[node]}\n        return [c for c in palette if c not in neigh_cols]\n\n    new_sol = sol[:]\n    colors = list(set(new_sol))\n    max_color = max(colors)\n\n    # 1) Conflict-directed recolor (if conflicts exist)\n    conflicted = conflict_vertices(new_sol)\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(set(new_sol))\n        random.shuffle(palette)\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Least-conflicting among existing colors\n            cur = new_sol[i-1]\n            best_c = cur\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == cur)\n            for c in palette:\n                if c == cur:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # 2) Color elimination: try moving vertices from the highest color to lower feasible colors\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    moved = False\n    for i in max_vertices:\n        lower_palette = set(new_sol) - {max_color}\n        feas = feasible_colors(i, new_sol, lower_palette)\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        # If highest color eliminated, relabel compactly to 1..m\n        if all(c != max_color for c in new_sol):\n            mapping = {}\n            nxt = 1\n            for c in new_sol:\n                if c not in mapping:\n                    mapping[c] = nxt\n                    nxt += 1\n            new_sol = [mapping[c] for c in new_sol]\n        return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap (diversification), biased to include max color\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        if random.random() < 0.7 and max_color in colors:\n            # seed from max_color class\n            candidates = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n            i = random.choice(candidates)\n            a = max_color\n            b = random.choice([c for c in colors if c != a])\n        else:\n            i = random.randint(1, n)\n            a = new_sol[i-1]\n            b = random.choice([c for c in colors if c != a])\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # 4) Fallback: random feasible recolor within existing palette\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize, then keep labels stable (canonical only at end)\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n\n    def conflicted(sol_local):\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                return True\n        return False\n\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move = random.random()\n        colors = list(set(new_sol))\n        if move < 0.5 and len(colors) >= 2:\n            # Kempe swap burst\n            if random.random() < 0.6:\n                # bias to include max color\n                max_color = max(colors)\n                seeds = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n                i = random.choice(seeds)\n                a = max_color\n                b = random.choice([c for c in colors if c != a])\n            else:\n                i = random.randint(1, n)\n                a = new_sol[i-1]\n                b = random.choice([c for c in colors if c != a])\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move < 0.8:\n            # Random vertex recolor, prefer feasible within current palette\n            i = random.randint(1, n)\n            palette = list(set(new_sol))\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color class labels\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n\n    # Canonical relabeling to 1..m at the end for cleanliness\n    mapping = {}\n    nxt = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0009985421}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate or initialize solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, palette=None):\n        if palette is None:\n            palette = set(sol_local)\n        neigh_cols = {sol_local[j-1] for j in adj[node]}\n        return [c for c in palette if c not in neigh_cols]\n\n    new_sol = sol[:]\n    colors = list(set(new_sol))\n    max_color = max(colors)\n\n    # 1) Conflict-directed recolor (if conflicts exist)\n    conflicted = conflict_vertices(new_sol)\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(set(new_sol))\n        random.shuffle(palette)\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Least-conflicting among existing colors\n            cur = new_sol[i-1]\n            best_c = cur\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == cur)\n            for c in palette:\n                if c == cur:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # 2) Color elimination: try moving vertices from the highest color to lower feasible colors\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    moved = False\n    for i in max_vertices:\n        lower_palette = set(new_sol) - {max_color}\n        feas = feasible_colors(i, new_sol, lower_palette)\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        # If highest color eliminated, relabel compactly to 1..m\n        if all(c != max_color for c in new_sol):\n            mapping = {}\n            nxt = 1\n            for c in new_sol:\n                if c not in mapping:\n                    mapping[c] = nxt\n                    nxt += 1\n            new_sol = [mapping[c] for c in new_sol]\n        return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap (diversification), biased to include max color\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        if random.random() < 0.7 and max_color in colors:\n            # seed from max_color class\n            candidates = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n            i = random.choice(candidates)\n            a = max_color\n            b = random.choice([c for c in colors if c != a])\n        else:\n            i = random.randint(1, n)\n            a = new_sol[i-1]\n            b = random.choice([c for c in colors if c != a])\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # 4) Fallback: random feasible recolor within existing palette\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize, then keep labels stable (canonical only at end)\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n\n    def conflicted(sol_local):\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                return True\n        return False\n\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move = random.random()\n        colors = list(set(new_sol))\n        if move < 0.5 and len(colors) >= 2:\n            # Kempe swap burst\n            if random.random() < 0.6:\n                # bias to include max color\n                max_color = max(colors)\n                seeds = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n                i = random.choice(seeds)\n                a = max_color\n                b = random.choice([c for c in colors if c != a])\n            else:\n                i = random.randint(1, n)\n                a = new_sol[i-1]\n                b = random.choice([c for c in colors if c != a])\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move < 0.8:\n            # Random vertex recolor, prefer feasible within current palette\n            i = random.randint(1, n)\n            palette = list(set(new_sol))\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color class labels\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n\n    # Canonical relabeling to 1..m at the end for cleanliness\n    mapping = {}\n    nxt = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001262426}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate or initialize solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, palette=None):\n        if palette is None:\n            palette = set(sol_local)\n        neigh_cols = {sol_local[j-1] for j in adj[node]}\n        return [c for c in palette if c not in neigh_cols]\n\n    new_sol = sol[:]\n    colors = list(set(new_sol))\n    max_color = max(colors)\n\n    # 1) Conflict-directed recolor (if conflicts exist)\n    conflicted = conflict_vertices(new_sol)\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(set(new_sol))\n        random.shuffle(palette)\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Least-conflicting among existing colors\n            cur = new_sol[i-1]\n            best_c = cur\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == cur)\n            for c in palette:\n                if c == cur:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # 2) Color elimination: try moving vertices from the highest color to lower feasible colors\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    moved = False\n    for i in max_vertices:\n        lower_palette = set(new_sol) - {max_color}\n        feas = feasible_colors(i, new_sol, lower_palette)\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        # If highest color eliminated, relabel compactly to 1..m\n        if all(c != max_color for c in new_sol):\n            mapping = {}\n            nxt = 1\n            for c in new_sol:\n                if c not in mapping:\n                    mapping[c] = nxt\n                    nxt += 1\n            new_sol = [mapping[c] for c in new_sol]\n        return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap (diversification), biased to include max color\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        if random.random() < 0.7 and max_color in colors:\n            # seed from max_color class\n            candidates = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n            i = random.choice(candidates)\n            a = max_color\n            b = random.choice([c for c in colors if c != a])\n        else:\n            i = random.randint(1, n)\n            a = new_sol[i-1]\n            b = random.choice([c for c in colors if c != a])\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # 4) Fallback: random feasible recolor within existing palette\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize, then keep labels stable (canonical only at end)\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n\n    def conflicted(sol_local):\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                return True\n        return False\n\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move = random.random()\n        colors = list(set(new_sol))\n        if move < 0.5 and len(colors) >= 2:\n            # Kempe swap burst\n            if random.random() < 0.6:\n                # bias to include max color\n                max_color = max(colors)\n                seeds = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n                i = random.choice(seeds)\n                a = max_color\n                b = random.choice([c for c in colors if c != a])\n            else:\n                i = random.randint(1, n)\n                a = new_sol[i-1]\n                b = random.choice([c for c in colors if c != a])\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move < 0.8:\n            # Random vertex recolor, prefer feasible within current palette\n            i = random.randint(1, n)\n            palette = list(set(new_sol))\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color class labels\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n\n    # Canonical relabeling to 1..m at the end for cleanliness\n    mapping = {}\n    nxt = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001256356}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    W = 10**8  # conflict weight\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return conflicts * W + num_groups\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\/init solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonical_relabel(sol_local):\n        # Stable relabeling by sorted unique colors\n        uniq = sorted(set(sol_local))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, palette=None):\n        if palette is None:\n            palette = set(sol_local)\n        neigh_cols = {sol_local[j-1] for j in adj[node]}\n        return [c for c in palette if c not in neigh_cols]\n\n    new_sol = sol[:]\n\n    # 1) Conflict-directed repair (may introduce new color if necessary)\n    conflicted = conflict_vertices(new_sol)\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(set(new_sol))\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n            meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"RecolorFeasible\"}\n        else:\n            # Either least-conflicting among existing colors or introduce k+1 with small prob\n            if random.random() < 0.25:\n                new_sol[i-1] = max(palette) + 1\n                meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"IntroduceNewColor\"}\n            else:\n                cur = new_sol[i-1]\n                best_c = cur\n                best_conf = sum(1 for j in adj[i] if new_sol[j-1] == cur)\n                for c in palette:\n                    if c == cur:\n                        continue\n                    conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_sol[i-1] = best_c\n                meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"RecolorLeastConflicting\"}\n        new_sol = canonical_relabel(new_sol)\n        return new_sol, meta\n\n    # 2) Greedy color elimination on max color class (best-improvement)\n    colors = sorted(set(new_sol))\n    max_color = colors[-1]\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    best_delta = 0\n    best_move = None\n    lower_palette = set(colors) - {max_color}\n    for i in max_vertices:\n        feas = feasible_colors(i, new_sol, lower_palette)\n        if not feas:\n            continue\n        # prefer lowest feasible color for stability\n        c_new = min(feas)\n        # simulate move and evaluate delta in k\n        # If after moving all vertices leave max_color empty, k reduces by 1\n        would_empty = all((idx != i and new_sol[idx-1] == max_color) == False for idx in range(1, n+1))\n        # More accurate: check if this i is the last vertex in max_color\n        cnt_max = sum(1 for x in new_sol if x == max_color)\n        would_empty = (cnt_max == 1)\n        delta = -1 if would_empty else 0\n        if delta < best_delta:\n            best_delta = delta\n            best_move = (i, c_new)\n        # If any direct elimination possible, take it immediately\n        if delta == -1:\n            best_move = (i, c_new)\n            break\n    if best_move is not None:\n        i, c_new = best_move\n        new_sol[i-1] = c_new\n        # If highest color eliminated, relabel compactly\n        if all(c != max_color for c in new_sol):\n            new_sol = canonical_relabel(new_sol)\n        meta = {\"nb_type\":\"ImprovementDirected\",\"move\":\"ColorElimination\"}\n        return new_sol, meta\n\n    # 3) Kempe-chain swap (diversification), biased to include max color\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        if random.random() < 0.7 and max_color in colors:\n            candidates = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n            i = random.choice(candidates)\n            a = max_color\n            b = random.choice([c for c in colors if c != a])\n        else:\n            i = random.randint(1, n)\n            a = new_sol[i-1]\n            b = random.choice([c for c in colors if c != a])\n        comp = set()\n        dq = deque([i])\n        seen = {i}\n        while dq:\n            u = dq.popleft()\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in seen:\n                    seen.add(v)\n                    dq.append(v)\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        new_sol = canonical_relabel(new_sol)\n        meta = {\"nb_type\":\"Diversification\",\"move\":\"KempeSwap\"}\n        return new_sol, meta\n\n    # 4) Fallback: random feasible recolor within existing palette\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    new_sol = canonical_relabel(new_sol)\n    meta = {\"nb_type\":\"Fallback\",\"move\":\"Recolor\"}\n    return new_sol, meta\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate\/init solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonical_relabel(sol_local):\n        uniq = sorted(set(sol_local))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    new_sol = sol[:]\n\n    # Strength scaled to palette size\n    k = len(set(new_sol))\n    num_kicks = max(2, min(4, k+1))\n    for _ in range(num_kicks):\n        move = random.random()\n        colors = sorted(set(new_sol))\n        if move < 0.5 and len(colors) >= 2:\n            # Kempe swap burst\n            if random.random() < 0.6:\n                max_color = colors[-1]\n                seeds = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n                i = random.choice(seeds)\n                a = max_color\n                b = random.choice([c for c in colors if c != a])\n            else:\n                i = random.randint(1, n)\n                a = new_sol[i-1]\n                b = random.choice([c for c in colors if c != a])\n            comp = set()\n            dq = deque([i])\n            seen = {i}\n            while dq:\n                u = dq.popleft()\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in seen:\n                        seen.add(v)\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move < 0.85:\n            # Random vertex recolor, prefer feasible within current palette\n            i = random.randint(1, n)\n            palette = list(set(new_sol))\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color class labels\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n\n    new_sol = canonical_relabel(new_sol)\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0012697651}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    W = 10**8  # conflict weight\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return conflicts * W + num_groups\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\/init solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonical_relabel(sol_local):\n        # Stable relabeling by sorted unique colors\n        uniq = sorted(set(sol_local))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, palette=None):\n        if palette is None:\n            palette = set(sol_local)\n        neigh_cols = {sol_local[j-1] for j in adj[node]}\n        return [c for c in palette if c not in neigh_cols]\n\n    new_sol = sol[:]\n\n    # 1) Conflict-directed repair (may introduce new color if necessary)\n    conflicted = conflict_vertices(new_sol)\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(set(new_sol))\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n            meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"RecolorFeasible\"}\n        else:\n            # Either least-conflicting among existing colors or introduce k+1 with small prob\n            if random.random() < 0.25:\n                new_sol[i-1] = max(palette) + 1\n                meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"IntroduceNewColor\"}\n            else:\n                cur = new_sol[i-1]\n                best_c = cur\n                best_conf = sum(1 for j in adj[i] if new_sol[j-1] == cur)\n                for c in palette:\n                    if c == cur:\n                        continue\n                    conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_sol[i-1] = best_c\n                meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"RecolorLeastConflicting\"}\n        new_sol = canonical_relabel(new_sol)\n        return new_sol, meta\n\n    # 2) Greedy color elimination on max color class (best-improvement)\n    colors = sorted(set(new_sol))\n    max_color = colors[-1]\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    best_delta = 0\n    best_move = None\n    lower_palette = set(colors) - {max_color}\n    for i in max_vertices:\n        feas = feasible_colors(i, new_sol, lower_palette)\n        if not feas:\n            continue\n        # prefer lowest feasible color for stability\n        c_new = min(feas)\n        # simulate move and evaluate delta in k\n        # If after moving all vertices leave max_color empty, k reduces by 1\n        would_empty = all((idx != i and new_sol[idx-1] == max_color) == False for idx in range(1, n+1))\n        # More accurate: check if this i is the last vertex in max_color\n        cnt_max = sum(1 for x in new_sol if x == max_color)\n        would_empty = (cnt_max == 1)\n        delta = -1 if would_empty else 0\n        if delta < best_delta:\n            best_delta = delta\n            best_move = (i, c_new)\n        # If any direct elimination possible, take it immediately\n        if delta == -1:\n            best_move = (i, c_new)\n            break\n    if best_move is not None:\n        i, c_new = best_move\n        new_sol[i-1] = c_new\n        # If highest color eliminated, relabel compactly\n        if all(c != max_color for c in new_sol):\n            new_sol = canonical_relabel(new_sol)\n        meta = {\"nb_type\":\"ImprovementDirected\",\"move\":\"ColorElimination\"}\n        return new_sol, meta\n\n    # 3) Kempe-chain swap (diversification), biased to include max color\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        if random.random() < 0.7 and max_color in colors:\n            candidates = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n            i = random.choice(candidates)\n            a = max_color\n            b = random.choice([c for c in colors if c != a])\n        else:\n            i = random.randint(1, n)\n            a = new_sol[i-1]\n            b = random.choice([c for c in colors if c != a])\n        comp = set()\n        dq = deque([i])\n        seen = {i}\n        while dq:\n            u = dq.popleft()\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in seen:\n                    seen.add(v)\n                    dq.append(v)\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        new_sol = canonical_relabel(new_sol)\n        meta = {\"nb_type\":\"Diversification\",\"move\":\"KempeSwap\"}\n        return new_sol, meta\n\n    # 4) Fallback: random feasible recolor within existing palette\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    new_sol = canonical_relabel(new_sol)\n    meta = {\"nb_type\":\"Fallback\",\"move\":\"Recolor\"}\n    return new_sol, meta\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate\/init solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonical_relabel(sol_local):\n        uniq = sorted(set(sol_local))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    new_sol = sol[:]\n\n    # Strength scaled to palette size\n    k = len(set(new_sol))\n    num_kicks = max(2, min(4, k+1))\n    for _ in range(num_kicks):\n        move = random.random()\n        colors = sorted(set(new_sol))\n        if move < 0.5 and len(colors) >= 2:\n            # Kempe swap burst\n            if random.random() < 0.6:\n                max_color = colors[-1]\n                seeds = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n                i = random.choice(seeds)\n                a = max_color\n                b = random.choice([c for c in colors if c != a])\n            else:\n                i = random.randint(1, n)\n                a = new_sol[i-1]\n                b = random.choice([c for c in colors if c != a])\n            comp = set()\n            dq = deque([i])\n            seen = {i}\n            while dq:\n                u = dq.popleft()\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in seen:\n                        seen.add(v)\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move < 0.85:\n            # Random vertex recolor, prefer feasible within current palette\n            i = random.randint(1, n)\n            palette = list(set(new_sol))\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color class labels\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n\n    new_sol = canonical_relabel(new_sol)\n    return new_sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001631599}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    W = 10**8  # conflict weight\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return conflicts * W + num_groups\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\/init solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonical_relabel(sol_local):\n        # Stable relabeling by sorted unique colors\n        uniq = sorted(set(sol_local))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, palette=None):\n        if palette is None:\n            palette = set(sol_local)\n        neigh_cols = {sol_local[j-1] for j in adj[node]}\n        return [c for c in palette if c not in neigh_cols]\n\n    new_sol = sol[:]\n\n    # 1) Conflict-directed repair (may introduce new color if necessary)\n    conflicted = conflict_vertices(new_sol)\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(set(new_sol))\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n            meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"RecolorFeasible\"}\n        else:\n            # Either least-conflicting among existing colors or introduce k+1 with small prob\n            if random.random() < 0.25:\n                new_sol[i-1] = max(palette) + 1\n                meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"IntroduceNewColor\"}\n            else:\n                cur = new_sol[i-1]\n                best_c = cur\n                best_conf = sum(1 for j in adj[i] if new_sol[j-1] == cur)\n                for c in palette:\n                    if c == cur:\n                        continue\n                    conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_sol[i-1] = best_c\n                meta = {\"nb_type\":\"ConflictDirected\",\"move\":\"RecolorLeastConflicting\"}\n        new_sol = canonical_relabel(new_sol)\n        return new_sol, meta\n\n    # 2) Greedy color elimination on max color class (best-improvement)\n    colors = sorted(set(new_sol))\n    max_color = colors[-1]\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    best_delta = 0\n    best_move = None\n    lower_palette = set(colors) - {max_color}\n    for i in max_vertices:\n        feas = feasible_colors(i, new_sol, lower_palette)\n        if not feas:\n            continue\n        # prefer lowest feasible color for stability\n        c_new = min(feas)\n        # simulate move and evaluate delta in k\n        # If after moving all vertices leave max_color empty, k reduces by 1\n        would_empty = all((idx != i and new_sol[idx-1] == max_color) == False for idx in range(1, n+1))\n        # More accurate: check if this i is the last vertex in max_color\n        cnt_max = sum(1 for x in new_sol if x == max_color)\n        would_empty = (cnt_max == 1)\n        delta = -1 if would_empty else 0\n        if delta < best_delta:\n            best_delta = delta\n            best_move = (i, c_new)\n        # If any direct elimination possible, take it immediately\n        if delta == -1:\n            best_move = (i, c_new)\n            break\n    if best_move is not None:\n        i, c_new = best_move\n        new_sol[i-1] = c_new\n        # If highest color eliminated, relabel compactly\n        if all(c != max_color for c in new_sol):\n            new_sol = canonical_relabel(new_sol)\n        meta = {\"nb_type\":\"ImprovementDirected\",\"move\":\"ColorElimination\"}\n        return new_sol, meta\n\n    # 3) Kempe-chain swap (diversification), biased to include max color\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        if random.random() < 0.7 and max_color in colors:\n            candidates = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n            i = random.choice(candidates)\n            a = max_color\n            b = random.choice([c for c in colors if c != a])\n        else:\n            i = random.randint(1, n)\n            a = new_sol[i-1]\n            b = random.choice([c for c in colors if c != a])\n        comp = set()\n        dq = deque([i])\n        seen = {i}\n        while dq:\n            u = dq.popleft()\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in seen:\n                    seen.add(v)\n                    dq.append(v)\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        new_sol = canonical_relabel(new_sol)\n        meta = {\"nb_type\":\"Diversification\",\"move\":\"KempeSwap\"}\n        return new_sol, meta\n\n    # 4) Fallback: random feasible recolor within existing palette\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    new_sol = canonical_relabel(new_sol)\n    meta = {\"nb_type\":\"Fallback\",\"move\":\"Recolor\"}\n    return new_sol, meta\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate\/init solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonical_relabel(sol_local):\n        uniq = sorted(set(sol_local))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    new_sol = sol[:]\n\n    # Strength scaled to palette size\n    k = len(set(new_sol))\n    num_kicks = max(2, min(4, k+1))\n    for _ in range(num_kicks):\n        move = random.random()\n        colors = sorted(set(new_sol))\n        if move < 0.5 and len(colors) >= 2:\n            # Kempe swap burst\n            if random.random() < 0.6:\n                max_color = colors[-1]\n                seeds = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n                i = random.choice(seeds)\n                a = max_color\n                b = random.choice([c for c in colors if c != a])\n            else:\n                i = random.randint(1, n)\n                a = new_sol[i-1]\n                b = random.choice([c for c in colors if c != a])\n            comp = set()\n            dq = deque([i])\n            seen = {i}\n            while dq:\n                u = dq.popleft()\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in seen:\n                        seen.add(v)\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move < 0.85:\n            # Random vertex recolor, prefer feasible within current palette\n            i = random.randint(1, n)\n            palette = list(set(new_sol))\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color class labels\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n\n    new_sol = canonical_relabel(new_sol)\n    return new_sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0015294979}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_1..9. Encoding: solution is a Python list of 9 positive integers [x1,...,x9], xi in {1..9}, where xi is the color assigned to vertex i.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph data embedded\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty; smaller K as tie-breaker\n        return 10**6 + 1000 * conflicts + K\n    # Valid coloring: minimize K\n    return K\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback: random valid-length vector with colors in 1..n\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = solution[:]\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Candidate vertices to change\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Choose vertex with highest degree to encourage impactful move\n        deg = [0]*n\n        for (u,v) in E:\n            deg[u-1] += 1\n            deg[v-1] += 1\n        max_deg = max(deg)\n        candidates = [i for i,d in enumerate(deg) if d == max_deg]\n        idx = random.choice(candidates)\n    current_color = new_sol[idx]\n    K = max(1, max(new_sol))\n    # Allowed colors: try within 1..K, occasionally allow K+1 to escape local minima\n    allow_new = list(range(1, K+1))\n    if random.random() < 0.1 and K < n:\n        allow_new.append(K+1)\n    if current_color in allow_new and len(allow_new) > 1:\n        allow_new.remove(current_color)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    feasible = [c for c in allow_new if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        new_color = random.choice(allow_new)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","Perturbacion":"import random\nimport copy\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: (a) random recolors, (b) random two-color component swap (Kempe chain style)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = solution[:]\n    # Step 1: t random recolors biased to conflicts or high degree\n    t = random.randint(2, 4)\n    deg = [0]*n\n    for (u,v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    for _ in range(t):\n        # Choose index with probability proportional to degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K+1, n+1)))\n        if random.random() < 0.25 and K < n:\n            colors.append(K+1)\n        if sol[idx] in colors and len(colors) > 1:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-like swap on random component of two colors\n    if len(set(sol)) >= 2:\n        c1, c2 = random.sample(list(set(sol)), 2)\n        # Build subgraph of vertices with colors in {c1,c2}\n        sub_vertices = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if sub_vertices:\n            start = random.choice(sub_vertices)\n            target_set = set(sub_vertices)\n            # BFS on induced subgraph restricted to edges whose endpoints are in target_set\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in target_set and v0 in target_set:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1<->c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000576406}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_1..9. Encoding: solution is a Python list of 9 positive integers [x1,...,x9], xi in {1..9}, where xi is the color assigned to vertex i.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph data embedded\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty; smaller K as tie-breaker\n        return 10**6 + 1000 * conflicts + K\n    # Valid coloring: minimize K\n    return K\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback: random valid-length vector with colors in 1..n\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = solution[:]\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Candidate vertices to change\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Choose vertex with highest degree to encourage impactful move\n        deg = [0]*n\n        for (u,v) in E:\n            deg[u-1] += 1\n            deg[v-1] += 1\n        max_deg = max(deg)\n        candidates = [i for i,d in enumerate(deg) if d == max_deg]\n        idx = random.choice(candidates)\n    current_color = new_sol[idx]\n    K = max(1, max(new_sol))\n    # Allowed colors: try within 1..K, occasionally allow K+1 to escape local minima\n    allow_new = list(range(1, K+1))\n    if random.random() < 0.1 and K < n:\n        allow_new.append(K+1)\n    if current_color in allow_new and len(allow_new) > 1:\n        allow_new.remove(current_color)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    feasible = [c for c in allow_new if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        new_color = random.choice(allow_new)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","Perturbacion":"import random\nimport copy\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: (a) random recolors, (b) random two-color component swap (Kempe chain style)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = solution[:]\n    # Step 1: t random recolors biased to conflicts or high degree\n    t = random.randint(2, 4)\n    deg = [0]*n\n    for (u,v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    for _ in range(t):\n        # Choose index with probability proportional to degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K+1, n+1)))\n        if random.random() < 0.25 and K < n:\n            colors.append(K+1)\n        if sol[idx] in colors and len(colors) > 1:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-like swap on random component of two colors\n    if len(set(sol)) >= 2:\n        c1, c2 = random.sample(list(set(sol)), 2)\n        # Build subgraph of vertices with colors in {c1,c2}\n        sub_vertices = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if sub_vertices:\n            start = random.choice(sub_vertices)\n            target_set = set(sub_vertices)\n            # BFS on induced subgraph restricted to edges whose endpoints are in target_set\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in target_set and v0 in target_set:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1<->c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000823339}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_1..9. Encoding: solution is a Python list of 9 positive integers [x1,...,x9], xi in {1..9}, where xi is the color assigned to vertex i.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph data embedded\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty; smaller K as tie-breaker\n        return 10**6 + 1000 * conflicts + K\n    # Valid coloring: minimize K\n    return K\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback: random valid-length vector with colors in 1..n\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = solution[:]\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Candidate vertices to change\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Choose vertex with highest degree to encourage impactful move\n        deg = [0]*n\n        for (u,v) in E:\n            deg[u-1] += 1\n            deg[v-1] += 1\n        max_deg = max(deg)\n        candidates = [i for i,d in enumerate(deg) if d == max_deg]\n        idx = random.choice(candidates)\n    current_color = new_sol[idx]\n    K = max(1, max(new_sol))\n    # Allowed colors: try within 1..K, occasionally allow K+1 to escape local minima\n    allow_new = list(range(1, K+1))\n    if random.random() < 0.1 and K < n:\n        allow_new.append(K+1)\n    if current_color in allow_new and len(allow_new) > 1:\n        allow_new.remove(current_color)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    feasible = [c for c in allow_new if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        new_color = random.choice(allow_new)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","Perturbacion":"import random\nimport copy\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: (a) random recolors, (b) random two-color component swap (Kempe chain style)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = solution[:]\n    # Step 1: t random recolors biased to conflicts or high degree\n    t = random.randint(2, 4)\n    deg = [0]*n\n    for (u,v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    for _ in range(t):\n        # Choose index with probability proportional to degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K+1, n+1)))\n        if random.random() < 0.25 and K < n:\n            colors.append(K+1)\n        if sol[idx] in colors and len(colors) > 1:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-like swap on random component of two colors\n    if len(set(sol)) >= 2:\n        c1, c2 = random.sample(list(set(sol)), 2)\n        # Build subgraph of vertices with colors in {c1,c2}\n        sub_vertices = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if sub_vertices:\n            start = random.choice(sub_vertices)\n            target_set = set(sub_vertices)\n            # BFS on induced subgraph restricted to edges whose endpoints are in target_set\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in target_set and v0 in target_set:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1<->c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00079794}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] of length 9. solution[i] in {1..9} encodes color of vertex i+1.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Fallback if invalid input\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = list(solution)\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Degrees\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Choose index to modify\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Bias toward vertices on current max color to enable K reduction\n        K = max(1, max(new_sol))\n        on_K = [i for i, c in enumerate(new_sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # Highest degree as fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Determine candidate colors within [1..n]\n    K = max(1, max(new_sol))\n    allowed = list(range(1, min(K, n) + 1))\n    # Occasionally allow trying lower color to reduce K; if no conflicts, do not increase K\n    if conflicted and K < n and random.random() < 0.1:\n        allowed.append(K+1)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    candidates = [c for c in allowed if c != new_sol[idx]]\n    preferred = [c for c in candidates if c not in neighbor_colors]\n    new_color = random.choice(preferred if preferred else candidates)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-step perturbation: random recolors + Kempe-chain swap\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Degrees for bias\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Step 1: t random biased recolors\n    t = random.randint(2, 4)\n    for _ in range(t):\n        # roulette by degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K, n) + 1))\n        if K < n and random.random() < 0.25:\n            colors.append(K+1)\n        if len(colors) > 1 and sol[idx] in colors:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-chain swap between two colors\n    used = list(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            start = random.choice(list(sub))\n            # Build adjacency on induced subgraph\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            # BFS from start within subgraph\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1 <-> c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Clamp domain to [1..n]\n    for i in range(n):\n        if sol[i] < 1:\n            sol[i] = 1\n        elif sol[i] > n:\n            sol[i] = n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000650528}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] of length 9. solution[i] in {1..9} encodes color of vertex i+1.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Fallback if invalid input\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = list(solution)\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Degrees\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Choose index to modify\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Bias toward vertices on current max color to enable K reduction\n        K = max(1, max(new_sol))\n        on_K = [i for i, c in enumerate(new_sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # Highest degree as fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Determine candidate colors within [1..n]\n    K = max(1, max(new_sol))\n    allowed = list(range(1, min(K, n) + 1))\n    # Occasionally allow trying lower color to reduce K; if no conflicts, do not increase K\n    if conflicted and K < n and random.random() < 0.1:\n        allowed.append(K+1)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    candidates = [c for c in allowed if c != new_sol[idx]]\n    preferred = [c for c in candidates if c not in neighbor_colors]\n    new_color = random.choice(preferred if preferred else candidates)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-step perturbation: random recolors + Kempe-chain swap\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Degrees for bias\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Step 1: t random biased recolors\n    t = random.randint(2, 4)\n    for _ in range(t):\n        # roulette by degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K, n) + 1))\n        if K < n and random.random() < 0.25:\n            colors.append(K+1)\n        if len(colors) > 1 and sol[idx] in colors:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-chain swap between two colors\n    used = list(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            start = random.choice(list(sub))\n            # Build adjacency on induced subgraph\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            # BFS from start within subgraph\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1 <-> c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Clamp domain to [1..n]\n    for i in range(n):\n        if sol[i] < 1:\n            sol[i] = 1\n        elif sol[i] > n:\n            sol[i] = n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0009642399}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] of length 9. solution[i] in {1..9} encodes color of vertex i+1.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Fallback if invalid input\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = list(solution)\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Degrees\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Choose index to modify\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Bias toward vertices on current max color to enable K reduction\n        K = max(1, max(new_sol))\n        on_K = [i for i, c in enumerate(new_sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # Highest degree as fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Determine candidate colors within [1..n]\n    K = max(1, max(new_sol))\n    allowed = list(range(1, min(K, n) + 1))\n    # Occasionally allow trying lower color to reduce K; if no conflicts, do not increase K\n    if conflicted and K < n and random.random() < 0.1:\n        allowed.append(K+1)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    candidates = [c for c in allowed if c != new_sol[idx]]\n    preferred = [c for c in candidates if c not in neighbor_colors]\n    new_color = random.choice(preferred if preferred else candidates)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-step perturbation: random recolors + Kempe-chain swap\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Degrees for bias\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Step 1: t random biased recolors\n    t = random.randint(2, 4)\n    for _ in range(t):\n        # roulette by degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K, n) + 1))\n        if K < n and random.random() < 0.25:\n            colors.append(K+1)\n        if len(colors) > 1 and sol[idx] in colors:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-chain swap between two colors\n    used = list(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            start = random.choice(list(sub))\n            # Build adjacency on induced subgraph\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            # BFS from start within subgraph\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1 <-> c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Clamp domain to [1..n]\n    for i in range(n):\n        if sol[i] < 1:\n            sol[i] = 1\n        elif sol[i] > n:\n            sol[i] = n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00094084}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] length 9. solution[i-1] is color of vertex i (1-indexed). Colors are positive integers with K = max(solution) and typically constrained to 1..K (K<=9).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate type and domain\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Cost: normalized penalty to preserve gradient\n    return 1000 * conflicts + K","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Fallback initialization if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 3) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"Init\")\n    sol = list(solution)\n    # Compute conflicts per vertex and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    K = max(sol)\n    # Vertex selection: prioritize conflicted with higher conflicts then degree; else vertices on max color\n    conflicted = [i for i in range(n) if conflicts_v[i] > 0]\n    if conflicted:\n        conflicted.sort(key=lambda i: (conflicts_v[i], deg[i]), reverse=True)\n        idx = conflicted[0]\n    else:\n        on_K = [i for i, c in enumerate(sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # highest degree fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Candidate colors: 1..K; permit K+1 only if no feasible color in 1..K\n    used_colors = set(sol)\n    candidate_colors = list(range(1, K+1))\n    # Evaluate each candidate by resulting local conflicts and potential K effect\n    best_c = sol[idx]\n    best_loc = None\n    best_tuple = (10**9, 10**9)  # (local_conflicts, new_K)\n    neigh_colors = {sol[j] for j in adj[idx]}\n    for c in candidate_colors:\n        if c == sol[idx]:\n            continue\n        local_conflicts = 0\n        # conflicts only with neighbors of idx\n        for j in adj[idx]:\n            if sol[j] == c:\n                local_conflicts += 1\n        new_K = max(c, K if sol[idx] < K else max([x for k, x in enumerate(sol) if k != idx] + [1]))\n        # Prefer fewer conflicts, then smaller K, then smaller color\n        key = (local_conflicts, new_K, c)\n        if key < best_tuple:\n            best_tuple = key\n            best_c = c\n            best_loc = local_conflicts\n    # If no improvement and idx has all colors in 1..K conflicting, allow K+1 escape\n    if best_loc is not None and best_loc > 0 and (neigh_colors.issuperset(set(candidate_colors))):\n        best_c = K + 1 if K < n else best_c\n    # Apply recolor\n    sol[idx] = best_c\n    # Compress palette to 1..K' to keep domain tight\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return (sol, \"NB_Recolor\", \"1-change\")","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Initialize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Step 1: biased random recolors on high-degree\/conflict vertices\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    weights = [1 + 2*conflicts_v[i] + deg[i] for i in range(n)]\n    t = random.randint(2, 4)\n    for _ in range(t):\n        s = sum(weights)\n        r = random.randint(1, s)\n        acc = 0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n        K = max(sol)\n        cand = list(range(1, min(K, n) + 1))\n        if sol[idx] in cand and len(cand) > 1:\n            cand.remove(sol[idx])\n        if not cand and K < n:\n            cand = [K+1]\n        if cand:\n            sol[idx] = random.choice(cand)\n    # Step 2: Kempe-chain swap between two used colors (if at least two exist)\n    used = sorted(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            # Build induced adjacency\n            iadj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    iadj[u0].append(v0)\n                    iadj[v0].append(u0)\n            start = random.choice(list(sub))\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in iadj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Palette compression\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return sol","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0007367181}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] length 9. solution[i-1] is color of vertex i (1-indexed). Colors are positive integers with K = max(solution) and typically constrained to 1..K (K<=9).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate type and domain\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Cost: normalized penalty to preserve gradient\n    return 1000 * conflicts + K","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Fallback initialization if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 3) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"Init\")\n    sol = list(solution)\n    # Compute conflicts per vertex and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    K = max(sol)\n    # Vertex selection: prioritize conflicted with higher conflicts then degree; else vertices on max color\n    conflicted = [i for i in range(n) if conflicts_v[i] > 0]\n    if conflicted:\n        conflicted.sort(key=lambda i: (conflicts_v[i], deg[i]), reverse=True)\n        idx = conflicted[0]\n    else:\n        on_K = [i for i, c in enumerate(sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # highest degree fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Candidate colors: 1..K; permit K+1 only if no feasible color in 1..K\n    used_colors = set(sol)\n    candidate_colors = list(range(1, K+1))\n    # Evaluate each candidate by resulting local conflicts and potential K effect\n    best_c = sol[idx]\n    best_loc = None\n    best_tuple = (10**9, 10**9)  # (local_conflicts, new_K)\n    neigh_colors = {sol[j] for j in adj[idx]}\n    for c in candidate_colors:\n        if c == sol[idx]:\n            continue\n        local_conflicts = 0\n        # conflicts only with neighbors of idx\n        for j in adj[idx]:\n            if sol[j] == c:\n                local_conflicts += 1\n        new_K = max(c, K if sol[idx] < K else max([x for k, x in enumerate(sol) if k != idx] + [1]))\n        # Prefer fewer conflicts, then smaller K, then smaller color\n        key = (local_conflicts, new_K, c)\n        if key < best_tuple:\n            best_tuple = key\n            best_c = c\n            best_loc = local_conflicts\n    # If no improvement and idx has all colors in 1..K conflicting, allow K+1 escape\n    if best_loc is not None and best_loc > 0 and (neigh_colors.issuperset(set(candidate_colors))):\n        best_c = K + 1 if K < n else best_c\n    # Apply recolor\n    sol[idx] = best_c\n    # Compress palette to 1..K' to keep domain tight\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return (sol, \"NB_Recolor\", \"1-change\")","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Initialize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Step 1: biased random recolors on high-degree\/conflict vertices\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    weights = [1 + 2*conflicts_v[i] + deg[i] for i in range(n)]\n    t = random.randint(2, 4)\n    for _ in range(t):\n        s = sum(weights)\n        r = random.randint(1, s)\n        acc = 0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n        K = max(sol)\n        cand = list(range(1, min(K, n) + 1))\n        if sol[idx] in cand and len(cand) > 1:\n            cand.remove(sol[idx])\n        if not cand and K < n:\n            cand = [K+1]\n        if cand:\n            sol[idx] = random.choice(cand)\n    # Step 2: Kempe-chain swap between two used colors (if at least two exist)\n    used = sorted(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            # Build induced adjacency\n            iadj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    iadj[u0].append(v0)\n                    iadj[v0].append(u0)\n            start = random.choice(list(sub))\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in iadj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Palette compression\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return sol","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0010493411}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] length 9. solution[i-1] is color of vertex i (1-indexed). Colors are positive integers with K = max(solution) and typically constrained to 1..K (K<=9).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate type and domain\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Cost: normalized penalty to preserve gradient\n    return 1000 * conflicts + K","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Fallback initialization if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 3) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"Init\")\n    sol = list(solution)\n    # Compute conflicts per vertex and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    K = max(sol)\n    # Vertex selection: prioritize conflicted with higher conflicts then degree; else vertices on max color\n    conflicted = [i for i in range(n) if conflicts_v[i] > 0]\n    if conflicted:\n        conflicted.sort(key=lambda i: (conflicts_v[i], deg[i]), reverse=True)\n        idx = conflicted[0]\n    else:\n        on_K = [i for i, c in enumerate(sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # highest degree fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Candidate colors: 1..K; permit K+1 only if no feasible color in 1..K\n    used_colors = set(sol)\n    candidate_colors = list(range(1, K+1))\n    # Evaluate each candidate by resulting local conflicts and potential K effect\n    best_c = sol[idx]\n    best_loc = None\n    best_tuple = (10**9, 10**9)  # (local_conflicts, new_K)\n    neigh_colors = {sol[j] for j in adj[idx]}\n    for c in candidate_colors:\n        if c == sol[idx]:\n            continue\n        local_conflicts = 0\n        # conflicts only with neighbors of idx\n        for j in adj[idx]:\n            if sol[j] == c:\n                local_conflicts += 1\n        new_K = max(c, K if sol[idx] < K else max([x for k, x in enumerate(sol) if k != idx] + [1]))\n        # Prefer fewer conflicts, then smaller K, then smaller color\n        key = (local_conflicts, new_K, c)\n        if key < best_tuple:\n            best_tuple = key\n            best_c = c\n            best_loc = local_conflicts\n    # If no improvement and idx has all colors in 1..K conflicting, allow K+1 escape\n    if best_loc is not None and best_loc > 0 and (neigh_colors.issuperset(set(candidate_colors))):\n        best_c = K + 1 if K < n else best_c\n    # Apply recolor\n    sol[idx] = best_c\n    # Compress palette to 1..K' to keep domain tight\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return (sol, \"NB_Recolor\", \"1-change\")","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Initialize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Step 1: biased random recolors on high-degree\/conflict vertices\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    weights = [1 + 2*conflicts_v[i] + deg[i] for i in range(n)]\n    t = random.randint(2, 4)\n    for _ in range(t):\n        s = sum(weights)\n        r = random.randint(1, s)\n        acc = 0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n        K = max(sol)\n        cand = list(range(1, min(K, n) + 1))\n        if sol[idx] in cand and len(cand) > 1:\n            cand.remove(sol[idx])\n        if not cand and K < n:\n            cand = [K+1]\n        if cand:\n            sol[idx] = random.choice(cand)\n    # Step 2: Kempe-chain swap between two used colors (if at least two exist)\n    used = sorted(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            # Build induced adjacency\n            iadj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    iadj[u0].append(v0)\n                    iadj[v0].append(u0)\n            start = random.choice(list(sub))\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in iadj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Palette compression\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return sol","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001040521}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] length 9; solution[i-1] is the color (int in [1..9]) of vertex i. Objective K = max(solution), constraints x_u != x_v for all edges.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph constants\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    # Evaluate conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    # Cost prioritizes conflict elimination, then minimizes K\n    return 1000 * conflicts + K\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Initialize\/clone and validate\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for c in sol:\n            if not isinstance(c, int) or c < 1 or c > n:\n                sol = [random.randint(1, 3) for _ in range(n)]\n                break\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Compute conflicts per vertex and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    K = max(sol)\n\n    # Select move type with diversification\n    # Higher chance to recolor if conflicts exist; else try Kempe\/swap to reduce K\n    has_conflict = any(c > 0 for c in conflicts_v)\n    if has_conflict:\n        move_probs = [(\"Recolor\", 0.6), (\"Kempe\", 0.25), (\"Swap\", 0.15)]\n    else:\n        move_probs = [(\"Kempe\", 0.5), (\"Swap\", 0.3), (\"Recolor\", 0.2)]\n    r = random.random()\n    acc = 0.0\n    move = \"Recolor\"\n    for name, p in move_probs:\n        acc += p\n        if r <= acc:\n            move = name\n            break\n\n    new_sol = list(sol)\n\n    if move == \"Recolor\":\n        # Pick vertex: prioritize conflicted, then highest degree, then random among max color class\n        candidates = [i for i in range(n) if conflicts_v[i] > 0]\n        if candidates:\n            candidates.sort(key=lambda i: (conflicts_v[i], deg[i]))\n            idx = candidates[-1]\n        else:\n            max_color_vertices = [i for i, c in enumerate(sol) if c == K]\n            if max_color_vertices:\n                idx = random.choice(max_color_vertices)\n            else:\n                mdeg = max(deg)\n                idx = random.choice([i for i, d in enumerate(deg) if d == mdeg])\n        # Try colors 1..K (and possibly K+1 if conflicts persist)\n        best_c = sol[idx]\n        best_key = (10**9, 10**9, 10**9)  # (local_conflicts, new_K, color)\n        # Precompute max color excluding idx for new_K computation (avoid incorrect inflation)\n        max_ex_idx = max([sol[j] for j in range(n) if j != idx] + [1])\n        for c in range(1, min(K, n) + 1):\n            if c == sol[idx]:\n                continue\n            local_conflicts = 0\n            for j in adj[idx]:\n                if sol[j] == c:\n                    local_conflicts += 1\n            new_K = max(c, max_ex_idx)\n            key = (local_conflicts, new_K, c)\n            if key < best_key:\n                best_key = key\n                best_c = c\n        # If still conflicting heavily at idx, allow K+1 escape (bounded by n)\n        local_after = 0\n        for j in adj[idx]:\n            if sol[j] == best_c:\n                local_after += 1\n        if local_after > 0 and K < n:\n            # Consider K+1 only if all colors 1..K cause conflict at idx\n            all_conflict = True\n            for c in range(1, min(K, n) + 1):\n                if c == sol[idx]:\n                    continue\n                if all(sol[j] != c for j in adj[idx]):\n                    all_conflict = False\n                    break\n            if all_conflict:\n                best_c = K + 1\n        new_sol[idx] = best_c\n        nb_type, mv_type = \"NB_Recolor\", \"1-change\"\n\n    elif move == \"Swap\":\n        # Swap colors of two vertices with different colors (pair-exchange)\n        # Prefer picking one conflicted vertex to escape plateaus\n        conflicted = [i for i in range(n) if conflicts_v[i] > 0]\n        if conflicted:\n            i = random.choice(conflicted)\n        else:\n            i = random.randrange(n)\n        # pick j with different color\n        others = [j for j in range(n) if sol[j] != sol[i]]\n        if not others:\n            j = i\n        else:\n            j = random.choice(others)\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        nb_type, mv_type = \"NB_Swap\", \"2-change\"\n\n    else:  # Kempe\n        used = sorted(set(sol))\n        if len(used) >= 2:\n            c1, c2 = random.sample(used, 2)\n            # Build induced subgraph for colors c1,c2\n            iadj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if (sol[u0] == c1 or sol[u0] == c2) and (sol[v0] == c1 or sol[v0] == c2):\n                    iadj[u0].append(v0)\n                    iadj[v0].append(u0)\n            # Pick random start among vertices with c1 or c2\n            sub = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n            if sub:\n                start = random.choice(sub)\n                # BFS the Kempe chain component\n                seen = {start}\n                q = [start]\n                while q:\n                    a = q.pop()\n                    for b in iadj[a]:\n                        if b not in seen:\n                            seen.add(b)\n                            q.append(b)\n                # Swap c1<->c2 on the component\n                for v in seen:\n                    if new_sol[v] == c1:\n                        new_sol[v] = c2\n                    elif new_sol[v] == c2:\n                        new_sol[v] = c1\n        nb_type, mv_type = \"NB_Kempe\", \"chain-swap\"\n\n    # Optional palette compression only if no conflicts after move\n    # Recompute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts += 1\n    if conflicts == 0:\n        colors = sorted(set(new_sol))\n        remap = {c:i+1 for i, c in enumerate(colors)}\n        new_sol = [remap[c] for c in new_sol]\n\n    return (new_sol, nb_type, mv_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Clone or random init if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for c in sol:\n            if not isinstance(c, int) or c < 1 or c > n:\n                sol = [random.randint(1, 3) for _ in range(n)]\n                break\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Conflicts and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n\n    # Step 1: biased random recolors on high-conflict\/high-degree vertices\n    weights = [1 + 2*conflicts_v[i] + deg[i] for i in range(n)]\n    t = random.randint(2, 4)\n    for _ in range(t):\n        total = sum(weights)\n        pick = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if pick <= acc:\n                idx = i\n                break\n        K = max(sol)\n        cand = list(range(1, min(K, n) + 1))\n        if sol[idx] in cand and len(cand) > 1:\n            cand.remove(sol[idx])\n        if not cand and K < n:\n            cand = [K+1]\n        if cand:\n            sol[idx] = random.choice(cand)\n    \n    # Step 2: Kempe-chain swap to escape local minima\n    used = sorted(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        iadj = [[] for _ in range(n)]\n        for (u, v) in E:\n            u0, v0 = u-1, v-1\n            if (sol[u0] in (c1, c2)) and (sol[v0] in (c1, c2)):\n                iadj[u0].append(v0)\n                iadj[v0].append(u0)\n        sub = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if sub:\n            start = random.choice(sub)\n            seen = {start}\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in iadj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    \n    # Step 3: light random swap of two vertices' colors\n    i = random.randrange(n)\n    j = random.randrange(n)\n    if i != j and sol[i] != sol[j]:\n        sol[i], sol[j] = sol[j], sol[i]\n\n    # Optional palette compression to keep colors tight if no conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    if conflicts == 0:\n        colors = sorted(set(sol))\n        remap = {c:i+1 for i, c in enumerate(colors)}\n        sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0011201299}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] length 9; solution[i-1] is the color (int in [1..9]) of vertex i. Objective K = max(solution), constraints x_u != x_v for all edges.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph constants\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    # Evaluate conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    # Cost prioritizes conflict elimination, then minimizes K\n    return 1000 * conflicts + K\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Initialize\/clone and validate\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for c in sol:\n            if not isinstance(c, int) or c < 1 or c > n:\n                sol = [random.randint(1, 3) for _ in range(n)]\n                break\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Compute conflicts per vertex and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    K = max(sol)\n\n    # Select move type with diversification\n    # Higher chance to recolor if conflicts exist; else try Kempe\/swap to reduce K\n    has_conflict = any(c > 0 for c in conflicts_v)\n    if has_conflict:\n        move_probs = [(\"Recolor\", 0.6), (\"Kempe\", 0.25), (\"Swap\", 0.15)]\n    else:\n        move_probs = [(\"Kempe\", 0.5), (\"Swap\", 0.3), (\"Recolor\", 0.2)]\n    r = random.random()\n    acc = 0.0\n    move = \"Recolor\"\n    for name, p in move_probs:\n        acc += p\n        if r <= acc:\n            move = name\n            break\n\n    new_sol = list(sol)\n\n    if move == \"Recolor\":\n        # Pick vertex: prioritize conflicted, then highest degree, then random among max color class\n        candidates = [i for i in range(n) if conflicts_v[i] > 0]\n        if candidates:\n            candidates.sort(key=lambda i: (conflicts_v[i], deg[i]))\n            idx = candidates[-1]\n        else:\n            max_color_vertices = [i for i, c in enumerate(sol) if c == K]\n            if max_color_vertices:\n                idx = random.choice(max_color_vertices)\n            else:\n                mdeg = max(deg)\n                idx = random.choice([i for i, d in enumerate(deg) if d == mdeg])\n        # Try colors 1..K (and possibly K+1 if conflicts persist)\n        best_c = sol[idx]\n        best_key = (10**9, 10**9, 10**9)  # (local_conflicts, new_K, color)\n        # Precompute max color excluding idx for new_K computation (avoid incorrect inflation)\n        max_ex_idx = max([sol[j] for j in range(n) if j != idx] + [1])\n        for c in range(1, min(K, n) + 1):\n            if c == sol[idx]:\n                continue\n            local_conflicts = 0\n            for j in adj[idx]:\n                if sol[j] == c:\n                    local_conflicts += 1\n            new_K = max(c, max_ex_idx)\n            key = (local_conflicts, new_K, c)\n            if key < best_key:\n                best_key = key\n                best_c = c\n        # If still conflicting heavily at idx, allow K+1 escape (bounded by n)\n        local_after = 0\n        for j in adj[idx]:\n            if sol[j] == best_c:\n                local_after += 1\n        if local_after > 0 and K < n:\n            # Consider K+1 only if all colors 1..K cause conflict at idx\n            all_conflict = True\n            for c in range(1, min(K, n) + 1):\n                if c == sol[idx]:\n                    continue\n                if all(sol[j] != c for j in adj[idx]):\n                    all_conflict = False\n                    break\n            if all_conflict:\n                best_c = K + 1\n        new_sol[idx] = best_c\n        nb_type, mv_type = \"NB_Recolor\", \"1-change\"\n\n    elif move == \"Swap\":\n        # Swap colors of two vertices with different colors (pair-exchange)\n        # Prefer picking one conflicted vertex to escape plateaus\n        conflicted = [i for i in range(n) if conflicts_v[i] > 0]\n        if conflicted:\n            i = random.choice(conflicted)\n        else:\n            i = random.randrange(n)\n        # pick j with different color\n        others = [j for j in range(n) if sol[j] != sol[i]]\n        if not others:\n            j = i\n        else:\n            j = random.choice(others)\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        nb_type, mv_type = \"NB_Swap\", \"2-change\"\n\n    else:  # Kempe\n        used = sorted(set(sol))\n        if len(used) >= 2:\n            c1, c2 = random.sample(used, 2)\n            # Build induced subgraph for colors c1,c2\n            iadj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if (sol[u0] == c1 or sol[u0] == c2) and (sol[v0] == c1 or sol[v0] == c2):\n                    iadj[u0].append(v0)\n                    iadj[v0].append(u0)\n            # Pick random start among vertices with c1 or c2\n            sub = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n            if sub:\n                start = random.choice(sub)\n                # BFS the Kempe chain component\n                seen = {start}\n                q = [start]\n                while q:\n                    a = q.pop()\n                    for b in iadj[a]:\n                        if b not in seen:\n                            seen.add(b)\n                            q.append(b)\n                # Swap c1<->c2 on the component\n                for v in seen:\n                    if new_sol[v] == c1:\n                        new_sol[v] = c2\n                    elif new_sol[v] == c2:\n                        new_sol[v] = c1\n        nb_type, mv_type = \"NB_Kempe\", \"chain-swap\"\n\n    # Optional palette compression only if no conflicts after move\n    # Recompute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts += 1\n    if conflicts == 0:\n        colors = sorted(set(new_sol))\n        remap = {c:i+1 for i, c in enumerate(colors)}\n        new_sol = [remap[c] for c in new_sol]\n\n    return (new_sol, nb_type, mv_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Clone or random init if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for c in sol:\n            if not isinstance(c, int) or c < 1 or c > n:\n                sol = [random.randint(1, 3) for _ in range(n)]\n                break\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Conflicts and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n\n    # Step 1: biased random recolors on high-conflict\/high-degree vertices\n    weights = [1 + 2*conflicts_v[i] + deg[i] for i in range(n)]\n    t = random.randint(2, 4)\n    for _ in range(t):\n        total = sum(weights)\n        pick = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if pick <= acc:\n                idx = i\n                break\n        K = max(sol)\n        cand = list(range(1, min(K, n) + 1))\n        if sol[idx] in cand and len(cand) > 1:\n            cand.remove(sol[idx])\n        if not cand and K < n:\n            cand = [K+1]\n        if cand:\n            sol[idx] = random.choice(cand)\n    \n    # Step 2: Kempe-chain swap to escape local minima\n    used = sorted(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        iadj = [[] for _ in range(n)]\n        for (u, v) in E:\n            u0, v0 = u-1, v-1\n            if (sol[u0] in (c1, c2)) and (sol[v0] in (c1, c2)):\n                iadj[u0].append(v0)\n                iadj[v0].append(u0)\n        sub = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if sub:\n            start = random.choice(sub)\n            seen = {start}\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in iadj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    \n    # Step 3: light random swap of two vertices' colors\n    i = random.randrange(n)\n    j = random.randrange(n)\n    if i != j and sol[i] != sol[j]:\n        sol[i], sol[j] = sol[j], sol[i]\n\n    # Optional palette compression to keep colors tight if no conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    if conflicts == 0:\n        colors = sorted(set(sol))\n        remap = {c:i+1 for i, c in enumerate(colors)}\n        sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0015095769}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] length 9; solution[i-1] is the color (int in [1..9]) of vertex i. Objective K = max(solution), constraints x_u != x_v for all edges.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph constants\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    # Evaluate conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    # Cost prioritizes conflict elimination, then minimizes K\n    return 1000 * conflicts + K\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Initialize\/clone and validate\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for c in sol:\n            if not isinstance(c, int) or c < 1 or c > n:\n                sol = [random.randint(1, 3) for _ in range(n)]\n                break\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Compute conflicts per vertex and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    K = max(sol)\n\n    # Select move type with diversification\n    # Higher chance to recolor if conflicts exist; else try Kempe\/swap to reduce K\n    has_conflict = any(c > 0 for c in conflicts_v)\n    if has_conflict:\n        move_probs = [(\"Recolor\", 0.6), (\"Kempe\", 0.25), (\"Swap\", 0.15)]\n    else:\n        move_probs = [(\"Kempe\", 0.5), (\"Swap\", 0.3), (\"Recolor\", 0.2)]\n    r = random.random()\n    acc = 0.0\n    move = \"Recolor\"\n    for name, p in move_probs:\n        acc += p\n        if r <= acc:\n            move = name\n            break\n\n    new_sol = list(sol)\n\n    if move == \"Recolor\":\n        # Pick vertex: prioritize conflicted, then highest degree, then random among max color class\n        candidates = [i for i in range(n) if conflicts_v[i] > 0]\n        if candidates:\n            candidates.sort(key=lambda i: (conflicts_v[i], deg[i]))\n            idx = candidates[-1]\n        else:\n            max_color_vertices = [i for i, c in enumerate(sol) if c == K]\n            if max_color_vertices:\n                idx = random.choice(max_color_vertices)\n            else:\n                mdeg = max(deg)\n                idx = random.choice([i for i, d in enumerate(deg) if d == mdeg])\n        # Try colors 1..K (and possibly K+1 if conflicts persist)\n        best_c = sol[idx]\n        best_key = (10**9, 10**9, 10**9)  # (local_conflicts, new_K, color)\n        # Precompute max color excluding idx for new_K computation (avoid incorrect inflation)\n        max_ex_idx = max([sol[j] for j in range(n) if j != idx] + [1])\n        for c in range(1, min(K, n) + 1):\n            if c == sol[idx]:\n                continue\n            local_conflicts = 0\n            for j in adj[idx]:\n                if sol[j] == c:\n                    local_conflicts += 1\n            new_K = max(c, max_ex_idx)\n            key = (local_conflicts, new_K, c)\n            if key < best_key:\n                best_key = key\n                best_c = c\n        # If still conflicting heavily at idx, allow K+1 escape (bounded by n)\n        local_after = 0\n        for j in adj[idx]:\n            if sol[j] == best_c:\n                local_after += 1\n        if local_after > 0 and K < n:\n            # Consider K+1 only if all colors 1..K cause conflict at idx\n            all_conflict = True\n            for c in range(1, min(K, n) + 1):\n                if c == sol[idx]:\n                    continue\n                if all(sol[j] != c for j in adj[idx]):\n                    all_conflict = False\n                    break\n            if all_conflict:\n                best_c = K + 1\n        new_sol[idx] = best_c\n        nb_type, mv_type = \"NB_Recolor\", \"1-change\"\n\n    elif move == \"Swap\":\n        # Swap colors of two vertices with different colors (pair-exchange)\n        # Prefer picking one conflicted vertex to escape plateaus\n        conflicted = [i for i in range(n) if conflicts_v[i] > 0]\n        if conflicted:\n            i = random.choice(conflicted)\n        else:\n            i = random.randrange(n)\n        # pick j with different color\n        others = [j for j in range(n) if sol[j] != sol[i]]\n        if not others:\n            j = i\n        else:\n            j = random.choice(others)\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        nb_type, mv_type = \"NB_Swap\", \"2-change\"\n\n    else:  # Kempe\n        used = sorted(set(sol))\n        if len(used) >= 2:\n            c1, c2 = random.sample(used, 2)\n            # Build induced subgraph for colors c1,c2\n            iadj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if (sol[u0] == c1 or sol[u0] == c2) and (sol[v0] == c1 or sol[v0] == c2):\n                    iadj[u0].append(v0)\n                    iadj[v0].append(u0)\n            # Pick random start among vertices with c1 or c2\n            sub = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n            if sub:\n                start = random.choice(sub)\n                # BFS the Kempe chain component\n                seen = {start}\n                q = [start]\n                while q:\n                    a = q.pop()\n                    for b in iadj[a]:\n                        if b not in seen:\n                            seen.add(b)\n                            q.append(b)\n                # Swap c1<->c2 on the component\n                for v in seen:\n                    if new_sol[v] == c1:\n                        new_sol[v] = c2\n                    elif new_sol[v] == c2:\n                        new_sol[v] = c1\n        nb_type, mv_type = \"NB_Kempe\", \"chain-swap\"\n\n    # Optional palette compression only if no conflicts after move\n    # Recompute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts += 1\n    if conflicts == 0:\n        colors = sorted(set(new_sol))\n        remap = {c:i+1 for i, c in enumerate(colors)}\n        new_sol = [remap[c] for c in new_sol]\n\n    return (new_sol, nb_type, mv_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Clone or random init if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for c in sol:\n            if not isinstance(c, int) or c < 1 or c > n:\n                sol = [random.randint(1, 3) for _ in range(n)]\n                break\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Conflicts and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n\n    # Step 1: biased random recolors on high-conflict\/high-degree vertices\n    weights = [1 + 2*conflicts_v[i] + deg[i] for i in range(n)]\n    t = random.randint(2, 4)\n    for _ in range(t):\n        total = sum(weights)\n        pick = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if pick <= acc:\n                idx = i\n                break\n        K = max(sol)\n        cand = list(range(1, min(K, n) + 1))\n        if sol[idx] in cand and len(cand) > 1:\n            cand.remove(sol[idx])\n        if not cand and K < n:\n            cand = [K+1]\n        if cand:\n            sol[idx] = random.choice(cand)\n    \n    # Step 2: Kempe-chain swap to escape local minima\n    used = sorted(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        iadj = [[] for _ in range(n)]\n        for (u, v) in E:\n            u0, v0 = u-1, v-1\n            if (sol[u0] in (c1, c2)) and (sol[v0] in (c1, c2)):\n                iadj[u0].append(v0)\n                iadj[v0].append(u0)\n        sub = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if sub:\n            start = random.choice(sub)\n            seen = {start}\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in iadj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    \n    # Step 3: light random swap of two vertices' colors\n    i = random.randrange(n)\n    j = random.randrange(n)\n    if i != j and sol[i] != sol[j]:\n        sol[i], sol[j] = sol[j], sol[i]\n\n    # Optional palette compression to keep colors tight if no conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    if conflicts == 0:\n        colors = sorted(set(sol))\n        remap = {c:i+1 for i, c in enumerate(colors)}\n        sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001542228}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1..k; c[i-1] is color of vertex i (1-based vertices 1..9).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Returns minimal number of parties k = max(color) if proper; else a large penalty\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    return float(max(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: single-vertex recolor to a random valid or new color if needed\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    v = random.randrange(n)  # vertex index 0..8\n    # Determine forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v:\n            forbidden.add(new_sol[w-1])\n        elif w-1 == v:\n            forbidden.add(new_sol[u-1])\n    # Candidate colors start from 1 up to current max or max+1 to allow expansion\n    current_max = max(new_sol) if new_sol else 1\n    candidates = [c for c in range(1, current_max+1) if c not in forbidden]\n    if not candidates:\n        # allow introducing a new color if no feasible among existing\n        candidates = [current_max + 1]\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    # Return movement metadata; neighbour carried in closure via new_sol variable for callers that inspect frame\n    # To expose neighbour without violating the required signature, attach as attribute\n    try:\n        generate_neighbour.last_neighbour = new_sol  # non-global, function attribute\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: perform multiple random recolors, possibly introducing a new color\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    steps = max(2, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        forbidden = set()\n        for (u, w) in E:\n            if u-1 == v:\n                forbidden.add(new_sol[w-1])\n            elif w-1 == v:\n                forbidden.add(new_sol[u-1])\n        current_max = max(new_sol) if new_sol else 1\n        # With small probability, allow a new color to escape local minima\n        allow_new = random.random() < 0.25\n        pool = list(range(1, current_max + 1 + (1 if allow_new else 0)))\n        candidates = [c for c in pool if c >= 1 and c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n        new_sol[v] = random.choice(candidates)\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000430837}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1..k; c[i-1] is color of vertex i (1-based vertices 1..9).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Returns minimal number of parties k = max(color) if proper; else a large penalty\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    return float(max(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: single-vertex recolor to a random valid or new color if needed\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    v = random.randrange(n)  # vertex index 0..8\n    # Determine forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v:\n            forbidden.add(new_sol[w-1])\n        elif w-1 == v:\n            forbidden.add(new_sol[u-1])\n    # Candidate colors start from 1 up to current max or max+1 to allow expansion\n    current_max = max(new_sol) if new_sol else 1\n    candidates = [c for c in range(1, current_max+1) if c not in forbidden]\n    if not candidates:\n        # allow introducing a new color if no feasible among existing\n        candidates = [current_max + 1]\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    # Return movement metadata; neighbour carried in closure via new_sol variable for callers that inspect frame\n    # To expose neighbour without violating the required signature, attach as attribute\n    try:\n        generate_neighbour.last_neighbour = new_sol  # non-global, function attribute\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: perform multiple random recolors, possibly introducing a new color\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    steps = max(2, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        forbidden = set()\n        for (u, w) in E:\n            if u-1 == v:\n                forbidden.add(new_sol[w-1])\n            elif w-1 == v:\n                forbidden.add(new_sol[u-1])\n        current_max = max(new_sol) if new_sol else 1\n        # With small probability, allow a new color to escape local minima\n        allow_new = random.random() < 0.25\n        pool = list(range(1, current_max + 1 + (1 if allow_new else 0)))\n        candidates = [c for c in pool if c >= 1 and c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n        new_sol[v] = random.choice(candidates)\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0005130691}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1..k; c[i-1] is color of vertex i (1-based vertices 1..9).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Returns minimal number of parties k = max(color) if proper; else a large penalty\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    return float(max(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: single-vertex recolor to a random valid or new color if needed\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    v = random.randrange(n)  # vertex index 0..8\n    # Determine forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v:\n            forbidden.add(new_sol[w-1])\n        elif w-1 == v:\n            forbidden.add(new_sol[u-1])\n    # Candidate colors start from 1 up to current max or max+1 to allow expansion\n    current_max = max(new_sol) if new_sol else 1\n    candidates = [c for c in range(1, current_max+1) if c not in forbidden]\n    if not candidates:\n        # allow introducing a new color if no feasible among existing\n        candidates = [current_max + 1]\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    # Return movement metadata; neighbour carried in closure via new_sol variable for callers that inspect frame\n    # To expose neighbour without violating the required signature, attach as attribute\n    try:\n        generate_neighbour.last_neighbour = new_sol  # non-global, function attribute\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: perform multiple random recolors, possibly introducing a new color\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    steps = max(2, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        forbidden = set()\n        for (u, w) in E:\n            if u-1 == v:\n                forbidden.add(new_sol[w-1])\n            elif w-1 == v:\n                forbidden.add(new_sol[u-1])\n        current_max = max(new_sol) if new_sol else 1\n        # With small probability, allow a new color to escape local minima\n        allow_new = random.random() < 0.25\n        pool = list(range(1, current_max + 1 + (1 if allow_new else 0)))\n        candidates = [c for c in pool if c >= 1 and c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n        new_sol[v] = random.choice(candidates)\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0005003881}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_POSITIVE_INTS;c[i-1] is color of vertex i; objective=max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Graph and parameters embedded locally per call (no globals)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and basic validity checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(PENALTY_BASE + 10**6)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PENALTY_BASE + 10**6)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize infeasible; include conflicts to provide gradient\n        return float(PENALTY_BASE + conflicts)\n    # Feasible: objective is minimal number of colors used (max color label)\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a single-vertex recolor neighbor; metadata returned per contract.\n    # Neighbor solution is exposed via function attributes to comply with signature.\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Identify conflict vertices and max-color class to focus search\n    current_max = max(cur)\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    candidates_vertices = list(conflict_vertices) if conflict_vertices else [i for i,x in enumerate(cur) if x == current_max]\n    if not candidates_vertices:\n        candidates_vertices = list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    # Build candidate colors with bias to reduce max color; avoid introducing new colors in feasible states\n    # If currently infeasible at v_idx (conflict), allow any color in 1..current_max; else avoid current_max if possible\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    if not feasible_colors:\n        # As a last resort, keep within palette; if empty, allow a new color only to repair infeasibility\n        feasible_colors = [current_max + 1]\n    # Prefer colors < current_max to drive k down when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    new_color = random.choice(choice_pool)\n    new_sol = list(cur)\n    old_color = new_sol[v_idx]\n    if new_color == old_color and len(choice_pool) > 1:\n        # Try a different color to ensure movement\n        alt_pool = [c for c in choice_pool if c != old_color]\n        if alt_pool:\n            new_color = random.choice(alt_pool)\n    new_sol[v_idx] = new_color\n    # Expose neighbour and move metadata via function attributes (no global state)\n    try:\n        generate_neighbour.neighbour = new_sol\n        generate_neighbour.move = {\n            'vertex': v_idx + 1,\n            'old_color': old_color,\n            'new_color': new_color\n        }\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasibility-preserving perturbation using partial DSATUR recoloring on a subset\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Helper: compute neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select a color class with largest size (often the current max color) and recolor t vertices from it\n    current_max = max(cur)\n    max_class_vertices = [i for i,c in enumerate(cur) if c == current_max]\n    t = max(2, len(max_class_vertices) \/\/ 2) if max_class_vertices else 3\n    chosen = random.sample(max_class_vertices if len(max_class_vertices) >= t else list(range(n)), k=t)\n    # Remove chosen vertices' colors temporarily\n    work = list(cur)\n    for v in chosen:\n        work[v] = 0  # 0 denotes uncolored\n    # DSATUR-like order: highest saturation degree first\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor greedily using only colors up to current_max; try to avoid using current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        # Preferred palette excludes current_max when possible\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # If impossible within 1..current_max, keep original color as fallback\n            candidates = [cur[v]] if cur[v] != 0 else [current_max]\n        # Prefer smallest feasible color to reduce max color class pressure\n        new_c = min(candidates)\n        work[v] = new_c\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000586639}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_POSITIVE_INTS;c[i-1] is color of vertex i; objective=max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Graph and parameters embedded locally per call (no globals)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and basic validity checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(PENALTY_BASE + 10**6)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PENALTY_BASE + 10**6)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize infeasible; include conflicts to provide gradient\n        return float(PENALTY_BASE + conflicts)\n    # Feasible: objective is minimal number of colors used (max color label)\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a single-vertex recolor neighbor; metadata returned per contract.\n    # Neighbor solution is exposed via function attributes to comply with signature.\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Identify conflict vertices and max-color class to focus search\n    current_max = max(cur)\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    candidates_vertices = list(conflict_vertices) if conflict_vertices else [i for i,x in enumerate(cur) if x == current_max]\n    if not candidates_vertices:\n        candidates_vertices = list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    # Build candidate colors with bias to reduce max color; avoid introducing new colors in feasible states\n    # If currently infeasible at v_idx (conflict), allow any color in 1..current_max; else avoid current_max if possible\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    if not feasible_colors:\n        # As a last resort, keep within palette; if empty, allow a new color only to repair infeasibility\n        feasible_colors = [current_max + 1]\n    # Prefer colors < current_max to drive k down when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    new_color = random.choice(choice_pool)\n    new_sol = list(cur)\n    old_color = new_sol[v_idx]\n    if new_color == old_color and len(choice_pool) > 1:\n        # Try a different color to ensure movement\n        alt_pool = [c for c in choice_pool if c != old_color]\n        if alt_pool:\n            new_color = random.choice(alt_pool)\n    new_sol[v_idx] = new_color\n    # Expose neighbour and move metadata via function attributes (no global state)\n    try:\n        generate_neighbour.neighbour = new_sol\n        generate_neighbour.move = {\n            'vertex': v_idx + 1,\n            'old_color': old_color,\n            'new_color': new_color\n        }\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasibility-preserving perturbation using partial DSATUR recoloring on a subset\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Helper: compute neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select a color class with largest size (often the current max color) and recolor t vertices from it\n    current_max = max(cur)\n    max_class_vertices = [i for i,c in enumerate(cur) if c == current_max]\n    t = max(2, len(max_class_vertices) \/\/ 2) if max_class_vertices else 3\n    chosen = random.sample(max_class_vertices if len(max_class_vertices) >= t else list(range(n)), k=t)\n    # Remove chosen vertices' colors temporarily\n    work = list(cur)\n    for v in chosen:\n        work[v] = 0  # 0 denotes uncolored\n    # DSATUR-like order: highest saturation degree first\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor greedily using only colors up to current_max; try to avoid using current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        # Preferred palette excludes current_max when possible\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # If impossible within 1..current_max, keep original color as fallback\n            candidates = [cur[v]] if cur[v] != 0 else [current_max]\n        # Prefer smallest feasible color to reduce max color class pressure\n        new_c = min(candidates)\n        work[v] = new_c\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000848313}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_POSITIVE_INTS;c[i-1] is color of vertex i; objective=max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Graph and parameters embedded locally per call (no globals)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and basic validity checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(PENALTY_BASE + 10**6)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PENALTY_BASE + 10**6)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize infeasible; include conflicts to provide gradient\n        return float(PENALTY_BASE + conflicts)\n    # Feasible: objective is minimal number of colors used (max color label)\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a single-vertex recolor neighbor; metadata returned per contract.\n    # Neighbor solution is exposed via function attributes to comply with signature.\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Identify conflict vertices and max-color class to focus search\n    current_max = max(cur)\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    candidates_vertices = list(conflict_vertices) if conflict_vertices else [i for i,x in enumerate(cur) if x == current_max]\n    if not candidates_vertices:\n        candidates_vertices = list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    # Build candidate colors with bias to reduce max color; avoid introducing new colors in feasible states\n    # If currently infeasible at v_idx (conflict), allow any color in 1..current_max; else avoid current_max if possible\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    if not feasible_colors:\n        # As a last resort, keep within palette; if empty, allow a new color only to repair infeasibility\n        feasible_colors = [current_max + 1]\n    # Prefer colors < current_max to drive k down when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    new_color = random.choice(choice_pool)\n    new_sol = list(cur)\n    old_color = new_sol[v_idx]\n    if new_color == old_color and len(choice_pool) > 1:\n        # Try a different color to ensure movement\n        alt_pool = [c for c in choice_pool if c != old_color]\n        if alt_pool:\n            new_color = random.choice(alt_pool)\n    new_sol[v_idx] = new_color\n    # Expose neighbour and move metadata via function attributes (no global state)\n    try:\n        generate_neighbour.neighbour = new_sol\n        generate_neighbour.move = {\n            'vertex': v_idx + 1,\n            'old_color': old_color,\n            'new_color': new_color\n        }\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasibility-preserving perturbation using partial DSATUR recoloring on a subset\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Helper: compute neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select a color class with largest size (often the current max color) and recolor t vertices from it\n    current_max = max(cur)\n    max_class_vertices = [i for i,c in enumerate(cur) if c == current_max]\n    t = max(2, len(max_class_vertices) \/\/ 2) if max_class_vertices else 3\n    chosen = random.sample(max_class_vertices if len(max_class_vertices) >= t else list(range(n)), k=t)\n    # Remove chosen vertices' colors temporarily\n    work = list(cur)\n    for v in chosen:\n        work[v] = 0  # 0 denotes uncolored\n    # DSATUR-like order: highest saturation degree first\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor greedily using only colors up to current_max; try to avoid using current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        # Preferred palette excludes current_max when possible\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # If impossible within 1..current_max, keep original color as fallback\n            candidates = [cur[v]] if cur[v] != 0 else [current_max]\n        # Prefer smallest feasible color to reduce max color class pressure\n        new_c = min(candidates)\n        work[v] = new_c\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0008141821}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective=max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 1_000_000.0\n    CONFLICT_WEIGHT = 1_000.0\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE + 10_000.0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + CONFLICT_WEIGHT * float(conflicts)\n    # Feasible: minimize number of colors used (max label)\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighbor solution (list[int]) via single-vertex recolor.\n    # Problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Basic normalization and copy\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a simple greedy initialization if input invalid\n        sol = [1]*n\n    else:\n        sol = [int(max(1, x)) for x in solution]\n    cur = list(sol)\n    current_max = max(cur)\n    # Identify conflict vertices\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    # Candidate vertex selection\n    if conflict_vertices:\n        candidates_vertices = list(conflict_vertices)\n    else:\n        # target vertices using max color; if none, use all\n        max_class = [i for i, c in enumerate(cur) if c == current_max]\n        candidates_vertices = max_class if max_class else list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    # Prefer colors < current_max to encourage compression when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    # Fallback: if no feasible color in 1..current_max (rare), keep old color\n    if not choice_pool:\n        choice_pool = [cur[v_idx]]\n    old_color = cur[v_idx]\n    # Ensure movement if possible\n    if len(choice_pool) == 1 and choice_pool[0] == old_color:\n        # try any other color in palette not equal old_color, ignoring forbidden to force diversification\n        alt = [c for c in palette if c != old_color]\n        if alt:\n            cur[v_idx] = random.choice(alt)\n        else:\n            cur[v_idx] = old_color\n    else:\n        new_color = random.choice(choice_pool)\n        if new_color == old_color and len(choice_pool) > 1:\n            # pick a different one\n            alt = [c for c in choice_pool if c != old_color]\n            new_color = random.choice(alt)\n        cur[v_idx] = new_color\n    return cur\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain\/greedy hybrid perturbation focused on max color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        work = [1]*n\n    else:\n        work = [int(max(1, x)) for x in solution]\n    current_max = max(work)\n    # Helper: neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select target vertices from the largest color class (often current_max)\n    max_class_vertices = [i for i, c in enumerate(work) if c == current_max]\n    t = max(2, min(len(max_class_vertices), 4)) if max_class_vertices else 3\n    pool = max_class_vertices if len(max_class_vertices) >= t else list(range(n))\n    chosen = sorted(random.sample(pool, k=t))\n    # Uncolor chosen\n    for v in chosen:\n        work[v] = 0\n    # Order by saturation degree (DSATUR-like)\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor within 1..current_max, avoiding current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # fallback: keep original or current_max\n            candidates = [current_max]\n        # prefer smallest to improve compressibility\n        work[v] = min(candidates)\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000575698}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective=max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 1_000_000.0\n    CONFLICT_WEIGHT = 1_000.0\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE + 10_000.0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + CONFLICT_WEIGHT * float(conflicts)\n    # Feasible: minimize number of colors used (max label)\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighbor solution (list[int]) via single-vertex recolor.\n    # Problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Basic normalization and copy\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a simple greedy initialization if input invalid\n        sol = [1]*n\n    else:\n        sol = [int(max(1, x)) for x in solution]\n    cur = list(sol)\n    current_max = max(cur)\n    # Identify conflict vertices\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    # Candidate vertex selection\n    if conflict_vertices:\n        candidates_vertices = list(conflict_vertices)\n    else:\n        # target vertices using max color; if none, use all\n        max_class = [i for i, c in enumerate(cur) if c == current_max]\n        candidates_vertices = max_class if max_class else list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    # Prefer colors < current_max to encourage compression when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    # Fallback: if no feasible color in 1..current_max (rare), keep old color\n    if not choice_pool:\n        choice_pool = [cur[v_idx]]\n    old_color = cur[v_idx]\n    # Ensure movement if possible\n    if len(choice_pool) == 1 and choice_pool[0] == old_color:\n        # try any other color in palette not equal old_color, ignoring forbidden to force diversification\n        alt = [c for c in palette if c != old_color]\n        if alt:\n            cur[v_idx] = random.choice(alt)\n        else:\n            cur[v_idx] = old_color\n    else:\n        new_color = random.choice(choice_pool)\n        if new_color == old_color and len(choice_pool) > 1:\n            # pick a different one\n            alt = [c for c in choice_pool if c != old_color]\n            new_color = random.choice(alt)\n        cur[v_idx] = new_color\n    return cur\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain\/greedy hybrid perturbation focused on max color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        work = [1]*n\n    else:\n        work = [int(max(1, x)) for x in solution]\n    current_max = max(work)\n    # Helper: neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select target vertices from the largest color class (often current_max)\n    max_class_vertices = [i for i, c in enumerate(work) if c == current_max]\n    t = max(2, min(len(max_class_vertices), 4)) if max_class_vertices else 3\n    pool = max_class_vertices if len(max_class_vertices) >= t else list(range(n))\n    chosen = sorted(random.sample(pool, k=t))\n    # Uncolor chosen\n    for v in chosen:\n        work[v] = 0\n    # Order by saturation degree (DSATUR-like)\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor within 1..current_max, avoiding current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # fallback: keep original or current_max\n            candidates = [current_max]\n        # prefer smallest to improve compressibility\n        work[v] = min(candidates)\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0008014709}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective=max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 1_000_000.0\n    CONFLICT_WEIGHT = 1_000.0\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE + 10_000.0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + CONFLICT_WEIGHT * float(conflicts)\n    # Feasible: minimize number of colors used (max label)\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighbor solution (list[int]) via single-vertex recolor.\n    # Problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Basic normalization and copy\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a simple greedy initialization if input invalid\n        sol = [1]*n\n    else:\n        sol = [int(max(1, x)) for x in solution]\n    cur = list(sol)\n    current_max = max(cur)\n    # Identify conflict vertices\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    # Candidate vertex selection\n    if conflict_vertices:\n        candidates_vertices = list(conflict_vertices)\n    else:\n        # target vertices using max color; if none, use all\n        max_class = [i for i, c in enumerate(cur) if c == current_max]\n        candidates_vertices = max_class if max_class else list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    # Prefer colors < current_max to encourage compression when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    # Fallback: if no feasible color in 1..current_max (rare), keep old color\n    if not choice_pool:\n        choice_pool = [cur[v_idx]]\n    old_color = cur[v_idx]\n    # Ensure movement if possible\n    if len(choice_pool) == 1 and choice_pool[0] == old_color:\n        # try any other color in palette not equal old_color, ignoring forbidden to force diversification\n        alt = [c for c in palette if c != old_color]\n        if alt:\n            cur[v_idx] = random.choice(alt)\n        else:\n            cur[v_idx] = old_color\n    else:\n        new_color = random.choice(choice_pool)\n        if new_color == old_color and len(choice_pool) > 1:\n            # pick a different one\n            alt = [c for c in choice_pool if c != old_color]\n            new_color = random.choice(alt)\n        cur[v_idx] = new_color\n    return cur\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain\/greedy hybrid perturbation focused on max color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        work = [1]*n\n    else:\n        work = [int(max(1, x)) for x in solution]\n    current_max = max(work)\n    # Helper: neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select target vertices from the largest color class (often current_max)\n    max_class_vertices = [i for i, c in enumerate(work) if c == current_max]\n    t = max(2, min(len(max_class_vertices), 4)) if max_class_vertices else 3\n    pool = max_class_vertices if len(max_class_vertices) >= t else list(range(n))\n    chosen = sorted(random.sample(pool, k=t))\n    # Uncolor chosen\n    for v in chosen:\n        work[v] = 0\n    # Order by saturation degree (DSATUR-like)\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor within 1..current_max, avoiding current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # fallback: keep original or current_max\n            candidates = [current_max]\n        # prefer smallest to improve compressibility\n        work[v] = min(candidates)\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000781161}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective = max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Score: lexicographic proxy (lower is better): conflicts first, then colors\n    # Keep feasible scores in small range to avoid freezing\n    if conflicts > 0:\n        return float(conflicts * 1000 + max(solution))\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: single-vertex recolor with conflict focus and color compression\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Build adjacency lists (local, no globals)\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Normalize\/repair input\n    if not isinstance(solution, list) or len(solution) != n:\n        cur = [1]*n\n    else:\n        cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    current_max = max(cur)\n    # Identify conflict vertices\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    # Selection policy\n    if conflict_vertices:\n        candidates = list(conflict_vertices)\n    else:\n        # Focus on compressing max color class\n        max_class = [i for i, c in enumerate(cur) if c == current_max]\n        candidates = max_class if max_class else list(range(n))\n    v_idx = random.choice(candidates)\n    # Compute forbidden colors for v_idx\n    forbidden = set(cur[nbr] for nbr in adj[v_idx])\n    palette = list(range(1, current_max + 1))  # do not introduce new colors\n    # Evaluate recolor options by a simple delta metric: (conflicts_after, new_max)\n    best_color = cur[v_idx]\n    best_metric = (10**9, 10**9)\n    original_color = cur[v_idx]\n    for col in palette:\n        if col == original_color and len(palette) > 1:\n            # allow staying only if it's the only option\n            pass\n        # tentative assign\n        cur[v_idx] = col\n        # count local conflicts around v_idx only\n        local_conf = 0\n        for nbr in adj[v_idx]:\n            if cur[nbr] == col:\n                local_conf += 1\n        new_max = max(current_max, col)\n        metric = (local_conf, new_max)\n        if metric < best_metric:\n            best_metric = metric\n            best_color = col\n    # Apply best move\n    cur[v_idx] = best_color\n    return cur\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex greedy recolor (DSATUR-like) focusing on max color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize solution\n    if not isinstance(solution, list) or len(solution) != n:\n        work = [1]*n\n    else:\n        work = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    current_max = max(work)\n    # Select target set from max color class (or all if too small)\n    max_class_vertices = [i for i, c in enumerate(work) if c == current_max]\n    k = 3 if len(max_class_vertices) < 3 else min(4, len(max_class_vertices))\n    pool = max_class_vertices if len(max_class_vertices) >= k else list(range(n))\n    chosen = sorted(random.sample(pool, k=k))\n    # Uncolor chosen\n    old_colors = {v: work[v] for v in chosen}\n    for v in chosen:\n        work[v] = 0\n    # Order by saturation degree (distinct neighbor colors among currently colored neighbors)\n    def sat_deg(sol, v):\n        colors = set()\n        for nb in adj[v]:\n            if sol[nb] > 0:\n                colors.add(sol[nb])\n        return len(colors)\n    order = sorted(chosen, key=lambda v: (-sat_deg(work, v), -len(adj[v])))\n    # Greedy recolor with preference to use colors < current_max\n    for v in order:\n        forbidden = set(work[nb] for nb in adj[v] if work[nb] > 0)\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if candidates:\n            work[v] = min(candidates)\n        else:\n            # fallback: restore old or assign current_max\n            work[v] = min(current_max, old_colors.get(v, current_max))\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000645829}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective = max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Score: lexicographic proxy (lower is better): conflicts first, then colors\n    # Keep feasible scores in small range to avoid freezing\n    if conflicts > 0:\n        return float(conflicts * 1000 + max(solution))\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: single-vertex recolor with conflict focus and color compression\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Build adjacency lists (local, no globals)\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Normalize\/repair input\n    if not isinstance(solution, list) or len(solution) != n:\n        cur = [1]*n\n    else:\n        cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    current_max = max(cur)\n    # Identify conflict vertices\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    # Selection policy\n    if conflict_vertices:\n        candidates = list(conflict_vertices)\n    else:\n        # Focus on compressing max color class\n        max_class = [i for i, c in enumerate(cur) if c == current_max]\n        candidates = max_class if max_class else list(range(n))\n    v_idx = random.choice(candidates)\n    # Compute forbidden colors for v_idx\n    forbidden = set(cur[nbr] for nbr in adj[v_idx])\n    palette = list(range(1, current_max + 1))  # do not introduce new colors\n    # Evaluate recolor options by a simple delta metric: (conflicts_after, new_max)\n    best_color = cur[v_idx]\n    best_metric = (10**9, 10**9)\n    original_color = cur[v_idx]\n    for col in palette:\n        if col == original_color and len(palette) > 1:\n            # allow staying only if it's the only option\n            pass\n        # tentative assign\n        cur[v_idx] = col\n        # count local conflicts around v_idx only\n        local_conf = 0\n        for nbr in adj[v_idx]:\n            if cur[nbr] == col:\n                local_conf += 1\n        new_max = max(current_max, col)\n        metric = (local_conf, new_max)\n        if metric < best_metric:\n            best_metric = metric\n            best_color = col\n    # Apply best move\n    cur[v_idx] = best_color\n    return cur\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex greedy recolor (DSATUR-like) focusing on max color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize solution\n    if not isinstance(solution, list) or len(solution) != n:\n        work = [1]*n\n    else:\n        work = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    current_max = max(work)\n    # Select target set from max color class (or all if too small)\n    max_class_vertices = [i for i, c in enumerate(work) if c == current_max]\n    k = 3 if len(max_class_vertices) < 3 else min(4, len(max_class_vertices))\n    pool = max_class_vertices if len(max_class_vertices) >= k else list(range(n))\n    chosen = sorted(random.sample(pool, k=k))\n    # Uncolor chosen\n    old_colors = {v: work[v] for v in chosen}\n    for v in chosen:\n        work[v] = 0\n    # Order by saturation degree (distinct neighbor colors among currently colored neighbors)\n    def sat_deg(sol, v):\n        colors = set()\n        for nb in adj[v]:\n            if sol[nb] > 0:\n                colors.add(sol[nb])\n        return len(colors)\n    order = sorted(chosen, key=lambda v: (-sat_deg(work, v), -len(adj[v])))\n    # Greedy recolor with preference to use colors < current_max\n    for v in order:\n        forbidden = set(work[nb] for nb in adj[v] if work[nb] > 0)\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if candidates:\n            work[v] = min(candidates)\n        else:\n            # fallback: restore old or assign current_max\n            work[v] = min(current_max, old_colors.get(v, current_max))\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0009493621}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective = max(c) minimized","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Score: lexicographic proxy (lower is better): conflicts first, then colors\n    # Keep feasible scores in small range to avoid freezing\n    if conflicts > 0:\n        return float(conflicts * 1000 + max(solution))\n    return float(max(solution))\n","Vecindad":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: single-vertex recolor with conflict focus and color compression\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Build adjacency lists (local, no globals)\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Normalize\/repair input\n    if not isinstance(solution, list) or len(solution) != n:\n        cur = [1]*n\n    else:\n        cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    current_max = max(cur)\n    # Identify conflict vertices\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    # Selection policy\n    if conflict_vertices:\n        candidates = list(conflict_vertices)\n    else:\n        # Focus on compressing max color class\n        max_class = [i for i, c in enumerate(cur) if c == current_max]\n        candidates = max_class if max_class else list(range(n))\n    v_idx = random.choice(candidates)\n    # Compute forbidden colors for v_idx\n    forbidden = set(cur[nbr] for nbr in adj[v_idx])\n    palette = list(range(1, current_max + 1))  # do not introduce new colors\n    # Evaluate recolor options by a simple delta metric: (conflicts_after, new_max)\n    best_color = cur[v_idx]\n    best_metric = (10**9, 10**9)\n    original_color = cur[v_idx]\n    for col in palette:\n        if col == original_color and len(palette) > 1:\n            # allow staying only if it's the only option\n            pass\n        # tentative assign\n        cur[v_idx] = col\n        # count local conflicts around v_idx only\n        local_conf = 0\n        for nbr in adj[v_idx]:\n            if cur[nbr] == col:\n                local_conf += 1\n        new_max = max(current_max, col)\n        metric = (local_conf, new_max)\n        if metric < best_metric:\n            best_metric = metric\n            best_color = col\n    # Apply best move\n    cur[v_idx] = best_color\n    return cur\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex greedy recolor (DSATUR-like) focusing on max color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize solution\n    if not isinstance(solution, list) or len(solution) != n:\n        work = [1]*n\n    else:\n        work = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    current_max = max(work)\n    # Select target set from max color class (or all if too small)\n    max_class_vertices = [i for i, c in enumerate(work) if c == current_max]\n    k = 3 if len(max_class_vertices) < 3 else min(4, len(max_class_vertices))\n    pool = max_class_vertices if len(max_class_vertices) >= k else list(range(n))\n    chosen = sorted(random.sample(pool, k=k))\n    # Uncolor chosen\n    old_colors = {v: work[v] for v in chosen}\n    for v in chosen:\n        work[v] = 0\n    # Order by saturation degree (distinct neighbor colors among currently colored neighbors)\n    def sat_deg(sol, v):\n        colors = set()\n        for nb in adj[v]:\n            if sol[nb] > 0:\n                colors.add(sol[nb])\n        return len(colors)\n    order = sorted(chosen, key=lambda v: (-sat_deg(work, v), -len(adj[v])))\n    # Greedy recolor with preference to use colors < current_max\n    for v in order:\n        forbidden = set(work[nb] for nb in adj[v] if work[nb] > 0)\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if candidates:\n            work[v] = min(candidates)\n        else:\n            # fallback: restore old or assign current_max\n            work[v] = min(current_max, old_colors.get(v, current_max))\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000919463}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,...,c9] where each ci is a color label; color classes must induce cliques.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Build edge set (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u, v = v, u\n        E.add((u, v))\n    # Feasibility and violations\n    K = max(solution)\n    for x in solution:\n        if x < 1 or x > K:\n            return float(10**9)\n    violations = 0\n    for i in range(9):\n        ui = i + 1\n        ci = solution[i]\n        for j in range(i + 1, 9):\n            if ci == solution[j]:\n                uj = j + 1\n                a, b = (ui, uj) if ui < uj else (uj, ui)\n                if (a, b) not in E:\n                    violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: compute K* by backtracking search\n    def can_color_with_k(k: int) -> bool:\n        ass = [0]*9\n        def dfs(idx: int) -> bool:\n            if idx == 9:\n                return True\n            u = idx + 1\n            for c in range(1, k + 1):\n                ok = True\n                for j in range(idx):\n                    if ass[j] == c:\n                        v = j + 1\n                        a, b = (u, v) if u < v else (v, u)\n                        if (a, b) not in E:\n                            ok = False\n                            break\n                if ok:\n                    ass[idx] = c\n                    if dfs(idx + 1):\n                        return True\n                    ass[idx] = 0\n            return False\n        return dfs(0)\n    Kstar = None\n    for k in range(1, 10):\n        if can_color_with_k(k):\n            Kstar = k\n            break\n    if Kstar is None:\n        return float(10**9)\n    gap = K - Kstar\n    penalty = 0.0 if gap <= 0 else 100.0 * gap\n    return float(K + penalty)\n","Vecindad":"import random\nimport copy\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Input validation and cloning\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return original to avoid crashes; label invalid\n        return solution[:], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution[:], \"invalid\"\n    s = solution[:]\n    n = 9\n    max_color = max(s)\n    # Choose move type: recolor or swap colors of two vertices\n    move = \"recolor\" if random.random() < 0.7 else \"swap_colors\"\n    if move == \"recolor\":\n        i = random.randrange(n)\n        # Candidate colors: existing colors plus possibly introducing a new color with small prob\n        existing = list({c for c in s})\n        # Bias toward existing colors to reduce K\n        if random.random() < 0.15:\n            # allow new color\n            candidates = existing + [max_color + 1]\n        else:\n            candidates = existing\n        new_c = random.choice(candidates)\n        # Ensure an actual change\n        if new_c == s[i]:\n            new_c = ((s[i] % max_color) + 1) if max_color >= 2 else 1\n        s[i] = new_c\n        # Optional relabeling to keep colors compact 1..K\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n        return s, \"recolor\"\n    else:\n        # swap color labels between two random vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        s[i], s[j] = s[j], s[i]\n        return s, \"swap_colors\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger random move: multiple recolors and occasional color merge\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        max_color = max(s)\n        existing = list({c for c in s})\n        # 50% try to reduce number of colors by mapping to an existing color\n        if random.random() < 0.5 and len(existing) > 1:\n            target = random.choice(existing)\n            s[i] = target\n        else:\n            # random recolor possibly introducing new color\n            if random.random() < 0.2:\n                s[i] = max_color + 1\n            else:\n                s[i] = random.choice(existing)\n        # Compact colors\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n    # Occasional color merge: pick two labels and merge\n    if random.random() < 0.3:\n        labels = list({c for c in s})\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            s = [a if c == b else c for c in s]\n            # Compact again\n            remap = {}\n            next_id = 1\n            for c in s:\n                if c not in remap:\n                    remap[c] = next_id\n                    next_id += 1\n            s = [remap[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0006863991}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,...,c9] where each ci is a color label; color classes must induce cliques.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Build edge set (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u, v = v, u\n        E.add((u, v))\n    # Feasibility and violations\n    K = max(solution)\n    for x in solution:\n        if x < 1 or x > K:\n            return float(10**9)\n    violations = 0\n    for i in range(9):\n        ui = i + 1\n        ci = solution[i]\n        for j in range(i + 1, 9):\n            if ci == solution[j]:\n                uj = j + 1\n                a, b = (ui, uj) if ui < uj else (uj, ui)\n                if (a, b) not in E:\n                    violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: compute K* by backtracking search\n    def can_color_with_k(k: int) -> bool:\n        ass = [0]*9\n        def dfs(idx: int) -> bool:\n            if idx == 9:\n                return True\n            u = idx + 1\n            for c in range(1, k + 1):\n                ok = True\n                for j in range(idx):\n                    if ass[j] == c:\n                        v = j + 1\n                        a, b = (u, v) if u < v else (v, u)\n                        if (a, b) not in E:\n                            ok = False\n                            break\n                if ok:\n                    ass[idx] = c\n                    if dfs(idx + 1):\n                        return True\n                    ass[idx] = 0\n            return False\n        return dfs(0)\n    Kstar = None\n    for k in range(1, 10):\n        if can_color_with_k(k):\n            Kstar = k\n            break\n    if Kstar is None:\n        return float(10**9)\n    gap = K - Kstar\n    penalty = 0.0 if gap <= 0 else 100.0 * gap\n    return float(K + penalty)\n","Vecindad":"import random\nimport copy\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Input validation and cloning\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return original to avoid crashes; label invalid\n        return solution[:], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution[:], \"invalid\"\n    s = solution[:]\n    n = 9\n    max_color = max(s)\n    # Choose move type: recolor or swap colors of two vertices\n    move = \"recolor\" if random.random() < 0.7 else \"swap_colors\"\n    if move == \"recolor\":\n        i = random.randrange(n)\n        # Candidate colors: existing colors plus possibly introducing a new color with small prob\n        existing = list({c for c in s})\n        # Bias toward existing colors to reduce K\n        if random.random() < 0.15:\n            # allow new color\n            candidates = existing + [max_color + 1]\n        else:\n            candidates = existing\n        new_c = random.choice(candidates)\n        # Ensure an actual change\n        if new_c == s[i]:\n            new_c = ((s[i] % max_color) + 1) if max_color >= 2 else 1\n        s[i] = new_c\n        # Optional relabeling to keep colors compact 1..K\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n        return s, \"recolor\"\n    else:\n        # swap color labels between two random vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        s[i], s[j] = s[j], s[i]\n        return s, \"swap_colors\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger random move: multiple recolors and occasional color merge\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        max_color = max(s)\n        existing = list({c for c in s})\n        # 50% try to reduce number of colors by mapping to an existing color\n        if random.random() < 0.5 and len(existing) > 1:\n            target = random.choice(existing)\n            s[i] = target\n        else:\n            # random recolor possibly introducing new color\n            if random.random() < 0.2:\n                s[i] = max_color + 1\n            else:\n                s[i] = random.choice(existing)\n        # Compact colors\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n    # Occasional color merge: pick two labels and merge\n    if random.random() < 0.3:\n        labels = list({c for c in s})\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            s = [a if c == b else c for c in s]\n            # Compact again\n            remap = {}\n            next_id = 1\n            for c in s:\n                if c not in remap:\n                    remap[c] = next_id\n                    next_id += 1\n            s = [remap[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000912912}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,...,c9] where each ci is a color label; color classes must induce cliques.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Build edge set (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u, v = v, u\n        E.add((u, v))\n    # Feasibility and violations\n    K = max(solution)\n    for x in solution:\n        if x < 1 or x > K:\n            return float(10**9)\n    violations = 0\n    for i in range(9):\n        ui = i + 1\n        ci = solution[i]\n        for j in range(i + 1, 9):\n            if ci == solution[j]:\n                uj = j + 1\n                a, b = (ui, uj) if ui < uj else (uj, ui)\n                if (a, b) not in E:\n                    violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: compute K* by backtracking search\n    def can_color_with_k(k: int) -> bool:\n        ass = [0]*9\n        def dfs(idx: int) -> bool:\n            if idx == 9:\n                return True\n            u = idx + 1\n            for c in range(1, k + 1):\n                ok = True\n                for j in range(idx):\n                    if ass[j] == c:\n                        v = j + 1\n                        a, b = (u, v) if u < v else (v, u)\n                        if (a, b) not in E:\n                            ok = False\n                            break\n                if ok:\n                    ass[idx] = c\n                    if dfs(idx + 1):\n                        return True\n                    ass[idx] = 0\n            return False\n        return dfs(0)\n    Kstar = None\n    for k in range(1, 10):\n        if can_color_with_k(k):\n            Kstar = k\n            break\n    if Kstar is None:\n        return float(10**9)\n    gap = K - Kstar\n    penalty = 0.0 if gap <= 0 else 100.0 * gap\n    return float(K + penalty)\n","Vecindad":"import random\nimport copy\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Input validation and cloning\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return original to avoid crashes; label invalid\n        return solution[:], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution[:], \"invalid\"\n    s = solution[:]\n    n = 9\n    max_color = max(s)\n    # Choose move type: recolor or swap colors of two vertices\n    move = \"recolor\" if random.random() < 0.7 else \"swap_colors\"\n    if move == \"recolor\":\n        i = random.randrange(n)\n        # Candidate colors: existing colors plus possibly introducing a new color with small prob\n        existing = list({c for c in s})\n        # Bias toward existing colors to reduce K\n        if random.random() < 0.15:\n            # allow new color\n            candidates = existing + [max_color + 1]\n        else:\n            candidates = existing\n        new_c = random.choice(candidates)\n        # Ensure an actual change\n        if new_c == s[i]:\n            new_c = ((s[i] % max_color) + 1) if max_color >= 2 else 1\n        s[i] = new_c\n        # Optional relabeling to keep colors compact 1..K\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n        return s, \"recolor\"\n    else:\n        # swap color labels between two random vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        s[i], s[j] = s[j], s[i]\n        return s, \"swap_colors\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger random move: multiple recolors and occasional color merge\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        max_color = max(s)\n        existing = list({c for c in s})\n        # 50% try to reduce number of colors by mapping to an existing color\n        if random.random() < 0.5 and len(existing) > 1:\n            target = random.choice(existing)\n            s[i] = target\n        else:\n            # random recolor possibly introducing new color\n            if random.random() < 0.2:\n                s[i] = max_color + 1\n            else:\n                s[i] = random.choice(existing)\n        # Compact colors\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n    # Occasional color merge: pick two labels and merge\n    if random.random() < 0.3:\n        labels = list({c for c in s})\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            s = [a if c == b else c for c in s]\n            # Compact again\n            remap = {}\n            next_id = 1\n            for c in s:\n                if c not in remap:\n                    remap[c] = next_id\n                    next_id += 1\n            s = [remap[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00081662}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci is the color label of vertex i. Each color class must induce a clique (if two vertices share a color, they must be adjacent in E).","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (a, b) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: penalize larger K above K*\n    K = max(solution)\n    # Precomputed optimal K* for this fixed graph (minimum clique cover number)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Helper: conflicts per vertex (non-edges within same color)\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    conf += 1\n        return conf\n    # Helper: feasible to move vertex i to color c?\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    # Choose move type based on current conflict state\n    conf_counts = [conflicts_of_vertex(i, s) for i in range(n)]\n    total_conf = sum(conf_counts)\n    move = None\n    if total_conf > 0 and random.random() < 0.7:\n        move = \"conflict_recolor\"\n    else:\n        move = \"class_move\"\n    if move == \"conflict_recolor\":\n        # Pick most conflicting vertex, move to best existing color\n        i = max(range(n), key=lambda t: conf_counts[t])\n        cur_c = s[i]\n        labels = list({c for c in s})\n        # Evaluate delta conflicts for each candidate color\n        best_c = cur_c\n        best_delta = 0\n        # Try existing colors first\n        for c in labels:\n            if c == cur_c:\n                continue\n            if feasible_in_color(i, c, s):\n                best_c = c\n                best_delta = -1  # strict improvement by resolving conflicts for this vertex\n                break\n        if best_delta == 0:\n            # As fallback, possibly introduce a new color with small probability\n            if random.random() < 0.2:\n                best_c = max(labels) + 1\n            else:\n                # move to a random existing different color\n                cand = [c for c in labels if c != cur_c]\n                if cand:\n                    best_c = random.choice(cand)\n        s[i] = best_c\n        return s, \"conflict_recolor\"\n    else:\n        # class_move: pick a vertex and move to a randomly chosen existing color if feasible; else random recolor\n        i = random.randrange(n)\n        labels = list({c for c in s})\n        random.shuffle(labels)\n        moved = False\n        for c in labels:\n            if c == s[i]:\n                continue\n            if feasible_in_color(i, c, s):\n                s[i] = c\n                moved = True\n                break\n        if not moved:\n            # random recolor possibly introducing a new color (diversification)\n            if random.random() < 0.15:\n                s[i] = max(labels) + 1\n            else:\n                s[i] = random.choice(labels)\n        return s, \"class_move\"","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    # Graph\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    def most_conflicting_vertex(arr):\n        worst_i = 0\n        worst = -1\n        for i in range(n):\n            u = i + 1\n            cu = arr[i]\n            conf = 0\n            for j in range(n):\n                if j == i:\n                    continue\n                if arr[j] == cu:\n                    v = j + 1\n                    a,b = (u,v) if u < v else (v,u)\n                    if (a,b) not in E:\n                        conf += 1\n            if conf > worst:\n                worst = conf\n                worst_i = i\n        return worst_i, worst\n    # Perform multiple strong moves\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i, worst = most_conflicting_vertex(s)\n        labels = list({c for c in s})\n        if worst > 0:\n            # try to move to a feasible existing color\n            random.shuffle(labels)\n            moved = False\n            for c in labels:\n                if c == s[i]:\n                    continue\n                if feasible_in_color(i, c, s):\n                    s[i] = c\n                    moved = True\n                    break\n            if not moved:\n                # introduce new color to break conflicts\n                s[i] = max(labels) + 1\n        else:\n            # No conflicts: attempt color merge by moving a vertex into another color if feasible\n            if len(labels) >= 2:\n                src = random.choice(labels)\n                dsts = [c for c in labels if c != src]\n                if dsts:\n                    dst = random.choice(dsts)\n                    # move a random vertex of src into dst if feasible, else random recolor\n                    idxs = [k for k in range(n) if s[k] == src]\n                    if idxs:\n                        k = random.choice(idxs)\n                        if feasible_in_color(k, dst, s):\n                            s[k] = dst\n                        else:\n                            # random recolor for diversification\n                            if random.random() < 0.3:\n                                s[k] = max(labels) + 1\n                            else:\n                                s[k] = random.choice(labels)\n            else:\n                # single color: diversify by splitting\n                k = random.randrange(n)\n                s[k] = max(labels) + 1\n    return s","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00086014}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci is the color label of vertex i. Each color class must induce a clique (if two vertices share a color, they must be adjacent in E).","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (a, b) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: penalize larger K above K*\n    K = max(solution)\n    # Precomputed optimal K* for this fixed graph (minimum clique cover number)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Helper: conflicts per vertex (non-edges within same color)\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    conf += 1\n        return conf\n    # Helper: feasible to move vertex i to color c?\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    # Choose move type based on current conflict state\n    conf_counts = [conflicts_of_vertex(i, s) for i in range(n)]\n    total_conf = sum(conf_counts)\n    move = None\n    if total_conf > 0 and random.random() < 0.7:\n        move = \"conflict_recolor\"\n    else:\n        move = \"class_move\"\n    if move == \"conflict_recolor\":\n        # Pick most conflicting vertex, move to best existing color\n        i = max(range(n), key=lambda t: conf_counts[t])\n        cur_c = s[i]\n        labels = list({c for c in s})\n        # Evaluate delta conflicts for each candidate color\n        best_c = cur_c\n        best_delta = 0\n        # Try existing colors first\n        for c in labels:\n            if c == cur_c:\n                continue\n            if feasible_in_color(i, c, s):\n                best_c = c\n                best_delta = -1  # strict improvement by resolving conflicts for this vertex\n                break\n        if best_delta == 0:\n            # As fallback, possibly introduce a new color with small probability\n            if random.random() < 0.2:\n                best_c = max(labels) + 1\n            else:\n                # move to a random existing different color\n                cand = [c for c in labels if c != cur_c]\n                if cand:\n                    best_c = random.choice(cand)\n        s[i] = best_c\n        return s, \"conflict_recolor\"\n    else:\n        # class_move: pick a vertex and move to a randomly chosen existing color if feasible; else random recolor\n        i = random.randrange(n)\n        labels = list({c for c in s})\n        random.shuffle(labels)\n        moved = False\n        for c in labels:\n            if c == s[i]:\n                continue\n            if feasible_in_color(i, c, s):\n                s[i] = c\n                moved = True\n                break\n        if not moved:\n            # random recolor possibly introducing a new color (diversification)\n            if random.random() < 0.15:\n                s[i] = max(labels) + 1\n            else:\n                s[i] = random.choice(labels)\n        return s, \"class_move\"","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    # Graph\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    def most_conflicting_vertex(arr):\n        worst_i = 0\n        worst = -1\n        for i in range(n):\n            u = i + 1\n            cu = arr[i]\n            conf = 0\n            for j in range(n):\n                if j == i:\n                    continue\n                if arr[j] == cu:\n                    v = j + 1\n                    a,b = (u,v) if u < v else (v,u)\n                    if (a,b) not in E:\n                        conf += 1\n            if conf > worst:\n                worst = conf\n                worst_i = i\n        return worst_i, worst\n    # Perform multiple strong moves\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i, worst = most_conflicting_vertex(s)\n        labels = list({c for c in s})\n        if worst > 0:\n            # try to move to a feasible existing color\n            random.shuffle(labels)\n            moved = False\n            for c in labels:\n                if c == s[i]:\n                    continue\n                if feasible_in_color(i, c, s):\n                    s[i] = c\n                    moved = True\n                    break\n            if not moved:\n                # introduce new color to break conflicts\n                s[i] = max(labels) + 1\n        else:\n            # No conflicts: attempt color merge by moving a vertex into another color if feasible\n            if len(labels) >= 2:\n                src = random.choice(labels)\n                dsts = [c for c in labels if c != src]\n                if dsts:\n                    dst = random.choice(dsts)\n                    # move a random vertex of src into dst if feasible, else random recolor\n                    idxs = [k for k in range(n) if s[k] == src]\n                    if idxs:\n                        k = random.choice(idxs)\n                        if feasible_in_color(k, dst, s):\n                            s[k] = dst\n                        else:\n                            # random recolor for diversification\n                            if random.random() < 0.3:\n                                s[k] = max(labels) + 1\n                            else:\n                                s[k] = random.choice(labels)\n            else:\n                # single color: diversify by splitting\n                k = random.randrange(n)\n                s[k] = max(labels) + 1\n    return s","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001163125}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci is the color label of vertex i. Each color class must induce a clique (if two vertices share a color, they must be adjacent in E).","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (a, b) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: penalize larger K above K*\n    K = max(solution)\n    # Precomputed optimal K* for this fixed graph (minimum clique cover number)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Helper: conflicts per vertex (non-edges within same color)\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    conf += 1\n        return conf\n    # Helper: feasible to move vertex i to color c?\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    # Choose move type based on current conflict state\n    conf_counts = [conflicts_of_vertex(i, s) for i in range(n)]\n    total_conf = sum(conf_counts)\n    move = None\n    if total_conf > 0 and random.random() < 0.7:\n        move = \"conflict_recolor\"\n    else:\n        move = \"class_move\"\n    if move == \"conflict_recolor\":\n        # Pick most conflicting vertex, move to best existing color\n        i = max(range(n), key=lambda t: conf_counts[t])\n        cur_c = s[i]\n        labels = list({c for c in s})\n        # Evaluate delta conflicts for each candidate color\n        best_c = cur_c\n        best_delta = 0\n        # Try existing colors first\n        for c in labels:\n            if c == cur_c:\n                continue\n            if feasible_in_color(i, c, s):\n                best_c = c\n                best_delta = -1  # strict improvement by resolving conflicts for this vertex\n                break\n        if best_delta == 0:\n            # As fallback, possibly introduce a new color with small probability\n            if random.random() < 0.2:\n                best_c = max(labels) + 1\n            else:\n                # move to a random existing different color\n                cand = [c for c in labels if c != cur_c]\n                if cand:\n                    best_c = random.choice(cand)\n        s[i] = best_c\n        return s, \"conflict_recolor\"\n    else:\n        # class_move: pick a vertex and move to a randomly chosen existing color if feasible; else random recolor\n        i = random.randrange(n)\n        labels = list({c for c in s})\n        random.shuffle(labels)\n        moved = False\n        for c in labels:\n            if c == s[i]:\n                continue\n            if feasible_in_color(i, c, s):\n                s[i] = c\n                moved = True\n                break\n        if not moved:\n            # random recolor possibly introducing a new color (diversification)\n            if random.random() < 0.15:\n                s[i] = max(labels) + 1\n            else:\n                s[i] = random.choice(labels)\n        return s, \"class_move\"","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    # Graph\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    def most_conflicting_vertex(arr):\n        worst_i = 0\n        worst = -1\n        for i in range(n):\n            u = i + 1\n            cu = arr[i]\n            conf = 0\n            for j in range(n):\n                if j == i:\n                    continue\n                if arr[j] == cu:\n                    v = j + 1\n                    a,b = (u,v) if u < v else (v,u)\n                    if (a,b) not in E:\n                        conf += 1\n            if conf > worst:\n                worst = conf\n                worst_i = i\n        return worst_i, worst\n    # Perform multiple strong moves\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i, worst = most_conflicting_vertex(s)\n        labels = list({c for c in s})\n        if worst > 0:\n            # try to move to a feasible existing color\n            random.shuffle(labels)\n            moved = False\n            for c in labels:\n                if c == s[i]:\n                    continue\n                if feasible_in_color(i, c, s):\n                    s[i] = c\n                    moved = True\n                    break\n            if not moved:\n                # introduce new color to break conflicts\n                s[i] = max(labels) + 1\n        else:\n            # No conflicts: attempt color merge by moving a vertex into another color if feasible\n            if len(labels) >= 2:\n                src = random.choice(labels)\n                dsts = [c for c in labels if c != src]\n                if dsts:\n                    dst = random.choice(dsts)\n                    # move a random vertex of src into dst if feasible, else random recolor\n                    idxs = [k for k in range(n) if s[k] == src]\n                    if idxs:\n                        k = random.choice(idxs)\n                        if feasible_in_color(k, dst, s):\n                            s[k] = dst\n                        else:\n                            # random recolor for diversification\n                            if random.random() < 0.3:\n                                s[k] = max(labels) + 1\n                            else:\n                                s[k] = random.choice(labels)\n            else:\n                # single color: diversify by splitting\n                k = random.randrange(n)\n                s[k] = max(labels) + 1\n    return s","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0010997631}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST of length 9: list[int] where index i in 0..8 encodes color of vertex i+1. Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (min(a,b), max(a,b)) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: objective is minimize K; add soft penalty if above known optimum K*\n    K = max(solution)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)\n","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def total_violations(arr):\n        # Count unordered pairs violating clique condition\n        viol = 0\n        color_to_vertices = {}\n        for i, c in enumerate(arr, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        for verts in color_to_vertices.values():\n            if len(verts) <= 1:\n                continue\n            for a, b in combinations(sorted(verts), 2):\n                if not is_edge(a,b):\n                    viol += 1\n        return viol\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                if not is_edge(u,v):\n                    conf += 1\n        return conf\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    # Current state\n    cur_viol = total_violations(s)\n    labels = sorted(set(s))\n    # If conflicts exist: best conflict-resolving recolor\n    if cur_viol > 0:\n        # choose vertex with highest conflicts (tie-break by random)\n        confs = [(conflicts_of_vertex(i, s), i) for i in range(n)]\n        max_conf = max(confs)[0]\n        cand_vertices = [i for c,i in confs if c == max_conf]\n        i = random.choice(cand_vertices)\n        cur_c = s[i]\n        best_arr = None\n        best_key = None  # (violations, K, color_label)\n        # Try recolor to all existing colors and possibly a new color\n        try_colors = list(labels)\n        if (max_conf == 0) and (len(labels) == 1):\n            try_colors.append(max(labels)+1)\n        else:\n            try_colors.append(max(labels)+1)\n        for c in try_colors:\n            if c == cur_c:\n                continue\n            t = s[:]\n            t[i] = c\n            # If recolor makes it infeasible w.r.t clique, it's still evaluated by violations metric\n            viol = total_violations(t)\n            key = (viol, max(t), c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_arr = t\n        if best_arr is None:\n            # fallback random recolor\n            t = s[:]\n            other = [c for c in labels if c != s[i]]\n            if other:\n                t[i] = random.choice(other)\n            best_arr = t\n        return normalize_colors(best_arr), \"conflict_recolor\"\n    # Feasible: attempt color elimination\/merge first\n    # Try to eliminate a color by moving its vertices to other colors\n    labels = sorted(set(s))\n    if len(labels) >= 2:\n        # pick a source color (smallest class first)\n        sizes = {c: s.count(c) for c in labels}\n        src = min(labels, key=lambda c: (sizes[c], c))\n        verts = [i for i in range(n) if s[i] == src]\n        target_labels = [c for c in labels if c != src]\n        # Greedy pack into feasible targets\n        t = s[:]\n        possible = True\n        for i in verts:\n            placed = False\n            # try targets in increasing size order to balance\n            target_labels.sort(key=lambda c: (t.count(c), c))\n            for c in target_labels:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    placed = True\n                    break\n            if not placed:\n                possible = False\n                break\n        if possible:\n            return normalize_colors(t), \"color_eliminate\"\n    # If elimination failed, try a feasible pair swap to diversify\n    trials = 20\n    for _ in range(trials):\n        i = random.randrange(n)\n        j = random.randrange(n)\n        if i == j or s[i] == s[j]:\n            continue\n        t = s[:]\n        ci, cj = t[i], t[j]\n        # swap colors if both remain feasible\n        t[i], t[j] = cj, ci\n        if feasible_in_color(i, t[i], t) and feasible_in_color(j, t[j], t):\n            return normalize_colors(t), \"pair_swap\"\n    # Fallback: simple feasible recolor of a random vertex\n    i = random.randrange(n)\n    other = [c for c in labels if c != s[i]]\n    random.shuffle(other)\n    for c in other:\n        if feasible_in_color(i, c, s):\n            t = s[:]\n            t[i] = c\n            return normalize_colors(t), \"class_move\"\n    # As last resort, introduce a new color to diversify (will be penalized but may escape)\n    t = s[:]\n    t[i] = max(labels) + 1\n    return normalize_colors(t), \"new_color\"\n","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Determine intensity based on conflicts: stronger if stagnated (simulated by random here)\n    steps = random.randint(4, 7)\n    t = s[:]\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = sorted(set(t))\n        # With probability, attempt move within existing colors; else possibly introduce a new color\n        if random.random() < 0.8:\n            # try to move to a random feasible existing color different from current\n            choices = [c for c in labels if c != t[i]]\n            random.shuffle(choices)\n            moved = False\n            for c in choices:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    moved = True\n                    break\n            if not moved and choices:\n                t[i] = random.choice(choices)\n        else:\n            t[i] = max(labels) + 1\n        # occasional color elimination attempt inside perturbation\n        if random.random() < 0.3 and len(set(t)) > 1:\n            labels = sorted(set(t))\n            # choose a source color and try to relocate one of its vertices\n            src = random.choice(labels)\n            dsts = [c for c in labels if c != src]\n            idxs = [k for k in range(n) if t[k] == src]\n            if idxs and dsts:\n                k = random.choice(idxs)\n                random.shuffle(dsts)\n                for c in dsts:\n                    if feasible_in_color(k, c, t):\n                        t[k] = c\n                        break\n        t = normalize_colors(t)\n    return t\n","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001184714}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST of length 9: list[int] where index i in 0..8 encodes color of vertex i+1. Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (min(a,b), max(a,b)) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: objective is minimize K; add soft penalty if above known optimum K*\n    K = max(solution)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)\n","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def total_violations(arr):\n        # Count unordered pairs violating clique condition\n        viol = 0\n        color_to_vertices = {}\n        for i, c in enumerate(arr, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        for verts in color_to_vertices.values():\n            if len(verts) <= 1:\n                continue\n            for a, b in combinations(sorted(verts), 2):\n                if not is_edge(a,b):\n                    viol += 1\n        return viol\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                if not is_edge(u,v):\n                    conf += 1\n        return conf\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    # Current state\n    cur_viol = total_violations(s)\n    labels = sorted(set(s))\n    # If conflicts exist: best conflict-resolving recolor\n    if cur_viol > 0:\n        # choose vertex with highest conflicts (tie-break by random)\n        confs = [(conflicts_of_vertex(i, s), i) for i in range(n)]\n        max_conf = max(confs)[0]\n        cand_vertices = [i for c,i in confs if c == max_conf]\n        i = random.choice(cand_vertices)\n        cur_c = s[i]\n        best_arr = None\n        best_key = None  # (violations, K, color_label)\n        # Try recolor to all existing colors and possibly a new color\n        try_colors = list(labels)\n        if (max_conf == 0) and (len(labels) == 1):\n            try_colors.append(max(labels)+1)\n        else:\n            try_colors.append(max(labels)+1)\n        for c in try_colors:\n            if c == cur_c:\n                continue\n            t = s[:]\n            t[i] = c\n            # If recolor makes it infeasible w.r.t clique, it's still evaluated by violations metric\n            viol = total_violations(t)\n            key = (viol, max(t), c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_arr = t\n        if best_arr is None:\n            # fallback random recolor\n            t = s[:]\n            other = [c for c in labels if c != s[i]]\n            if other:\n                t[i] = random.choice(other)\n            best_arr = t\n        return normalize_colors(best_arr), \"conflict_recolor\"\n    # Feasible: attempt color elimination\/merge first\n    # Try to eliminate a color by moving its vertices to other colors\n    labels = sorted(set(s))\n    if len(labels) >= 2:\n        # pick a source color (smallest class first)\n        sizes = {c: s.count(c) for c in labels}\n        src = min(labels, key=lambda c: (sizes[c], c))\n        verts = [i for i in range(n) if s[i] == src]\n        target_labels = [c for c in labels if c != src]\n        # Greedy pack into feasible targets\n        t = s[:]\n        possible = True\n        for i in verts:\n            placed = False\n            # try targets in increasing size order to balance\n            target_labels.sort(key=lambda c: (t.count(c), c))\n            for c in target_labels:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    placed = True\n                    break\n            if not placed:\n                possible = False\n                break\n        if possible:\n            return normalize_colors(t), \"color_eliminate\"\n    # If elimination failed, try a feasible pair swap to diversify\n    trials = 20\n    for _ in range(trials):\n        i = random.randrange(n)\n        j = random.randrange(n)\n        if i == j or s[i] == s[j]:\n            continue\n        t = s[:]\n        ci, cj = t[i], t[j]\n        # swap colors if both remain feasible\n        t[i], t[j] = cj, ci\n        if feasible_in_color(i, t[i], t) and feasible_in_color(j, t[j], t):\n            return normalize_colors(t), \"pair_swap\"\n    # Fallback: simple feasible recolor of a random vertex\n    i = random.randrange(n)\n    other = [c for c in labels if c != s[i]]\n    random.shuffle(other)\n    for c in other:\n        if feasible_in_color(i, c, s):\n            t = s[:]\n            t[i] = c\n            return normalize_colors(t), \"class_move\"\n    # As last resort, introduce a new color to diversify (will be penalized but may escape)\n    t = s[:]\n    t[i] = max(labels) + 1\n    return normalize_colors(t), \"new_color\"\n","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Determine intensity based on conflicts: stronger if stagnated (simulated by random here)\n    steps = random.randint(4, 7)\n    t = s[:]\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = sorted(set(t))\n        # With probability, attempt move within existing colors; else possibly introduce a new color\n        if random.random() < 0.8:\n            # try to move to a random feasible existing color different from current\n            choices = [c for c in labels if c != t[i]]\n            random.shuffle(choices)\n            moved = False\n            for c in choices:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    moved = True\n                    break\n            if not moved and choices:\n                t[i] = random.choice(choices)\n        else:\n            t[i] = max(labels) + 1\n        # occasional color elimination attempt inside perturbation\n        if random.random() < 0.3 and len(set(t)) > 1:\n            labels = sorted(set(t))\n            # choose a source color and try to relocate one of its vertices\n            src = random.choice(labels)\n            dsts = [c for c in labels if c != src]\n            idxs = [k for k in range(n) if t[k] == src]\n            if idxs and dsts:\n                k = random.choice(idxs)\n                random.shuffle(dsts)\n                for c in dsts:\n                    if feasible_in_color(k, c, t):\n                        t[k] = c\n                        break\n        t = normalize_colors(t)\n    return t\n","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001396236}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST of length 9: list[int] where index i in 0..8 encodes color of vertex i+1. Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (min(a,b), max(a,b)) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: objective is minimize K; add soft penalty if above known optimum K*\n    K = max(solution)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)\n","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def total_violations(arr):\n        # Count unordered pairs violating clique condition\n        viol = 0\n        color_to_vertices = {}\n        for i, c in enumerate(arr, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        for verts in color_to_vertices.values():\n            if len(verts) <= 1:\n                continue\n            for a, b in combinations(sorted(verts), 2):\n                if not is_edge(a,b):\n                    viol += 1\n        return viol\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                if not is_edge(u,v):\n                    conf += 1\n        return conf\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    # Current state\n    cur_viol = total_violations(s)\n    labels = sorted(set(s))\n    # If conflicts exist: best conflict-resolving recolor\n    if cur_viol > 0:\n        # choose vertex with highest conflicts (tie-break by random)\n        confs = [(conflicts_of_vertex(i, s), i) for i in range(n)]\n        max_conf = max(confs)[0]\n        cand_vertices = [i for c,i in confs if c == max_conf]\n        i = random.choice(cand_vertices)\n        cur_c = s[i]\n        best_arr = None\n        best_key = None  # (violations, K, color_label)\n        # Try recolor to all existing colors and possibly a new color\n        try_colors = list(labels)\n        if (max_conf == 0) and (len(labels) == 1):\n            try_colors.append(max(labels)+1)\n        else:\n            try_colors.append(max(labels)+1)\n        for c in try_colors:\n            if c == cur_c:\n                continue\n            t = s[:]\n            t[i] = c\n            # If recolor makes it infeasible w.r.t clique, it's still evaluated by violations metric\n            viol = total_violations(t)\n            key = (viol, max(t), c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_arr = t\n        if best_arr is None:\n            # fallback random recolor\n            t = s[:]\n            other = [c for c in labels if c != s[i]]\n            if other:\n                t[i] = random.choice(other)\n            best_arr = t\n        return normalize_colors(best_arr), \"conflict_recolor\"\n    # Feasible: attempt color elimination\/merge first\n    # Try to eliminate a color by moving its vertices to other colors\n    labels = sorted(set(s))\n    if len(labels) >= 2:\n        # pick a source color (smallest class first)\n        sizes = {c: s.count(c) for c in labels}\n        src = min(labels, key=lambda c: (sizes[c], c))\n        verts = [i for i in range(n) if s[i] == src]\n        target_labels = [c for c in labels if c != src]\n        # Greedy pack into feasible targets\n        t = s[:]\n        possible = True\n        for i in verts:\n            placed = False\n            # try targets in increasing size order to balance\n            target_labels.sort(key=lambda c: (t.count(c), c))\n            for c in target_labels:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    placed = True\n                    break\n            if not placed:\n                possible = False\n                break\n        if possible:\n            return normalize_colors(t), \"color_eliminate\"\n    # If elimination failed, try a feasible pair swap to diversify\n    trials = 20\n    for _ in range(trials):\n        i = random.randrange(n)\n        j = random.randrange(n)\n        if i == j or s[i] == s[j]:\n            continue\n        t = s[:]\n        ci, cj = t[i], t[j]\n        # swap colors if both remain feasible\n        t[i], t[j] = cj, ci\n        if feasible_in_color(i, t[i], t) and feasible_in_color(j, t[j], t):\n            return normalize_colors(t), \"pair_swap\"\n    # Fallback: simple feasible recolor of a random vertex\n    i = random.randrange(n)\n    other = [c for c in labels if c != s[i]]\n    random.shuffle(other)\n    for c in other:\n        if feasible_in_color(i, c, s):\n            t = s[:]\n            t[i] = c\n            return normalize_colors(t), \"class_move\"\n    # As last resort, introduce a new color to diversify (will be penalized but may escape)\n    t = s[:]\n    t[i] = max(labels) + 1\n    return normalize_colors(t), \"new_color\"\n","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Determine intensity based on conflicts: stronger if stagnated (simulated by random here)\n    steps = random.randint(4, 7)\n    t = s[:]\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = sorted(set(t))\n        # With probability, attempt move within existing colors; else possibly introduce a new color\n        if random.random() < 0.8:\n            # try to move to a random feasible existing color different from current\n            choices = [c for c in labels if c != t[i]]\n            random.shuffle(choices)\n            moved = False\n            for c in choices:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    moved = True\n                    break\n            if not moved and choices:\n                t[i] = random.choice(choices)\n        else:\n            t[i] = max(labels) + 1\n        # occasional color elimination attempt inside perturbation\n        if random.random() < 0.3 and len(set(t)) > 1:\n            labels = sorted(set(t))\n            # choose a source color and try to relocate one of its vertices\n            src = random.choice(labels)\n            dsts = [c for c in labels if c != src]\n            idxs = [k for k in range(n) if t[k] == src]\n            if idxs and dsts:\n                k = random.choice(idxs)\n                random.shuffle(dsts)\n                for c in dsts:\n                    if feasible_in_color(k, c, t):\n                        t[k] = c\n                        break\n        t = normalize_colors(t)\n    return t\n","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001356876}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST length 9: list[int] where position i (0-based) stores color of vertex i+1. Colors are positive integers; each color class must induce a clique.","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility: each color class must be a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (min(a,b), max(a,b)) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: objective is minimize number of colors\n    K = max(solution)\n    return float(K)","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def total_violations(arr):\n        viol = 0\n        color_to_vertices = {}\n        for i, c in enumerate(arr, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        for verts in color_to_vertices.values():\n            if len(verts) <= 1:\n                continue\n            for a, b in combinations(sorted(verts), 2):\n                if not is_edge(a,b):\n                    viol += 1\n        return viol\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                if not is_edge(u,v):\n                    conf += 1\n        return conf\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    # Current state\n    cur_viol = total_violations(s)\n    labels = sorted(set(s))\n    # If conflicts exist: try conflict-reducing recolor\n    if cur_viol > 0:\n        confs = [(conflicts_of_vertex(i, s), i) for i in range(n)]\n        max_conf = max(confs)[0]\n        cand_vertices = [i for c,i in confs if c == max_conf]\n        i = random.choice(cand_vertices)\n        cur_c = s[i]\n        best_arr = None\n        best_key = None  # (violations, K, color_label)\n        try_colors = list(labels)\n        try_colors.append(max(labels)+1)\n        for c in try_colors:\n            if c == cur_c:\n                continue\n            t = s[:]\n            t[i] = c\n            viol = total_violations(t)\n            key = (viol, max(t), c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_arr = t\n        if best_arr is None:\n            t = s[:]\n            other = [c for c in labels if c != s[i]]\n            if other:\n                t[i] = random.choice(other)\n            best_arr = t\n        return normalize_colors(best_arr), \"conflict_recolor\"\n    # Feasible: try eliminate a color (merge smallest class)\n    labels = sorted(set(s))\n    if len(labels) >= 2:\n        sizes = {c: s.count(c) for c in labels}\n        src = min(labels, key=lambda c: (sizes[c], c))\n        verts = [i for i in range(n) if s[i] == src]\n        target_labels = [c for c in labels if c != src]\n        t = s[:]\n        possible = True\n        for i in verts:\n            placed = False\n            target_labels.sort(key=lambda c: (t.count(c), c))\n            for c in target_labels:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    placed = True\n                    break\n            if not placed:\n                possible = False\n                break\n        if possible:\n            return normalize_colors(t), \"color_eliminate\"\n    # Feasible but elimination failed: try pair swap\n    trials = 30\n    for _ in range(trials):\n        i = random.randrange(n)\n        j = random.randrange(n)\n        if i == j or s[i] == s[j]:\n            continue\n        t = s[:]\n        ci, cj = t[i], t[j]\n        t[i], t[j] = cj, ci\n        # Check feasibility for both affected vertices\n        ok_i = all((i==k) or (t[k]!=t[i]) or is_edge(i+1,k+1) for k in range(n))\n        ok_j = all((j==k) or (t[k]!=t[j]) or is_edge(j+1,k+1) for k in range(n))\n        if ok_i and ok_j:\n            return normalize_colors(t), \"pair_swap\"\n    # Fallback: feasible recolor move within existing labels if possible\n    i = random.randrange(n)\n    other = [c for c in labels if c != s[i]]\n    random.shuffle(other)\n    for c in other:\n        if feasible_in_color(i, c, s):\n            t = s[:]\n            t[i] = c\n            return normalize_colors(t), \"class_move\"\n    # Last resort: introduce a new color\n    t = s[:]\n    t[i] = max(labels) + 1\n    return normalize_colors(t), \"new_color\"","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Perturbation intensity: 4-7 random recolor attempts with feasibility bias\n    steps = random.randint(4, 7)\n    t = s[:]\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = sorted(set(t))\n        if random.random() < 0.85:\n            choices = [c for c in labels if c != t[i]]\n            random.shuffle(choices)\n            moved = False\n            for c in choices:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    moved = True\n                    break\n            if not moved and choices:\n                t[i] = random.choice(choices)\n        else:\n            t[i] = max(labels) + 1\n        # occasional partial color elimination attempt\n        if random.random() < 0.35 and len(set(t)) > 1:\n            labels = sorted(set(t))\n            src = min(labels, key=lambda c: t.count(c))\n            idxs = [k for k in range(n) if t[k] == src]\n            dsts = [c for c in labels if c != src]\n            if idxs and dsts:\n                k = random.choice(idxs)\n                random.shuffle(dsts)\n                for c in dsts:\n                    if feasible_in_color(k, c, t):\n                        t[k] = c\n                        break\n        t = normalize_colors(t)\n    return t","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001190424}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST length 9: list[int] where position i (0-based) stores color of vertex i+1. Colors are positive integers; each color class must induce a clique.","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility: each color class must be a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (min(a,b), max(a,b)) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: objective is minimize number of colors\n    K = max(solution)\n    return float(K)","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def total_violations(arr):\n        viol = 0\n        color_to_vertices = {}\n        for i, c in enumerate(arr, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        for verts in color_to_vertices.values():\n            if len(verts) <= 1:\n                continue\n            for a, b in combinations(sorted(verts), 2):\n                if not is_edge(a,b):\n                    viol += 1\n        return viol\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                if not is_edge(u,v):\n                    conf += 1\n        return conf\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    # Current state\n    cur_viol = total_violations(s)\n    labels = sorted(set(s))\n    # If conflicts exist: try conflict-reducing recolor\n    if cur_viol > 0:\n        confs = [(conflicts_of_vertex(i, s), i) for i in range(n)]\n        max_conf = max(confs)[0]\n        cand_vertices = [i for c,i in confs if c == max_conf]\n        i = random.choice(cand_vertices)\n        cur_c = s[i]\n        best_arr = None\n        best_key = None  # (violations, K, color_label)\n        try_colors = list(labels)\n        try_colors.append(max(labels)+1)\n        for c in try_colors:\n            if c == cur_c:\n                continue\n            t = s[:]\n            t[i] = c\n            viol = total_violations(t)\n            key = (viol, max(t), c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_arr = t\n        if best_arr is None:\n            t = s[:]\n            other = [c for c in labels if c != s[i]]\n            if other:\n                t[i] = random.choice(other)\n            best_arr = t\n        return normalize_colors(best_arr), \"conflict_recolor\"\n    # Feasible: try eliminate a color (merge smallest class)\n    labels = sorted(set(s))\n    if len(labels) >= 2:\n        sizes = {c: s.count(c) for c in labels}\n        src = min(labels, key=lambda c: (sizes[c], c))\n        verts = [i for i in range(n) if s[i] == src]\n        target_labels = [c for c in labels if c != src]\n        t = s[:]\n        possible = True\n        for i in verts:\n            placed = False\n            target_labels.sort(key=lambda c: (t.count(c), c))\n            for c in target_labels:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    placed = True\n                    break\n            if not placed:\n                possible = False\n                break\n        if possible:\n            return normalize_colors(t), \"color_eliminate\"\n    # Feasible but elimination failed: try pair swap\n    trials = 30\n    for _ in range(trials):\n        i = random.randrange(n)\n        j = random.randrange(n)\n        if i == j or s[i] == s[j]:\n            continue\n        t = s[:]\n        ci, cj = t[i], t[j]\n        t[i], t[j] = cj, ci\n        # Check feasibility for both affected vertices\n        ok_i = all((i==k) or (t[k]!=t[i]) or is_edge(i+1,k+1) for k in range(n))\n        ok_j = all((j==k) or (t[k]!=t[j]) or is_edge(j+1,k+1) for k in range(n))\n        if ok_i and ok_j:\n            return normalize_colors(t), \"pair_swap\"\n    # Fallback: feasible recolor move within existing labels if possible\n    i = random.randrange(n)\n    other = [c for c in labels if c != s[i]]\n    random.shuffle(other)\n    for c in other:\n        if feasible_in_color(i, c, s):\n            t = s[:]\n            t[i] = c\n            return normalize_colors(t), \"class_move\"\n    # Last resort: introduce a new color\n    t = s[:]\n    t[i] = max(labels) + 1\n    return normalize_colors(t), \"new_color\"","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Perturbation intensity: 4-7 random recolor attempts with feasibility bias\n    steps = random.randint(4, 7)\n    t = s[:]\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = sorted(set(t))\n        if random.random() < 0.85:\n            choices = [c for c in labels if c != t[i]]\n            random.shuffle(choices)\n            moved = False\n            for c in choices:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    moved = True\n                    break\n            if not moved and choices:\n                t[i] = random.choice(choices)\n        else:\n            t[i] = max(labels) + 1\n        # occasional partial color elimination attempt\n        if random.random() < 0.35 and len(set(t)) > 1:\n            labels = sorted(set(t))\n            src = min(labels, key=lambda c: t.count(c))\n            idxs = [k for k in range(n) if t[k] == src]\n            dsts = [c for c in labels if c != src]\n            if idxs and dsts:\n                k = random.choice(idxs)\n                random.shuffle(dsts)\n                for c in dsts:\n                    if feasible_in_color(k, c, t):\n                        t[k] = c\n                        break\n        t = normalize_colors(t)\n    return t","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001426277}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST length 9: list[int] where position i (0-based) stores color of vertex i+1. Colors are positive integers; each color class must induce a clique.","Evaluacion":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility: each color class must be a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (min(a,b), max(a,b)) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: objective is minimize number of colors\n    K = max(solution)\n    return float(K)","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def total_violations(arr):\n        viol = 0\n        color_to_vertices = {}\n        for i, c in enumerate(arr, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        for verts in color_to_vertices.values():\n            if len(verts) <= 1:\n                continue\n            for a, b in combinations(sorted(verts), 2):\n                if not is_edge(a,b):\n                    viol += 1\n        return viol\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                if not is_edge(u,v):\n                    conf += 1\n        return conf\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    # Current state\n    cur_viol = total_violations(s)\n    labels = sorted(set(s))\n    # If conflicts exist: try conflict-reducing recolor\n    if cur_viol > 0:\n        confs = [(conflicts_of_vertex(i, s), i) for i in range(n)]\n        max_conf = max(confs)[0]\n        cand_vertices = [i for c,i in confs if c == max_conf]\n        i = random.choice(cand_vertices)\n        cur_c = s[i]\n        best_arr = None\n        best_key = None  # (violations, K, color_label)\n        try_colors = list(labels)\n        try_colors.append(max(labels)+1)\n        for c in try_colors:\n            if c == cur_c:\n                continue\n            t = s[:]\n            t[i] = c\n            viol = total_violations(t)\n            key = (viol, max(t), c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_arr = t\n        if best_arr is None:\n            t = s[:]\n            other = [c for c in labels if c != s[i]]\n            if other:\n                t[i] = random.choice(other)\n            best_arr = t\n        return normalize_colors(best_arr), \"conflict_recolor\"\n    # Feasible: try eliminate a color (merge smallest class)\n    labels = sorted(set(s))\n    if len(labels) >= 2:\n        sizes = {c: s.count(c) for c in labels}\n        src = min(labels, key=lambda c: (sizes[c], c))\n        verts = [i for i in range(n) if s[i] == src]\n        target_labels = [c for c in labels if c != src]\n        t = s[:]\n        possible = True\n        for i in verts:\n            placed = False\n            target_labels.sort(key=lambda c: (t.count(c), c))\n            for c in target_labels:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    placed = True\n                    break\n            if not placed:\n                possible = False\n                break\n        if possible:\n            return normalize_colors(t), \"color_eliminate\"\n    # Feasible but elimination failed: try pair swap\n    trials = 30\n    for _ in range(trials):\n        i = random.randrange(n)\n        j = random.randrange(n)\n        if i == j or s[i] == s[j]:\n            continue\n        t = s[:]\n        ci, cj = t[i], t[j]\n        t[i], t[j] = cj, ci\n        # Check feasibility for both affected vertices\n        ok_i = all((i==k) or (t[k]!=t[i]) or is_edge(i+1,k+1) for k in range(n))\n        ok_j = all((j==k) or (t[k]!=t[j]) or is_edge(j+1,k+1) for k in range(n))\n        if ok_i and ok_j:\n            return normalize_colors(t), \"pair_swap\"\n    # Fallback: feasible recolor move within existing labels if possible\n    i = random.randrange(n)\n    other = [c for c in labels if c != s[i]]\n    random.shuffle(other)\n    for c in other:\n        if feasible_in_color(i, c, s):\n            t = s[:]\n            t[i] = c\n            return normalize_colors(t), \"class_move\"\n    # Last resort: introduce a new color\n    t = s[:]\n    t[i] = max(labels) + 1\n    return normalize_colors(t), \"new_color\"","Perturbacion":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Perturbation intensity: 4-7 random recolor attempts with feasibility bias\n    steps = random.randint(4, 7)\n    t = s[:]\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = sorted(set(t))\n        if random.random() < 0.85:\n            choices = [c for c in labels if c != t[i]]\n            random.shuffle(choices)\n            moved = False\n            for c in choices:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    moved = True\n                    break\n            if not moved and choices:\n                t[i] = random.choice(choices)\n        else:\n            t[i] = max(labels) + 1\n        # occasional partial color elimination attempt\n        if random.random() < 0.35 and len(set(t)) > 1:\n            labels = sorted(set(t))\n            src = min(labels, key=lambda c: t.count(c))\n            idxs = [k for k in range(n) if t[k] == src]\n            dsts = [c for c in labels if c != src]\n            if idxs and dsts:\n                k = random.choice(idxs)\n                random.shuffle(dsts)\n                for c in dsts:\n                    if feasible_in_color(k, c, t):\n                        t[k] = c\n                        break\n        t = normalize_colors(t)\n    return t","Resultados":"Failed to run target heuristic: combinations() missing required argument 'r' (pos 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001431966}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_1..k_CONSECUTIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    # All labels must be positive integers\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    # Labels must be exactly {1,..,k}\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build undirected adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\nimport copy\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'relabel', 'swap', 'split', 'merge'\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        # fallback to a simple valid seed\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        # Map existing labels to 1..m in order of first appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    move = random.random()\n    if move < 0.35:\n        # Relabel a single vertex to an existing or new label (at most +1 new)\n        i = random.randrange(9)\n        current_k = max(s)\n        choices = list(range(1, current_k+2))  # allow k+1 to enable exploration\n        choices.remove(s[i])\n        s[i] = random.choice(choices)\n        s = canonicalize(s)\n        return s, 'relabel'\n    elif move < 0.7:\n        # Swap labels of two vertices\n        i, j = random.sample(range(9), 2)\n        s[i], s[j] = s[j], s[i]\n        s = canonicalize(s)\n        return s, 'swap'\n    elif move < 0.85:\n        # Merge two random labels (if possible)\n        current_k = max(s)\n        if current_k >= 2:\n            a, b = random.sample(range(1, current_k+1), 2)\n            target = min(a, b)\n            source = max(a, b)\n            s = [target if x == source else x for x in s]\n            s = canonicalize(s)\n            return s, 'merge'\n        else:\n            # fallback to relabel\n            i = random.randrange(9)\n            s[i] = 1\n            s = canonicalize(s)\n            return s, 'relabel'\n    else:\n        # Split: pick a label with size >=2 and move one vertex to new label k+1\n        current_k = max(s)\n        # build groups\n        groups = {}\n        for idx, lab in enumerate(s):\n            groups.setdefault(lab, []).append(idx)\n        candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(groups[lab])\n            s[idx] = current_k + 1\n            s = canonicalize(s)\n            return s, 'split'\n        else:\n            # fallback to swap\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n            s = canonicalize(s)\n            return s, 'swap'\n","Perturbacion":"import random\n\n# Strong perturbation to escape local minima\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        current_k = max(s)\n        if move < 0.4:\n            i = random.randrange(9)\n            choices = list(range(1, current_k+2))\n            if s[i] in choices:\n                choices.remove(s[i])\n            s[i] = random.choice(choices)\n        elif move < 0.7:\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n        else:\n            # random merge or split\n            if current_k >= 2 and random.random() < 0.5:\n                a, b = random.sample(range(1, current_k+1), 2)\n                target = min(a, b)\n                source = max(a, b)\n                s = [target if x == source else x for x in s]\n            else:\n                # split\n                groups = {}\n                for idx, lab in enumerate(s):\n                    groups.setdefault(lab, []).append(idx)\n                candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n                if candidates:\n                    lab = random.choice(candidates)\n                    idx = random.choice(groups[lab])\n                    s[idx] = current_k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000679618}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_1..k_CONSECUTIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    # All labels must be positive integers\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    # Labels must be exactly {1,..,k}\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build undirected adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\nimport copy\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'relabel', 'swap', 'split', 'merge'\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        # fallback to a simple valid seed\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        # Map existing labels to 1..m in order of first appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    move = random.random()\n    if move < 0.35:\n        # Relabel a single vertex to an existing or new label (at most +1 new)\n        i = random.randrange(9)\n        current_k = max(s)\n        choices = list(range(1, current_k+2))  # allow k+1 to enable exploration\n        choices.remove(s[i])\n        s[i] = random.choice(choices)\n        s = canonicalize(s)\n        return s, 'relabel'\n    elif move < 0.7:\n        # Swap labels of two vertices\n        i, j = random.sample(range(9), 2)\n        s[i], s[j] = s[j], s[i]\n        s = canonicalize(s)\n        return s, 'swap'\n    elif move < 0.85:\n        # Merge two random labels (if possible)\n        current_k = max(s)\n        if current_k >= 2:\n            a, b = random.sample(range(1, current_k+1), 2)\n            target = min(a, b)\n            source = max(a, b)\n            s = [target if x == source else x for x in s]\n            s = canonicalize(s)\n            return s, 'merge'\n        else:\n            # fallback to relabel\n            i = random.randrange(9)\n            s[i] = 1\n            s = canonicalize(s)\n            return s, 'relabel'\n    else:\n        # Split: pick a label with size >=2 and move one vertex to new label k+1\n        current_k = max(s)\n        # build groups\n        groups = {}\n        for idx, lab in enumerate(s):\n            groups.setdefault(lab, []).append(idx)\n        candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(groups[lab])\n            s[idx] = current_k + 1\n            s = canonicalize(s)\n            return s, 'split'\n        else:\n            # fallback to swap\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n            s = canonicalize(s)\n            return s, 'swap'\n","Perturbacion":"import random\n\n# Strong perturbation to escape local minima\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        current_k = max(s)\n        if move < 0.4:\n            i = random.randrange(9)\n            choices = list(range(1, current_k+2))\n            if s[i] in choices:\n                choices.remove(s[i])\n            s[i] = random.choice(choices)\n        elif move < 0.7:\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n        else:\n            # random merge or split\n            if current_k >= 2 and random.random() < 0.5:\n                a, b = random.sample(range(1, current_k+1), 2)\n                target = min(a, b)\n                source = max(a, b)\n                s = [target if x == source else x for x in s]\n            else:\n                # split\n                groups = {}\n                for idx, lab in enumerate(s):\n                    groups.setdefault(lab, []).append(idx)\n                candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n                if candidates:\n                    lab = random.choice(candidates)\n                    idx = random.choice(groups[lab])\n                    s[idx] = current_k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000791279}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_1..k_CONSECUTIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    # All labels must be positive integers\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    # Labels must be exactly {1,..,k}\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build undirected adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\nimport copy\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'relabel', 'swap', 'split', 'merge'\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        # fallback to a simple valid seed\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        # Map existing labels to 1..m in order of first appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    move = random.random()\n    if move < 0.35:\n        # Relabel a single vertex to an existing or new label (at most +1 new)\n        i = random.randrange(9)\n        current_k = max(s)\n        choices = list(range(1, current_k+2))  # allow k+1 to enable exploration\n        choices.remove(s[i])\n        s[i] = random.choice(choices)\n        s = canonicalize(s)\n        return s, 'relabel'\n    elif move < 0.7:\n        # Swap labels of two vertices\n        i, j = random.sample(range(9), 2)\n        s[i], s[j] = s[j], s[i]\n        s = canonicalize(s)\n        return s, 'swap'\n    elif move < 0.85:\n        # Merge two random labels (if possible)\n        current_k = max(s)\n        if current_k >= 2:\n            a, b = random.sample(range(1, current_k+1), 2)\n            target = min(a, b)\n            source = max(a, b)\n            s = [target if x == source else x for x in s]\n            s = canonicalize(s)\n            return s, 'merge'\n        else:\n            # fallback to relabel\n            i = random.randrange(9)\n            s[i] = 1\n            s = canonicalize(s)\n            return s, 'relabel'\n    else:\n        # Split: pick a label with size >=2 and move one vertex to new label k+1\n        current_k = max(s)\n        # build groups\n        groups = {}\n        for idx, lab in enumerate(s):\n            groups.setdefault(lab, []).append(idx)\n        candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(groups[lab])\n            s[idx] = current_k + 1\n            s = canonicalize(s)\n            return s, 'split'\n        else:\n            # fallback to swap\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n            s = canonicalize(s)\n            return s, 'swap'\n","Perturbacion":"import random\n\n# Strong perturbation to escape local minima\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        current_k = max(s)\n        if move < 0.4:\n            i = random.randrange(9)\n            choices = list(range(1, current_k+2))\n            if s[i] in choices:\n                choices.remove(s[i])\n            s[i] = random.choice(choices)\n        elif move < 0.7:\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n        else:\n            # random merge or split\n            if current_k >= 2 and random.random() < 0.5:\n                a, b = random.sample(range(1, current_k+1), 2)\n                target = min(a, b)\n                source = max(a, b)\n                s = [target if x == source else x for x in s]\n            else:\n                # split\n                groups = {}\n                for idx, lab in enumerate(s):\n                    groups.setdefault(lab, []).append(idx)\n                candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n                if candidates:\n                    lab = random.choice(candidates)\n                    idx = random.choice(groups[lab])\n                    s[idx] = current_k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000891491}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; solution is a list of 9 positive ints; labels must be exactly {1,..,k} without gaps","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    move = random.random()\n    current_k = max(s)\n\n    if move < 0.5:\n        # move: assign a vertex to an existing feasible label or new label\n        tries = 0\n        while tries < 20:\n            i0 = random.randrange(9)  # 0-based index\n            v = i0 + 1\n            k = max(s)\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    s = canonicalize(s)\n                    return s, 'move'\n            tries += 1\n        # fallback: trivial relabel to new group\n        s[random.randrange(9)] = max(s)+1\n        s = canonicalize(s)\n        return s, 'move'\n    elif move < 0.75:\n        # merge two labels if merged set stays a clique\n        k = max(s)\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            # check feasibility of merged group\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            feasible = True\n            for i in range(len(merged)):\n                u = merged[i]\n                for j in range(i+1, len(merged)):\n                    v = merged[j]\n                    if v not in adj[u]:\n                        feasible = False\n                        break\n                if not feasible:\n                    break\n            if feasible:\n                s = [target if x == source else x for x in s]\n                s = canonicalize(s)\n                return s, 'merge'\n        # fallback to move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        k = max(s)\n        candidates = list(range(1, k+1)) + [k+1]\n        if s[i0] in candidates:\n            candidates.remove(s[i0])\n        random.shuffle(candidates)\n        for L in candidates:\n            if L == k+1 or can_join_group(v, L, s):\n                s[i0] = L\n                s = canonicalize(s)\n                return s, 'move'\n        s = canonicalize(s)\n        return s, 'move'\n    else:\n        # split: choose a label with size>=2 and move one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1  # convert to 0-based\n            s[idx] = max(s) + 1\n            s = canonicalize(s)\n            return s, 'split'\n        # fallback to move\n        i0 = random.randrange(9)\n        s[i0] = max(s) + 1\n        s = canonicalize(s)\n        return s, 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        k = max(s)\n        if move < 0.5:\n            # feasibility-aware move\n            i0 = random.randrange(9)\n            v = i0 + 1\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            done = False\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    done = True\n                    break\n            if not done:\n                # force new label\n                s[i0] = k + 1\n        elif move < 0.75:\n            # merge if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                feasible = True\n                for i in range(len(merged)):\n                    u = merged[i]\n                    for j in range(i+1, len(merged)):\n                        v = merged[j]\n                        if v not in adj[u]:\n                            feasible = False\n                            break\n                    if not feasible:\n                        break\n                if feasible:\n                    s = [target if x == source else x for x in s]\n        else:\n            # split a group of size>=2\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000970741}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; solution is a list of 9 positive ints; labels must be exactly {1,..,k} without gaps","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    move = random.random()\n    current_k = max(s)\n\n    if move < 0.5:\n        # move: assign a vertex to an existing feasible label or new label\n        tries = 0\n        while tries < 20:\n            i0 = random.randrange(9)  # 0-based index\n            v = i0 + 1\n            k = max(s)\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    s = canonicalize(s)\n                    return s, 'move'\n            tries += 1\n        # fallback: trivial relabel to new group\n        s[random.randrange(9)] = max(s)+1\n        s = canonicalize(s)\n        return s, 'move'\n    elif move < 0.75:\n        # merge two labels if merged set stays a clique\n        k = max(s)\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            # check feasibility of merged group\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            feasible = True\n            for i in range(len(merged)):\n                u = merged[i]\n                for j in range(i+1, len(merged)):\n                    v = merged[j]\n                    if v not in adj[u]:\n                        feasible = False\n                        break\n                if not feasible:\n                    break\n            if feasible:\n                s = [target if x == source else x for x in s]\n                s = canonicalize(s)\n                return s, 'merge'\n        # fallback to move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        k = max(s)\n        candidates = list(range(1, k+1)) + [k+1]\n        if s[i0] in candidates:\n            candidates.remove(s[i0])\n        random.shuffle(candidates)\n        for L in candidates:\n            if L == k+1 or can_join_group(v, L, s):\n                s[i0] = L\n                s = canonicalize(s)\n                return s, 'move'\n        s = canonicalize(s)\n        return s, 'move'\n    else:\n        # split: choose a label with size>=2 and move one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1  # convert to 0-based\n            s[idx] = max(s) + 1\n            s = canonicalize(s)\n            return s, 'split'\n        # fallback to move\n        i0 = random.randrange(9)\n        s[i0] = max(s) + 1\n        s = canonicalize(s)\n        return s, 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        k = max(s)\n        if move < 0.5:\n            # feasibility-aware move\n            i0 = random.randrange(9)\n            v = i0 + 1\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            done = False\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    done = True\n                    break\n            if not done:\n                # force new label\n                s[i0] = k + 1\n        elif move < 0.75:\n            # merge if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                feasible = True\n                for i in range(len(merged)):\n                    u = merged[i]\n                    for j in range(i+1, len(merged)):\n                        v = merged[j]\n                        if v not in adj[u]:\n                            feasible = False\n                            break\n                    if not feasible:\n                        break\n                if feasible:\n                    s = [target if x == source else x for x in s]\n        else:\n            # split a group of size>=2\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001239914}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; solution is a list of 9 positive ints; labels must be exactly {1,..,k} without gaps","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    move = random.random()\n    current_k = max(s)\n\n    if move < 0.5:\n        # move: assign a vertex to an existing feasible label or new label\n        tries = 0\n        while tries < 20:\n            i0 = random.randrange(9)  # 0-based index\n            v = i0 + 1\n            k = max(s)\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    s = canonicalize(s)\n                    return s, 'move'\n            tries += 1\n        # fallback: trivial relabel to new group\n        s[random.randrange(9)] = max(s)+1\n        s = canonicalize(s)\n        return s, 'move'\n    elif move < 0.75:\n        # merge two labels if merged set stays a clique\n        k = max(s)\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            # check feasibility of merged group\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            feasible = True\n            for i in range(len(merged)):\n                u = merged[i]\n                for j in range(i+1, len(merged)):\n                    v = merged[j]\n                    if v not in adj[u]:\n                        feasible = False\n                        break\n                if not feasible:\n                    break\n            if feasible:\n                s = [target if x == source else x for x in s]\n                s = canonicalize(s)\n                return s, 'merge'\n        # fallback to move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        k = max(s)\n        candidates = list(range(1, k+1)) + [k+1]\n        if s[i0] in candidates:\n            candidates.remove(s[i0])\n        random.shuffle(candidates)\n        for L in candidates:\n            if L == k+1 or can_join_group(v, L, s):\n                s[i0] = L\n                s = canonicalize(s)\n                return s, 'move'\n        s = canonicalize(s)\n        return s, 'move'\n    else:\n        # split: choose a label with size>=2 and move one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1  # convert to 0-based\n            s[idx] = max(s) + 1\n            s = canonicalize(s)\n            return s, 'split'\n        # fallback to move\n        i0 = random.randrange(9)\n        s[i0] = max(s) + 1\n        s = canonicalize(s)\n        return s, 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        k = max(s)\n        if move < 0.5:\n            # feasibility-aware move\n            i0 = random.randrange(9)\n            v = i0 + 1\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            done = False\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    done = True\n                    break\n            if not done:\n                # force new label\n                s[i0] = k + 1\n        elif move < 0.75:\n            # merge if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                feasible = True\n                for i in range(len(merged)):\n                    u = merged[i]\n                    for j in range(i+1, len(merged)):\n                        v = merged[j]\n                        if v not in adj[u]:\n                            feasible = False\n                            break\n                    if not feasible:\n                        break\n                if feasible:\n                    s = [target if x == source else x for x in s]\n        else:\n            # split a group of size>=2\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001312885}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; labels in {1..k}; exactly 9 ints; groups form cliques; labels canonicalized","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split', 'swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    def is_clique(nodes):\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    move_r = random.random()\n    k = max(s)\n\n    if move_r < 0.45:\n        # move: assign a vertex to an existing feasible label or new label\n        i0 = random.randrange(9)  # 0-based\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        # optionally create a new label only if no feasible join exists\n        s[i0] = k + 1\n        return canonicalize(s), 'move'\n\n    if move_r < 0.70:\n        # merge two labels if merged set stays a clique\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            if is_clique(merged):\n                s = [target if x == source else x for x in s]\n                return canonicalize(s), 'merge'\n        # fallback small move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        return canonicalize(s), 'move'\n\n    if move_r < 0.85:\n        # split: take a group of size>=2 and peel one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1\n            s[idx] = k + 1\n            return canonicalize(s), 'split'\n        return canonicalize(s), 'split'\n\n    # swap: try swapping labels of two vertices to keep feasibility\n    i, j = random.sample(range(9), 2)\n    if s[i] != s[j]:\n        si, sj = s[i], s[j]\n        v_i, v_j = i+1, j+1\n        s[i], s[j] = sj, si\n        # verify both affected groups remain cliques\n        g = groups_of(s)\n        ok = True\n        for lab in set([si, sj]):\n            if not is_clique(g.get(lab, [])):\n                ok = False\n                break\n        if ok:\n            return canonicalize(s), 'swap'\n        # revert\n        s[i], s[j] = si, sj\n    # final fallback: no-op canonicalize\n    return canonicalize(s), 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    steps = random.randint(6, 12)\n    for _ in range(steps):\n        k = max(s)\n        op = random.random()\n        if op < 0.5:\n            # shuffle label of a random vertex, try feasible join else new\n            i0 = random.randrange(9)\n            v = i0 + 1\n            labels = list(range(1, k+1))\n            random.shuffle(labels)\n            moved = False\n            for L in labels:\n                if L == s[i0]:\n                    continue\n                # tentative move\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    moved = True\n                    break\n                s[i0] = old\n            if not moved:\n                s[i0] = k + 1\n        elif op < 0.75:\n            # merge two labels if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                if group_is_clique(merged):\n                    s = [target if x == source else x for x in s]\n        else:\n            # split: move one vertex of a multi-vertex group to a fresh label\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0009903311}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; labels in {1..k}; exactly 9 ints; groups form cliques; labels canonicalized","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split', 'swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    def is_clique(nodes):\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    move_r = random.random()\n    k = max(s)\n\n    if move_r < 0.45:\n        # move: assign a vertex to an existing feasible label or new label\n        i0 = random.randrange(9)  # 0-based\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        # optionally create a new label only if no feasible join exists\n        s[i0] = k + 1\n        return canonicalize(s), 'move'\n\n    if move_r < 0.70:\n        # merge two labels if merged set stays a clique\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            if is_clique(merged):\n                s = [target if x == source else x for x in s]\n                return canonicalize(s), 'merge'\n        # fallback small move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        return canonicalize(s), 'move'\n\n    if move_r < 0.85:\n        # split: take a group of size>=2 and peel one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1\n            s[idx] = k + 1\n            return canonicalize(s), 'split'\n        return canonicalize(s), 'split'\n\n    # swap: try swapping labels of two vertices to keep feasibility\n    i, j = random.sample(range(9), 2)\n    if s[i] != s[j]:\n        si, sj = s[i], s[j]\n        v_i, v_j = i+1, j+1\n        s[i], s[j] = sj, si\n        # verify both affected groups remain cliques\n        g = groups_of(s)\n        ok = True\n        for lab in set([si, sj]):\n            if not is_clique(g.get(lab, [])):\n                ok = False\n                break\n        if ok:\n            return canonicalize(s), 'swap'\n        # revert\n        s[i], s[j] = si, sj\n    # final fallback: no-op canonicalize\n    return canonicalize(s), 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    steps = random.randint(6, 12)\n    for _ in range(steps):\n        k = max(s)\n        op = random.random()\n        if op < 0.5:\n            # shuffle label of a random vertex, try feasible join else new\n            i0 = random.randrange(9)\n            v = i0 + 1\n            labels = list(range(1, k+1))\n            random.shuffle(labels)\n            moved = False\n            for L in labels:\n                if L == s[i0]:\n                    continue\n                # tentative move\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    moved = True\n                    break\n                s[i0] = old\n            if not moved:\n                s[i0] = k + 1\n        elif op < 0.75:\n            # merge two labels if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                if group_is_clique(merged):\n                    s = [target if x == source else x for x in s]\n        else:\n            # split: move one vertex of a multi-vertex group to a fresh label\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001246694}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; labels in {1..k}; exactly 9 ints; groups form cliques; labels canonicalized","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","Vecindad":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split', 'swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    def is_clique(nodes):\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    move_r = random.random()\n    k = max(s)\n\n    if move_r < 0.45:\n        # move: assign a vertex to an existing feasible label or new label\n        i0 = random.randrange(9)  # 0-based\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        # optionally create a new label only if no feasible join exists\n        s[i0] = k + 1\n        return canonicalize(s), 'move'\n\n    if move_r < 0.70:\n        # merge two labels if merged set stays a clique\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            if is_clique(merged):\n                s = [target if x == source else x for x in s]\n                return canonicalize(s), 'merge'\n        # fallback small move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        return canonicalize(s), 'move'\n\n    if move_r < 0.85:\n        # split: take a group of size>=2 and peel one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1\n            s[idx] = k + 1\n            return canonicalize(s), 'split'\n        return canonicalize(s), 'split'\n\n    # swap: try swapping labels of two vertices to keep feasibility\n    i, j = random.sample(range(9), 2)\n    if s[i] != s[j]:\n        si, sj = s[i], s[j]\n        v_i, v_j = i+1, j+1\n        s[i], s[j] = sj, si\n        # verify both affected groups remain cliques\n        g = groups_of(s)\n        ok = True\n        for lab in set([si, sj]):\n            if not is_clique(g.get(lab, [])):\n                ok = False\n                break\n        if ok:\n            return canonicalize(s), 'swap'\n        # revert\n        s[i], s[j] = si, sj\n    # final fallback: no-op canonicalize\n    return canonicalize(s), 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    steps = random.randint(6, 12)\n    for _ in range(steps):\n        k = max(s)\n        op = random.random()\n        if op < 0.5:\n            # shuffle label of a random vertex, try feasible join else new\n            i0 = random.randrange(9)\n            v = i0 + 1\n            labels = list(range(1, k+1))\n            random.shuffle(labels)\n            moved = False\n            for L in labels:\n                if L == s[i0]:\n                    continue\n                # tentative move\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    moved = True\n                    break\n                s[i0] = old\n            if not moved:\n                s[i0] = k + 1\n        elif op < 0.75:\n            # merge two labels if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                if group_is_clique(merged):\n                    s = [target if x == source else x for x in s]\n        else:\n            # split: move one vertex of a multi-vertex group to a fresh label\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0014214059}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k. s[i] is label for vertex i in {1..9}. Labels are positive ints, contiguous 1..k, groups non-empty, each label's vertex set must induce a clique.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PEN_TYPE = 1e7\n    PEN_LABELS = 1e6\n    PEN_CLIQUE = 1e5\n    # Type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PEN_TYPE)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PEN_TYPE)\n    k = max(solution)\n    # Consecutive label check\n    if set(solution) != set(range(1, k+1)):\n        return float(PEN_LABELS)\n    # Build adjacency (problem-embedded)\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PEN_CLIQUE)\n    # Feasible; objective is to minimize k\n    return float(k)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Fallback and copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,1,2,3,2,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data and helpers\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    def can_join_group(vertex, target_label, labels):\n        g = groups_of(labels)\n        members = g.get(target_label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    move_r = random.random()\n    k = max(s)\n\n    if move_r < 0.40:\n        # MOVE: reassign a vertex to a feasible existing group, else new label\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    return canonicalize(s), 'move'\n                s[i0] = old\n        s[i0] = k + 1\n        return canonicalize(s), 'move'\n\n    if move_r < 0.70:\n        # MERGE: try merging two labels if union remains a clique\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            if group_is_clique(merged):\n                s = [target if x == source else x for x in s]\n                return canonicalize(s), 'merge'\n        # fallback small move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    return canonicalize(s), 'move'\n                s[i0] = old\n        return canonicalize(s), 'move'\n\n    if move_r < 0.85:\n        # SPLIT: peel one vertex from a multi-vertex group to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1\n            s[idx] = k + 1\n            return canonicalize(s), 'split'\n        return canonicalize(s), 'split'\n\n    # SWAP: swap labels of two vertices if both labels remain cliques\n    i, j = random.sample(range(9), 2)\n    if s[i] != s[j]:\n        si, sj = s[i], s[j]\n        s[i], s[j] = sj, si\n        g = groups_of(s)\n        ok = True\n        for lab in {si, sj}:\n            if not group_is_clique(g.get(lab, [])):\n                ok = False\n                break\n        if ok:\n            return canonicalize(s), 'swap'\n        s[i], s[j] = si, sj\n    return canonicalize(s), 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback and copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,1,2,3,2,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data and helpers\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    # Perform a controlled kick: several random splits\/merges\/moves\n    steps = random.randint(6, 12)\n    for _ in range(steps):\n        k = max(s)\n        r = random.random()\n        if r < 0.45:\n            # Random reassignment with feasibility check; else create new label\n            i0 = random.randrange(9)\n            v = i0 + 1\n            labs = list(range(1, k+1))\n            random.shuffle(labs)\n            moved = False\n            old = s[i0]\n            for L in labs:\n                if L == old:\n                    continue\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    moved = True\n                    break\n                s[i0] = old\n            if not moved:\n                s[i0] = k + 1\n        elif r < 0.75:\n            # Try a feasible merge\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                if group_is_clique(merged):\n                    s = [target if x == source else x for x in s]\n        else:\n            # Split: move a random member of a multi-vertex group to new label\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001056881}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k. s[i] is label for vertex i in {1..9}. Labels are positive ints, contiguous 1..k, groups non-empty, each label's vertex set must induce a clique.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PEN_TYPE = 1e7\n    PEN_LABELS = 1e6\n    PEN_CLIQUE = 1e5\n    # Type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PEN_TYPE)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PEN_TYPE)\n    k = max(solution)\n    # Consecutive label check\n    if set(solution) != set(range(1, k+1)):\n        return float(PEN_LABELS)\n    # Build adjacency (problem-embedded)\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PEN_CLIQUE)\n    # Feasible; objective is to minimize k\n    return float(k)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Fallback and copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,1,2,3,2,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data and helpers\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    def can_join_group(vertex, target_label, labels):\n        g = groups_of(labels)\n        members = g.get(target_label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    move_r = random.random()\n    k = max(s)\n\n    if move_r < 0.40:\n        # MOVE: reassign a vertex to a feasible existing group, else new label\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    return canonicalize(s), 'move'\n                s[i0] = old\n        s[i0] = k + 1\n        return canonicalize(s), 'move'\n\n    if move_r < 0.70:\n        # MERGE: try merging two labels if union remains a clique\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            if group_is_clique(merged):\n                s = [target if x == source else x for x in s]\n                return canonicalize(s), 'merge'\n        # fallback small move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    return canonicalize(s), 'move'\n                s[i0] = old\n        return canonicalize(s), 'move'\n\n    if move_r < 0.85:\n        # SPLIT: peel one vertex from a multi-vertex group to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1\n            s[idx] = k + 1\n            return canonicalize(s), 'split'\n        return canonicalize(s), 'split'\n\n    # SWAP: swap labels of two vertices if both labels remain cliques\n    i, j = random.sample(range(9), 2)\n    if s[i] != s[j]:\n        si, sj = s[i], s[j]\n        s[i], s[j] = sj, si\n        g = groups_of(s)\n        ok = True\n        for lab in {si, sj}:\n            if not group_is_clique(g.get(lab, [])):\n                ok = False\n                break\n        if ok:\n            return canonicalize(s), 'swap'\n        s[i], s[j] = si, sj\n    return canonicalize(s), 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback and copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,1,2,3,2,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data and helpers\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    # Perform a controlled kick: several random splits\/merges\/moves\n    steps = random.randint(6, 12)\n    for _ in range(steps):\n        k = max(s)\n        r = random.random()\n        if r < 0.45:\n            # Random reassignment with feasibility check; else create new label\n            i0 = random.randrange(9)\n            v = i0 + 1\n            labs = list(range(1, k+1))\n            random.shuffle(labs)\n            moved = False\n            old = s[i0]\n            for L in labs:\n                if L == old:\n                    continue\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    moved = True\n                    break\n                s[i0] = old\n            if not moved:\n                s[i0] = k + 1\n        elif r < 0.75:\n            # Try a feasible merge\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                if group_is_clique(merged):\n                    s = [target if x == source else x for x in s]\n        else:\n            # Split: move a random member of a multi-vertex group to new label\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001354865}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k. s[i] is label for vertex i in {1..9}. Labels are positive ints, contiguous 1..k, groups non-empty, each label's vertex set must induce a clique.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PEN_TYPE = 1e7\n    PEN_LABELS = 1e6\n    PEN_CLIQUE = 1e5\n    # Type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PEN_TYPE)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PEN_TYPE)\n    k = max(solution)\n    # Consecutive label check\n    if set(solution) != set(range(1, k+1)):\n        return float(PEN_LABELS)\n    # Build adjacency (problem-embedded)\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PEN_CLIQUE)\n    # Feasible; objective is to minimize k\n    return float(k)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Fallback and copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,1,2,3,2,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data and helpers\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    def can_join_group(vertex, target_label, labels):\n        g = groups_of(labels)\n        members = g.get(target_label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    move_r = random.random()\n    k = max(s)\n\n    if move_r < 0.40:\n        # MOVE: reassign a vertex to a feasible existing group, else new label\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    return canonicalize(s), 'move'\n                s[i0] = old\n        s[i0] = k + 1\n        return canonicalize(s), 'move'\n\n    if move_r < 0.70:\n        # MERGE: try merging two labels if union remains a clique\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            if group_is_clique(merged):\n                s = [target if x == source else x for x in s]\n                return canonicalize(s), 'merge'\n        # fallback small move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    return canonicalize(s), 'move'\n                s[i0] = old\n        return canonicalize(s), 'move'\n\n    if move_r < 0.85:\n        # SPLIT: peel one vertex from a multi-vertex group to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1\n            s[idx] = k + 1\n            return canonicalize(s), 'split'\n        return canonicalize(s), 'split'\n\n    # SWAP: swap labels of two vertices if both labels remain cliques\n    i, j = random.sample(range(9), 2)\n    if s[i] != s[j]:\n        si, sj = s[i], s[j]\n        s[i], s[j] = sj, si\n        g = groups_of(s)\n        ok = True\n        for lab in {si, sj}:\n            if not group_is_clique(g.get(lab, [])):\n                ok = False\n                break\n        if ok:\n            return canonicalize(s), 'swap'\n        s[i], s[j] = si, sj\n    return canonicalize(s), 'move'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback and copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,1,2,3,2,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data and helpers\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    # Perform a controlled kick: several random splits\/merges\/moves\n    steps = random.randint(6, 12)\n    for _ in range(steps):\n        k = max(s)\n        r = random.random()\n        if r < 0.45:\n            # Random reassignment with feasibility check; else create new label\n            i0 = random.randrange(9)\n            v = i0 + 1\n            labs = list(range(1, k+1))\n            random.shuffle(labs)\n            moved = False\n            old = s[i0]\n            for L in labs:\n                if L == old:\n                    continue\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    moved = True\n                    break\n                s[i0] = old\n            if not moved:\n                s[i0] = k + 1\n        elif r < 0.75:\n            # Try a feasible merge\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                if group_is_clique(merged):\n                    s = [target if x == source else x for x in s]\n        else:\n            # Split: move a random member of a multi-vertex group to new label\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001502977}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        if u==v or not (1 <= u <= n and 1 <= v <= n):\n            return 10**12\n        adj[u].add(v)\n        adj[v].add(u)\n    # Feasibility check: if same room then edge must exist in G\n    violations = 0\n    for i in range(1, n+1):\n        if solution[i-1] <= 0:\n            return 10**12\n        for j in range(i+1, n+1):\n            if solution[i-1] == solution[j-1]:\n                if j not in adj[i]:\n                    violations += 1\n    if violations > 0:\n        return 10**10 + violations\n    # Objective: number of distinct rooms used\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for G\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_room_feasible(assign: List[int], room_label: int) -> bool:\n        members = [i+1 for i,r in enumerate(assign) if r == room_label]\n        for i in range(len(members)):\n            for j in range(i+1, len(members)):\n                if members[j] not in adj[members[i]]:\n                    return False\n        return True\n\n    def feasible_rooms_for_vertex(assign: List[int], v_idx: int):\n        rooms = sorted(set(assign))\n        res = []\n        for rl in rooms:\n            # Test if v can be placed in room rl\n            ok = True\n            for u in range(1, n+1):\n                if u == v_idx:\n                    continue\n                if assign[u-1] == rl:\n                    if u not in adj[v_idx]:\n                        ok = False\n                        break\n            if ok:\n                res.append(rl)\n        return res\n\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    move_type = None\n    r = random.random()\n\n    if r < 0.5:\n        # Single-vertex reassignment prioritizing feasible rooms\n        v = random.randint(1, n)\n        current_room = x[v-1]\n        feas = feasible_rooms_for_vertex(x, v)\n        # Allow moving to an existing feasible room different from current, else maybe open a new room\n        candidates = [rl for rl in feas if rl != current_room]\n        if not candidates and random.random() < 0.3:\n            # open a new room label\n            new_label = max(rooms) + 1\n            x[v-1] = new_label\n            move_type = \"open_room\"\n        elif candidates:\n            x[v-1] = random.choice(candidates)\n            move_type = \"move_to_feasible_room\"\n        else:\n            # fallback: move to a random existing room (may be infeasible)\n            x[v-1] = random.choice(rooms)\n            move_type = \"move_random_room\"\n    elif r < 0.8:\n        # Merge attempt between two rooms (feasible-preferred)\n        if len(rooms) >= 2:\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            y = list(x)\n            for i in range(n):\n                if y[i] == source:\n                    y[i] = target\n            # check feasibility; if infeasible, accept with small probability\n            if is_room_feasible(y, target):\n                x = y\n                move_type = \"merge_rooms_feasible\"\n            else:\n                if random.random() < 0.2:\n                    x = y\n                    move_type = \"merge_rooms_forced\"\n                else:\n                    # try different pair by doing a random swap instead\n                    i,j = random.sample(range(n), 2)\n                    x[i], x[j] = x[j], x[i]\n                    move_type = \"swap_vertices_rooms\"\n        else:\n            # not enough rooms to merge; do a swap\n            i,j = random.sample(range(n), 2)\n            x[i], x[j] = x[j], x[i]\n            move_type = \"swap_vertices_rooms\"\n    else:\n        # Relabel compression + local tweak\n        mapping = {old:new for new, old in enumerate(sorted(rooms), start=1)}\n        x = [mapping[r] for r in x]\n        rooms = sorted(set(x))\n        v = random.randint(1, n)\n        feas = feasible_rooms_for_vertex(x, v)\n        if feas:\n            x[v-1] = random.choice(feas)\n            move_type = \"relabel_and_move_feasible\"\n        else:\n            # random reassignment among existing labels\n            x[v-1] = random.choice(rooms)\n            move_type = \"relabel_and_move_random\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple randomized moves including opening new rooms and reassignments\n    n = 9\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n\n    for _ in range(num_moves):\n        act = random.random()\n        if act < 0.4:\n            # Random vertex to random room (existing or new with small prob)\n            v = random.randint(1, n)\n            if random.random() < 0.2:\n                new_label = max(rooms) + 1\n                x[v-1] = new_label\n                rooms = sorted(set(x))\n            else:\n                x[v-1] = random.choice(rooms)\n        elif act < 0.7 and len(rooms) >= 2:\n            # Random merge (may be infeasible; evaluation penalizes)\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            for i in range(n):\n                if x[i] == source:\n                    x[i] = target\n            rooms = sorted(set(x))\n        else:\n            # Shuffle labels of a random subset to disrupt structure\n            subset_size = random.randint(2, 4)\n            idxs = random.sample(range(n), subset_size)\n            labels = [x[i] for i in idxs]\n            random.shuffle(labels)\n            for i, lbl in zip(idxs, labels):\n                x[i] = lbl\n            rooms = sorted(set(x))\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000998661}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        if u==v or not (1 <= u <= n and 1 <= v <= n):\n            return 10**12\n        adj[u].add(v)\n        adj[v].add(u)\n    # Feasibility check: if same room then edge must exist in G\n    violations = 0\n    for i in range(1, n+1):\n        if solution[i-1] <= 0:\n            return 10**12\n        for j in range(i+1, n+1):\n            if solution[i-1] == solution[j-1]:\n                if j not in adj[i]:\n                    violations += 1\n    if violations > 0:\n        return 10**10 + violations\n    # Objective: number of distinct rooms used\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for G\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_room_feasible(assign: List[int], room_label: int) -> bool:\n        members = [i+1 for i,r in enumerate(assign) if r == room_label]\n        for i in range(len(members)):\n            for j in range(i+1, len(members)):\n                if members[j] not in adj[members[i]]:\n                    return False\n        return True\n\n    def feasible_rooms_for_vertex(assign: List[int], v_idx: int):\n        rooms = sorted(set(assign))\n        res = []\n        for rl in rooms:\n            # Test if v can be placed in room rl\n            ok = True\n            for u in range(1, n+1):\n                if u == v_idx:\n                    continue\n                if assign[u-1] == rl:\n                    if u not in adj[v_idx]:\n                        ok = False\n                        break\n            if ok:\n                res.append(rl)\n        return res\n\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    move_type = None\n    r = random.random()\n\n    if r < 0.5:\n        # Single-vertex reassignment prioritizing feasible rooms\n        v = random.randint(1, n)\n        current_room = x[v-1]\n        feas = feasible_rooms_for_vertex(x, v)\n        # Allow moving to an existing feasible room different from current, else maybe open a new room\n        candidates = [rl for rl in feas if rl != current_room]\n        if not candidates and random.random() < 0.3:\n            # open a new room label\n            new_label = max(rooms) + 1\n            x[v-1] = new_label\n            move_type = \"open_room\"\n        elif candidates:\n            x[v-1] = random.choice(candidates)\n            move_type = \"move_to_feasible_room\"\n        else:\n            # fallback: move to a random existing room (may be infeasible)\n            x[v-1] = random.choice(rooms)\n            move_type = \"move_random_room\"\n    elif r < 0.8:\n        # Merge attempt between two rooms (feasible-preferred)\n        if len(rooms) >= 2:\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            y = list(x)\n            for i in range(n):\n                if y[i] == source:\n                    y[i] = target\n            # check feasibility; if infeasible, accept with small probability\n            if is_room_feasible(y, target):\n                x = y\n                move_type = \"merge_rooms_feasible\"\n            else:\n                if random.random() < 0.2:\n                    x = y\n                    move_type = \"merge_rooms_forced\"\n                else:\n                    # try different pair by doing a random swap instead\n                    i,j = random.sample(range(n), 2)\n                    x[i], x[j] = x[j], x[i]\n                    move_type = \"swap_vertices_rooms\"\n        else:\n            # not enough rooms to merge; do a swap\n            i,j = random.sample(range(n), 2)\n            x[i], x[j] = x[j], x[i]\n            move_type = \"swap_vertices_rooms\"\n    else:\n        # Relabel compression + local tweak\n        mapping = {old:new for new, old in enumerate(sorted(rooms), start=1)}\n        x = [mapping[r] for r in x]\n        rooms = sorted(set(x))\n        v = random.randint(1, n)\n        feas = feasible_rooms_for_vertex(x, v)\n        if feas:\n            x[v-1] = random.choice(feas)\n            move_type = \"relabel_and_move_feasible\"\n        else:\n            # random reassignment among existing labels\n            x[v-1] = random.choice(rooms)\n            move_type = \"relabel_and_move_random\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple randomized moves including opening new rooms and reassignments\n    n = 9\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n\n    for _ in range(num_moves):\n        act = random.random()\n        if act < 0.4:\n            # Random vertex to random room (existing or new with small prob)\n            v = random.randint(1, n)\n            if random.random() < 0.2:\n                new_label = max(rooms) + 1\n                x[v-1] = new_label\n                rooms = sorted(set(x))\n            else:\n                x[v-1] = random.choice(rooms)\n        elif act < 0.7 and len(rooms) >= 2:\n            # Random merge (may be infeasible; evaluation penalizes)\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            for i in range(n):\n                if x[i] == source:\n                    x[i] = target\n            rooms = sorted(set(x))\n        else:\n            # Shuffle labels of a random subset to disrupt structure\n            subset_size = random.randint(2, 4)\n            idxs = random.sample(range(n), subset_size)\n            labels = [x[i] for i in idxs]\n            random.shuffle(labels)\n            for i, lbl in zip(idxs, labels):\n                x[i] = lbl\n            rooms = sorted(set(x))\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0009626009}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        if u==v or not (1 <= u <= n and 1 <= v <= n):\n            return 10**12\n        adj[u].add(v)\n        adj[v].add(u)\n    # Feasibility check: if same room then edge must exist in G\n    violations = 0\n    for i in range(1, n+1):\n        if solution[i-1] <= 0:\n            return 10**12\n        for j in range(i+1, n+1):\n            if solution[i-1] == solution[j-1]:\n                if j not in adj[i]:\n                    violations += 1\n    if violations > 0:\n        return 10**10 + violations\n    # Objective: number of distinct rooms used\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for G\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_room_feasible(assign: List[int], room_label: int) -> bool:\n        members = [i+1 for i,r in enumerate(assign) if r == room_label]\n        for i in range(len(members)):\n            for j in range(i+1, len(members)):\n                if members[j] not in adj[members[i]]:\n                    return False\n        return True\n\n    def feasible_rooms_for_vertex(assign: List[int], v_idx: int):\n        rooms = sorted(set(assign))\n        res = []\n        for rl in rooms:\n            # Test if v can be placed in room rl\n            ok = True\n            for u in range(1, n+1):\n                if u == v_idx:\n                    continue\n                if assign[u-1] == rl:\n                    if u not in adj[v_idx]:\n                        ok = False\n                        break\n            if ok:\n                res.append(rl)\n        return res\n\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    move_type = None\n    r = random.random()\n\n    if r < 0.5:\n        # Single-vertex reassignment prioritizing feasible rooms\n        v = random.randint(1, n)\n        current_room = x[v-1]\n        feas = feasible_rooms_for_vertex(x, v)\n        # Allow moving to an existing feasible room different from current, else maybe open a new room\n        candidates = [rl for rl in feas if rl != current_room]\n        if not candidates and random.random() < 0.3:\n            # open a new room label\n            new_label = max(rooms) + 1\n            x[v-1] = new_label\n            move_type = \"open_room\"\n        elif candidates:\n            x[v-1] = random.choice(candidates)\n            move_type = \"move_to_feasible_room\"\n        else:\n            # fallback: move to a random existing room (may be infeasible)\n            x[v-1] = random.choice(rooms)\n            move_type = \"move_random_room\"\n    elif r < 0.8:\n        # Merge attempt between two rooms (feasible-preferred)\n        if len(rooms) >= 2:\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            y = list(x)\n            for i in range(n):\n                if y[i] == source:\n                    y[i] = target\n            # check feasibility; if infeasible, accept with small probability\n            if is_room_feasible(y, target):\n                x = y\n                move_type = \"merge_rooms_feasible\"\n            else:\n                if random.random() < 0.2:\n                    x = y\n                    move_type = \"merge_rooms_forced\"\n                else:\n                    # try different pair by doing a random swap instead\n                    i,j = random.sample(range(n), 2)\n                    x[i], x[j] = x[j], x[i]\n                    move_type = \"swap_vertices_rooms\"\n        else:\n            # not enough rooms to merge; do a swap\n            i,j = random.sample(range(n), 2)\n            x[i], x[j] = x[j], x[i]\n            move_type = \"swap_vertices_rooms\"\n    else:\n        # Relabel compression + local tweak\n        mapping = {old:new for new, old in enumerate(sorted(rooms), start=1)}\n        x = [mapping[r] for r in x]\n        rooms = sorted(set(x))\n        v = random.randint(1, n)\n        feas = feasible_rooms_for_vertex(x, v)\n        if feas:\n            x[v-1] = random.choice(feas)\n            move_type = \"relabel_and_move_feasible\"\n        else:\n            # random reassignment among existing labels\n            x[v-1] = random.choice(rooms)\n            move_type = \"relabel_and_move_random\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple randomized moves including opening new rooms and reassignments\n    n = 9\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n\n    for _ in range(num_moves):\n        act = random.random()\n        if act < 0.4:\n            # Random vertex to random room (existing or new with small prob)\n            v = random.randint(1, n)\n            if random.random() < 0.2:\n                new_label = max(rooms) + 1\n                x[v-1] = new_label\n                rooms = sorted(set(x))\n            else:\n                x[v-1] = random.choice(rooms)\n        elif act < 0.7 and len(rooms) >= 2:\n            # Random merge (may be infeasible; evaluation penalizes)\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            for i in range(n):\n                if x[i] == source:\n                    x[i] = target\n            rooms = sorted(set(x))\n        else:\n            # Shuffle labels of a random subset to disrupt structure\n            subset_size = random.randint(2, 4)\n            idxs = random.sample(range(n), subset_size)\n            labels = [x[i] for i in idxs]\n            random.shuffle(labels)\n            for i, lbl in zip(idxs, labels):\n                x[i] = lbl\n            rooms = sorted(set(x))\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0010800119}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Moderate penalty to allow SA\/ILS scaling while prioritizing feasibility\n        return rooms_used + 1000 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = max(rooms_list) + 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (choose best by largest compatible room)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge of compatible vertices\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            # test full merge b -> a\n            # apply tentative merge\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                # partial merge: move only vertices from b that are fully compatible with a\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong but feasibility-preserving perturbation using multiple safe operations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = max(rooms_list) + 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique; otherwise skip\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swaps between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                # Check both rooms remain cliques\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001310123}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Moderate penalty to allow SA\/ILS scaling while prioritizing feasibility\n        return rooms_used + 1000 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = max(rooms_list) + 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (choose best by largest compatible room)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge of compatible vertices\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            # test full merge b -> a\n            # apply tentative merge\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                # partial merge: move only vertices from b that are fully compatible with a\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong but feasibility-preserving perturbation using multiple safe operations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = max(rooms_list) + 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique; otherwise skip\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swaps between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                # Check both rooms remain cliques\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001552027}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Moderate penalty to allow SA\/ILS scaling while prioritizing feasibility\n        return rooms_used + 1000 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = max(rooms_list) + 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (choose best by largest compatible room)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge of compatible vertices\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            # test full merge b -> a\n            # apply tentative merge\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                # partial merge: move only vertices from b that are fully compatible with a\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong but feasibility-preserving perturbation using multiple safe operations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = max(rooms_list) + 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique; otherwise skip\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swaps between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                # Check both rooms remain cliques\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001578367}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Penalty dominates room count while allowing search dynamics\n        return rooms_used + 900 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = (max(rooms_list) + 1) if rooms_list else 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (prefer largest)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong feasibility-preserving perturbation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = (max(rooms_list) + 1) if rooms_list else 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swap between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00124338}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Penalty dominates room count while allowing search dynamics\n        return rooms_used + 900 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = (max(rooms_list) + 1) if rooms_list else 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (prefer largest)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong feasibility-preserving perturbation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = (max(rooms_list) + 1) if rooms_list else 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swap between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001511364}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Penalty dominates room count while allowing search dynamics\n        return rooms_used + 900 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = (max(rooms_list) + 1) if rooms_list else 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (prefer largest)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong feasibility-preserving perturbation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = (max(rooms_list) + 1) if rooms_list else 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swap between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001488674}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**12\n    # Graph edges (opponents graph G)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Group by room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    # Count conflicts: pairs in same room that are NOT edges of G\n    conflicts = 0\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if (min(u, v), max(u, v)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        return rooms_used + 1000 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, repair first\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        new_label = (max(rooms_list) + 1) if rooms_list else 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving moves\n    move_type = \"no_change\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (prefer largest)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap vertices across rooms if both rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 12 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge rooms if union is a clique, else partial merge\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong feasibility-preserving perturbation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a feasible room or open new\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = (max(rooms_list) + 1) if rooms_list else 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swap\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0012364089}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**12\n    # Graph edges (opponents graph G)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Group by room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    # Count conflicts: pairs in same room that are NOT edges of G\n    conflicts = 0\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if (min(u, v), max(u, v)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        return rooms_used + 1000 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, repair first\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        new_label = (max(rooms_list) + 1) if rooms_list else 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving moves\n    move_type = \"no_change\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (prefer largest)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap vertices across rooms if both rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 12 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge rooms if union is a clique, else partial merge\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong feasibility-preserving perturbation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a feasible room or open new\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = (max(rooms_list) + 1) if rooms_list else 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swap\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001551933}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**12\n    # Graph edges (opponents graph G)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Group by room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    # Count conflicts: pairs in same room that are NOT edges of G\n    conflicts = 0\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if (min(u, v), max(u, v)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        return rooms_used + 1000 * conflicts\n    return rooms_used\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, repair first\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        new_label = (max(rooms_list) + 1) if rooms_list else 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving moves\n    move_type = \"no_change\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (prefer largest)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap vertices across rooms if both rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 12 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge rooms if union is a clique, else partial merge\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong feasibility-preserving perturbation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a feasible room or open new\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = (max(rooms_list) + 1) if rooms_list else 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swap\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001549343}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is party label (int >=1) for vertex i. Labels need not be contiguous, but feasibility requires: for any i<j with solution[i-1]==solution[j-1], edge {i,j} must be in E.","Evaluacion":"import random\nimport itertools\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        # Feasible: objective is number of parties used\n        return len(parties)\n    # Infeasible: penalize heavily, but differentiate by number of violations and parties used\n    return 10**9 + 1000*len(parties) + violations\n","Vecindad":"import random\nimport itertools\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: single-vertex reassign or swap between two vertices\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    move_type = None\n    if random.random() < 0.6:\n        # Reassign one vertex to an existing or new label\n        i = random.randrange(n)\n        current_label = s[i]\n        labels = set(s)\n        # Candidate labels: existing labels excluding current, plus possibly a new label\n        candidates = list(labels - {current_label})\n        # Allow introducing a new label with small probability\n        if random.random() < 0.2:\n            candidates.append(max(labels) + 1)\n        if not candidates:\n            # Force some change: move to label 1 if not same\n            target = 1 if current_label != 1 else 2\n        else:\n            target = random.choice(candidates)\n        s[i] = target\n        move_type = \"reassign\"\n        # Optional clean-up: if a label becomes empty, relabel to keep labels compact is NOT required by representation\n    else:\n        # Swap labels of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        move_type = \"swap\"\n    return (s, move_type)\n","Perturbacion":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple reassignments and potential label merging\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    labels = sorted(set(s))\n    # With some probability, merge two labels\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        # Merge label b into a\n        s = [a if lab == b else lab for lab in s]\n    # Apply several random reassigns\n    m = random.randint(2, 4)\n    for _ in range(m):\n        i = random.randrange(n)\n        labels = set(s)\n        current_label = s[i]\n        candidates = list(labels - {current_label})\n        # Occasionally introduce a new label to escape local minima\n        if random.random() < 0.15:\n            candidates.append(max(labels) + 1)\n        if candidates:\n            s[i] = random.choice(candidates)\n    return s\n","Resultados":"Failed to run target heuristic: solution must be a list of ints.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0005016171}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is party label (int >=1) for vertex i. Labels need not be contiguous, but feasibility requires: for any i<j with solution[i-1]==solution[j-1], edge {i,j} must be in E.","Evaluacion":"import random\nimport itertools\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        # Feasible: objective is number of parties used\n        return len(parties)\n    # Infeasible: penalize heavily, but differentiate by number of violations and parties used\n    return 10**9 + 1000*len(parties) + violations\n","Vecindad":"import random\nimport itertools\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: single-vertex reassign or swap between two vertices\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    move_type = None\n    if random.random() < 0.6:\n        # Reassign one vertex to an existing or new label\n        i = random.randrange(n)\n        current_label = s[i]\n        labels = set(s)\n        # Candidate labels: existing labels excluding current, plus possibly a new label\n        candidates = list(labels - {current_label})\n        # Allow introducing a new label with small probability\n        if random.random() < 0.2:\n            candidates.append(max(labels) + 1)\n        if not candidates:\n            # Force some change: move to label 1 if not same\n            target = 1 if current_label != 1 else 2\n        else:\n            target = random.choice(candidates)\n        s[i] = target\n        move_type = \"reassign\"\n        # Optional clean-up: if a label becomes empty, relabel to keep labels compact is NOT required by representation\n    else:\n        # Swap labels of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        move_type = \"swap\"\n    return (s, move_type)\n","Perturbacion":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple reassignments and potential label merging\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    labels = sorted(set(s))\n    # With some probability, merge two labels\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        # Merge label b into a\n        s = [a if lab == b else lab for lab in s]\n    # Apply several random reassigns\n    m = random.randint(2, 4)\n    for _ in range(m):\n        i = random.randrange(n)\n        labels = set(s)\n        current_label = s[i]\n        candidates = list(labels - {current_label})\n        # Occasionally introduce a new label to escape local minima\n        if random.random() < 0.15:\n            candidates.append(max(labels) + 1)\n        if candidates:\n            s[i] = random.choice(candidates)\n    return s\n","Resultados":"Failed to run target heuristic: solution must be a list of ints.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000540768}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is party label (int >=1) for vertex i. Labels need not be contiguous, but feasibility requires: for any i<j with solution[i-1]==solution[j-1], edge {i,j} must be in E.","Evaluacion":"import random\nimport itertools\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        # Feasible: objective is number of parties used\n        return len(parties)\n    # Infeasible: penalize heavily, but differentiate by number of violations and parties used\n    return 10**9 + 1000*len(parties) + violations\n","Vecindad":"import random\nimport itertools\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: single-vertex reassign or swap between two vertices\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    move_type = None\n    if random.random() < 0.6:\n        # Reassign one vertex to an existing or new label\n        i = random.randrange(n)\n        current_label = s[i]\n        labels = set(s)\n        # Candidate labels: existing labels excluding current, plus possibly a new label\n        candidates = list(labels - {current_label})\n        # Allow introducing a new label with small probability\n        if random.random() < 0.2:\n            candidates.append(max(labels) + 1)\n        if not candidates:\n            # Force some change: move to label 1 if not same\n            target = 1 if current_label != 1 else 2\n        else:\n            target = random.choice(candidates)\n        s[i] = target\n        move_type = \"reassign\"\n        # Optional clean-up: if a label becomes empty, relabel to keep labels compact is NOT required by representation\n    else:\n        # Swap labels of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        move_type = \"swap\"\n    return (s, move_type)\n","Perturbacion":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple reassignments and potential label merging\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    labels = sorted(set(s))\n    # With some probability, merge two labels\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        # Merge label b into a\n        s = [a if lab == b else lab for lab in s]\n    # Apply several random reassigns\n    m = random.randint(2, 4)\n    for _ in range(m):\n        i = random.randrange(n)\n        labels = set(s)\n        current_label = s[i]\n        candidates = list(labels - {current_label})\n        # Occasionally introduce a new label to escape local minima\n        if random.random() < 0.15:\n            candidates.append(max(labels) + 1)\n        if candidates:\n            s[i] = random.choice(candidates)\n    return s\n","Resultados":"Failed to run target heuristic: solution must be a list of ints.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000526568}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9; solution[i-1] is party label (positive int) for vertex i. Labels need not be contiguous; normalization maps labels to 1..m in first-occurrence order after each move.","Evaluacion":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    # Type and size checks\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    return 10**9 + 1000*len(parties) + violations\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    # Graph data\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"reassign\"\n\n    if r < 0.6:\n        # Move one vertex to another existing label if target remains clique; or to new singleton label\n        i = random.randrange(n)  # 0-based index of vertex\n        v = i+1\n        cur = s[i]\n        candidates = [lab for lab in labels if lab != cur]\n        random.shuffle(candidates)\n        moved = False\n        for tgt in candidates:\n            # Check target clique condition with v added\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                moved = True\n                move_type = \"vertex->party\"\n                break\n        if not moved:\n            # New singleton label (always feasible)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"vertex->new\"\n    elif r < 0.85:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # Fallback to safe singleton move\n                i = random.randrange(n)\n                new_lab = max(labels) + 1\n                s[i] = new_lab\n                move_type = \"fallback-new\"\n        else:\n            i = random.randrange(n)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"fallback-new\"\n    else:\n        # Exchange two vertices between two labels if both parties remain cliques\n        i,j = random.sample(range(n), 2)\n        if s[i] != s[j]:\n            li, lj = s[i], s[j]\n            vi, vj = i+1, j+1\n            memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n            memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n            if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                s[i], s[j] = s[j], s[i]\n                move_type = \"exchange\"\n            else:\n                # Try simple reassignment of one endpoint to maintain clique\n                moved = False\n                for tgt in [lj, li]:\n                    # try move vi->lj or vj->li\n                    if tgt == lj:\n                        if all(is_edge(vi,u) for u in memb_j):\n                            s[i] = lj\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                    else:\n                        if all(is_edge(vj,u) for u in memb_i):\n                            s[j] = li\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                if not moved:\n                    # No-op fallback to keep signature contract: force a benign singleton move\n                    k = random.choice([i,j])\n                    new_lab = max(labels) + 1\n                    s[k] = new_lab\n                    move_type = \"fallback-new\"\n        else:\n            # Same label: move one to singleton to diversify\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"singleton-diversify\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Feasible stronger shake: sequence of safe operations with normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.4:\n            # Random reassign to compatible party or new singleton\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            candidates = [lab for lab in labels if lab != cur]\n            random.shuffle(candidates)\n            moved = False\n            for tgt in candidates:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved:\n                s[i] = max(labels) + 1\n        elif op < 0.7:\n            # Attempt merge of two labels when union is a clique\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # Exchange between two labels if feasible\n            i,j = random.sample(range(n), 2)\n            if s[i] != s[j]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                else:\n                    # As fallback, move one to singleton to keep feasibility\n                    k = random.choice([i,j])\n                    s[k] = max(labels) + 1 if (labels:=list(members_by_label(s).keys())) else 1\n        s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0011707071}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9; solution[i-1] is party label (positive int) for vertex i. Labels need not be contiguous; normalization maps labels to 1..m in first-occurrence order after each move.","Evaluacion":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    # Type and size checks\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    return 10**9 + 1000*len(parties) + violations\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    # Graph data\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"reassign\"\n\n    if r < 0.6:\n        # Move one vertex to another existing label if target remains clique; or to new singleton label\n        i = random.randrange(n)  # 0-based index of vertex\n        v = i+1\n        cur = s[i]\n        candidates = [lab for lab in labels if lab != cur]\n        random.shuffle(candidates)\n        moved = False\n        for tgt in candidates:\n            # Check target clique condition with v added\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                moved = True\n                move_type = \"vertex->party\"\n                break\n        if not moved:\n            # New singleton label (always feasible)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"vertex->new\"\n    elif r < 0.85:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # Fallback to safe singleton move\n                i = random.randrange(n)\n                new_lab = max(labels) + 1\n                s[i] = new_lab\n                move_type = \"fallback-new\"\n        else:\n            i = random.randrange(n)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"fallback-new\"\n    else:\n        # Exchange two vertices between two labels if both parties remain cliques\n        i,j = random.sample(range(n), 2)\n        if s[i] != s[j]:\n            li, lj = s[i], s[j]\n            vi, vj = i+1, j+1\n            memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n            memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n            if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                s[i], s[j] = s[j], s[i]\n                move_type = \"exchange\"\n            else:\n                # Try simple reassignment of one endpoint to maintain clique\n                moved = False\n                for tgt in [lj, li]:\n                    # try move vi->lj or vj->li\n                    if tgt == lj:\n                        if all(is_edge(vi,u) for u in memb_j):\n                            s[i] = lj\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                    else:\n                        if all(is_edge(vj,u) for u in memb_i):\n                            s[j] = li\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                if not moved:\n                    # No-op fallback to keep signature contract: force a benign singleton move\n                    k = random.choice([i,j])\n                    new_lab = max(labels) + 1\n                    s[k] = new_lab\n                    move_type = \"fallback-new\"\n        else:\n            # Same label: move one to singleton to diversify\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"singleton-diversify\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Feasible stronger shake: sequence of safe operations with normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.4:\n            # Random reassign to compatible party or new singleton\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            candidates = [lab for lab in labels if lab != cur]\n            random.shuffle(candidates)\n            moved = False\n            for tgt in candidates:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved:\n                s[i] = max(labels) + 1\n        elif op < 0.7:\n            # Attempt merge of two labels when union is a clique\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # Exchange between two labels if feasible\n            i,j = random.sample(range(n), 2)\n            if s[i] != s[j]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                else:\n                    # As fallback, move one to singleton to keep feasibility\n                    k = random.choice([i,j])\n                    s[k] = max(labels) + 1 if (labels:=list(members_by_label(s).keys())) else 1\n        s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0016489821}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9; solution[i-1] is party label (positive int) for vertex i. Labels need not be contiguous; normalization maps labels to 1..m in first-occurrence order after each move.","Evaluacion":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    # Type and size checks\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    return 10**9 + 1000*len(parties) + violations\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    # Graph data\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"reassign\"\n\n    if r < 0.6:\n        # Move one vertex to another existing label if target remains clique; or to new singleton label\n        i = random.randrange(n)  # 0-based index of vertex\n        v = i+1\n        cur = s[i]\n        candidates = [lab for lab in labels if lab != cur]\n        random.shuffle(candidates)\n        moved = False\n        for tgt in candidates:\n            # Check target clique condition with v added\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                moved = True\n                move_type = \"vertex->party\"\n                break\n        if not moved:\n            # New singleton label (always feasible)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"vertex->new\"\n    elif r < 0.85:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # Fallback to safe singleton move\n                i = random.randrange(n)\n                new_lab = max(labels) + 1\n                s[i] = new_lab\n                move_type = \"fallback-new\"\n        else:\n            i = random.randrange(n)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"fallback-new\"\n    else:\n        # Exchange two vertices between two labels if both parties remain cliques\n        i,j = random.sample(range(n), 2)\n        if s[i] != s[j]:\n            li, lj = s[i], s[j]\n            vi, vj = i+1, j+1\n            memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n            memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n            if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                s[i], s[j] = s[j], s[i]\n                move_type = \"exchange\"\n            else:\n                # Try simple reassignment of one endpoint to maintain clique\n                moved = False\n                for tgt in [lj, li]:\n                    # try move vi->lj or vj->li\n                    if tgt == lj:\n                        if all(is_edge(vi,u) for u in memb_j):\n                            s[i] = lj\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                    else:\n                        if all(is_edge(vj,u) for u in memb_i):\n                            s[j] = li\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                if not moved:\n                    # No-op fallback to keep signature contract: force a benign singleton move\n                    k = random.choice([i,j])\n                    new_lab = max(labels) + 1\n                    s[k] = new_lab\n                    move_type = \"fallback-new\"\n        else:\n            # Same label: move one to singleton to diversify\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"singleton-diversify\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Feasible stronger shake: sequence of safe operations with normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.4:\n            # Random reassign to compatible party or new singleton\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            candidates = [lab for lab in labels if lab != cur]\n            random.shuffle(candidates)\n            moved = False\n            for tgt in candidates:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved:\n                s[i] = max(labels) + 1\n        elif op < 0.7:\n            # Attempt merge of two labels when union is a clique\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # Exchange between two labels if feasible\n            i,j = random.sample(range(n), 2)\n            if s[i] != s[j]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                else:\n                    # As fallback, move one to singleton to keep feasibility\n                    k = random.choice([i,j])\n                    s[k] = max(labels) + 1 if (labels:=list(members_by_label(s).keys())) else 1\n        s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0016010531}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is positive int party label for vertex i. Labels may be non-contiguous; internal operations normalize to 1..m in first-occurrence order.","Evaluacion":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 10**6\n    if len(solution) != n:\n        return PENALTY_BASE + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    # Penalize infeasible strongly with slight dependence on k and number of violations\n    return PENALTY_BASE + 1000*len(parties) + violations\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization and richer operators\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"noop\"\n\n    if r < 0.45:\n        # Greedy reassignment: try to place a vertex into the smallest compatible party, else keep label\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        candidates = []\n        for lab in labels:\n            if lab == cur:\n                continue\n            tgt_members = [u for u,lab2 in enumerate(s, start=1) if lab2 == lab]\n            if all(is_edge(v,u) for u in tgt_members):\n                candidates.append((len(tgt_members), lab))\n        if candidates:\n            candidates.sort()\n            s[i] = candidates[0][1]\n            move_type = \"vertex->best_party\"\n        else:\n            # attempt swap-based improvement with another vertex\n            j = random.randrange(n)\n            if j != i and s[j] != s[i]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                    move_type = \"exchange\"\n                else:\n                    move_type = \"noop\"\n            else:\n                move_type = \"noop\"\n    elif r < 0.7:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # split a non-clique label if exists\n                non_clique_labels = []\n                for L, mem in members_by_label(s).items():\n                    if not party_is_clique(mem):\n                        non_clique_labels.append((L, mem))\n                if non_clique_labels:\n                    L, mem = random.choice(non_clique_labels)\n                    # move a violating vertex to a new singleton\n                    picked = None\n                    for u in mem:\n                        if any((min(u,v), max(u,v)) not in E for v in mem if v!=u):\n                            picked = u\n                            break\n                    if picked is None:\n                        picked = random.choice(mem)\n                    new_lab = max(labels) + 1\n                    s[picked-1] = new_lab\n                    move_type = \"split_violation\"\n                else:\n                    move_type = \"noop\"\n        else:\n            move_type = \"noop\"\n    else:\n        # Reassign to compatible existing party if any; avoid creating new labels\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        cand = [lab for lab in labels if lab != cur]\n        random.shuffle(cand)\n        moved = False\n        for tgt in cand:\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                move_type = \"vertex->party\"\n                moved = True\n                break\n        if not moved:\n            move_type = \"noop\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasible shake: multiple clique-preserving moves plus merges\/splits\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.35:\n            # random reassignment to any compatible party\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            cands = [lab for lab in labels if lab != cur]\n            random.shuffle(cands)\n            moved = False\n            for tgt in cands:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved and len(labels) >= 2:\n                # try exchange\n                j = random.randrange(n)\n                if j != i and s[j] != s[i]:\n                    li, lj = s[i], s[j]\n                    vi, vj = i+1, j+1\n                    memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                    memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                    if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                        s[i], s[j] = s[j], s[i]\n        elif op < 0.65:\n            # merge if possible\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # split a non-clique party or diversify by moving a member to new label\n            labels_now = list(members_by_label(s).keys())\n            target_label = None\n            for L, mem in members_by_label(s).items():\n                if len(mem) >= 2 and not party_is_clique(mem):\n                    target_label = L\n                    break\n            if target_label is None and labels_now:\n                target_label = random.choice(labels_now)\n            if target_label is not None:\n                mem = [u for u,lab in enumerate(s, start=1) if lab == target_label]\n                pick = random.choice(mem)\n                new_lab = max(labels_now) + 1 if labels_now else 1\n                s[pick-1] = new_lab\n        s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0012034159}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is positive int party label for vertex i. Labels may be non-contiguous; internal operations normalize to 1..m in first-occurrence order.","Evaluacion":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 10**6\n    if len(solution) != n:\n        return PENALTY_BASE + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    # Penalize infeasible strongly with slight dependence on k and number of violations\n    return PENALTY_BASE + 1000*len(parties) + violations\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization and richer operators\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"noop\"\n\n    if r < 0.45:\n        # Greedy reassignment: try to place a vertex into the smallest compatible party, else keep label\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        candidates = []\n        for lab in labels:\n            if lab == cur:\n                continue\n            tgt_members = [u for u,lab2 in enumerate(s, start=1) if lab2 == lab]\n            if all(is_edge(v,u) for u in tgt_members):\n                candidates.append((len(tgt_members), lab))\n        if candidates:\n            candidates.sort()\n            s[i] = candidates[0][1]\n            move_type = \"vertex->best_party\"\n        else:\n            # attempt swap-based improvement with another vertex\n            j = random.randrange(n)\n            if j != i and s[j] != s[i]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                    move_type = \"exchange\"\n                else:\n                    move_type = \"noop\"\n            else:\n                move_type = \"noop\"\n    elif r < 0.7:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # split a non-clique label if exists\n                non_clique_labels = []\n                for L, mem in members_by_label(s).items():\n                    if not party_is_clique(mem):\n                        non_clique_labels.append((L, mem))\n                if non_clique_labels:\n                    L, mem = random.choice(non_clique_labels)\n                    # move a violating vertex to a new singleton\n                    picked = None\n                    for u in mem:\n                        if any((min(u,v), max(u,v)) not in E for v in mem if v!=u):\n                            picked = u\n                            break\n                    if picked is None:\n                        picked = random.choice(mem)\n                    new_lab = max(labels) + 1\n                    s[picked-1] = new_lab\n                    move_type = \"split_violation\"\n                else:\n                    move_type = \"noop\"\n        else:\n            move_type = \"noop\"\n    else:\n        # Reassign to compatible existing party if any; avoid creating new labels\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        cand = [lab for lab in labels if lab != cur]\n        random.shuffle(cand)\n        moved = False\n        for tgt in cand:\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                move_type = \"vertex->party\"\n                moved = True\n                break\n        if not moved:\n            move_type = \"noop\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasible shake: multiple clique-preserving moves plus merges\/splits\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.35:\n            # random reassignment to any compatible party\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            cands = [lab for lab in labels if lab != cur]\n            random.shuffle(cands)\n            moved = False\n            for tgt in cands:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved and len(labels) >= 2:\n                # try exchange\n                j = random.randrange(n)\n                if j != i and s[j] != s[i]:\n                    li, lj = s[i], s[j]\n                    vi, vj = i+1, j+1\n                    memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                    memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                    if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                        s[i], s[j] = s[j], s[i]\n        elif op < 0.65:\n            # merge if possible\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # split a non-clique party or diversify by moving a member to new label\n            labels_now = list(members_by_label(s).keys())\n            target_label = None\n            for L, mem in members_by_label(s).items():\n                if len(mem) >= 2 and not party_is_clique(mem):\n                    target_label = L\n                    break\n            if target_label is None and labels_now:\n                target_label = random.choice(labels_now)\n            if target_label is not None:\n                mem = [u for u,lab in enumerate(s, start=1) if lab == target_label]\n                pick = random.choice(mem)\n                new_lab = max(labels_now) + 1 if labels_now else 1\n                s[pick-1] = new_lab\n        s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002302701}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is positive int party label for vertex i. Labels may be non-contiguous; internal operations normalize to 1..m in first-occurrence order.","Evaluacion":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 10**6\n    if len(solution) != n:\n        return PENALTY_BASE + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    # Penalize infeasible strongly with slight dependence on k and number of violations\n    return PENALTY_BASE + 1000*len(parties) + violations\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization and richer operators\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"noop\"\n\n    if r < 0.45:\n        # Greedy reassignment: try to place a vertex into the smallest compatible party, else keep label\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        candidates = []\n        for lab in labels:\n            if lab == cur:\n                continue\n            tgt_members = [u for u,lab2 in enumerate(s, start=1) if lab2 == lab]\n            if all(is_edge(v,u) for u in tgt_members):\n                candidates.append((len(tgt_members), lab))\n        if candidates:\n            candidates.sort()\n            s[i] = candidates[0][1]\n            move_type = \"vertex->best_party\"\n        else:\n            # attempt swap-based improvement with another vertex\n            j = random.randrange(n)\n            if j != i and s[j] != s[i]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                    move_type = \"exchange\"\n                else:\n                    move_type = \"noop\"\n            else:\n                move_type = \"noop\"\n    elif r < 0.7:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # split a non-clique label if exists\n                non_clique_labels = []\n                for L, mem in members_by_label(s).items():\n                    if not party_is_clique(mem):\n                        non_clique_labels.append((L, mem))\n                if non_clique_labels:\n                    L, mem = random.choice(non_clique_labels)\n                    # move a violating vertex to a new singleton\n                    picked = None\n                    for u in mem:\n                        if any((min(u,v), max(u,v)) not in E for v in mem if v!=u):\n                            picked = u\n                            break\n                    if picked is None:\n                        picked = random.choice(mem)\n                    new_lab = max(labels) + 1\n                    s[picked-1] = new_lab\n                    move_type = \"split_violation\"\n                else:\n                    move_type = \"noop\"\n        else:\n            move_type = \"noop\"\n    else:\n        # Reassign to compatible existing party if any; avoid creating new labels\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        cand = [lab for lab in labels if lab != cur]\n        random.shuffle(cand)\n        moved = False\n        for tgt in cand:\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                move_type = \"vertex->party\"\n                moved = True\n                break\n        if not moved:\n            move_type = \"noop\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasible shake: multiple clique-preserving moves plus merges\/splits\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.35:\n            # random reassignment to any compatible party\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            cands = [lab for lab in labels if lab != cur]\n            random.shuffle(cands)\n            moved = False\n            for tgt in cands:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved and len(labels) >= 2:\n                # try exchange\n                j = random.randrange(n)\n                if j != i and s[j] != s[i]:\n                    li, lj = s[i], s[j]\n                    vi, vj = i+1, j+1\n                    memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                    memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                    if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                        s[i], s[j] = s[j], s[i]\n        elif op < 0.65:\n            # merge if possible\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # split a non-clique party or diversify by moving a member to new label\n            labels_now = list(members_by_label(s).keys())\n            target_label = None\n            for L, mem in members_by_label(s).items():\n                if len(mem) >= 2 and not party_is_clique(mem):\n                    target_label = L\n                    break\n            if target_label is None and labels_now:\n                target_label = random.choice(labels_now)\n            if target_label is not None:\n                mem = [u for u,lab in enumerate(s, start=1) if lab == target_label]\n                pick = random.choice(mem)\n                new_lab = max(labels_now) + 1 if labels_now else 1\n                s[pick-1] = new_lab\n        s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001781624}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is a positive int party label for vertex i. Labels may be non-contiguous; all operations normalize to contiguous 1..m in first-occurrence order.","Evaluacion":"import itertools\nimport random\n\ndef evaluate_solution(solution):\n    n = 9\n    PENALTY_BASE = 10**9\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 10**6\n    if len(solution) != n:\n        return PENALTY_BASE + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10**6 + 1\n\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    # Penalize infeasible strongly with slight dependence on k and number of violations\n    return PENALTY_BASE + 1000*len(parties) + violations\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, move_type). Feasibility-preserving when possible; normalizes labels.\n    n = 9\n\n    # Local helpers (closed over this function)\n    def normalize_labels(s):\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def edges_set():\n        raw_edges = [\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        E = set()\n        for u,v in raw_edges:\n            a,b = (u,v) if u < v else (v,u)\n            E.add((a,b))\n        return E\n\n    def is_edge(E, i, j):\n        a,b = (i,j) if i < j else (j,i)\n        return (a,b) in E\n\n    def members_by_label(s):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(E, group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(E, u, v):\n                    return False\n        return True\n\n    def repair_to_feasible(E, s):\n        # Greedy: while any party is not a clique, move a violating vertex to a new label\n        s = s[:]\n        while True:\n            groups = members_by_label(s)\n            repaired = False\n            for L, mem in list(groups.items()):\n                if len(mem) <= 1:\n                    continue\n                if not party_is_clique(E, mem):\n                    # pick a vertex with a violation\n                    pick = None\n                    for u in mem:\n                        if any(not is_edge(E, u, v) for v in mem if v != u):\n                            pick = u\n                            break\n                    if pick is None:\n                        pick = mem[0]\n                    new_lab = max(groups.keys()) + 1\n                    s[pick-1] = new_lab\n                    s = normalize_labels(s)\n                    repaired = True\n                    break\n            if not repaired:\n                break\n        return s\n\n    # Validate and sanitize input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"noop\")\n\n    s = normalize_labels(solution[:])\n    E = edges_set()\n    s = repair_to_feasible(E, s)\n\n    move_type = \"noop\"\n\n    # Retry loop to avoid excessive no-ops\n    for _ in range(25):\n        groups = members_by_label(s)\n        labels = sorted(groups.keys())\n        r = random.random()\n\n        if r < 0.45:\n            # Vertex relocation to the smallest compatible party\n            i = random.randrange(n)\n            v = i + 1\n            cur_lab = s[i]\n            candidates = []\n            for lab in labels:\n                if lab == cur_lab:\n                    continue\n                members = groups[lab]\n                if all(is_edge(E, v, u) for u in members):\n                    candidates.append((len(members), lab))\n            if candidates:\n                candidates.sort()\n                s[i] = candidates[0][1]\n                move_type = \"vertex->best_party\"\n            else:\n                # try exchange with another vertex\n                j = random.randrange(n)\n                if j != i and s[j] != s[i]:\n                    vi, vj = i+1, j+1\n                    li, lj = s[i], s[j]\n                    memb_i = [u for u in groups[li] if u != vi]\n                    memb_j = [u for u in groups[lj] if u != vj]\n                    if all(is_edge(E, vi, u) for u in memb_j) and all(is_edge(E, vj, u) for u in memb_i):\n                        s[i], s[j] = s[j], s[i]\n                        move_type = \"exchange\"\n        elif r < 0.7:\n            # Merge two parties if their union is a clique\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                union = groups[a] + groups[b]\n                if party_is_clique(E, union):\n                    for idx, lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n                    move_type = \"merge\"\n                else:\n                    # Partial merge: move any fully-compatible vertices from b to a\n                    moved_any = False\n                    from_b = [u for u in groups[b]]\n                    for u in from_b:\n                        if all(is_edge(E, u, x) for x in groups[a]):\n                            s[u-1] = a\n                            moved_any = True\n                    if moved_any:\n                        move_type = \"partial_merge\"\n        else:\n            # Random feasible reassignment to any compatible party\n            i = random.randrange(n)\n            v = i + 1\n            cur_lab = s[i]\n            cands = [lab for lab in labels if lab != cur_lab]\n            random.shuffle(cands)\n            for tgt in cands:\n                if all(is_edge(E, v, u) for u in groups[tgt]):\n                    s[i] = tgt\n                    move_type = \"vertex->party\"\n                    break\n\n        s = normalize_labels(s)\n        # ensure feasibility post-move\n        s = repair_to_feasible(E, s)\n        if move_type != \"noop\":\n            break\n\n    return (s, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but feasible shake with normalization. Returns a feasible solution list.\n    n = 9\n\n    def normalize_labels(s):\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def edges_set():\n        raw_edges = [\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        E = set()\n        for u,v in raw_edges:\n            a,b = (u,v) if u < v else (v,u)\n            E.add((a,b))\n        return E\n\n    def is_edge(E, i, j):\n        a,b = (i,j) if i < j else (j,i)\n        return (a,b) in E\n\n    def members_by_label(s):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(E, group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(E, u, v):\n                    return False\n        return True\n\n    def repair_to_feasible(E, s):\n        s = s[:]\n        while True:\n            groups = members_by_label(s)\n            fixed = True\n            for L, mem in list(groups.items()):\n                if len(mem) <= 1:\n                    continue\n                if not party_is_clique(E, mem):\n                    # move a violating vertex to a new label\n                    pick = None\n                    for u in mem:\n                        if any(not is_edge(E, u, v) for v in mem if v != u):\n                            pick = u\n                            break\n                    if pick is None:\n                        pick = mem[0]\n                    new_lab = max(groups.keys()) + 1\n                    s[pick-1] = new_lab\n                    s = normalize_labels(s)\n                    fixed = False\n                    break\n            if fixed:\n                break\n        return s\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n\n    s = normalize_labels(solution[:])\n    E = edges_set()\n    s = repair_to_feasible(E, s)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = sorted(groups.keys())\n        op = random.random()\n        if op < 0.4:\n            # random feasible reassignment\n            i = random.randrange(n)\n            v = i + 1\n            cur = s[i]\n            cands = [lab for lab in labels if lab != cur]\n            random.shuffle(cands)\n            for tgt in cands:\n                if all(is_edge(E, v, u) for u in groups[tgt]):\n                    s[i] = tgt\n                    break\n        elif op < 0.7:\n            # try merging two labels if union clique\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                union = groups[a] + groups[b]\n                if party_is_clique(E, union):\n                    for idx, lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n                else:\n                    # move subset from b to a if compatible\n                    for u in list(groups[b]):\n                        if all(is_edge(E, u, x) for x in groups[a]):\n                            s[u-1] = a\n        else:\n            # diversify: split a party (prefer non-clique or largest party)\n            target_label = None\n            for L, mem in sorted(members_by_label(s).items(), key=lambda kv: -len(kv[1])):\n                target_label = L\n                break\n            if target_label is not None and len(groups[target_label]) >= 2:\n                mem = groups[target_label]\n                pick_cnt = max(1, len(mem)\/\/2)\n                picks = random.sample(mem, pick_cnt)\n                new_lab = max(labels) + 1\n                for u in picks:\n                    s[u-1] = new_lab\n        s = normalize_labels(s)\n        s = repair_to_feasible(E, s)\n\n    return s\n","Resultados":["[3,1,2,1,3,2,1,1,2]",1001000000,"[3,1,2,1,3,2,1,1,2]",1001000000],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001241826}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is a positive int party label for vertex i. Labels may be non-contiguous; all operations normalize to contiguous 1..m in first-occurrence order.","Evaluacion":"import itertools\nimport random\n\ndef evaluate_solution(solution):\n    n = 9\n    PENALTY_BASE = 10**9\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 10**6\n    if len(solution) != n:\n        return PENALTY_BASE + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10**6 + 1\n\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    # Penalize infeasible strongly with slight dependence on k and number of violations\n    return PENALTY_BASE + 1000*len(parties) + violations\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, move_type). Feasibility-preserving when possible; normalizes labels.\n    n = 9\n\n    # Local helpers (closed over this function)\n    def normalize_labels(s):\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def edges_set():\n        raw_edges = [\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        E = set()\n        for u,v in raw_edges:\n            a,b = (u,v) if u < v else (v,u)\n            E.add((a,b))\n        return E\n\n    def is_edge(E, i, j):\n        a,b = (i,j) if i < j else (j,i)\n        return (a,b) in E\n\n    def members_by_label(s):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(E, group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(E, u, v):\n                    return False\n        return True\n\n    def repair_to_feasible(E, s):\n        # Greedy: while any party is not a clique, move a violating vertex to a new label\n        s = s[:]\n        while True:\n            groups = members_by_label(s)\n            repaired = False\n            for L, mem in list(groups.items()):\n                if len(mem) <= 1:\n                    continue\n                if not party_is_clique(E, mem):\n                    # pick a vertex with a violation\n                    pick = None\n                    for u in mem:\n                        if any(not is_edge(E, u, v) for v in mem if v != u):\n                            pick = u\n                            break\n                    if pick is None:\n                        pick = mem[0]\n                    new_lab = max(groups.keys()) + 1\n                    s[pick-1] = new_lab\n                    s = normalize_labels(s)\n                    repaired = True\n                    break\n            if not repaired:\n                break\n        return s\n\n    # Validate and sanitize input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"noop\")\n\n    s = normalize_labels(solution[:])\n    E = edges_set()\n    s = repair_to_feasible(E, s)\n\n    move_type = \"noop\"\n\n    # Retry loop to avoid excessive no-ops\n    for _ in range(25):\n        groups = members_by_label(s)\n        labels = sorted(groups.keys())\n        r = random.random()\n\n        if r < 0.45:\n            # Vertex relocation to the smallest compatible party\n            i = random.randrange(n)\n            v = i + 1\n            cur_lab = s[i]\n            candidates = []\n            for lab in labels:\n                if lab == cur_lab:\n                    continue\n                members = groups[lab]\n                if all(is_edge(E, v, u) for u in members):\n                    candidates.append((len(members), lab))\n            if candidates:\n                candidates.sort()\n                s[i] = candidates[0][1]\n                move_type = \"vertex->best_party\"\n            else:\n                # try exchange with another vertex\n                j = random.randrange(n)\n                if j != i and s[j] != s[i]:\n                    vi, vj = i+1, j+1\n                    li, lj = s[i], s[j]\n                    memb_i = [u for u in groups[li] if u != vi]\n                    memb_j = [u for u in groups[lj] if u != vj]\n                    if all(is_edge(E, vi, u) for u in memb_j) and all(is_edge(E, vj, u) for u in memb_i):\n                        s[i], s[j] = s[j], s[i]\n                        move_type = \"exchange\"\n        elif r < 0.7:\n            # Merge two parties if their union is a clique\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                union = groups[a] + groups[b]\n                if party_is_clique(E, union):\n                    for idx, lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n                    move_type = \"merge\"\n                else:\n                    # Partial merge: move any fully-compatible vertices from b to a\n                    moved_any = False\n                    from_b = [u for u in groups[b]]\n                    for u in from_b:\n                        if all(is_edge(E, u, x) for x in groups[a]):\n                            s[u-1] = a\n                            moved_any = True\n                    if moved_any:\n                        move_type = \"partial_merge\"\n        else:\n            # Random feasible reassignment to any compatible party\n            i = random.randrange(n)\n            v = i + 1\n            cur_lab = s[i]\n            cands = [lab for lab in labels if lab != cur_lab]\n            random.shuffle(cands)\n            for tgt in cands:\n                if all(is_edge(E, v, u) for u in groups[tgt]):\n                    s[i] = tgt\n                    move_type = \"vertex->party\"\n                    break\n\n        s = normalize_labels(s)\n        # ensure feasibility post-move\n        s = repair_to_feasible(E, s)\n        if move_type != \"noop\":\n            break\n\n    return (s, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but feasible shake with normalization. Returns a feasible solution list.\n    n = 9\n\n    def normalize_labels(s):\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def edges_set():\n        raw_edges = [\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        E = set()\n        for u,v in raw_edges:\n            a,b = (u,v) if u < v else (v,u)\n            E.add((a,b))\n        return E\n\n    def is_edge(E, i, j):\n        a,b = (i,j) if i < j else (j,i)\n        return (a,b) in E\n\n    def members_by_label(s):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(E, group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(E, u, v):\n                    return False\n        return True\n\n    def repair_to_feasible(E, s):\n        s = s[:]\n        while True:\n            groups = members_by_label(s)\n            fixed = True\n            for L, mem in list(groups.items()):\n                if len(mem) <= 1:\n                    continue\n                if not party_is_clique(E, mem):\n                    # move a violating vertex to a new label\n                    pick = None\n                    for u in mem:\n                        if any(not is_edge(E, u, v) for v in mem if v != u):\n                            pick = u\n                            break\n                    if pick is None:\n                        pick = mem[0]\n                    new_lab = max(groups.keys()) + 1\n                    s[pick-1] = new_lab\n                    s = normalize_labels(s)\n                    fixed = False\n                    break\n            if fixed:\n                break\n        return s\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n\n    s = normalize_labels(solution[:])\n    E = edges_set()\n    s = repair_to_feasible(E, s)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = sorted(groups.keys())\n        op = random.random()\n        if op < 0.4:\n            # random feasible reassignment\n            i = random.randrange(n)\n            v = i + 1\n            cur = s[i]\n            cands = [lab for lab in labels if lab != cur]\n            random.shuffle(cands)\n            for tgt in cands:\n                if all(is_edge(E, v, u) for u in groups[tgt]):\n                    s[i] = tgt\n                    break\n        elif op < 0.7:\n            # try merging two labels if union clique\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                union = groups[a] + groups[b]\n                if party_is_clique(E, union):\n                    for idx, lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n                else:\n                    # move subset from b to a if compatible\n                    for u in list(groups[b]):\n                        if all(is_edge(E, u, x) for x in groups[a]):\n                            s[u-1] = a\n        else:\n            # diversify: split a party (prefer non-clique or largest party)\n            target_label = None\n            for L, mem in sorted(members_by_label(s).items(), key=lambda kv: -len(kv[1])):\n                target_label = L\n                break\n            if target_label is not None and len(groups[target_label]) >= 2:\n                mem = groups[target_label]\n                pick_cnt = max(1, len(mem)\/\/2)\n                picks = random.sample(mem, pick_cnt)\n                new_lab = max(labels) + 1\n                for u in picks:\n                    s[u-1] = new_lab\n        s = normalize_labels(s)\n        s = repair_to_feasible(E, s)\n\n    return s\n","Resultados":["[3,1,2,1,3,2,1,1,2]",1001000000,"[3,1,2,1,3,2,1,1,2]",1001000000],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0016448221}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is a positive int party label for vertex i. Labels may be non-contiguous; all operations normalize to contiguous 1..m in first-occurrence order.","Evaluacion":"import itertools\nimport random\n\ndef evaluate_solution(solution):\n    n = 9\n    PENALTY_BASE = 10**9\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 10**6\n    if len(solution) != n:\n        return PENALTY_BASE + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10**6 + 1\n\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    # Penalize infeasible strongly with slight dependence on k and number of violations\n    return PENALTY_BASE + 1000*len(parties) + violations\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, move_type). Feasibility-preserving when possible; normalizes labels.\n    n = 9\n\n    # Local helpers (closed over this function)\n    def normalize_labels(s):\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def edges_set():\n        raw_edges = [\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        E = set()\n        for u,v in raw_edges:\n            a,b = (u,v) if u < v else (v,u)\n            E.add((a,b))\n        return E\n\n    def is_edge(E, i, j):\n        a,b = (i,j) if i < j else (j,i)\n        return (a,b) in E\n\n    def members_by_label(s):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(E, group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(E, u, v):\n                    return False\n        return True\n\n    def repair_to_feasible(E, s):\n        # Greedy: while any party is not a clique, move a violating vertex to a new label\n        s = s[:]\n        while True:\n            groups = members_by_label(s)\n            repaired = False\n            for L, mem in list(groups.items()):\n                if len(mem) <= 1:\n                    continue\n                if not party_is_clique(E, mem):\n                    # pick a vertex with a violation\n                    pick = None\n                    for u in mem:\n                        if any(not is_edge(E, u, v) for v in mem if v != u):\n                            pick = u\n                            break\n                    if pick is None:\n                        pick = mem[0]\n                    new_lab = max(groups.keys()) + 1\n                    s[pick-1] = new_lab\n                    s = normalize_labels(s)\n                    repaired = True\n                    break\n            if not repaired:\n                break\n        return s\n\n    # Validate and sanitize input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"noop\")\n\n    s = normalize_labels(solution[:])\n    E = edges_set()\n    s = repair_to_feasible(E, s)\n\n    move_type = \"noop\"\n\n    # Retry loop to avoid excessive no-ops\n    for _ in range(25):\n        groups = members_by_label(s)\n        labels = sorted(groups.keys())\n        r = random.random()\n\n        if r < 0.45:\n            # Vertex relocation to the smallest compatible party\n            i = random.randrange(n)\n            v = i + 1\n            cur_lab = s[i]\n            candidates = []\n            for lab in labels:\n                if lab == cur_lab:\n                    continue\n                members = groups[lab]\n                if all(is_edge(E, v, u) for u in members):\n                    candidates.append((len(members), lab))\n            if candidates:\n                candidates.sort()\n                s[i] = candidates[0][1]\n                move_type = \"vertex->best_party\"\n            else:\n                # try exchange with another vertex\n                j = random.randrange(n)\n                if j != i and s[j] != s[i]:\n                    vi, vj = i+1, j+1\n                    li, lj = s[i], s[j]\n                    memb_i = [u for u in groups[li] if u != vi]\n                    memb_j = [u for u in groups[lj] if u != vj]\n                    if all(is_edge(E, vi, u) for u in memb_j) and all(is_edge(E, vj, u) for u in memb_i):\n                        s[i], s[j] = s[j], s[i]\n                        move_type = \"exchange\"\n        elif r < 0.7:\n            # Merge two parties if their union is a clique\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                union = groups[a] + groups[b]\n                if party_is_clique(E, union):\n                    for idx, lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n                    move_type = \"merge\"\n                else:\n                    # Partial merge: move any fully-compatible vertices from b to a\n                    moved_any = False\n                    from_b = [u for u in groups[b]]\n                    for u in from_b:\n                        if all(is_edge(E, u, x) for x in groups[a]):\n                            s[u-1] = a\n                            moved_any = True\n                    if moved_any:\n                        move_type = \"partial_merge\"\n        else:\n            # Random feasible reassignment to any compatible party\n            i = random.randrange(n)\n            v = i + 1\n            cur_lab = s[i]\n            cands = [lab for lab in labels if lab != cur_lab]\n            random.shuffle(cands)\n            for tgt in cands:\n                if all(is_edge(E, v, u) for u in groups[tgt]):\n                    s[i] = tgt\n                    move_type = \"vertex->party\"\n                    break\n\n        s = normalize_labels(s)\n        # ensure feasibility post-move\n        s = repair_to_feasible(E, s)\n        if move_type != \"noop\":\n            break\n\n    return (s, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but feasible shake with normalization. Returns a feasible solution list.\n    n = 9\n\n    def normalize_labels(s):\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def edges_set():\n        raw_edges = [\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        E = set()\n        for u,v in raw_edges:\n            a,b = (u,v) if u < v else (v,u)\n            E.add((a,b))\n        return E\n\n    def is_edge(E, i, j):\n        a,b = (i,j) if i < j else (j,i)\n        return (a,b) in E\n\n    def members_by_label(s):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(E, group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(E, u, v):\n                    return False\n        return True\n\n    def repair_to_feasible(E, s):\n        s = s[:]\n        while True:\n            groups = members_by_label(s)\n            fixed = True\n            for L, mem in list(groups.items()):\n                if len(mem) <= 1:\n                    continue\n                if not party_is_clique(E, mem):\n                    # move a violating vertex to a new label\n                    pick = None\n                    for u in mem:\n                        if any(not is_edge(E, u, v) for v in mem if v != u):\n                            pick = u\n                            break\n                    if pick is None:\n                        pick = mem[0]\n                    new_lab = max(groups.keys()) + 1\n                    s[pick-1] = new_lab\n                    s = normalize_labels(s)\n                    fixed = False\n                    break\n            if fixed:\n                break\n        return s\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n\n    s = normalize_labels(solution[:])\n    E = edges_set()\n    s = repair_to_feasible(E, s)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = sorted(groups.keys())\n        op = random.random()\n        if op < 0.4:\n            # random feasible reassignment\n            i = random.randrange(n)\n            v = i + 1\n            cur = s[i]\n            cands = [lab for lab in labels if lab != cur]\n            random.shuffle(cands)\n            for tgt in cands:\n                if all(is_edge(E, v, u) for u in groups[tgt]):\n                    s[i] = tgt\n                    break\n        elif op < 0.7:\n            # try merging two labels if union clique\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                union = groups[a] + groups[b]\n                if party_is_clique(E, union):\n                    for idx, lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n                else:\n                    # move subset from b to a if compatible\n                    for u in list(groups[b]):\n                        if all(is_edge(E, u, x) for x in groups[a]):\n                            s[u-1] = a\n        else:\n            # diversify: split a party (prefer non-clique or largest party)\n            target_label = None\n            for L, mem in sorted(members_by_label(s).items(), key=lambda kv: -len(kv[1])):\n                target_label = L\n                break\n            if target_label is not None and len(groups[target_label]) >= 2:\n                mem = groups[target_label]\n                pick_cnt = max(1, len(mem)\/\/2)\n                picks = random.sample(mem, pick_cnt)\n                new_lab = max(labels) + 1\n                for u in picks:\n                    s[u-1] = new_lab\n        s = normalize_labels(s)\n        s = repair_to_feasible(E, s)\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001724302}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize to list copy\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        return (curr, (\"InvalidSize\", \"NoMove\"))\n    # Ensure positivity fallback for safety\n    for i, x in enumerate(curr):\n        if not isinstance(x, int) or x < 1:\n            curr[i] = 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Detect conflicts\n    conflicts = []\n    for u, v in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n\n    max_col = max(curr) if curr else 1\n\n    def recolor_vertex(i: int) -> None:\n        nonlocal curr, max_col\n        forbidden = {curr[j] for j in adj[i]}\n        # Try smallest feasible color among existing ones\n        for c in range(1, max_col + 1):\n            if c not in forbidden:\n                curr[i] = c\n                return\n        # If none feasible in existing palette, open a new color\n        curr[i] = max_col + 1\n        max_col = max_col + 1\n\n    if conflicts:\n        # Conflict-driven move: pick a random endpoint of a random conflicting edge\n        u, v = random.choice(conflicts)\n        i = random.choice([u, v])\n        recolor_vertex(i)\n        return (curr, (\"1-Change\", \"Conflict-Driven-Recolor\"))\n    else:\n        # No conflicts: attempt color reduction by recoloring a vertex using smallest available color\n        # Prefer vertices using the highest color to encourage palette shrinkage\n        highest = [i for i, c in enumerate(curr) if c == max_col]\n        i = random.choice(highest if highest else list(range(n)))\n        old = curr[i]\n        recolor_vertex(i)\n        # If color count increased unnecessarily, revert with some probability\n        if max(curr) > max_col:\n            curr[i] = old\n        return (curr, (\"1-Change\", \"Greedy-Recolor\"))\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        # Resize by truncating\/padding with 1s for robustness\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Simple helper to check if reassigning vertex i to color c is feasible\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        ci = color\n        if ci < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    max_col = max(curr) if curr else 1\n\n    # Apply a burst of random recolors\n    t = random.randint(2, 5)\n    for _ in range(t):\n        i = random.randrange(n)\n        # Try random existing color first\n        palette = list(range(1, max_col + 1))\n        random.shuffle(palette)\n        placed = False\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # Open a new color as last resort\n            curr[i] = max_col + 1\n            max_col += 1\n\n    # Palette compaction attempt: try to merge a random color into a lower one\n    colors = sorted(set(curr))\n    if len(colors) >= 2:\n        src = random.choice(colors)\n        tgt_candidates = [c for c in colors if c < src]\n        if tgt_candidates:\n            tgt = random.choice(tgt_candidates)\n            # Tentatively map src -> tgt if feasible per-vertex\n            changed_idxs = [i for i, c in enumerate(curr) if c == src]\n            ok = True\n            for i in changed_idxs:\n                if not feasible_color(i, tgt, curr):\n                    ok = False\n                    break\n            if ok:\n                for i in changed_idxs:\n                    curr[i] = tgt\n                # Optional renumbering to keep colors compact 1..K\n                remap = {c: idx+1 for idx, c in enumerate(sorted(set(curr)))}\n                curr = [remap[c] for c in curr]\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.00080833}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize to list copy\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        return (curr, (\"InvalidSize\", \"NoMove\"))\n    # Ensure positivity fallback for safety\n    for i, x in enumerate(curr):\n        if not isinstance(x, int) or x < 1:\n            curr[i] = 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Detect conflicts\n    conflicts = []\n    for u, v in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n\n    max_col = max(curr) if curr else 1\n\n    def recolor_vertex(i: int) -> None:\n        nonlocal curr, max_col\n        forbidden = {curr[j] for j in adj[i]}\n        # Try smallest feasible color among existing ones\n        for c in range(1, max_col + 1):\n            if c not in forbidden:\n                curr[i] = c\n                return\n        # If none feasible in existing palette, open a new color\n        curr[i] = max_col + 1\n        max_col = max_col + 1\n\n    if conflicts:\n        # Conflict-driven move: pick a random endpoint of a random conflicting edge\n        u, v = random.choice(conflicts)\n        i = random.choice([u, v])\n        recolor_vertex(i)\n        return (curr, (\"1-Change\", \"Conflict-Driven-Recolor\"))\n    else:\n        # No conflicts: attempt color reduction by recoloring a vertex using smallest available color\n        # Prefer vertices using the highest color to encourage palette shrinkage\n        highest = [i for i, c in enumerate(curr) if c == max_col]\n        i = random.choice(highest if highest else list(range(n)))\n        old = curr[i]\n        recolor_vertex(i)\n        # If color count increased unnecessarily, revert with some probability\n        if max(curr) > max_col:\n            curr[i] = old\n        return (curr, (\"1-Change\", \"Greedy-Recolor\"))\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        # Resize by truncating\/padding with 1s for robustness\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Simple helper to check if reassigning vertex i to color c is feasible\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        ci = color\n        if ci < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    max_col = max(curr) if curr else 1\n\n    # Apply a burst of random recolors\n    t = random.randint(2, 5)\n    for _ in range(t):\n        i = random.randrange(n)\n        # Try random existing color first\n        palette = list(range(1, max_col + 1))\n        random.shuffle(palette)\n        placed = False\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # Open a new color as last resort\n            curr[i] = max_col + 1\n            max_col += 1\n\n    # Palette compaction attempt: try to merge a random color into a lower one\n    colors = sorted(set(curr))\n    if len(colors) >= 2:\n        src = random.choice(colors)\n        tgt_candidates = [c for c in colors if c < src]\n        if tgt_candidates:\n            tgt = random.choice(tgt_candidates)\n            # Tentatively map src -> tgt if feasible per-vertex\n            changed_idxs = [i for i, c in enumerate(curr) if c == src]\n            ok = True\n            for i in changed_idxs:\n                if not feasible_color(i, tgt, curr):\n                    ok = False\n                    break\n            if ok:\n                for i in changed_idxs:\n                    curr[i] = tgt\n                # Optional renumbering to keep colors compact 1..K\n                remap = {c: idx+1 for idx, c in enumerate(sorted(set(curr)))}\n                curr = [remap[c] for c in curr]\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001043894}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize to list copy\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        return (curr, (\"InvalidSize\", \"NoMove\"))\n    # Ensure positivity fallback for safety\n    for i, x in enumerate(curr):\n        if not isinstance(x, int) or x < 1:\n            curr[i] = 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Detect conflicts\n    conflicts = []\n    for u, v in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n\n    max_col = max(curr) if curr else 1\n\n    def recolor_vertex(i: int) -> None:\n        nonlocal curr, max_col\n        forbidden = {curr[j] for j in adj[i]}\n        # Try smallest feasible color among existing ones\n        for c in range(1, max_col + 1):\n            if c not in forbidden:\n                curr[i] = c\n                return\n        # If none feasible in existing palette, open a new color\n        curr[i] = max_col + 1\n        max_col = max_col + 1\n\n    if conflicts:\n        # Conflict-driven move: pick a random endpoint of a random conflicting edge\n        u, v = random.choice(conflicts)\n        i = random.choice([u, v])\n        recolor_vertex(i)\n        return (curr, (\"1-Change\", \"Conflict-Driven-Recolor\"))\n    else:\n        # No conflicts: attempt color reduction by recoloring a vertex using smallest available color\n        # Prefer vertices using the highest color to encourage palette shrinkage\n        highest = [i for i, c in enumerate(curr) if c == max_col]\n        i = random.choice(highest if highest else list(range(n)))\n        old = curr[i]\n        recolor_vertex(i)\n        # If color count increased unnecessarily, revert with some probability\n        if max(curr) > max_col:\n            curr[i] = old\n        return (curr, (\"1-Change\", \"Greedy-Recolor\"))\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        # Resize by truncating\/padding with 1s for robustness\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Simple helper to check if reassigning vertex i to color c is feasible\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        ci = color\n        if ci < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    max_col = max(curr) if curr else 1\n\n    # Apply a burst of random recolors\n    t = random.randint(2, 5)\n    for _ in range(t):\n        i = random.randrange(n)\n        # Try random existing color first\n        palette = list(range(1, max_col + 1))\n        random.shuffle(palette)\n        placed = False\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # Open a new color as last resort\n            curr[i] = max_col + 1\n            max_col += 1\n\n    # Palette compaction attempt: try to merge a random color into a lower one\n    colors = sorted(set(curr))\n    if len(colors) >= 2:\n        src = random.choice(colors)\n        tgt_candidates = [c for c in colors if c < src]\n        if tgt_candidates:\n            tgt = random.choice(tgt_candidates)\n            # Tentatively map src -> tgt if feasible per-vertex\n            changed_idxs = [i for i, c in enumerate(curr) if c == src]\n            ok = True\n            for i in changed_idxs:\n                if not feasible_color(i, tgt, curr):\n                    ok = False\n                    break\n            if ok:\n                for i in changed_idxs:\n                    curr[i] = tgt\n                # Optional renumbering to keep colors compact 1..K\n                remap = {c: idx+1 for idx, c in enumerate(sorted(set(curr)))}\n                curr = [remap[c] for c in curr]\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001016923}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: first minimize violations, then k, then slight balance tie-breaker\n    # Tie-breaker: variance-like penalty on class sizes to encourage compaction stability\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Build color counts for tie-breaker\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors to 1..k by order of appearance\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        ci = color\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        color_r = state[r]\n        if color_r not in (a, b):\n            return state[:]\n        target = a if color_r == b else b\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # Move 1: Conflict-driven recolor with smallest feasible color\n    if conflicts:\n        # pick vertex with maximum conflict degree\n        max_cd = max(conflict_deg)\n        cand = [i for i, d in enumerate(conflict_deg) if d == max_cd]\n        i = random.choice(cand)\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        palette = list(range(1, max_col+1))\n        placed = False\n        for c in palette:\n            if c != curr[i] and feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                move = (\"1-Change\", \"Conflict-Driven-Recolor\")\n                break\n        if not placed:\n            # pick a color from neighbor colors to attempt Kempe swap\n            neigh_colors = list({curr[j] for j in adj[i]})\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n                a = curr[i]\n                new_state = kempe_swap(curr, a, b, i)\n                curr = canonicalize(new_state)\n                move = (\"Kempe-Chain\", \"Conflict-Driven-Swap\")\n            else:\n                # fallback: keep as is\n                move = (\"NoMove\", \"Stall\")\n        return (curr, move)\n\n    # No conflicts: try color elimination of highest color\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n\n    # Attempt to relocate all vertices of the highest color into lower colors greedily (DSATUR-like order)\n    hv = color_vertices.get(highest, [])\n    if hv:\n        # order by saturation (distinct neighbor colors) descending\n        def sat_deg(i: int, state: List[int]) -> int:\n            return len({state[j] for j in adj[i]})\n        order = sorted(hv, key=lambda i: sat_deg(i, curr), reverse=True)\n        trial = curr[:]\n        success = True\n        for v in order:\n            # try colors 1..highest-1, best-fit (fewest conflicts) which is feasibility here\n            placed_local = False\n            for c in range(1, highest):\n                if feasible_color(v, c, trial):\n                    trial[v] = c\n                    placed_local = True\n                    break\n            if not placed_local:\n                success = False\n                break\n        if success:\n            # remove empty highest color and canonicalize\n            curr = canonicalize(trial)\n            return (curr, (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # If elimination failed, do a gentle greedy recolor of a highest-color vertex to a lower color if possible\n    if hv:\n        v = random.choice(hv)\n        for c in range(1, highest):\n            if feasible_color(v, c, curr):\n                curr[v] = c\n                curr = canonicalize(curr)\n                return (curr, (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap between two random colors\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a, b = random.sample(colors, 2)\n        # choose a vertex of color a to start\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            curr = canonicalize(kempe_swap(curr, a, b, r))\n            return (curr, (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: random safe recolor attempt\n    i = random.randrange(n)\n    for c in colors:\n        if c != curr[i] and feasible_color(i, c, curr):\n            curr[i] = c\n            curr = canonicalize(curr)\n            return (curr, (\"1-Change\", \"Fallback-Recolor\"))\n\n    return (curr, (\"NoMove\", \"NoChange\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors 1..k\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        from collections import deque as _dq\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = _dq([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across random color pairs\n    k = len(set(curr)) if curr else 1\n    t_swaps = 1 if k <= 3 else 2\n    for _ in range(t_swaps):\n        colors = sorted(set(curr))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize(curr)\n\n    # 3) Random removal and greedy reinsertion for a small subset\n    k = len(set(curr))\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    removed = {i: curr[i] for i in idxs}\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n    # Reinsertion by highest saturation first\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n    order = sorted(idxs, key=lambda i: sat_deg(i, curr), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k) + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            curr[i] = max([x for x in curr if isinstance(x, int)]) + 1\n            k = len(set([x for x in curr if x > 0]))\n    curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001443918}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: first minimize violations, then k, then slight balance tie-breaker\n    # Tie-breaker: variance-like penalty on class sizes to encourage compaction stability\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Build color counts for tie-breaker\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors to 1..k by order of appearance\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        ci = color\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        color_r = state[r]\n        if color_r not in (a, b):\n            return state[:]\n        target = a if color_r == b else b\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # Move 1: Conflict-driven recolor with smallest feasible color\n    if conflicts:\n        # pick vertex with maximum conflict degree\n        max_cd = max(conflict_deg)\n        cand = [i for i, d in enumerate(conflict_deg) if d == max_cd]\n        i = random.choice(cand)\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        palette = list(range(1, max_col+1))\n        placed = False\n        for c in palette:\n            if c != curr[i] and feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                move = (\"1-Change\", \"Conflict-Driven-Recolor\")\n                break\n        if not placed:\n            # pick a color from neighbor colors to attempt Kempe swap\n            neigh_colors = list({curr[j] for j in adj[i]})\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n                a = curr[i]\n                new_state = kempe_swap(curr, a, b, i)\n                curr = canonicalize(new_state)\n                move = (\"Kempe-Chain\", \"Conflict-Driven-Swap\")\n            else:\n                # fallback: keep as is\n                move = (\"NoMove\", \"Stall\")\n        return (curr, move)\n\n    # No conflicts: try color elimination of highest color\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n\n    # Attempt to relocate all vertices of the highest color into lower colors greedily (DSATUR-like order)\n    hv = color_vertices.get(highest, [])\n    if hv:\n        # order by saturation (distinct neighbor colors) descending\n        def sat_deg(i: int, state: List[int]) -> int:\n            return len({state[j] for j in adj[i]})\n        order = sorted(hv, key=lambda i: sat_deg(i, curr), reverse=True)\n        trial = curr[:]\n        success = True\n        for v in order:\n            # try colors 1..highest-1, best-fit (fewest conflicts) which is feasibility here\n            placed_local = False\n            for c in range(1, highest):\n                if feasible_color(v, c, trial):\n                    trial[v] = c\n                    placed_local = True\n                    break\n            if not placed_local:\n                success = False\n                break\n        if success:\n            # remove empty highest color and canonicalize\n            curr = canonicalize(trial)\n            return (curr, (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # If elimination failed, do a gentle greedy recolor of a highest-color vertex to a lower color if possible\n    if hv:\n        v = random.choice(hv)\n        for c in range(1, highest):\n            if feasible_color(v, c, curr):\n                curr[v] = c\n                curr = canonicalize(curr)\n                return (curr, (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap between two random colors\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a, b = random.sample(colors, 2)\n        # choose a vertex of color a to start\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            curr = canonicalize(kempe_swap(curr, a, b, r))\n            return (curr, (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: random safe recolor attempt\n    i = random.randrange(n)\n    for c in colors:\n        if c != curr[i] and feasible_color(i, c, curr):\n            curr[i] = c\n            curr = canonicalize(curr)\n            return (curr, (\"1-Change\", \"Fallback-Recolor\"))\n\n    return (curr, (\"NoMove\", \"NoChange\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors 1..k\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        from collections import deque as _dq\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = _dq([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across random color pairs\n    k = len(set(curr)) if curr else 1\n    t_swaps = 1 if k <= 3 else 2\n    for _ in range(t_swaps):\n        colors = sorted(set(curr))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize(curr)\n\n    # 3) Random removal and greedy reinsertion for a small subset\n    k = len(set(curr))\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    removed = {i: curr[i] for i in idxs}\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n    # Reinsertion by highest saturation first\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n    order = sorted(idxs, key=lambda i: sat_deg(i, curr), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k) + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            curr[i] = max([x for x in curr if isinstance(x, int)]) + 1\n            k = len(set([x for x in curr if x > 0]))\n    curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0018358431}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: first minimize violations, then k, then slight balance tie-breaker\n    # Tie-breaker: variance-like penalty on class sizes to encourage compaction stability\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Build color counts for tie-breaker\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors to 1..k by order of appearance\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        ci = color\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        color_r = state[r]\n        if color_r not in (a, b):\n            return state[:]\n        target = a if color_r == b else b\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # Move 1: Conflict-driven recolor with smallest feasible color\n    if conflicts:\n        # pick vertex with maximum conflict degree\n        max_cd = max(conflict_deg)\n        cand = [i for i, d in enumerate(conflict_deg) if d == max_cd]\n        i = random.choice(cand)\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        palette = list(range(1, max_col+1))\n        placed = False\n        for c in palette:\n            if c != curr[i] and feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                move = (\"1-Change\", \"Conflict-Driven-Recolor\")\n                break\n        if not placed:\n            # pick a color from neighbor colors to attempt Kempe swap\n            neigh_colors = list({curr[j] for j in adj[i]})\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n                a = curr[i]\n                new_state = kempe_swap(curr, a, b, i)\n                curr = canonicalize(new_state)\n                move = (\"Kempe-Chain\", \"Conflict-Driven-Swap\")\n            else:\n                # fallback: keep as is\n                move = (\"NoMove\", \"Stall\")\n        return (curr, move)\n\n    # No conflicts: try color elimination of highest color\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n\n    # Attempt to relocate all vertices of the highest color into lower colors greedily (DSATUR-like order)\n    hv = color_vertices.get(highest, [])\n    if hv:\n        # order by saturation (distinct neighbor colors) descending\n        def sat_deg(i: int, state: List[int]) -> int:\n            return len({state[j] for j in adj[i]})\n        order = sorted(hv, key=lambda i: sat_deg(i, curr), reverse=True)\n        trial = curr[:]\n        success = True\n        for v in order:\n            # try colors 1..highest-1, best-fit (fewest conflicts) which is feasibility here\n            placed_local = False\n            for c in range(1, highest):\n                if feasible_color(v, c, trial):\n                    trial[v] = c\n                    placed_local = True\n                    break\n            if not placed_local:\n                success = False\n                break\n        if success:\n            # remove empty highest color and canonicalize\n            curr = canonicalize(trial)\n            return (curr, (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # If elimination failed, do a gentle greedy recolor of a highest-color vertex to a lower color if possible\n    if hv:\n        v = random.choice(hv)\n        for c in range(1, highest):\n            if feasible_color(v, c, curr):\n                curr[v] = c\n                curr = canonicalize(curr)\n                return (curr, (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap between two random colors\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a, b = random.sample(colors, 2)\n        # choose a vertex of color a to start\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            curr = canonicalize(kempe_swap(curr, a, b, r))\n            return (curr, (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: random safe recolor attempt\n    i = random.randrange(n)\n    for c in colors:\n        if c != curr[i] and feasible_color(i, c, curr):\n            curr[i] = c\n            curr = canonicalize(curr)\n            return (curr, (\"1-Change\", \"Fallback-Recolor\"))\n\n    return (curr, (\"NoMove\", \"NoChange\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors 1..k\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        from collections import deque as _dq\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = _dq([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across random color pairs\n    k = len(set(curr)) if curr else 1\n    t_swaps = 1 if k <= 3 else 2\n    for _ in range(t_swaps):\n        colors = sorted(set(curr))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize(curr)\n\n    # 3) Random removal and greedy reinsertion for a small subset\n    k = len(set(curr))\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    removed = {i: curr[i] for i in idxs}\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n    # Reinsertion by highest saturation first\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n    order = sorted(idxs, key=lambda i: sat_deg(i, curr), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k) + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            curr[i] = max([x for x in curr if isinstance(x, int)]) + 1\n            k = len(set([x for x in curr if x > 0]))\n    curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001767142}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation and normalization penalties\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Stable tie-breaker on color class sizes\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n    # Sanitize entries\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization: relabel colors by sorting colors by smallest vertex index they appear on\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i]})\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # Helper: count conflicts quickly\n    def conflict_count(state: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges0:\n            if state[u] == state[v]:\n                cnt += 1\n        return cnt\n\n    # Move 1: Conflict-driven recolor with deterministic tie-breaking\n    if conflicts:\n        # vertices involved in a conflict\n        involved = sorted({u for uv in conflicts for u in uv})\n        # choose vertex with max conflict degree, then higher saturation, then higher static degree, then lower index\n        deg = [len(adj[i]) for i in range(n)]\n        best_i = max(involved, key=lambda i: (conflict_deg[i], sat_deg(i, curr), deg[i], -i))\n        i = best_i\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        for c in range(1, max_col+1):\n            if c != curr[i] and feasible_color(i, c, curr):\n                new_state = curr[:]\n                new_state[i] = c\n                return (canonicalize_stable(new_state), (\"1-Change\", \"Conflict-Driven-Recolor\"))\n        # try Kempe swap with a neighbor color that reduces same-color neighbors\n        neigh_colors = sorted({curr[j] for j in adj[i]})\n        base_same = sum(1 for j in adj[i] if curr[j] == curr[i])\n        for b in neigh_colors:\n            a = curr[i]\n            trial = kempe_swap(curr, a, b, i)\n            # accept if it reduces or keeps local same-color count, and does not explode conflicts\n            new_same = sum(1 for j in adj[i] if trial[j] == trial[i])\n            if new_same <= base_same and conflict_count(trial) <= conflict_count(curr) + 1:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Conflict-Driven-Swap\"))\n        # fallback: no change\n        return (curr, (\"NoMove\", \"Stall\"))\n\n    # No conflicts: try color elimination of highest color with limited backtracking\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n    hv = color_vertices.get(highest, [])\n    if hv:\n        order = sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n        trial = curr[:]\n        palette = list(range(1, highest))\n\n        def backtrack(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            for c in palette:\n                if feasible_color(v, c, trial):\n                    old = trial[v]\n                    trial[v] = c\n                    if backtrack(idx+1):\n                        return True\n                    trial[v] = old\n            return False\n\n        if backtrack(0):\n            trial2 = [x if x != highest else highest for x in trial]\n            # remove empty class via canonicalization\n            return (canonicalize_stable(trial2), (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # Gentle greedy reduction: move one vertex from highest color to a lower color\n    if hv:\n        for v in sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True):\n            for c in range(1, highest):\n                if feasible_color(v, c, curr):\n                    new_state = curr[:]\n                    new_state[v] = c\n                    return (canonicalize_stable(new_state), (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap involving highest and another color (feasibility preserved)\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a = highest\n        b = random.choice([c for c in colors if c != a])\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            return (canonicalize_stable(kempe_swap(curr, a, b, r)), (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: return unchanged\n    return (curr, (\"NoMove\", \"NoChange\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = deque([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across pairs involving the largest color class\n    colors = sorted(set(curr))\n    class_sizes = {c: sum(1 for x in curr if x == c) for c in colors}\n    largest = max(colors, key=lambda c: class_sizes[c]) if colors else 1\n    t_swaps = 1 if len(colors) <= 3 else 2\n    for _ in range(t_swaps):\n        colors_now = sorted(set(curr))\n        if len(colors_now) >= 2:\n            a = largest if largest in colors_now else colors_now[-1]\n            b = random.choice([c for c in colors_now if c != a])\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize_stable(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify, then stabilize)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize_stable(curr)\n\n    # 3) Random removal and greedy reinsertion for a subset (shake-and-repair)\n    k = len(set(curr)) if curr else 1\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n\n    order = sorted(idxs, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k))) if k > 1 else [1]\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            new_c = (max([x for x in curr if isinstance(x, int)], default=0) + 1)\n            curr[i] = new_c\n            k = len(set([x for x in curr if isinstance(x, int) and x > 0]))\n\n    curr = [1 if x == 0 else x for x in curr]\n    curr = canonicalize_stable(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0016836709}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation and normalization penalties\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Stable tie-breaker on color class sizes\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n    # Sanitize entries\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization: relabel colors by sorting colors by smallest vertex index they appear on\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i]})\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # Helper: count conflicts quickly\n    def conflict_count(state: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges0:\n            if state[u] == state[v]:\n                cnt += 1\n        return cnt\n\n    # Move 1: Conflict-driven recolor with deterministic tie-breaking\n    if conflicts:\n        # vertices involved in a conflict\n        involved = sorted({u for uv in conflicts for u in uv})\n        # choose vertex with max conflict degree, then higher saturation, then higher static degree, then lower index\n        deg = [len(adj[i]) for i in range(n)]\n        best_i = max(involved, key=lambda i: (conflict_deg[i], sat_deg(i, curr), deg[i], -i))\n        i = best_i\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        for c in range(1, max_col+1):\n            if c != curr[i] and feasible_color(i, c, curr):\n                new_state = curr[:]\n                new_state[i] = c\n                return (canonicalize_stable(new_state), (\"1-Change\", \"Conflict-Driven-Recolor\"))\n        # try Kempe swap with a neighbor color that reduces same-color neighbors\n        neigh_colors = sorted({curr[j] for j in adj[i]})\n        base_same = sum(1 for j in adj[i] if curr[j] == curr[i])\n        for b in neigh_colors:\n            a = curr[i]\n            trial = kempe_swap(curr, a, b, i)\n            # accept if it reduces or keeps local same-color count, and does not explode conflicts\n            new_same = sum(1 for j in adj[i] if trial[j] == trial[i])\n            if new_same <= base_same and conflict_count(trial) <= conflict_count(curr) + 1:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Conflict-Driven-Swap\"))\n        # fallback: no change\n        return (curr, (\"NoMove\", \"Stall\"))\n\n    # No conflicts: try color elimination of highest color with limited backtracking\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n    hv = color_vertices.get(highest, [])\n    if hv:\n        order = sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n        trial = curr[:]\n        palette = list(range(1, highest))\n\n        def backtrack(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            for c in palette:\n                if feasible_color(v, c, trial):\n                    old = trial[v]\n                    trial[v] = c\n                    if backtrack(idx+1):\n                        return True\n                    trial[v] = old\n            return False\n\n        if backtrack(0):\n            trial2 = [x if x != highest else highest for x in trial]\n            # remove empty class via canonicalization\n            return (canonicalize_stable(trial2), (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # Gentle greedy reduction: move one vertex from highest color to a lower color\n    if hv:\n        for v in sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True):\n            for c in range(1, highest):\n                if feasible_color(v, c, curr):\n                    new_state = curr[:]\n                    new_state[v] = c\n                    return (canonicalize_stable(new_state), (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap involving highest and another color (feasibility preserved)\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a = highest\n        b = random.choice([c for c in colors if c != a])\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            return (canonicalize_stable(kempe_swap(curr, a, b, r)), (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: return unchanged\n    return (curr, (\"NoMove\", \"NoChange\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = deque([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across pairs involving the largest color class\n    colors = sorted(set(curr))\n    class_sizes = {c: sum(1 for x in curr if x == c) for c in colors}\n    largest = max(colors, key=lambda c: class_sizes[c]) if colors else 1\n    t_swaps = 1 if len(colors) <= 3 else 2\n    for _ in range(t_swaps):\n        colors_now = sorted(set(curr))\n        if len(colors_now) >= 2:\n            a = largest if largest in colors_now else colors_now[-1]\n            b = random.choice([c for c in colors_now if c != a])\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize_stable(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify, then stabilize)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize_stable(curr)\n\n    # 3) Random removal and greedy reinsertion for a subset (shake-and-repair)\n    k = len(set(curr)) if curr else 1\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n\n    order = sorted(idxs, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k))) if k > 1 else [1]\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            new_c = (max([x for x in curr if isinstance(x, int)], default=0) + 1)\n            curr[i] = new_c\n            k = len(set([x for x in curr if isinstance(x, int) and x > 0]))\n\n    curr = [1 if x == 0 else x for x in curr]\n    curr = canonicalize_stable(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.002147096}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation and normalization penalties\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Stable tie-breaker on color class sizes\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n    # Sanitize entries\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization: relabel colors by sorting colors by smallest vertex index they appear on\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i]})\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # Helper: count conflicts quickly\n    def conflict_count(state: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges0:\n            if state[u] == state[v]:\n                cnt += 1\n        return cnt\n\n    # Move 1: Conflict-driven recolor with deterministic tie-breaking\n    if conflicts:\n        # vertices involved in a conflict\n        involved = sorted({u for uv in conflicts for u in uv})\n        # choose vertex with max conflict degree, then higher saturation, then higher static degree, then lower index\n        deg = [len(adj[i]) for i in range(n)]\n        best_i = max(involved, key=lambda i: (conflict_deg[i], sat_deg(i, curr), deg[i], -i))\n        i = best_i\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        for c in range(1, max_col+1):\n            if c != curr[i] and feasible_color(i, c, curr):\n                new_state = curr[:]\n                new_state[i] = c\n                return (canonicalize_stable(new_state), (\"1-Change\", \"Conflict-Driven-Recolor\"))\n        # try Kempe swap with a neighbor color that reduces same-color neighbors\n        neigh_colors = sorted({curr[j] for j in adj[i]})\n        base_same = sum(1 for j in adj[i] if curr[j] == curr[i])\n        for b in neigh_colors:\n            a = curr[i]\n            trial = kempe_swap(curr, a, b, i)\n            # accept if it reduces or keeps local same-color count, and does not explode conflicts\n            new_same = sum(1 for j in adj[i] if trial[j] == trial[i])\n            if new_same <= base_same and conflict_count(trial) <= conflict_count(curr) + 1:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Conflict-Driven-Swap\"))\n        # fallback: no change\n        return (curr, (\"NoMove\", \"Stall\"))\n\n    # No conflicts: try color elimination of highest color with limited backtracking\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n    hv = color_vertices.get(highest, [])\n    if hv:\n        order = sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n        trial = curr[:]\n        palette = list(range(1, highest))\n\n        def backtrack(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            for c in palette:\n                if feasible_color(v, c, trial):\n                    old = trial[v]\n                    trial[v] = c\n                    if backtrack(idx+1):\n                        return True\n                    trial[v] = old\n            return False\n\n        if backtrack(0):\n            trial2 = [x if x != highest else highest for x in trial]\n            # remove empty class via canonicalization\n            return (canonicalize_stable(trial2), (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # Gentle greedy reduction: move one vertex from highest color to a lower color\n    if hv:\n        for v in sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True):\n            for c in range(1, highest):\n                if feasible_color(v, c, curr):\n                    new_state = curr[:]\n                    new_state[v] = c\n                    return (canonicalize_stable(new_state), (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap involving highest and another color (feasibility preserved)\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a = highest\n        b = random.choice([c for c in colors if c != a])\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            return (canonicalize_stable(kempe_swap(curr, a, b, r)), (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: return unchanged\n    return (curr, (\"NoMove\", \"NoChange\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = deque([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across pairs involving the largest color class\n    colors = sorted(set(curr))\n    class_sizes = {c: sum(1 for x in curr if x == c) for c in colors}\n    largest = max(colors, key=lambda c: class_sizes[c]) if colors else 1\n    t_swaps = 1 if len(colors) <= 3 else 2\n    for _ in range(t_swaps):\n        colors_now = sorted(set(curr))\n        if len(colors_now) >= 2:\n            a = largest if largest in colors_now else colors_now[-1]\n            b = random.choice([c for c in colors_now if c != a])\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize_stable(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify, then stabilize)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize_stable(curr)\n\n    # 3) Random removal and greedy reinsertion for a subset (shake-and-repair)\n    k = len(set(curr)) if curr else 1\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n\n    order = sorted(idxs, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k))) if k > 1 else [1]\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            new_c = (max([x for x in curr if isinstance(x, int)], default=0) + 1)\n            curr[i] = new_c\n            k = len(set([x for x in curr if isinstance(x, int) and x > 0]))\n\n    curr = [1 if x == 0 else x for x in curr]\n    curr = canonicalize_stable(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.002142156}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation and normalization penalties\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Stable tie-breaker on color class sizes\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization: relabel colors by first appearance\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    def conflict_edges(state: List[int]) -> List[Tuple[int,int]]:\n        res = []\n        for (u, v) in edges0:\n            if state[u] == state[v]:\n                res.append((u, v))\n        return res\n\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    conflicts = conflict_edges(curr)\n    max_col = max(curr) if curr else 1\n\n    # 1) If conflicts exist: conflict-driven recolor (ensure a change)\n    if conflicts:\n        involved = sorted({u for e in conflicts for u in e})\n        # pick vertex with largest number of conflicts, break ties by degree desc, then index asc\n        deg = [len(adj[i]) for i in range(n)]\n        conf_deg = [0]*n\n        for u, v in conflicts:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n        i = max(involved, key=lambda x: (conf_deg[x], deg[x], -x))\n        # try recolor to any feasible existing color\n        for c in range(1, max_col+1):\n            if c != curr[i] and feasible_color(i, c, curr):\n                new_state = curr[:]\n                new_state[i] = c\n                return (canonicalize_stable(new_state), (\"1-Change\", \"Conflict-Recolor\"))\n        # try kempe swap with a neighbor color\n        neigh_colors = sorted({curr[j] for j in adj[i]})\n        for b in neigh_colors:\n            a = curr[i]\n            trial = kempe_swap(curr, a, b, i)\n            if trial != curr:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Conflict-Swap\"))\n        # deterministic fallback: rotate color of the chosen vertex (ensures change)\n        new_state = curr[:]\n        new_state[i] = (curr[i] % max_col) + 1\n        return (canonicalize_stable(new_state), (\"1-Change\", \"Rotate-Color\"))\n\n    # 2) No conflicts: attempt to reduce number of colors by eliminating highest color\n    k = max_col\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n    highest = k\n    hv = color_vertices.get(highest, [])\n    if hv:\n        # greedy try move vertices from highest to lower colors\n        for v in sorted(hv, key=lambda i: (len(adj[i]), -i), reverse=True):\n            for c in range(1, highest):\n                if feasible_color(v, c, curr):\n                    new_state = curr[:]\n                    new_state[v] = c\n                    return (canonicalize_stable(new_state), (\"1-Change\", \"Greedy-Reduction\"))\n    # 3) Diversification via Kempe swap between two random existing colors\n    colors = sorted(set(curr))\n    if len(colors) >= 2:\n        a = colors[-1]\n        b = random.choice(colors[:-1])\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            trial = kempe_swap(curr, a, b, r)\n            if trial != curr:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Diversification\"))\n    # 4) Final fallback: relabel a random vertex to an existing color (always changes)\n    i = random.randrange(n)\n    avail = [c for c in colors if c != curr[i]]\n    if not avail:\n        avail = [1 if curr[i] != 1 else 2]\n    new_state = curr[:]\n    new_state[i] = random.choice(avail)\n    return (canonicalize_stable(new_state), (\"1-Change\", \"Random-Relabel\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Shake 1: apply 1-2 Kempe-chain swaps involving the largest color class\n    colors = sorted(set(curr))\n    if colors:\n        class_sizes = {c: sum(1 for x in curr if x == c) for c in colors}\n        largest = max(colors, key=lambda c: class_sizes[c])\n        t_swaps = 1 if len(colors) <= 3 else 2\n        for _ in range(t_swaps):\n            colors_now = sorted(set(curr))\n            if len(colors_now) >= 2:\n                a = largest if largest in colors_now else colors_now[-1]\n                b = random.choice([c for c in colors_now if c != a])\n                cand = [i for i, c in enumerate(curr) if c in (a, b)]\n                if cand:\n                    r = random.choice(cand)\n                    # BFS over the subgraph induced by colors a and b\n                    from collections import deque as _dq\n                    q = _dq([r])\n                    vis = [False]*n\n                    vis[r] = True\n                    comp = [r]\n                    while q:\n                        u = q.popleft()\n                        for w in adj[u]:\n                            if not vis[w] and curr[w] in (a, b):\n                                vis[w] = True\n                                q.append(w)\n                                comp.append(w)\n                    for u in comp:\n                        curr[u] = a if curr[u] == b else (b if curr[u] == a else curr[u])\n                    curr = canonicalize_stable(curr)\n\n    # Shake 2: random permutation of color labels\n    colors = sorted(set(curr))\n    if colors:\n        perm = colors[:]\n        random.shuffle(perm)\n        remap = {c: perm[idx] for idx, c in enumerate(colors)}\n        curr = [remap[c] for c in curr]\n        curr = canonicalize_stable(curr)\n\n    # Shake 3: remove a few vertices and greedily reinsert\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    removed_vals = {i: curr[i] for i in idxs}\n    for i in idxs:\n        curr[i] = 0\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n\n    order = sorted(idxs, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n    palette_base = sorted(set([x for x in curr if x > 0]))\n    for i in order:\n        placed = False\n        palette = palette_base[:]\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # fallback to previous color if feasible\n            oldc = removed_vals[i]\n            if oldc > 0 and feasible_color(i, oldc, curr):\n                curr[i] = oldc\n                placed = True\n        if not placed:\n            # open a new color sparingly\n            new_c = (max([x for x in curr if isinstance(x, int)], default=0) + 1)\n            curr[i] = new_c\n            palette_base = sorted(set([x for x in curr if x > 0]))\n\n    curr = [1 if x == 0 else x for x in curr]\n    curr = canonicalize_stable(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001388277}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation and normalization penalties\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Stable tie-breaker on color class sizes\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization: relabel colors by first appearance\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    def conflict_edges(state: List[int]) -> List[Tuple[int,int]]:\n        res = []\n        for (u, v) in edges0:\n            if state[u] == state[v]:\n                res.append((u, v))\n        return res\n\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    conflicts = conflict_edges(curr)\n    max_col = max(curr) if curr else 1\n\n    # 1) If conflicts exist: conflict-driven recolor (ensure a change)\n    if conflicts:\n        involved = sorted({u for e in conflicts for u in e})\n        # pick vertex with largest number of conflicts, break ties by degree desc, then index asc\n        deg = [len(adj[i]) for i in range(n)]\n        conf_deg = [0]*n\n        for u, v in conflicts:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n        i = max(involved, key=lambda x: (conf_deg[x], deg[x], -x))\n        # try recolor to any feasible existing color\n        for c in range(1, max_col+1):\n            if c != curr[i] and feasible_color(i, c, curr):\n                new_state = curr[:]\n                new_state[i] = c\n                return (canonicalize_stable(new_state), (\"1-Change\", \"Conflict-Recolor\"))\n        # try kempe swap with a neighbor color\n        neigh_colors = sorted({curr[j] for j in adj[i]})\n        for b in neigh_colors:\n            a = curr[i]\n            trial = kempe_swap(curr, a, b, i)\n            if trial != curr:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Conflict-Swap\"))\n        # deterministic fallback: rotate color of the chosen vertex (ensures change)\n        new_state = curr[:]\n        new_state[i] = (curr[i] % max_col) + 1\n        return (canonicalize_stable(new_state), (\"1-Change\", \"Rotate-Color\"))\n\n    # 2) No conflicts: attempt to reduce number of colors by eliminating highest color\n    k = max_col\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n    highest = k\n    hv = color_vertices.get(highest, [])\n    if hv:\n        # greedy try move vertices from highest to lower colors\n        for v in sorted(hv, key=lambda i: (len(adj[i]), -i), reverse=True):\n            for c in range(1, highest):\n                if feasible_color(v, c, curr):\n                    new_state = curr[:]\n                    new_state[v] = c\n                    return (canonicalize_stable(new_state), (\"1-Change\", \"Greedy-Reduction\"))\n    # 3) Diversification via Kempe swap between two random existing colors\n    colors = sorted(set(curr))\n    if len(colors) >= 2:\n        a = colors[-1]\n        b = random.choice(colors[:-1])\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            trial = kempe_swap(curr, a, b, r)\n            if trial != curr:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Diversification\"))\n    # 4) Final fallback: relabel a random vertex to an existing color (always changes)\n    i = random.randrange(n)\n    avail = [c for c in colors if c != curr[i]]\n    if not avail:\n        avail = [1 if curr[i] != 1 else 2]\n    new_state = curr[:]\n    new_state[i] = random.choice(avail)\n    return (canonicalize_stable(new_state), (\"1-Change\", \"Random-Relabel\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Shake 1: apply 1-2 Kempe-chain swaps involving the largest color class\n    colors = sorted(set(curr))\n    if colors:\n        class_sizes = {c: sum(1 for x in curr if x == c) for c in colors}\n        largest = max(colors, key=lambda c: class_sizes[c])\n        t_swaps = 1 if len(colors) <= 3 else 2\n        for _ in range(t_swaps):\n            colors_now = sorted(set(curr))\n            if len(colors_now) >= 2:\n                a = largest if largest in colors_now else colors_now[-1]\n                b = random.choice([c for c in colors_now if c != a])\n                cand = [i for i, c in enumerate(curr) if c in (a, b)]\n                if cand:\n                    r = random.choice(cand)\n                    # BFS over the subgraph induced by colors a and b\n                    from collections import deque as _dq\n                    q = _dq([r])\n                    vis = [False]*n\n                    vis[r] = True\n                    comp = [r]\n                    while q:\n                        u = q.popleft()\n                        for w in adj[u]:\n                            if not vis[w] and curr[w] in (a, b):\n                                vis[w] = True\n                                q.append(w)\n                                comp.append(w)\n                    for u in comp:\n                        curr[u] = a if curr[u] == b else (b if curr[u] == a else curr[u])\n                    curr = canonicalize_stable(curr)\n\n    # Shake 2: random permutation of color labels\n    colors = sorted(set(curr))\n    if colors:\n        perm = colors[:]\n        random.shuffle(perm)\n        remap = {c: perm[idx] for idx, c in enumerate(colors)}\n        curr = [remap[c] for c in curr]\n        curr = canonicalize_stable(curr)\n\n    # Shake 3: remove a few vertices and greedily reinsert\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    removed_vals = {i: curr[i] for i in idxs}\n    for i in idxs:\n        curr[i] = 0\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n\n    order = sorted(idxs, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n    palette_base = sorted(set([x for x in curr if x > 0]))\n    for i in order:\n        placed = False\n        palette = palette_base[:]\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # fallback to previous color if feasible\n            oldc = removed_vals[i]\n            if oldc > 0 and feasible_color(i, oldc, curr):\n                curr[i] = oldc\n                placed = True\n        if not placed:\n            # open a new color sparingly\n            new_c = (max([x for x in curr if isinstance(x, int)], default=0) + 1)\n            curr[i] = new_c\n            palette_base = sorted(set([x for x in curr if x > 0]))\n\n    curr = [1 if x == 0 else x for x in curr]\n    curr = canonicalize_stable(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001940883}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation and normalization penalties\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Stable tie-breaker on color class sizes\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization: relabel colors by first appearance\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    def conflict_edges(state: List[int]) -> List[Tuple[int,int]]:\n        res = []\n        for (u, v) in edges0:\n            if state[u] == state[v]:\n                res.append((u, v))\n        return res\n\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    conflicts = conflict_edges(curr)\n    max_col = max(curr) if curr else 1\n\n    # 1) If conflicts exist: conflict-driven recolor (ensure a change)\n    if conflicts:\n        involved = sorted({u for e in conflicts for u in e})\n        # pick vertex with largest number of conflicts, break ties by degree desc, then index asc\n        deg = [len(adj[i]) for i in range(n)]\n        conf_deg = [0]*n\n        for u, v in conflicts:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n        i = max(involved, key=lambda x: (conf_deg[x], deg[x], -x))\n        # try recolor to any feasible existing color\n        for c in range(1, max_col+1):\n            if c != curr[i] and feasible_color(i, c, curr):\n                new_state = curr[:]\n                new_state[i] = c\n                return (canonicalize_stable(new_state), (\"1-Change\", \"Conflict-Recolor\"))\n        # try kempe swap with a neighbor color\n        neigh_colors = sorted({curr[j] for j in adj[i]})\n        for b in neigh_colors:\n            a = curr[i]\n            trial = kempe_swap(curr, a, b, i)\n            if trial != curr:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Conflict-Swap\"))\n        # deterministic fallback: rotate color of the chosen vertex (ensures change)\n        new_state = curr[:]\n        new_state[i] = (curr[i] % max_col) + 1\n        return (canonicalize_stable(new_state), (\"1-Change\", \"Rotate-Color\"))\n\n    # 2) No conflicts: attempt to reduce number of colors by eliminating highest color\n    k = max_col\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n    highest = k\n    hv = color_vertices.get(highest, [])\n    if hv:\n        # greedy try move vertices from highest to lower colors\n        for v in sorted(hv, key=lambda i: (len(adj[i]), -i), reverse=True):\n            for c in range(1, highest):\n                if feasible_color(v, c, curr):\n                    new_state = curr[:]\n                    new_state[v] = c\n                    return (canonicalize_stable(new_state), (\"1-Change\", \"Greedy-Reduction\"))\n    # 3) Diversification via Kempe swap between two random existing colors\n    colors = sorted(set(curr))\n    if len(colors) >= 2:\n        a = colors[-1]\n        b = random.choice(colors[:-1])\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            trial = kempe_swap(curr, a, b, r)\n            if trial != curr:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Diversification\"))\n    # 4) Final fallback: relabel a random vertex to an existing color (always changes)\n    i = random.randrange(n)\n    avail = [c for c in colors if c != curr[i]]\n    if not avail:\n        avail = [1 if curr[i] != 1 else 2]\n    new_state = curr[:]\n    new_state[i] = random.choice(avail)\n    return (canonicalize_stable(new_state), (\"1-Change\", \"Random-Relabel\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Shake 1: apply 1-2 Kempe-chain swaps involving the largest color class\n    colors = sorted(set(curr))\n    if colors:\n        class_sizes = {c: sum(1 for x in curr if x == c) for c in colors}\n        largest = max(colors, key=lambda c: class_sizes[c])\n        t_swaps = 1 if len(colors) <= 3 else 2\n        for _ in range(t_swaps):\n            colors_now = sorted(set(curr))\n            if len(colors_now) >= 2:\n                a = largest if largest in colors_now else colors_now[-1]\n                b = random.choice([c for c in colors_now if c != a])\n                cand = [i for i, c in enumerate(curr) if c in (a, b)]\n                if cand:\n                    r = random.choice(cand)\n                    # BFS over the subgraph induced by colors a and b\n                    from collections import deque as _dq\n                    q = _dq([r])\n                    vis = [False]*n\n                    vis[r] = True\n                    comp = [r]\n                    while q:\n                        u = q.popleft()\n                        for w in adj[u]:\n                            if not vis[w] and curr[w] in (a, b):\n                                vis[w] = True\n                                q.append(w)\n                                comp.append(w)\n                    for u in comp:\n                        curr[u] = a if curr[u] == b else (b if curr[u] == a else curr[u])\n                    curr = canonicalize_stable(curr)\n\n    # Shake 2: random permutation of color labels\n    colors = sorted(set(curr))\n    if colors:\n        perm = colors[:]\n        random.shuffle(perm)\n        remap = {c: perm[idx] for idx, c in enumerate(colors)}\n        curr = [remap[c] for c in curr]\n        curr = canonicalize_stable(curr)\n\n    # Shake 3: remove a few vertices and greedily reinsert\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    removed_vals = {i: curr[i] for i in idxs}\n    for i in idxs:\n        curr[i] = 0\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n\n    order = sorted(idxs, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n    palette_base = sorted(set([x for x in curr if x > 0]))\n    for i in order:\n        placed = False\n        palette = palette_base[:]\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # fallback to previous color if feasible\n            oldc = removed_vals[i]\n            if oldc > 0 and feasible_color(i, oldc, curr):\n                curr[i] = oldc\n                placed = True\n        if not placed:\n            # open a new color sparingly\n            new_c = (max([x for x in curr if isinstance(x, int)], default=0) + 1)\n            curr[i] = new_c\n            palette_base = sorted(set([x for x in curr if x > 0]))\n\n    curr = [1 if x == 0 else x for x in curr]\n    curr = canonicalize_stable(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001987424}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS. Example: \"1,2,3,4,1,2,3,4,1\". Each position i in [1..9] is color c_i in {1,2,...,k}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001983823}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS. Example: \"1,2,3,4,1,2,3,4,1\". Each position i in [1..9] is color c_i in {1,2,...,k}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001760551}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS. Example: \"1,2,3,4,1,2,3,4,1\". Each position i in [1..9] is color c_i in {1,2,...,k}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.002669032}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.002091225}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0018763121}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.002350967}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily and skip expensive checks\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    memo = {}\n    def k_colorable(k):\n        if k in memo:\n            return memo[k]\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        res = backtrack()\n        memo[k] = res\n        return res\n\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    # determine current k and allowed palette; allow attempts to reduce colors periodically\n    k_hat = max(1, max(colors))\n\n    color_list = list(colors)\n\n    # Build conflict frequency and neighbors for quick checks\n    neighbors_list = [set() for _ in range(n)]\n    for (u,v) in edges:\n        neighbors_list[u-1].add(v-1)\n        neighbors_list[v-1].add(u-1)\n\n    conflict_vertices = set()\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n\n    # With small probability, try a color-reduction move targeting color k_hat\n    if random.random() < 0.2 and k_hat > 1:\n        targets = [i for i,c in enumerate(color_list) if c == k_hat]\n        shuffled = targets[:]\n        random.shuffle(shuffled)\n        feasible = True\n        for idx in shuffled:\n            neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n            choices = [c for c in range(1, k_hat) if c not in neighbor_colors]\n            if choices:\n                color_list[idx] = random.choice(choices)\n            else:\n                feasible = False\n                break\n        if feasible:\n            # successful color drop; normalize if any gap remains\n            new_str = stringify(color_list)\n            return new_str, \"NB_Recolor\", \"Color-Reduce\"\n        # fallback to standard move below\n\n    # Select a vertex: prioritize conflicts; else max-degree random choice\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices))\n    else:\n        # choose a vertex with higher degree more often\n        weights = [len(neighbors_list[i]) for i in range(n)]\n        total = sum(weights)\n        r = random.uniform(0, total)\n        acc = 0.0\n        idx = 0\n        for i,w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n\n    current_color = color_list[idx]\n    neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n\n    # palette allows staying within [1..k_hat], but also try smaller colors first\n    choices = [c for c in range(1, k_hat+1) if c != current_color and c not in neighbor_colors]\n    if not choices:\n        # if no conflict-free color within [1..k_hat], allow a random recolor (may be conflicting) to escape\n        palette_max = max(2, k_hat)\n        choices = [c for c in range(1, palette_max+1) if c != current_color]\n    # greedy bias to smallest feasible color\n    if choices:\n        # 70% choose smallest, else random\n        if random.random() < 0.7:\n            new_color = min(choices)\n        else:\n            new_color = random.choice(choices)\n        color_list[idx] = new_color\n\n    new_str = stringify(color_list)\n    return new_str, \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    k_hat = max(1, max(colors))\n\n    # Strategy: pick a random edge, perform a Kempe-chain swap between two colors across the component; fallback to random multi-vertex recolor.\n    color_list = list(colors)\n\n    # Build adjacency list\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Try Kempe-chain swap with probability 0.7\n    if random.random() < 0.7:\n        # choose a random vertex and a random alternate color from [1..max(k_hat,3)]\n        v = random.randrange(n)\n        cur = color_list[v]\n        palette_max = max(3, k_hat)\n        alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n        if alt_choices:\n            alt = random.choice(alt_choices)\n            # BFS over subgraph induced by colors {cur, alt}\n            stack = [v]\n            seen = set([v])\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y not in seen and color_list[y] in (cur, alt):\n                        seen.add(y)\n                        stack.append(y)\n            # swap colors along the Kempe chain\n            for u in seen:\n                color_list[u] = alt if color_list[u] == cur else cur\n            return stringify(color_list)\n\n    # Fallback: recolor t vertices with expanded palette to shake\n    palette_max = max(3, k_hat)\n    q = random.randint(2, 4)\n    idxs = random.sample(range(n), q)\n    for idx in idxs:\n        cur = color_list[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        color_list[idx] = random.choice(choices)\n\n    return stringify(color_list)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.002215356}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily and skip expensive checks\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    memo = {}\n    def k_colorable(k):\n        if k in memo:\n            return memo[k]\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        res = backtrack()\n        memo[k] = res\n        return res\n\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    # determine current k and allowed palette; allow attempts to reduce colors periodically\n    k_hat = max(1, max(colors))\n\n    color_list = list(colors)\n\n    # Build conflict frequency and neighbors for quick checks\n    neighbors_list = [set() for _ in range(n)]\n    for (u,v) in edges:\n        neighbors_list[u-1].add(v-1)\n        neighbors_list[v-1].add(u-1)\n\n    conflict_vertices = set()\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n\n    # With small probability, try a color-reduction move targeting color k_hat\n    if random.random() < 0.2 and k_hat > 1:\n        targets = [i for i,c in enumerate(color_list) if c == k_hat]\n        shuffled = targets[:]\n        random.shuffle(shuffled)\n        feasible = True\n        for idx in shuffled:\n            neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n            choices = [c for c in range(1, k_hat) if c not in neighbor_colors]\n            if choices:\n                color_list[idx] = random.choice(choices)\n            else:\n                feasible = False\n                break\n        if feasible:\n            # successful color drop; normalize if any gap remains\n            new_str = stringify(color_list)\n            return new_str, \"NB_Recolor\", \"Color-Reduce\"\n        # fallback to standard move below\n\n    # Select a vertex: prioritize conflicts; else max-degree random choice\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices))\n    else:\n        # choose a vertex with higher degree more often\n        weights = [len(neighbors_list[i]) for i in range(n)]\n        total = sum(weights)\n        r = random.uniform(0, total)\n        acc = 0.0\n        idx = 0\n        for i,w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n\n    current_color = color_list[idx]\n    neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n\n    # palette allows staying within [1..k_hat], but also try smaller colors first\n    choices = [c for c in range(1, k_hat+1) if c != current_color and c not in neighbor_colors]\n    if not choices:\n        # if no conflict-free color within [1..k_hat], allow a random recolor (may be conflicting) to escape\n        palette_max = max(2, k_hat)\n        choices = [c for c in range(1, palette_max+1) if c != current_color]\n    # greedy bias to smallest feasible color\n    if choices:\n        # 70% choose smallest, else random\n        if random.random() < 0.7:\n            new_color = min(choices)\n        else:\n            new_color = random.choice(choices)\n        color_list[idx] = new_color\n\n    new_str = stringify(color_list)\n    return new_str, \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    k_hat = max(1, max(colors))\n\n    # Strategy: pick a random edge, perform a Kempe-chain swap between two colors across the component; fallback to random multi-vertex recolor.\n    color_list = list(colors)\n\n    # Build adjacency list\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Try Kempe-chain swap with probability 0.7\n    if random.random() < 0.7:\n        # choose a random vertex and a random alternate color from [1..max(k_hat,3)]\n        v = random.randrange(n)\n        cur = color_list[v]\n        palette_max = max(3, k_hat)\n        alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n        if alt_choices:\n            alt = random.choice(alt_choices)\n            # BFS over subgraph induced by colors {cur, alt}\n            stack = [v]\n            seen = set([v])\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y not in seen and color_list[y] in (cur, alt):\n                        seen.add(y)\n                        stack.append(y)\n            # swap colors along the Kempe chain\n            for u in seen:\n                color_list[u] = alt if color_list[u] == cur else cur\n            return stringify(color_list)\n\n    # Fallback: recolor t vertices with expanded palette to shake\n    palette_max = max(3, k_hat)\n    q = random.randint(2, 4)\n    idxs = random.sample(range(n), q)\n    for idx in idxs:\n        cur = color_list[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        color_list[idx] = random.choice(choices)\n\n    return stringify(color_list)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0021675359}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily and skip expensive checks\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    memo = {}\n    def k_colorable(k):\n        if k in memo:\n            return memo[k]\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        res = backtrack()\n        memo[k] = res\n        return res\n\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    # determine current k and allowed palette; allow attempts to reduce colors periodically\n    k_hat = max(1, max(colors))\n\n    color_list = list(colors)\n\n    # Build conflict frequency and neighbors for quick checks\n    neighbors_list = [set() for _ in range(n)]\n    for (u,v) in edges:\n        neighbors_list[u-1].add(v-1)\n        neighbors_list[v-1].add(u-1)\n\n    conflict_vertices = set()\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n\n    # With small probability, try a color-reduction move targeting color k_hat\n    if random.random() < 0.2 and k_hat > 1:\n        targets = [i for i,c in enumerate(color_list) if c == k_hat]\n        shuffled = targets[:]\n        random.shuffle(shuffled)\n        feasible = True\n        for idx in shuffled:\n            neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n            choices = [c for c in range(1, k_hat) if c not in neighbor_colors]\n            if choices:\n                color_list[idx] = random.choice(choices)\n            else:\n                feasible = False\n                break\n        if feasible:\n            # successful color drop; normalize if any gap remains\n            new_str = stringify(color_list)\n            return new_str, \"NB_Recolor\", \"Color-Reduce\"\n        # fallback to standard move below\n\n    # Select a vertex: prioritize conflicts; else max-degree random choice\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices))\n    else:\n        # choose a vertex with higher degree more often\n        weights = [len(neighbors_list[i]) for i in range(n)]\n        total = sum(weights)\n        r = random.uniform(0, total)\n        acc = 0.0\n        idx = 0\n        for i,w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n\n    current_color = color_list[idx]\n    neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n\n    # palette allows staying within [1..k_hat], but also try smaller colors first\n    choices = [c for c in range(1, k_hat+1) if c != current_color and c not in neighbor_colors]\n    if not choices:\n        # if no conflict-free color within [1..k_hat], allow a random recolor (may be conflicting) to escape\n        palette_max = max(2, k_hat)\n        choices = [c for c in range(1, palette_max+1) if c != current_color]\n    # greedy bias to smallest feasible color\n    if choices:\n        # 70% choose smallest, else random\n        if random.random() < 0.7:\n            new_color = min(choices)\n        else:\n            new_color = random.choice(choices)\n        color_list[idx] = new_color\n\n    new_str = stringify(color_list)\n    return new_str, \"NB_Recolor\", \"Single-Vertex\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    k_hat = max(1, max(colors))\n\n    # Strategy: pick a random edge, perform a Kempe-chain swap between two colors across the component; fallback to random multi-vertex recolor.\n    color_list = list(colors)\n\n    # Build adjacency list\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Try Kempe-chain swap with probability 0.7\n    if random.random() < 0.7:\n        # choose a random vertex and a random alternate color from [1..max(k_hat,3)]\n        v = random.randrange(n)\n        cur = color_list[v]\n        palette_max = max(3, k_hat)\n        alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n        if alt_choices:\n            alt = random.choice(alt_choices)\n            # BFS over subgraph induced by colors {cur, alt}\n            stack = [v]\n            seen = set([v])\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y not in seen and color_list[y] in (cur, alt):\n                        seen.add(y)\n                        stack.append(y)\n            # swap colors along the Kempe chain\n            for u in seen:\n                color_list[u] = alt if color_list[u] == cur else cur\n            return stringify(color_list)\n\n    # Fallback: recolor t vertices with expanded palette to shake\n    palette_max = max(3, k_hat)\n    q = random.randint(2, 4)\n    idxs = random.sample(range(n), q)\n    for idx in idxs:\n        cur = color_list[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        color_list[idx] = random.choice(choices)\n\n    return stringify(color_list)\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0024016181}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph instance (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    omega = 4  # precomputed max clique size for this fixed instance\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n                return out\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n                return out\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + 10_000.0*violations\n\n    # Feasible: compute objective k and a tiny tie-breaker\n    k_hat = max(colors) if colors else 0\n\n    # Lower-bound consistency (should not trigger for feasible but kept as guard)\n    lb_pen = 0.0\n    if k_hat < omega:\n        lb_pen = (omega - k_hat) * 1000.0\n\n    # Tiny tie-breaker to encourage compact palettes and smaller average color\n    avg_col = sum(colors)\/n\n    tie_break = 0.001 * (avg_col)\n\n    return float(k_hat) + lb_pen + tie_break\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n            return out\n        return [1]*n\n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        # force correct length\n        colors = (colors + [1]*n)[:n]\n\n    # Normalize palette to 1..k without gaps to reduce symmetry\n    def normalize_palette(col_list):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col_list:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    color_list = normalize_palette(list(colors))\n\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Helper: conflicts and degrees\n    conflicts = set()\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflicts.add(u-1); conflicts.add(v-1)\n\n    k_hat = max(1, max(color_list))\n\n    # Mode A: If no conflicts, try structured color reduction on max color\n    if not conflicts and k_hat > 1:\n        max_color = k_hat\n        targets = [i for i,c in enumerate(color_list) if c == max_color]\n        random.shuffle(targets)\n        moved = False\n        for idx in targets:\n            forbidden = {color_list[v] for v in adj[idx]}\n            choices = [c for c in range(1, max_color) if c not in forbidden]\n            if choices:\n                color_list[idx] = min(choices)\n                moved = True\n        if moved:\n            color_list = normalize_palette(color_list)\n            return stringify(color_list), \"NB_Recolor\", \"Color-Reduce\"\n        # If direct reduction failed, attempt a Kempe chain swap involving max color\n        v = random.choice(targets) if targets else random.randrange(n)\n        cur = color_list[v]\n        alt_pool = [c for c in range(1, max_color) if c != cur]\n        if alt_pool:\n            alt = random.choice(alt_pool)\n            # Kempe chain on colors {cur, alt}\n            stack = [v]; seen = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y not in seen and color_list[y] in (cur, alt):\n                        seen.add(y); stack.append(y)\n            for u in seen:\n                color_list[u] = alt if color_list[u] == cur else cur\n            color_list = normalize_palette(color_list)\n            return stringify(color_list), \"NB_Kempe\", \"Color-Pair-Swap\"\n\n    # Mode B: If conflicts exist, repair-biased single-vertex recolor or swap\n    if conflicts:\n        # pick vertex with highest number of same-colored neighbors to target conflict hot-spot\n        def conflict_weight(i):\n            c = color_list[i]\n            return sum(1 for v in adj[i] if color_list[v]==c)\n        idx = max(conflicts, key=conflict_weight)\n    else:\n        # no conflicts but no reduction; pick higher-degree vertex\n        degrees = [len(adj[i]) for i in range(n)]\n        total = sum(degrees)\n        r = random.uniform(0, max(1, total))\n        acc = 0.0\n        idx = 0\n        for i,w in enumerate(degrees):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n\n    cur = color_list[idx]\n    neighbor_cols = {color_list[v] for v in adj[idx]}\n\n    # 1) With some probability, try a two-vertex color swap along an edge to break stalemates\n    if random.random() < 0.25:\n        # find neighbor with different color and attempt swapping colors cur <-> that color if beneficial\n        candidates = [v for v in adj[idx] if color_list[v] != cur]\n        if candidates:\n            j = random.choice(candidates)\n            c2 = color_list[j]\n            # simulate swap and check if conflicts do not increase locally\n            def local_conflicts(i, newc):\n                return sum(1 for v in adj[i] if color_list[v] == newc and v != i)\n            before = local_conflicts(idx, cur) + local_conflicts(j, c2)\n            after = local_conflicts(idx, c2) + local_conflicts(j, cur)\n            if after <= before:\n                color_list[idx], color_list[j] = c2, cur\n                color_list = normalize_palette(color_list)\n                return stringify(color_list), \"NB_Swap\", \"Edge-Color-Swap\"\n\n    # 2) Else try greedy recolor with smallest feasible color within current palette\n    choices = [c for c in range(1, k_hat+1) if c != cur and c not in neighbor_cols]\n    if choices:\n        newc = min(choices) if random.random() < 0.8 else random.choice(choices)\n        color_list[idx] = newc\n        color_list = normalize_palette(color_list)\n        return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n\n    # 3) If no feasible within [1..k_hat], allow a Kempe chain recolor using an alternate color\n    palette_max = max(3, k_hat)\n    alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if alt_choices:\n        alt = random.choice(alt_choices)\n        stack = [idx]; seen = {idx}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and color_list[y] in (cur, alt):\n                    seen.add(y); stack.append(y)\n        for u in seen:\n            color_list[u] = alt if color_list[u] == cur else cur\n        color_list = normalize_palette(color_list)\n        return stringify(color_list), \"NB_Kempe\", \"Color-Pair-Swap\"\n\n    # 4) Fallback random recolor (escape move)\n    fallback_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if not fallback_choices:\n        fallback_choices = [cur]\n    color_list[idx] = random.choice(fallback_choices)\n    color_list = normalize_palette(color_list)\n    return stringify(color_list), \"NB_Recolor\", \"Escape\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed neighbor as a comma-separated string (no side effects)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n            return out\n        return [1]*n\n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    # Normalize palette to 1..k without gaps\n    def normalize_palette(col_list):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col_list:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    color_list = normalize_palette(list(colors))\n    k_hat = max(1, max(color_list))\n\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Primary: random Kempe chain swap on random vertex and alternate color\n    v = random.randrange(n)\n    cur = color_list[v]\n    palette_max = max(3, k_hat)\n    alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if alt_choices:\n        alt = random.choice(alt_choices)\n        stack = [v]; seen = {v}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and color_list[y] in (cur, alt):\n                    seen.add(y); stack.append(y)\n        for u in seen:\n            color_list[u] = alt if color_list[u] == cur else cur\n        return stringify(normalize_palette(color_list))\n\n    # Fallback: random multi-vertex recolor with expanded palette\n    q = random.randint(2, 4)\n    idxs = random.sample(range(n), q)\n    for idx in idxs:\n        c = color_list[idx]\n        choices = [x for x in range(1, palette_max+1) if x != c]\n        if not choices:\n            choices = [c]\n        color_list[idx] = random.choice(choices)\n    return stringify(normalize_palette(color_list))\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001430787}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph instance (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    omega = 4  # precomputed max clique size for this fixed instance\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n                return out\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n                return out\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + 10_000.0*violations\n\n    # Feasible: compute objective k and a tiny tie-breaker\n    k_hat = max(colors) if colors else 0\n\n    # Lower-bound consistency (should not trigger for feasible but kept as guard)\n    lb_pen = 0.0\n    if k_hat < omega:\n        lb_pen = (omega - k_hat) * 1000.0\n\n    # Tiny tie-breaker to encourage compact palettes and smaller average color\n    avg_col = sum(colors)\/n\n    tie_break = 0.001 * (avg_col)\n\n    return float(k_hat) + lb_pen + tie_break\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n            return out\n        return [1]*n\n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        # force correct length\n        colors = (colors + [1]*n)[:n]\n\n    # Normalize palette to 1..k without gaps to reduce symmetry\n    def normalize_palette(col_list):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col_list:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    color_list = normalize_palette(list(colors))\n\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Helper: conflicts and degrees\n    conflicts = set()\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflicts.add(u-1); conflicts.add(v-1)\n\n    k_hat = max(1, max(color_list))\n\n    # Mode A: If no conflicts, try structured color reduction on max color\n    if not conflicts and k_hat > 1:\n        max_color = k_hat\n        targets = [i for i,c in enumerate(color_list) if c == max_color]\n        random.shuffle(targets)\n        moved = False\n        for idx in targets:\n            forbidden = {color_list[v] for v in adj[idx]}\n            choices = [c for c in range(1, max_color) if c not in forbidden]\n            if choices:\n                color_list[idx] = min(choices)\n                moved = True\n        if moved:\n            color_list = normalize_palette(color_list)\n            return stringify(color_list), \"NB_Recolor\", \"Color-Reduce\"\n        # If direct reduction failed, attempt a Kempe chain swap involving max color\n        v = random.choice(targets) if targets else random.randrange(n)\n        cur = color_list[v]\n        alt_pool = [c for c in range(1, max_color) if c != cur]\n        if alt_pool:\n            alt = random.choice(alt_pool)\n            # Kempe chain on colors {cur, alt}\n            stack = [v]; seen = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y not in seen and color_list[y] in (cur, alt):\n                        seen.add(y); stack.append(y)\n            for u in seen:\n                color_list[u] = alt if color_list[u] == cur else cur\n            color_list = normalize_palette(color_list)\n            return stringify(color_list), \"NB_Kempe\", \"Color-Pair-Swap\"\n\n    # Mode B: If conflicts exist, repair-biased single-vertex recolor or swap\n    if conflicts:\n        # pick vertex with highest number of same-colored neighbors to target conflict hot-spot\n        def conflict_weight(i):\n            c = color_list[i]\n            return sum(1 for v in adj[i] if color_list[v]==c)\n        idx = max(conflicts, key=conflict_weight)\n    else:\n        # no conflicts but no reduction; pick higher-degree vertex\n        degrees = [len(adj[i]) for i in range(n)]\n        total = sum(degrees)\n        r = random.uniform(0, max(1, total))\n        acc = 0.0\n        idx = 0\n        for i,w in enumerate(degrees):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n\n    cur = color_list[idx]\n    neighbor_cols = {color_list[v] for v in adj[idx]}\n\n    # 1) With some probability, try a two-vertex color swap along an edge to break stalemates\n    if random.random() < 0.25:\n        # find neighbor with different color and attempt swapping colors cur <-> that color if beneficial\n        candidates = [v for v in adj[idx] if color_list[v] != cur]\n        if candidates:\n            j = random.choice(candidates)\n            c2 = color_list[j]\n            # simulate swap and check if conflicts do not increase locally\n            def local_conflicts(i, newc):\n                return sum(1 for v in adj[i] if color_list[v] == newc and v != i)\n            before = local_conflicts(idx, cur) + local_conflicts(j, c2)\n            after = local_conflicts(idx, c2) + local_conflicts(j, cur)\n            if after <= before:\n                color_list[idx], color_list[j] = c2, cur\n                color_list = normalize_palette(color_list)\n                return stringify(color_list), \"NB_Swap\", \"Edge-Color-Swap\"\n\n    # 2) Else try greedy recolor with smallest feasible color within current palette\n    choices = [c for c in range(1, k_hat+1) if c != cur and c not in neighbor_cols]\n    if choices:\n        newc = min(choices) if random.random() < 0.8 else random.choice(choices)\n        color_list[idx] = newc\n        color_list = normalize_palette(color_list)\n        return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n\n    # 3) If no feasible within [1..k_hat], allow a Kempe chain recolor using an alternate color\n    palette_max = max(3, k_hat)\n    alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if alt_choices:\n        alt = random.choice(alt_choices)\n        stack = [idx]; seen = {idx}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and color_list[y] in (cur, alt):\n                    seen.add(y); stack.append(y)\n        for u in seen:\n            color_list[u] = alt if color_list[u] == cur else cur\n        color_list = normalize_palette(color_list)\n        return stringify(color_list), \"NB_Kempe\", \"Color-Pair-Swap\"\n\n    # 4) Fallback random recolor (escape move)\n    fallback_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if not fallback_choices:\n        fallback_choices = [cur]\n    color_list[idx] = random.choice(fallback_choices)\n    color_list = normalize_palette(color_list)\n    return stringify(color_list), \"NB_Recolor\", \"Escape\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed neighbor as a comma-separated string (no side effects)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n            return out\n        return [1]*n\n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    # Normalize palette to 1..k without gaps\n    def normalize_palette(col_list):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col_list:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    color_list = normalize_palette(list(colors))\n    k_hat = max(1, max(color_list))\n\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Primary: random Kempe chain swap on random vertex and alternate color\n    v = random.randrange(n)\n    cur = color_list[v]\n    palette_max = max(3, k_hat)\n    alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if alt_choices:\n        alt = random.choice(alt_choices)\n        stack = [v]; seen = {v}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and color_list[y] in (cur, alt):\n                    seen.add(y); stack.append(y)\n        for u in seen:\n            color_list[u] = alt if color_list[u] == cur else cur\n        return stringify(normalize_palette(color_list))\n\n    # Fallback: random multi-vertex recolor with expanded palette\n    q = random.randint(2, 4)\n    idxs = random.sample(range(n), q)\n    for idx in idxs:\n        c = color_list[idx]\n        choices = [x for x in range(1, palette_max+1) if x != c]\n        if not choices:\n            choices = [c]\n        color_list[idx] = random.choice(choices)\n    return stringify(normalize_palette(color_list))\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0016643989}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph instance (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    omega = 4  # precomputed max clique size for this fixed instance\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n                return out\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n                return out\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + 10_000.0*violations\n\n    # Feasible: compute objective k and a tiny tie-breaker\n    k_hat = max(colors) if colors else 0\n\n    # Lower-bound consistency (should not trigger for feasible but kept as guard)\n    lb_pen = 0.0\n    if k_hat < omega:\n        lb_pen = (omega - k_hat) * 1000.0\n\n    # Tiny tie-breaker to encourage compact palettes and smaller average color\n    avg_col = sum(colors)\/n\n    tie_break = 0.001 * (avg_col)\n\n    return float(k_hat) + lb_pen + tie_break\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n            return out\n        return [1]*n\n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        # force correct length\n        colors = (colors + [1]*n)[:n]\n\n    # Normalize palette to 1..k without gaps to reduce symmetry\n    def normalize_palette(col_list):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col_list:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    color_list = normalize_palette(list(colors))\n\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Helper: conflicts and degrees\n    conflicts = set()\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflicts.add(u-1); conflicts.add(v-1)\n\n    k_hat = max(1, max(color_list))\n\n    # Mode A: If no conflicts, try structured color reduction on max color\n    if not conflicts and k_hat > 1:\n        max_color = k_hat\n        targets = [i for i,c in enumerate(color_list) if c == max_color]\n        random.shuffle(targets)\n        moved = False\n        for idx in targets:\n            forbidden = {color_list[v] for v in adj[idx]}\n            choices = [c for c in range(1, max_color) if c not in forbidden]\n            if choices:\n                color_list[idx] = min(choices)\n                moved = True\n        if moved:\n            color_list = normalize_palette(color_list)\n            return stringify(color_list), \"NB_Recolor\", \"Color-Reduce\"\n        # If direct reduction failed, attempt a Kempe chain swap involving max color\n        v = random.choice(targets) if targets else random.randrange(n)\n        cur = color_list[v]\n        alt_pool = [c for c in range(1, max_color) if c != cur]\n        if alt_pool:\n            alt = random.choice(alt_pool)\n            # Kempe chain on colors {cur, alt}\n            stack = [v]; seen = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y not in seen and color_list[y] in (cur, alt):\n                        seen.add(y); stack.append(y)\n            for u in seen:\n                color_list[u] = alt if color_list[u] == cur else cur\n            color_list = normalize_palette(color_list)\n            return stringify(color_list), \"NB_Kempe\", \"Color-Pair-Swap\"\n\n    # Mode B: If conflicts exist, repair-biased single-vertex recolor or swap\n    if conflicts:\n        # pick vertex with highest number of same-colored neighbors to target conflict hot-spot\n        def conflict_weight(i):\n            c = color_list[i]\n            return sum(1 for v in adj[i] if color_list[v]==c)\n        idx = max(conflicts, key=conflict_weight)\n    else:\n        # no conflicts but no reduction; pick higher-degree vertex\n        degrees = [len(adj[i]) for i in range(n)]\n        total = sum(degrees)\n        r = random.uniform(0, max(1, total))\n        acc = 0.0\n        idx = 0\n        for i,w in enumerate(degrees):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n\n    cur = color_list[idx]\n    neighbor_cols = {color_list[v] for v in adj[idx]}\n\n    # 1) With some probability, try a two-vertex color swap along an edge to break stalemates\n    if random.random() < 0.25:\n        # find neighbor with different color and attempt swapping colors cur <-> that color if beneficial\n        candidates = [v for v in adj[idx] if color_list[v] != cur]\n        if candidates:\n            j = random.choice(candidates)\n            c2 = color_list[j]\n            # simulate swap and check if conflicts do not increase locally\n            def local_conflicts(i, newc):\n                return sum(1 for v in adj[i] if color_list[v] == newc and v != i)\n            before = local_conflicts(idx, cur) + local_conflicts(j, c2)\n            after = local_conflicts(idx, c2) + local_conflicts(j, cur)\n            if after <= before:\n                color_list[idx], color_list[j] = c2, cur\n                color_list = normalize_palette(color_list)\n                return stringify(color_list), \"NB_Swap\", \"Edge-Color-Swap\"\n\n    # 2) Else try greedy recolor with smallest feasible color within current palette\n    choices = [c for c in range(1, k_hat+1) if c != cur and c not in neighbor_cols]\n    if choices:\n        newc = min(choices) if random.random() < 0.8 else random.choice(choices)\n        color_list[idx] = newc\n        color_list = normalize_palette(color_list)\n        return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n\n    # 3) If no feasible within [1..k_hat], allow a Kempe chain recolor using an alternate color\n    palette_max = max(3, k_hat)\n    alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if alt_choices:\n        alt = random.choice(alt_choices)\n        stack = [idx]; seen = {idx}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and color_list[y] in (cur, alt):\n                    seen.add(y); stack.append(y)\n        for u in seen:\n            color_list[u] = alt if color_list[u] == cur else cur\n        color_list = normalize_palette(color_list)\n        return stringify(color_list), \"NB_Kempe\", \"Color-Pair-Swap\"\n\n    # 4) Fallback random recolor (escape move)\n    fallback_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if not fallback_choices:\n        fallback_choices = [cur]\n    color_list[idx] = random.choice(fallback_choices)\n    color_list = normalize_palette(color_list)\n    return stringify(color_list), \"NB_Recolor\", \"Escape\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed neighbor as a comma-separated string (no side effects)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n            return out\n        return [1]*n\n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    # Normalize palette to 1..k without gaps\n    def normalize_palette(col_list):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col_list:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    color_list = normalize_palette(list(colors))\n    k_hat = max(1, max(color_list))\n\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Primary: random Kempe chain swap on random vertex and alternate color\n    v = random.randrange(n)\n    cur = color_list[v]\n    palette_max = max(3, k_hat)\n    alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n    if alt_choices:\n        alt = random.choice(alt_choices)\n        stack = [v]; seen = {v}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and color_list[y] in (cur, alt):\n                    seen.add(y); stack.append(y)\n        for u in seen:\n            color_list[u] = alt if color_list[u] == cur else cur\n        return stringify(normalize_palette(color_list))\n\n    # Fallback: random multi-vertex recolor with expanded palette\n    q = random.randint(2, 4)\n    idxs = random.sample(range(n), q)\n    for idx in idxs:\n        c = color_list[idx]\n        choices = [x for x in range(1, palette_max+1) if x != c]\n        if not choices:\n            choices = [c]\n        color_list[idx] = random.choice(choices)\n    return stringify(normalize_palette(color_list))\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001634829}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9. Encoding: a solution is a single CSV string of 9 positive integers (no spaces), each the color (room ID) for vertex indices 1..9 in order. Example: \"1,1,1,2,3,2,3,4,4\".","Evaluacion":"import math\nfrom typing import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _parse_csv_solution(sol_str: str) -> List[int]:\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(\",\")]\n\ndef _to_csv_solution(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a tuple of two strings: (neighbor_solution_csv, movement_type)\n    # Falls back to a random valid-length CSV if input is malformed.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    idx = random.randrange(n)\n\n    # Candidate color set: 1..max_c plus optional new color with small probability\n    allow_new = random.random() < 0.25\n    choices = list(range(1, max_c + 1))\n    if allow_new:\n        choices.append(max_c + 1)\n    new_c = curr[idx]\n    if len(choices) > 1:\n        # ensure change\n        choices_no_eq = [c for c in choices if c != curr[idx]]\n        if choices_no_eq:\n            new_c = random.choice(choices_no_eq)\n        else:\n            new_c = curr[idx]\n    else:\n        new_c = choices[0]\n\n    neigh = curr[:]\n    neigh[idx] = new_c\n\n    return _to_csv_solution(neigh), \"recolor_single\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _parse_csv_solution_p(sol_str: str) -> List[int]:\n    return [int(x) for x in sol_str.strip().split(\",\")]\n\ndef _to_csv_solution_p(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor 2-4 vertices; may introduce up to +2 new colors.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    k_changes = random.randint(2, 4)\n    idxs = random.sample(range(n), k_changes)\n    for idx in idxs:\n        # allow up to two new colors with diminishing probability\n        span = max_c + (1 if random.random() < 0.6 else 0) + (1 if random.random() < 0.25 else 0)\n        span = max(span, 2)\n        new_c = curr[idx]\n        attempts = 0\n        while new_c == curr[idx] and attempts < 5:\n            new_c = random.randint(1, span)\n            attempts += 1\n        curr[idx] = new_c\n        if new_c > max_c:\n            max_c = new_c\n\n    return _to_csv_solution_p(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0007544491}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9. Encoding: a solution is a single CSV string of 9 positive integers (no spaces), each the color (room ID) for vertex indices 1..9 in order. Example: \"1,1,1,2,3,2,3,4,4\".","Evaluacion":"import math\nfrom typing import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _parse_csv_solution(sol_str: str) -> List[int]:\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(\",\")]\n\ndef _to_csv_solution(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a tuple of two strings: (neighbor_solution_csv, movement_type)\n    # Falls back to a random valid-length CSV if input is malformed.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    idx = random.randrange(n)\n\n    # Candidate color set: 1..max_c plus optional new color with small probability\n    allow_new = random.random() < 0.25\n    choices = list(range(1, max_c + 1))\n    if allow_new:\n        choices.append(max_c + 1)\n    new_c = curr[idx]\n    if len(choices) > 1:\n        # ensure change\n        choices_no_eq = [c for c in choices if c != curr[idx]]\n        if choices_no_eq:\n            new_c = random.choice(choices_no_eq)\n        else:\n            new_c = curr[idx]\n    else:\n        new_c = choices[0]\n\n    neigh = curr[:]\n    neigh[idx] = new_c\n\n    return _to_csv_solution(neigh), \"recolor_single\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _parse_csv_solution_p(sol_str: str) -> List[int]:\n    return [int(x) for x in sol_str.strip().split(\",\")]\n\ndef _to_csv_solution_p(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor 2-4 vertices; may introduce up to +2 new colors.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    k_changes = random.randint(2, 4)\n    idxs = random.sample(range(n), k_changes)\n    for idx in idxs:\n        # allow up to two new colors with diminishing probability\n        span = max_c + (1 if random.random() < 0.6 else 0) + (1 if random.random() < 0.25 else 0)\n        span = max(span, 2)\n        new_c = curr[idx]\n        attempts = 0\n        while new_c == curr[idx] and attempts < 5:\n            new_c = random.randint(1, span)\n            attempts += 1\n        curr[idx] = new_c\n        if new_c > max_c:\n            max_c = new_c\n\n    return _to_csv_solution_p(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.000813739}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9. Encoding: a solution is a single CSV string of 9 positive integers (no spaces), each the color (room ID) for vertex indices 1..9 in order. Example: \"1,1,1,2,3,2,3,4,4\".","Evaluacion":"import math\nfrom typing import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _parse_csv_solution(sol_str: str) -> List[int]:\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(\",\")]\n\ndef _to_csv_solution(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a tuple of two strings: (neighbor_solution_csv, movement_type)\n    # Falls back to a random valid-length CSV if input is malformed.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    idx = random.randrange(n)\n\n    # Candidate color set: 1..max_c plus optional new color with small probability\n    allow_new = random.random() < 0.25\n    choices = list(range(1, max_c + 1))\n    if allow_new:\n        choices.append(max_c + 1)\n    new_c = curr[idx]\n    if len(choices) > 1:\n        # ensure change\n        choices_no_eq = [c for c in choices if c != curr[idx]]\n        if choices_no_eq:\n            new_c = random.choice(choices_no_eq)\n        else:\n            new_c = curr[idx]\n    else:\n        new_c = choices[0]\n\n    neigh = curr[:]\n    neigh[idx] = new_c\n\n    return _to_csv_solution(neigh), \"recolor_single\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _parse_csv_solution_p(sol_str: str) -> List[int]:\n    return [int(x) for x in sol_str.strip().split(\",\")]\n\ndef _to_csv_solution_p(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor 2-4 vertices; may introduce up to +2 new colors.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    k_changes = random.randint(2, 4)\n    idxs = random.sample(range(n), k_changes)\n    for idx in idxs:\n        # allow up to two new colors with diminishing probability\n        span = max_c + (1 if random.random() < 0.6 else 0) + (1 if random.random() < 0.25 else 0)\n        span = max(span, 2)\n        new_c = curr[idx]\n        attempts = 0\n        while new_c == curr[idx] and attempts < 5:\n            new_c = random.randint(1, span)\n            attempts += 1\n        curr[idx] = new_c\n        if new_c > max_c:\n            max_c = new_c\n\n    return _to_csv_solution_p(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.00080572}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections import defaultdict\n\n# Internal helpers (no filesystem \/ network)\n\ndef _edges():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n_DEF_N = 9\n\ndef _parse_csv_solution(sol_str):\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(',')]\n\n\ndef _to_csv_solution(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef _palette(cols):\n    k = 0\n    for c in cols:\n        if c > k:\n            k = c\n    return max(1, k)\n\n\ndef _color_conflicts(u, color, cols, adj):\n    # number of conflicts introduced at u if colored 'color'\n    cnt = 0\n    for v in adj[u]:\n        if cols[v] == color:\n            cnt += 1\n    return cnt\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven neighbor:\n    # 1) If conflicts exist: pick a conflicted vertex u and recolor with color from 1..k minimizing conflicts\n    # 2) If no conflicts: try to reduce palette by recoloring a vertex of max color into one of lower colors without adding conflicts\n    # 3) Fallback: recolor a random vertex to a random existing color\n    n = _DEF_N\n    edges = _edges()\n    adj = _build_adj(n, edges)\n\n    # Parse solution\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = _palette(curr)\n\n    # Step 1: conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k+1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        # Allow a new color only if all existing colors cause conflicts >= current\n        movement = \"recolor_conflict_minconf\"\n        if not best_colors:\n            # fallback to same color set with new color as escape (rare)\n            if random.random() < 0.05:\n                new_color = k + 1\n                new_cols = curr[:]\n                new_cols[u] = new_color\n                return _to_csv_solution(new_cols), movement + \"_newcolor\"\n            else:\n                # keep as is (no-op) -> try random recolor among existing\n                best_colors = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n        new_c = random.choice(best_colors)\n        new_cols = curr[:]\n        new_cols[u] = new_c\n        return _to_csv_solution(new_cols), movement\n\n    # Step 2: palette reduction when feasible\n    max_color = k\n    max_class_vertices = [i for i,c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class_vertices)\n    for u in max_class_vertices:\n        candidates = [c for c in range(1, max_color) if c != curr[u]]\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv_solution(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: safe recolor without increasing conflicts (maintain feasibility)\n    # choose random vertex and color with zero added conflicts; if none, keep same\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k+1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv_solution(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback random recolor among existing palette\n    new_cols = curr[:]\n    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv_solution(new_cols), \"fallback_recolor_existing\"\n","Perturbacion":"import random\n\n_DEF_N = 9\n\ndef _edges_p():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n\ndef _parse_csv_solution_p(sol_str):\n    return [int(x) for x in sol_str.strip().split(',')]\n\n\ndef _to_csv_solution_p(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj_p(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices_p(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef perturb_solution(solution):\n    # Stronger shake focusing on conflicted vertices; limited new-color introduction.\n    n = _DEF_N\n    edges = _edges_p()\n    adj = _build_adj_p(n, edges)\n\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices_p(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices with existing colors, preserving feasibility if possible\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            # try zero-conflict recolor in existing palette\n            zero_conf = [c for c in range(1, k+1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                # as escape, possibly introduce k+1 with small prob\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv_solution_p(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color overall\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k+1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        # If all existing colors are bad and we haven't used a new color, consider k+1 with small prob\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv_solution_p(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0011460769}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections import defaultdict\n\n# Internal helpers (no filesystem \/ network)\n\ndef _edges():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n_DEF_N = 9\n\ndef _parse_csv_solution(sol_str):\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(',')]\n\n\ndef _to_csv_solution(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef _palette(cols):\n    k = 0\n    for c in cols:\n        if c > k:\n            k = c\n    return max(1, k)\n\n\ndef _color_conflicts(u, color, cols, adj):\n    # number of conflicts introduced at u if colored 'color'\n    cnt = 0\n    for v in adj[u]:\n        if cols[v] == color:\n            cnt += 1\n    return cnt\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven neighbor:\n    # 1) If conflicts exist: pick a conflicted vertex u and recolor with color from 1..k minimizing conflicts\n    # 2) If no conflicts: try to reduce palette by recoloring a vertex of max color into one of lower colors without adding conflicts\n    # 3) Fallback: recolor a random vertex to a random existing color\n    n = _DEF_N\n    edges = _edges()\n    adj = _build_adj(n, edges)\n\n    # Parse solution\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = _palette(curr)\n\n    # Step 1: conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k+1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        # Allow a new color only if all existing colors cause conflicts >= current\n        movement = \"recolor_conflict_minconf\"\n        if not best_colors:\n            # fallback to same color set with new color as escape (rare)\n            if random.random() < 0.05:\n                new_color = k + 1\n                new_cols = curr[:]\n                new_cols[u] = new_color\n                return _to_csv_solution(new_cols), movement + \"_newcolor\"\n            else:\n                # keep as is (no-op) -> try random recolor among existing\n                best_colors = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n        new_c = random.choice(best_colors)\n        new_cols = curr[:]\n        new_cols[u] = new_c\n        return _to_csv_solution(new_cols), movement\n\n    # Step 2: palette reduction when feasible\n    max_color = k\n    max_class_vertices = [i for i,c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class_vertices)\n    for u in max_class_vertices:\n        candidates = [c for c in range(1, max_color) if c != curr[u]]\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv_solution(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: safe recolor without increasing conflicts (maintain feasibility)\n    # choose random vertex and color with zero added conflicts; if none, keep same\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k+1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv_solution(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback random recolor among existing palette\n    new_cols = curr[:]\n    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv_solution(new_cols), \"fallback_recolor_existing\"\n","Perturbacion":"import random\n\n_DEF_N = 9\n\ndef _edges_p():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n\ndef _parse_csv_solution_p(sol_str):\n    return [int(x) for x in sol_str.strip().split(',')]\n\n\ndef _to_csv_solution_p(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj_p(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices_p(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef perturb_solution(solution):\n    # Stronger shake focusing on conflicted vertices; limited new-color introduction.\n    n = _DEF_N\n    edges = _edges_p()\n    adj = _build_adj_p(n, edges)\n\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices_p(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices with existing colors, preserving feasibility if possible\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            # try zero-conflict recolor in existing palette\n            zero_conf = [c for c in range(1, k+1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                # as escape, possibly introduce k+1 with small prob\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv_solution_p(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color overall\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k+1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        # If all existing colors are bad and we haven't used a new color, consider k+1 with small prob\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv_solution_p(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001544922}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections import defaultdict\n\n# Internal helpers (no filesystem \/ network)\n\ndef _edges():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n_DEF_N = 9\n\ndef _parse_csv_solution(sol_str):\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(',')]\n\n\ndef _to_csv_solution(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef _palette(cols):\n    k = 0\n    for c in cols:\n        if c > k:\n            k = c\n    return max(1, k)\n\n\ndef _color_conflicts(u, color, cols, adj):\n    # number of conflicts introduced at u if colored 'color'\n    cnt = 0\n    for v in adj[u]:\n        if cols[v] == color:\n            cnt += 1\n    return cnt\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven neighbor:\n    # 1) If conflicts exist: pick a conflicted vertex u and recolor with color from 1..k minimizing conflicts\n    # 2) If no conflicts: try to reduce palette by recoloring a vertex of max color into one of lower colors without adding conflicts\n    # 3) Fallback: recolor a random vertex to a random existing color\n    n = _DEF_N\n    edges = _edges()\n    adj = _build_adj(n, edges)\n\n    # Parse solution\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = _palette(curr)\n\n    # Step 1: conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k+1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        # Allow a new color only if all existing colors cause conflicts >= current\n        movement = \"recolor_conflict_minconf\"\n        if not best_colors:\n            # fallback to same color set with new color as escape (rare)\n            if random.random() < 0.05:\n                new_color = k + 1\n                new_cols = curr[:]\n                new_cols[u] = new_color\n                return _to_csv_solution(new_cols), movement + \"_newcolor\"\n            else:\n                # keep as is (no-op) -> try random recolor among existing\n                best_colors = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n        new_c = random.choice(best_colors)\n        new_cols = curr[:]\n        new_cols[u] = new_c\n        return _to_csv_solution(new_cols), movement\n\n    # Step 2: palette reduction when feasible\n    max_color = k\n    max_class_vertices = [i for i,c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class_vertices)\n    for u in max_class_vertices:\n        candidates = [c for c in range(1, max_color) if c != curr[u]]\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv_solution(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: safe recolor without increasing conflicts (maintain feasibility)\n    # choose random vertex and color with zero added conflicts; if none, keep same\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k+1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv_solution(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback random recolor among existing palette\n    new_cols = curr[:]\n    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv_solution(new_cols), \"fallback_recolor_existing\"\n","Perturbacion":"import random\n\n_DEF_N = 9\n\ndef _edges_p():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n\ndef _parse_csv_solution_p(sol_str):\n    return [int(x) for x in sol_str.strip().split(',')]\n\n\ndef _to_csv_solution_p(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj_p(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices_p(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef perturb_solution(solution):\n    # Stronger shake focusing on conflicted vertices; limited new-color introduction.\n    n = _DEF_N\n    edges = _edges_p()\n    adj = _build_adj_p(n, edges)\n\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices_p(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices with existing colors, preserving feasibility if possible\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            # try zero-conflict recolor in existing palette\n            zero_conf = [c for c in range(1, k+1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                # as escape, possibly introduce k+1 with small prob\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv_solution_p(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color overall\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k+1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        # If all existing colors are bad and we haven't used a new color, consider k+1 with small prob\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv_solution_p(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0014647819}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections.abc import Iterable\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor coloring for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: (CSV string, move_type)\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _palette(cols):\n        k = 1\n        for c in cols:\n            if c > k:\n                k = c\n        return k\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _color_conflicts(u, color, cols, adj):\n        cnt = 0\n        for v in adj[u]:\n            if cols[v] == color:\n                cnt += 1\n        return cnt\n\n    # Parsing and normalization\n    n = 9\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    k = _palette(curr)\n\n    # Step 1: Conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k + 1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        if not best_colors:\n            # escape: rare new color introduction\n            if random.random() < 0.05:\n                new_cols = curr[:]\n                new_cols[u] = k + 1\n                return _to_csv(new_cols), \"recolor_conflict_newcolor\"\n            else:\n                best_colors = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n        new_cols = curr[:]\n        new_cols[u] = random.choice(best_colors)\n        return _to_csv(new_cols), \"recolor_conflict_minconf\"\n\n    # Step 2: Palette reduction: try to move max color class to lower colors without conflicts\n    max_color = k\n    max_class = [i for i, c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class)\n    for u in max_class:\n        candidates = list(range(1, max_color))\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: Feasible recolor with zero-conflict change\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k + 1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback: recolor to a different existing color\n    new_cols = curr[:]\n    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv(new_cols), \"fallback_recolor_existing\"\n","Perturbacion":"import random\nfrom collections.abc import Iterable\n\ndef perturb_solution(solution):\n    # Stronger diversification for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: CSV string.\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    # Parse\n    n = 9\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices within palette; prefer zero-conflict moves\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            zero_conf = [c for c in range(1, k + 1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k + 1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001123235}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections.abc import Iterable\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor coloring for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: (CSV string, move_type)\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _palette(cols):\n        k = 1\n        for c in cols:\n            if c > k:\n                k = c\n        return k\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _color_conflicts(u, color, cols, adj):\n        cnt = 0\n        for v in adj[u]:\n            if cols[v] == color:\n                cnt += 1\n        return cnt\n\n    # Parsing and normalization\n    n = 9\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    k = _palette(curr)\n\n    # Step 1: Conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k + 1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        if not best_colors:\n            # escape: rare new color introduction\n            if random.random() < 0.05:\n                new_cols = curr[:]\n                new_cols[u] = k + 1\n                return _to_csv(new_cols), \"recolor_conflict_newcolor\"\n            else:\n                best_colors = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n        new_cols = curr[:]\n        new_cols[u] = random.choice(best_colors)\n        return _to_csv(new_cols), \"recolor_conflict_minconf\"\n\n    # Step 2: Palette reduction: try to move max color class to lower colors without conflicts\n    max_color = k\n    max_class = [i for i, c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class)\n    for u in max_class:\n        candidates = list(range(1, max_color))\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: Feasible recolor with zero-conflict change\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k + 1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback: recolor to a different existing color\n    new_cols = curr[:]\n    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv(new_cols), \"fallback_recolor_existing\"\n","Perturbacion":"import random\nfrom collections.abc import Iterable\n\ndef perturb_solution(solution):\n    # Stronger diversification for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: CSV string.\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    # Parse\n    n = 9\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices within palette; prefer zero-conflict moves\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            zero_conf = [c for c in range(1, k + 1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k + 1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001560402}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections.abc import Iterable\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor coloring for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: (CSV string, move_type)\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _palette(cols):\n        k = 1\n        for c in cols:\n            if c > k:\n                k = c\n        return k\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _color_conflicts(u, color, cols, adj):\n        cnt = 0\n        for v in adj[u]:\n            if cols[v] == color:\n                cnt += 1\n        return cnt\n\n    # Parsing and normalization\n    n = 9\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    k = _palette(curr)\n\n    # Step 1: Conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k + 1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        if not best_colors:\n            # escape: rare new color introduction\n            if random.random() < 0.05:\n                new_cols = curr[:]\n                new_cols[u] = k + 1\n                return _to_csv(new_cols), \"recolor_conflict_newcolor\"\n            else:\n                best_colors = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n        new_cols = curr[:]\n        new_cols[u] = random.choice(best_colors)\n        return _to_csv(new_cols), \"recolor_conflict_minconf\"\n\n    # Step 2: Palette reduction: try to move max color class to lower colors without conflicts\n    max_color = k\n    max_class = [i for i, c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class)\n    for u in max_class:\n        candidates = list(range(1, max_color))\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: Feasible recolor with zero-conflict change\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k + 1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback: recolor to a different existing color\n    new_cols = curr[:]\n    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv(new_cols), \"fallback_recolor_existing\"\n","Perturbacion":"import random\nfrom collections.abc import Iterable\n\ndef perturb_solution(solution):\n    # Stronger diversification for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: CSV string.\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    # Parse\n    n = 9\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices within palette; prefer zero-conflict moves\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            zero_conf = [c for c in range(1, k + 1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k + 1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0015023609}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections.abc import Iterable\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor coloring for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: (CSV string, move_type)\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _palette(cols):\n        k = 1\n        for c in cols:\n            if c > k:\n                k = c\n        return k\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _zero_conf_colors(u, cols, adj, palette):\n        res = []\n        for c in range(1, palette + 1):\n            if c == cols[u]:\n                continue\n            ok = True\n            for v in adj[u]:\n                if cols[v] == c:\n                    ok = False\n                    break\n            if ok:\n                res.append(c)\n        return res\n\n    def _color_conflicts(u, color, cols, adj):\n        cnt = 0\n        for v in adj[u]:\n            if cols[v] == color:\n                cnt += 1\n        return cnt\n\n    def _kempe_chain_move(cols, adj, u, c1, c2):\n        # Perform 2-color Kempe chain swap on colors c1 and c2 starting at u.\n        n = len(cols)\n        visited = [False]*n\n        stack = [u]\n        visited[u] = True\n        chain = []\n        while stack:\n            x = stack.pop()\n            chain.append(x)\n            for y in adj[x]:\n                if not visited[y] and (cols[y] == c1 or cols[y] == c2):\n                    visited[y] = True\n                    stack.append(y)\n        new_cols = cols[:]\n        for x in chain:\n            if new_cols[x] == c1:\n                new_cols[x] = c2\n            elif new_cols[x] == c2:\n                new_cols[x] = c1\n        return new_cols\n\n    # Parsing and normalization\n    n = 9\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 2, 1, 3, 1, 4, 3, 4]\n    if len(curr) != n:\n        curr = [1, 2, 2, 1, 3, 1, 4, 3, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    k = _palette(curr)\n\n    # 1) If conflicts exist, target highest-conflict vertex and recolor greedily\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        # pick vertex with max number of conflicts (tie-break by degree)\n        best_u = None\n        best_conf = -1\n        for u in conflicted:\n            ccount = 0\n            for v in adj[u]:\n                if curr[v] == curr[u]:\n                    ccount += 1\n            if ccount > best_conf or (ccount == best_conf and len(adj[u]) > (len(adj[best_u]) if best_u is not None else -1)):\n                best_conf = ccount\n                best_u = u\n        u = best_u\n        # try zero-conflict colors first\n        zero = _zero_conf_colors(u, curr, adj, k)\n        if zero:\n            new_cols = curr[:]\n            new_cols[u] = random.choice(zero)\n            return _to_csv(new_cols), \"recolor_conflict_zero\"\n        # try minimal-conflict recolor within palette\n        best_colors = []\n        best_cval = 10**9\n        for color in range(1, k + 1):\n            if color == curr[u]:\n                continue\n            cval = _color_conflicts(u, color, curr, adj)\n            if cval < best_cval:\n                best_cval = cval\n                best_colors = [color]\n            elif cval == best_cval:\n                best_colors.append(color)\n        if best_colors:\n            new_cols = curr[:]\n            new_cols[u] = random.choice(best_colors)\n            return _to_csv(new_cols), \"recolor_conflict_min\"\n        # fallback: allow a new color with small probability\n        if random.random() < 0.05:\n            new_cols = curr[:]\n            new_cols[u] = k + 1\n            return _to_csv(new_cols), \"recolor_conflict_newcolor\"\n\n    # 2) Kempe-chain swap to reduce palette or resolve tight spots\n    if k >= 2 and random.random() < 0.5:\n        u = random.randrange(n)\n        # pick a second color different from curr[u]\n        available = list({c for c in curr if c != curr[u]})\n        if available:\n            c2 = random.choice(available)\n            c1 = curr[u]\n            new_cols = _kempe_chain_move(curr, adj, u, c1, c2)\n            if new_cols != curr:\n                return _to_csv(new_cols), \"kempe_swap\"\n\n    # 3) Palette reduction: try to move vertices of max color down\n    max_color = k\n    max_class = [i for i, c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class)\n    for u in max_class:\n        candidates = list(range(1, max_color))\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv(new_cols), \"palette_reduce\"\n\n    # 4) Feasible recolor with zero-conflict change\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k + 1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv(new_cols), \"feasible_zero\"\n\n    # 5) Fallback: recolor to a different existing color\n    new_cols = curr[:]\n    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv(new_cols), \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections.abc import Iterable\n\ndef perturb_solution(solution):\n    # Strong diversification focused on largest color class and Kempe chains.\n    # Input: CSV string or iterable of length 9. Output: CSV string.\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _kempe_chain_move(cols, adj, u, c1, c2):\n        n = len(cols)\n        visited = [False]*n\n        stack = [u]\n        visited[u] = True\n        chain = []\n        while stack:\n            x = stack.pop()\n            chain.append(x)\n            for y in adj[x]:\n                if not visited[y] and (cols[y] == c1 or cols[y] == c2):\n                    visited[y] = True\n                    stack.append(y)\n        new_cols = cols[:]\n        for x in chain:\n            if new_cols[x] == c1:\n                new_cols[x] = c2\n            elif new_cols[x] == c2:\n                new_cols[x] = c1\n        return new_cols\n\n    # Parse\n    n = 9\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [2,2,2,1,3,1,4,3,4]\n    if len(curr) != n:\n        curr = [2,2,2,1,3,1,4,3,4]\n    curr = [max(1, int(x)) for x in curr]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices(curr, adj)\n    if not conflicted:\n        # diversify: target the largest color class and apply Kempe swaps and recolors\n        counts = {}\n        for c in curr:\n            counts[c] = counts.get(c, 0) + 1\n        if counts:\n            largest_color = max(counts.items(), key=lambda t: t[1])[0]\n            idxs = [i for i, c in enumerate(curr) if c == largest_color]\n            m = min(len(idxs), random.randint(2, 3))\n            pick = random.sample(idxs, m)\n            for u in pick:\n                # try a Kempe swap with a random other color\n                others = [c for c in counts.keys() if c != largest_color]\n                if others:\n                    c2 = random.choice(others)\n                    curr = _kempe_chain_move(curr, adj, u, largest_color, c2)\n                else:\n                    # recolor to any feasible different color or introduce new with small prob\n                    choices = [c for c in range(1, k + 1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n                    if choices:\n                        curr[u] = random.choice(choices)\n                    else:\n                        if random.random() < 0.1:\n                            k += 1\n                            curr[u] = k\n        return _to_csv(curr)\n\n    # When conflicts exist: recolor several conflicted vertices using minimal local conflicts; allow at most +1 new color\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        # consider existing palette\n        for c in range(1, k + 1):\n            if c == curr[u]:\n                continue\n            conf = 0\n            for v in adj[u]:\n                if curr[v] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        # optional new color\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            k += 1\n            best_c = k\n            new_color_used = True\n        curr[u] = best_c\n    return _to_csv(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.00149657}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections.abc import Iterable\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor coloring for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: (CSV string, move_type)\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _palette(cols):\n        k = 1\n        for c in cols:\n            if c > k:\n                k = c\n        return k\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _zero_conf_colors(u, cols, adj, palette):\n        res = []\n        for c in range(1, palette + 1):\n            if c == cols[u]:\n                continue\n            ok = True\n            for v in adj[u]:\n                if cols[v] == c:\n                    ok = False\n                    break\n            if ok:\n                res.append(c)\n        return res\n\n    def _color_conflicts(u, color, cols, adj):\n        cnt = 0\n        for v in adj[u]:\n            if cols[v] == color:\n                cnt += 1\n        return cnt\n\n    def _kempe_chain_move(cols, adj, u, c1, c2):\n        # Perform 2-color Kempe chain swap on colors c1 and c2 starting at u.\n        n = len(cols)\n        visited = [False]*n\n        stack = [u]\n        visited[u] = True\n        chain = []\n        while stack:\n            x = stack.pop()\n            chain.append(x)\n            for y in adj[x]:\n                if not visited[y] and (cols[y] == c1 or cols[y] == c2):\n                    visited[y] = True\n                    stack.append(y)\n        new_cols = cols[:]\n        for x in chain:\n            if new_cols[x] == c1:\n                new_cols[x] = c2\n            elif new_cols[x] == c2:\n                new_cols[x] = c1\n        return new_cols\n\n    # Parsing and normalization\n    n = 9\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 2, 1, 3, 1, 4, 3, 4]\n    if len(curr) != n:\n        curr = [1, 2, 2, 1, 3, 1, 4, 3, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    k = _palette(curr)\n\n    # 1) If conflicts exist, target highest-conflict vertex and recolor greedily\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        # pick vertex with max number of conflicts (tie-break by degree)\n        best_u = None\n        best_conf = -1\n        for u in conflicted:\n            ccount = 0\n            for v in adj[u]:\n                if curr[v] == curr[u]:\n                    ccount += 1\n            if ccount > best_conf or (ccount == best_conf and len(adj[u]) > (len(adj[best_u]) if best_u is not None else -1)):\n                best_conf = ccount\n                best_u = u\n        u = best_u\n        # try zero-conflict colors first\n        zero = _zero_conf_colors(u, curr, adj, k)\n        if zero:\n            new_cols = curr[:]\n            new_cols[u] = random.choice(zero)\n            return _to_csv(new_cols), \"recolor_conflict_zero\"\n        # try minimal-conflict recolor within palette\n        best_colors = []\n        best_cval = 10**9\n        for color in range(1, k + 1):\n            if color == curr[u]:\n                continue\n            cval = _color_conflicts(u, color, curr, adj)\n            if cval < best_cval:\n                best_cval = cval\n                best_colors = [color]\n            elif cval == best_cval:\n                best_colors.append(color)\n        if best_colors:\n            new_cols = curr[:]\n            new_cols[u] = random.choice(best_colors)\n            return _to_csv(new_cols), \"recolor_conflict_min\"\n        # fallback: allow a new color with small probability\n        if random.random() < 0.05:\n            new_cols = curr[:]\n            new_cols[u] = k + 1\n            return _to_csv(new_cols), \"recolor_conflict_newcolor\"\n\n    # 2) Kempe-chain swap to reduce palette or resolve tight spots\n    if k >= 2 and random.random() < 0.5:\n        u = random.randrange(n)\n        # pick a second color different from curr[u]\n        available = list({c for c in curr if c != curr[u]})\n        if available:\n            c2 = random.choice(available)\n            c1 = curr[u]\n            new_cols = _kempe_chain_move(curr, adj, u, c1, c2)\n            if new_cols != curr:\n                return _to_csv(new_cols), \"kempe_swap\"\n\n    # 3) Palette reduction: try to move vertices of max color down\n    max_color = k\n    max_class = [i for i, c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class)\n    for u in max_class:\n        candidates = list(range(1, max_color))\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv(new_cols), \"palette_reduce\"\n\n    # 4) Feasible recolor with zero-conflict change\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k + 1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv(new_cols), \"feasible_zero\"\n\n    # 5) Fallback: recolor to a different existing color\n    new_cols = curr[:]\n    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv(new_cols), \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections.abc import Iterable\n\ndef perturb_solution(solution):\n    # Strong diversification focused on largest color class and Kempe chains.\n    # Input: CSV string or iterable of length 9. Output: CSV string.\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _kempe_chain_move(cols, adj, u, c1, c2):\n        n = len(cols)\n        visited = [False]*n\n        stack = [u]\n        visited[u] = True\n        chain = []\n        while stack:\n            x = stack.pop()\n            chain.append(x)\n            for y in adj[x]:\n                if not visited[y] and (cols[y] == c1 or cols[y] == c2):\n                    visited[y] = True\n                    stack.append(y)\n        new_cols = cols[:]\n        for x in chain:\n            if new_cols[x] == c1:\n                new_cols[x] = c2\n            elif new_cols[x] == c2:\n                new_cols[x] = c1\n        return new_cols\n\n    # Parse\n    n = 9\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [2,2,2,1,3,1,4,3,4]\n    if len(curr) != n:\n        curr = [2,2,2,1,3,1,4,3,4]\n    curr = [max(1, int(x)) for x in curr]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices(curr, adj)\n    if not conflicted:\n        # diversify: target the largest color class and apply Kempe swaps and recolors\n        counts = {}\n        for c in curr:\n            counts[c] = counts.get(c, 0) + 1\n        if counts:\n            largest_color = max(counts.items(), key=lambda t: t[1])[0]\n            idxs = [i for i, c in enumerate(curr) if c == largest_color]\n            m = min(len(idxs), random.randint(2, 3))\n            pick = random.sample(idxs, m)\n            for u in pick:\n                # try a Kempe swap with a random other color\n                others = [c for c in counts.keys() if c != largest_color]\n                if others:\n                    c2 = random.choice(others)\n                    curr = _kempe_chain_move(curr, adj, u, largest_color, c2)\n                else:\n                    # recolor to any feasible different color or introduce new with small prob\n                    choices = [c for c in range(1, k + 1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n                    if choices:\n                        curr[u] = random.choice(choices)\n                    else:\n                        if random.random() < 0.1:\n                            k += 1\n                            curr[u] = k\n        return _to_csv(curr)\n\n    # When conflicts exist: recolor several conflicted vertices using minimal local conflicts; allow at most +1 new color\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        # consider existing palette\n        for c in range(1, k + 1):\n            if c == curr[u]:\n                continue\n            conf = 0\n            for v in adj[u]:\n                if curr[v] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        # optional new color\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            k += 1\n            best_c = k\n            new_color_used = True\n        curr[u] = best_c\n    return _to_csv(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001892265}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Evaluacion":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom collections.abc import Iterable\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor coloring for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: (CSV string, move_type)\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _palette(cols):\n        k = 1\n        for c in cols:\n            if c > k:\n                k = c\n        return k\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _zero_conf_colors(u, cols, adj, palette):\n        res = []\n        for c in range(1, palette + 1):\n            if c == cols[u]:\n                continue\n            ok = True\n            for v in adj[u]:\n                if cols[v] == c:\n                    ok = False\n                    break\n            if ok:\n                res.append(c)\n        return res\n\n    def _color_conflicts(u, color, cols, adj):\n        cnt = 0\n        for v in adj[u]:\n            if cols[v] == color:\n                cnt += 1\n        return cnt\n\n    def _kempe_chain_move(cols, adj, u, c1, c2):\n        # Perform 2-color Kempe chain swap on colors c1 and c2 starting at u.\n        n = len(cols)\n        visited = [False]*n\n        stack = [u]\n        visited[u] = True\n        chain = []\n        while stack:\n            x = stack.pop()\n            chain.append(x)\n            for y in adj[x]:\n                if not visited[y] and (cols[y] == c1 or cols[y] == c2):\n                    visited[y] = True\n                    stack.append(y)\n        new_cols = cols[:]\n        for x in chain:\n            if new_cols[x] == c1:\n                new_cols[x] = c2\n            elif new_cols[x] == c2:\n                new_cols[x] = c1\n        return new_cols\n\n    # Parsing and normalization\n    n = 9\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 2, 1, 3, 1, 4, 3, 4]\n    if len(curr) != n:\n        curr = [1, 2, 2, 1, 3, 1, 4, 3, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    k = _palette(curr)\n\n    # 1) If conflicts exist, target highest-conflict vertex and recolor greedily\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        # pick vertex with max number of conflicts (tie-break by degree)\n        best_u = None\n        best_conf = -1\n        for u in conflicted:\n            ccount = 0\n            for v in adj[u]:\n                if curr[v] == curr[u]:\n                    ccount += 1\n            if ccount > best_conf or (ccount == best_conf and len(adj[u]) > (len(adj[best_u]) if best_u is not None else -1)):\n                best_conf = ccount\n                best_u = u\n        u = best_u\n        # try zero-conflict colors first\n        zero = _zero_conf_colors(u, curr, adj, k)\n        if zero:\n            new_cols = curr[:]\n            new_cols[u] = random.choice(zero)\n            return _to_csv(new_cols), \"recolor_conflict_zero\"\n        # try minimal-conflict recolor within palette\n        best_colors = []\n        best_cval = 10**9\n        for color in range(1, k + 1):\n            if color == curr[u]:\n                continue\n            cval = _color_conflicts(u, color, curr, adj)\n            if cval < best_cval:\n                best_cval = cval\n                best_colors = [color]\n            elif cval == best_cval:\n                best_colors.append(color)\n        if best_colors:\n            new_cols = curr[:]\n            new_cols[u] = random.choice(best_colors)\n            return _to_csv(new_cols), \"recolor_conflict_min\"\n        # fallback: allow a new color with small probability\n        if random.random() < 0.05:\n            new_cols = curr[:]\n            new_cols[u] = k + 1\n            return _to_csv(new_cols), \"recolor_conflict_newcolor\"\n\n    # 2) Kempe-chain swap to reduce palette or resolve tight spots\n    if k >= 2 and random.random() < 0.5:\n        u = random.randrange(n)\n        # pick a second color different from curr[u]\n        available = list({c for c in curr if c != curr[u]})\n        if available:\n            c2 = random.choice(available)\n            c1 = curr[u]\n            new_cols = _kempe_chain_move(curr, adj, u, c1, c2)\n            if new_cols != curr:\n                return _to_csv(new_cols), \"kempe_swap\"\n\n    # 3) Palette reduction: try to move vertices of max color down\n    max_color = k\n    max_class = [i for i, c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class)\n    for u in max_class:\n        candidates = list(range(1, max_color))\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv(new_cols), \"palette_reduce\"\n\n    # 4) Feasible recolor with zero-conflict change\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k + 1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv(new_cols), \"feasible_zero\"\n\n    # 5) Fallback: recolor to a different existing color\n    new_cols = curr[:]\n    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv(new_cols), \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections.abc import Iterable\n\ndef perturb_solution(solution):\n    # Strong diversification focused on largest color class and Kempe chains.\n    # Input: CSV string or iterable of length 9. Output: CSV string.\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _kempe_chain_move(cols, adj, u, c1, c2):\n        n = len(cols)\n        visited = [False]*n\n        stack = [u]\n        visited[u] = True\n        chain = []\n        while stack:\n            x = stack.pop()\n            chain.append(x)\n            for y in adj[x]:\n                if not visited[y] and (cols[y] == c1 or cols[y] == c2):\n                    visited[y] = True\n                    stack.append(y)\n        new_cols = cols[:]\n        for x in chain:\n            if new_cols[x] == c1:\n                new_cols[x] = c2\n            elif new_cols[x] == c2:\n                new_cols[x] = c1\n        return new_cols\n\n    # Parse\n    n = 9\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [2,2,2,1,3,1,4,3,4]\n    if len(curr) != n:\n        curr = [2,2,2,1,3,1,4,3,4]\n    curr = [max(1, int(x)) for x in curr]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices(curr, adj)\n    if not conflicted:\n        # diversify: target the largest color class and apply Kempe swaps and recolors\n        counts = {}\n        for c in curr:\n            counts[c] = counts.get(c, 0) + 1\n        if counts:\n            largest_color = max(counts.items(), key=lambda t: t[1])[0]\n            idxs = [i for i, c in enumerate(curr) if c == largest_color]\n            m = min(len(idxs), random.randint(2, 3))\n            pick = random.sample(idxs, m)\n            for u in pick:\n                # try a Kempe swap with a random other color\n                others = [c for c in counts.keys() if c != largest_color]\n                if others:\n                    c2 = random.choice(others)\n                    curr = _kempe_chain_move(curr, adj, u, largest_color, c2)\n                else:\n                    # recolor to any feasible different color or introduce new with small prob\n                    choices = [c for c in range(1, k + 1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n                    if choices:\n                        curr[u] = random.choice(choices)\n                    else:\n                        if random.random() < 0.1:\n                            k += 1\n                            curr[u] = k\n        return _to_csv(curr)\n\n    # When conflicts exist: recolor several conflicted vertices using minimal local conflicts; allow at most +1 new color\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        # consider existing palette\n        for c in range(1, k + 1):\n            if c == curr[u]:\n                continue\n            conf = 0\n            for v in adj[u]:\n                if curr[v] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        # optional new color\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            k += 1\n            best_c = k\n            new_color_used = True\n        curr[u] = best_c\n    return _to_csv(curr)\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001872255}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric objective value: smaller is better\n    # If infeasible or invalid type\/shape\/domain, returns a large penalty\n    # Solution type: list of 9 positive integers (colors)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4  # label-normalization penalty\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Edge conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used (distinct labels)\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    # Prefer normalized label sets {1,2,...,k}\n    normalized_ok = (distinct == list(range(1, k_used+1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):  # -> (\"NB_Type\", \"Movement_Type\")\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random feasible-leaning solution if input invalid\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Helper: adjacency list\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Compute conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n    # Candidate colors set\n    def smallest_feasible_color(vertex, sol_list):\n        used = {sol_list[nbr-1] for nbr in adj[vertex]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n    new_sol = list(sol)\n    if conflicts:\n        # Pick a random conflicting edge, recolor one endpoint to smallest feasible color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        new_color = smallest_feasible_color(target, new_sol)\n        new_sol[target-1] = new_color\n        return new_sol, \"Local_Recolor\", \"ConflictRepair\"\n    # If no conflicts: try to reduce number of colors by recoloring a max-color vertex\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        candidates = [i+1 for i, c in enumerate(new_sol) if c == max_color]\n        if candidates:\n            v = random.choice(candidates)\n            # Try assign the smallest feasible color < max_color\n            used = {new_sol[nbr-1] for nbr in adj[v]}\n            for c in range(1, max_color):\n                if c not in used:\n                    new_sol[v-1] = c\n                    break\n            return new_sol, \"Local_Recolor\", \"ColorReduction\"\n    # Fallback: random vertex recolor to a nearby color\n    v = random.randint(1, n)\n    used = {new_sol[nbr-1] for nbr in adj[v]}\n    # Propose a color from 1..max(used)+1 to keep palette compact\n    cap = (max(used) + 1) if used else 1\n    cap = max(cap, 1)\n    new_color = random.randint(1, max(1, cap))\n    # Ensure not equal to any neighbor if possible by cycling up\n    tries = 0\n    while new_color in used and tries < n+5:\n        new_color += 1\n        tries += 1\n    new_sol[v-1] = new_color\n    return new_sol, \"Local_Recolor\", \"Random\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-vertex recoloring to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Decide how many vertices to perturb\n    k = max(2, min(4, n \/\/ 3))\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    # Recolor chosen vertices with random feasible-ish colors\n    for v in chosen:\n        used = {sol[nbr-1] for nbr in adj[v]}\n        # pick a color among 1..max(used)+1 but avoid used if possible\n        cap = (max(used) + 1) if used else 1\n        # Try a few random draws to avoid used\n        picked = None\n        for _ in range(5):\n            cand = random.randint(1, max(1, cap))\n            if cand not in used:\n                picked = cand\n                break\n        if picked is None:\n            picked = cap\n        sol[v-1] = picked\n    # Optional palette compaction: relabel to 1..k by order of appearance\n    mapping = {}\n    next_label = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0007387501}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric objective value: smaller is better\n    # If infeasible or invalid type\/shape\/domain, returns a large penalty\n    # Solution type: list of 9 positive integers (colors)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4  # label-normalization penalty\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Edge conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used (distinct labels)\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    # Prefer normalized label sets {1,2,...,k}\n    normalized_ok = (distinct == list(range(1, k_used+1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):  # -> (\"NB_Type\", \"Movement_Type\")\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random feasible-leaning solution if input invalid\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Helper: adjacency list\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Compute conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n    # Candidate colors set\n    def smallest_feasible_color(vertex, sol_list):\n        used = {sol_list[nbr-1] for nbr in adj[vertex]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n    new_sol = list(sol)\n    if conflicts:\n        # Pick a random conflicting edge, recolor one endpoint to smallest feasible color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        new_color = smallest_feasible_color(target, new_sol)\n        new_sol[target-1] = new_color\n        return new_sol, \"Local_Recolor\", \"ConflictRepair\"\n    # If no conflicts: try to reduce number of colors by recoloring a max-color vertex\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        candidates = [i+1 for i, c in enumerate(new_sol) if c == max_color]\n        if candidates:\n            v = random.choice(candidates)\n            # Try assign the smallest feasible color < max_color\n            used = {new_sol[nbr-1] for nbr in adj[v]}\n            for c in range(1, max_color):\n                if c not in used:\n                    new_sol[v-1] = c\n                    break\n            return new_sol, \"Local_Recolor\", \"ColorReduction\"\n    # Fallback: random vertex recolor to a nearby color\n    v = random.randint(1, n)\n    used = {new_sol[nbr-1] for nbr in adj[v]}\n    # Propose a color from 1..max(used)+1 to keep palette compact\n    cap = (max(used) + 1) if used else 1\n    cap = max(cap, 1)\n    new_color = random.randint(1, max(1, cap))\n    # Ensure not equal to any neighbor if possible by cycling up\n    tries = 0\n    while new_color in used and tries < n+5:\n        new_color += 1\n        tries += 1\n    new_sol[v-1] = new_color\n    return new_sol, \"Local_Recolor\", \"Random\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-vertex recoloring to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Decide how many vertices to perturb\n    k = max(2, min(4, n \/\/ 3))\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    # Recolor chosen vertices with random feasible-ish colors\n    for v in chosen:\n        used = {sol[nbr-1] for nbr in adj[v]}\n        # pick a color among 1..max(used)+1 but avoid used if possible\n        cap = (max(used) + 1) if used else 1\n        # Try a few random draws to avoid used\n        picked = None\n        for _ in range(5):\n            cand = random.randint(1, max(1, cap))\n            if cand not in used:\n                picked = cand\n                break\n        if picked is None:\n            picked = cap\n        sol[v-1] = picked\n    # Optional palette compaction: relabel to 1..k by order of appearance\n    mapping = {}\n    next_label = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0008397511}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric objective value: smaller is better\n    # If infeasible or invalid type\/shape\/domain, returns a large penalty\n    # Solution type: list of 9 positive integers (colors)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4  # label-normalization penalty\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Edge conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used (distinct labels)\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    # Prefer normalized label sets {1,2,...,k}\n    normalized_ok = (distinct == list(range(1, k_used+1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):  # -> (\"NB_Type\", \"Movement_Type\")\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random feasible-leaning solution if input invalid\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Helper: adjacency list\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Compute conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n    # Candidate colors set\n    def smallest_feasible_color(vertex, sol_list):\n        used = {sol_list[nbr-1] for nbr in adj[vertex]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n    new_sol = list(sol)\n    if conflicts:\n        # Pick a random conflicting edge, recolor one endpoint to smallest feasible color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        new_color = smallest_feasible_color(target, new_sol)\n        new_sol[target-1] = new_color\n        return new_sol, \"Local_Recolor\", \"ConflictRepair\"\n    # If no conflicts: try to reduce number of colors by recoloring a max-color vertex\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        candidates = [i+1 for i, c in enumerate(new_sol) if c == max_color]\n        if candidates:\n            v = random.choice(candidates)\n            # Try assign the smallest feasible color < max_color\n            used = {new_sol[nbr-1] for nbr in adj[v]}\n            for c in range(1, max_color):\n                if c not in used:\n                    new_sol[v-1] = c\n                    break\n            return new_sol, \"Local_Recolor\", \"ColorReduction\"\n    # Fallback: random vertex recolor to a nearby color\n    v = random.randint(1, n)\n    used = {new_sol[nbr-1] for nbr in adj[v]}\n    # Propose a color from 1..max(used)+1 to keep palette compact\n    cap = (max(used) + 1) if used else 1\n    cap = max(cap, 1)\n    new_color = random.randint(1, max(1, cap))\n    # Ensure not equal to any neighbor if possible by cycling up\n    tries = 0\n    while new_color in used and tries < n+5:\n        new_color += 1\n        tries += 1\n    new_sol[v-1] = new_color\n    return new_sol, \"Local_Recolor\", \"Random\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-vertex recoloring to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Decide how many vertices to perturb\n    k = max(2, min(4, n \/\/ 3))\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    # Recolor chosen vertices with random feasible-ish colors\n    for v in chosen:\n        used = {sol[nbr-1] for nbr in adj[v]}\n        # pick a color among 1..max(used)+1 but avoid used if possible\n        cap = (max(used) + 1) if used else 1\n        # Try a few random draws to avoid used\n        picked = None\n        for _ in range(5):\n            cand = random.randint(1, max(1, cap))\n            if cand not in used:\n                picked = cand\n                break\n        if picked is None:\n            picked = cap\n        sol[v-1] = picked\n    # Optional palette compaction: relabel to 1..k by order of appearance\n    mapping = {}\n    next_label = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0008169509}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    # Weight ensures any conflict dominates color count differences\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution):  # -> (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helper: compute per-vertex conflicts and saturation degree\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    conflicts_cnt = vertex_conflicts(new_sol)\n    total_conflicts = sum(1 for (u,v) in edges if new_sol[u-1] == new_sol[v-1])\n    # Try DSATUR-guided recolor\n    if total_conflicts > 0:\n        # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n        candidates = list(range(1, n+1))\n        random.shuffle(candidates)\n        best_v = None\n        best_key = None\n        for v in candidates:\n            key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best_v = v\n        v = best_v\n        neighbor_colors = {new_sol[w-1] for w in adj[v]}\n        # Try to assign smallest feasible color among existing palette first\n        palette = sorted(set(new_sol))\n        chosen = None\n        for c in palette:\n            if c not in neighbor_colors:\n                chosen = c\n                break\n        if chosen is None:\n            # If none feasible among existing, allow introducing at most one new color = max+1\n            chosen = (max(palette) + 1) if palette else 1\n        new_sol[v-1] = chosen\n        return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n    # If no conflicts: attempt color reduction via recoloring max-color class\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n        if holders:\n            v = random.choice(holders)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            # Try to recolor into a lower color\n            moved = False\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    new_sol[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                return new_sol, \"Local_Recolor\", \"ColorReduction\"\n            # Kempe-chain inspired swap between two colors to free max_color at v\n            # Pick a target color t < max_color and try swapping on the connected component\n            target_colors = [c for c in range(1, max_color)]\n            random.shuffle(target_colors)\n            for t in target_colors:\n                a, b = max_color, t\n                # BFS on subgraph induced by colors {a,b}\n                from collections import deque\n                queue = deque([v])\n                seen = set([v])\n                while queue:\n                    x = queue.popleft()\n                    for y in adj[x]:\n                        if new_sol[y-1] in (a, b) and y not in seen:\n                            seen.add(y)\n                            queue.append(y)\n                # Swap colors a<->b in component 'seen'\n                test = list(new_sol)\n                for x in seen:\n                    if test[x-1] == a:\n                        test[x-1] = b\n                    elif test[x-1] == b:\n                        test[x-1] = a\n                # Accept if still conflict-free and reduces count of max_color holders\n                ok = True\n                for (u, w) in edges:\n                    if test[u-1] == test[w-1]:\n                        ok = False\n                        break\n                if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                    return test, \"Kempe_Swap\", \"ColorReduction\"\n    # Fallback: recolor a random vertex to an existing feasible color; avoid introducing new colors\n    v = random.randint(1, n)\n    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n    palette = sorted(set(new_sol))\n    feasible = [c for c in palette if c not in neighbor_colors]\n    if feasible:\n        new_sol[v-1] = random.choice(feasible)\n        return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # If no feasible within palette, keep color (no-op) to maintain validity of signature\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Choose k vertices to perturb (2..4)\n    k = max(2, min(4, n \/\/ 3))\n    order = list(range(1, n+1))\n    random.shuffle(order)\n    chosen = order[:k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        # Prefer colors within current palette not used by neighbors\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick a random color within 1..max_color\n            sol[v-1] = random.randint(1, max_color)\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001025383}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    # Weight ensures any conflict dominates color count differences\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution):  # -> (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helper: compute per-vertex conflicts and saturation degree\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    conflicts_cnt = vertex_conflicts(new_sol)\n    total_conflicts = sum(1 for (u,v) in edges if new_sol[u-1] == new_sol[v-1])\n    # Try DSATUR-guided recolor\n    if total_conflicts > 0:\n        # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n        candidates = list(range(1, n+1))\n        random.shuffle(candidates)\n        best_v = None\n        best_key = None\n        for v in candidates:\n            key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best_v = v\n        v = best_v\n        neighbor_colors = {new_sol[w-1] for w in adj[v]}\n        # Try to assign smallest feasible color among existing palette first\n        palette = sorted(set(new_sol))\n        chosen = None\n        for c in palette:\n            if c not in neighbor_colors:\n                chosen = c\n                break\n        if chosen is None:\n            # If none feasible among existing, allow introducing at most one new color = max+1\n            chosen = (max(palette) + 1) if palette else 1\n        new_sol[v-1] = chosen\n        return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n    # If no conflicts: attempt color reduction via recoloring max-color class\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n        if holders:\n            v = random.choice(holders)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            # Try to recolor into a lower color\n            moved = False\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    new_sol[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                return new_sol, \"Local_Recolor\", \"ColorReduction\"\n            # Kempe-chain inspired swap between two colors to free max_color at v\n            # Pick a target color t < max_color and try swapping on the connected component\n            target_colors = [c for c in range(1, max_color)]\n            random.shuffle(target_colors)\n            for t in target_colors:\n                a, b = max_color, t\n                # BFS on subgraph induced by colors {a,b}\n                from collections import deque\n                queue = deque([v])\n                seen = set([v])\n                while queue:\n                    x = queue.popleft()\n                    for y in adj[x]:\n                        if new_sol[y-1] in (a, b) and y not in seen:\n                            seen.add(y)\n                            queue.append(y)\n                # Swap colors a<->b in component 'seen'\n                test = list(new_sol)\n                for x in seen:\n                    if test[x-1] == a:\n                        test[x-1] = b\n                    elif test[x-1] == b:\n                        test[x-1] = a\n                # Accept if still conflict-free and reduces count of max_color holders\n                ok = True\n                for (u, w) in edges:\n                    if test[u-1] == test[w-1]:\n                        ok = False\n                        break\n                if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                    return test, \"Kempe_Swap\", \"ColorReduction\"\n    # Fallback: recolor a random vertex to an existing feasible color; avoid introducing new colors\n    v = random.randint(1, n)\n    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n    palette = sorted(set(new_sol))\n    feasible = [c for c in palette if c not in neighbor_colors]\n    if feasible:\n        new_sol[v-1] = random.choice(feasible)\n        return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # If no feasible within palette, keep color (no-op) to maintain validity of signature\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Choose k vertices to perturb (2..4)\n    k = max(2, min(4, n \/\/ 3))\n    order = list(range(1, n+1))\n    random.shuffle(order)\n    chosen = order[:k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        # Prefer colors within current palette not used by neighbors\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick a random color within 1..max_color\n            sol[v-1] = random.randint(1, max_color)\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001109014}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    # Weight ensures any conflict dominates color count differences\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution):  # -> (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helper: compute per-vertex conflicts and saturation degree\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    conflicts_cnt = vertex_conflicts(new_sol)\n    total_conflicts = sum(1 for (u,v) in edges if new_sol[u-1] == new_sol[v-1])\n    # Try DSATUR-guided recolor\n    if total_conflicts > 0:\n        # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n        candidates = list(range(1, n+1))\n        random.shuffle(candidates)\n        best_v = None\n        best_key = None\n        for v in candidates:\n            key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best_v = v\n        v = best_v\n        neighbor_colors = {new_sol[w-1] for w in adj[v]}\n        # Try to assign smallest feasible color among existing palette first\n        palette = sorted(set(new_sol))\n        chosen = None\n        for c in palette:\n            if c not in neighbor_colors:\n                chosen = c\n                break\n        if chosen is None:\n            # If none feasible among existing, allow introducing at most one new color = max+1\n            chosen = (max(palette) + 1) if palette else 1\n        new_sol[v-1] = chosen\n        return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n    # If no conflicts: attempt color reduction via recoloring max-color class\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n        if holders:\n            v = random.choice(holders)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            # Try to recolor into a lower color\n            moved = False\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    new_sol[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                return new_sol, \"Local_Recolor\", \"ColorReduction\"\n            # Kempe-chain inspired swap between two colors to free max_color at v\n            # Pick a target color t < max_color and try swapping on the connected component\n            target_colors = [c for c in range(1, max_color)]\n            random.shuffle(target_colors)\n            for t in target_colors:\n                a, b = max_color, t\n                # BFS on subgraph induced by colors {a,b}\n                from collections import deque\n                queue = deque([v])\n                seen = set([v])\n                while queue:\n                    x = queue.popleft()\n                    for y in adj[x]:\n                        if new_sol[y-1] in (a, b) and y not in seen:\n                            seen.add(y)\n                            queue.append(y)\n                # Swap colors a<->b in component 'seen'\n                test = list(new_sol)\n                for x in seen:\n                    if test[x-1] == a:\n                        test[x-1] = b\n                    elif test[x-1] == b:\n                        test[x-1] = a\n                # Accept if still conflict-free and reduces count of max_color holders\n                ok = True\n                for (u, w) in edges:\n                    if test[u-1] == test[w-1]:\n                        ok = False\n                        break\n                if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                    return test, \"Kempe_Swap\", \"ColorReduction\"\n    # Fallback: recolor a random vertex to an existing feasible color; avoid introducing new colors\n    v = random.randint(1, n)\n    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n    palette = sorted(set(new_sol))\n    feasible = [c for c in palette if c not in neighbor_colors]\n    if feasible:\n        new_sol[v-1] = random.choice(feasible)\n        return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # If no feasible within palette, keep color (no-op) to maintain validity of signature\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Choose k vertices to perturb (2..4)\n    k = max(2, min(4, n \/\/ 3))\n    order = list(range(1, n+1))\n    random.shuffle(order)\n    chosen = order[:k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        # Prefer colors within current palette not used by neighbors\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick a random color within 1..max_color\n            sol[v-1] = random.randint(1, max_color)\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001069634}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution):  # returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helpers\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def total_conflicts(sol_list):\n        return sum(1 for (u,v) in edges if sol_list[u-1] == sol_list[v-1])\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    # Retry loop to avoid NoOp under conflicts\n    for _ in range(10):\n        conflicts_cnt = vertex_conflicts(new_sol)\n        tot_conf = total_conflicts(new_sol)\n        if tot_conf > 0:\n            # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n            candidates = list(range(1, n+1))\n            random.shuffle(candidates)\n            best_v = None\n            best_key = None\n            for v in candidates:\n                key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            v = best_v\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            chosen = None\n            # Try feasible color in palette\n            for c in palette:\n                if c not in neighbor_colors:\n                    chosen = c\n                    break\n            if chosen is None:\n                # If none feasible, allow introducing one new color\n                chosen = (max(palette) + 1) if palette else 1\n            if new_sol[v-1] != chosen:\n                cand = list(new_sol)\n                cand[v-1] = chosen\n                new_sol = cand\n                return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n            else:\n                # random tweak to escape tie\n                v = random.randint(1, n)\n                cand = list(new_sol)\n                cand[v-1] = max(new_sol) if new_sol[v-1] != max(new_sol) else 1\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomTweak\"\n        else:\n            # No conflicts: attempt color reduction via recoloring max-color class\n            colors_used = sorted(set(new_sol))\n            if colors_used:\n                max_color = max(colors_used)\n                holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n                if holders:\n                    v = random.choice(holders)\n                    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                    moved = False\n                    for c in range(1, max_color):\n                        if c not in neighbor_colors:\n                            cand = list(new_sol)\n                            cand[v-1] = c\n                            new_sol = cand\n                            moved = True\n                            break\n                    if moved:\n                        return new_sol, \"Local_Recolor\", \"ColorReduction\"\n                    # Kempe-chain swap between max_color and target t < max_color\n                    target_colors = [c for c in range(1, max_color)]\n                    random.shuffle(target_colors)\n                    for t in target_colors:\n                        a, b = max_color, t\n                        queue = deque([v])\n                        seen = set([v])\n                        while queue:\n                            x = queue.popleft()\n                            for y in adj[x]:\n                                if new_sol[y-1] in (a, b) and y not in seen:\n                                    seen.add(y)\n                                    queue.append(y)\n                        test = list(new_sol)\n                        for x in seen:\n                            if test[x-1] == a:\n                                test[x-1] = b\n                            elif test[x-1] == b:\n                                test[x-1] = a\n                        # Verify no conflicts introduced\n                        ok = True\n                        for (u, w) in edges:\n                            if test[u-1] == test[w-1]:\n                                ok = False\n                                break\n                        if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                            return test, \"Kempe_Swap\", \"ColorReduction\"\n            # Fallback: random feasible recolor within current palette\n            v = random.randint(1, n)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            feasible = [c for c in palette if c not in neighbor_colors]\n            if feasible:\n                cand = list(new_sol)\n                cand[v-1] = random.choice(feasible)\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # As a last resort, return the original (NoOp)\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Conflict-guided vertex set\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    # Choose k vertices to perturb (bias to conflicts)\n    base_k = max(2, min(4, n \/\/ 3))\n    chosen = list(conflicts)\n    random.shuffle(chosen)\n    if len(chosen) < base_k:\n        extra = [v for v in vertices if v not in chosen]\n        chosen += extra[: base_k - len(chosen)]\n    else:\n        chosen = chosen[:base_k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    # Apply mixed perturbations\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            sol[v-1] = random.randint(1, max_color)\n    # Optionally perform one Kempe swap between two random colors to diversify\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        start = random.randint(1, n)\n        queue = deque([start])\n        seen = set([start])\n        while queue:\n            x = queue.popleft()\n            for y in adj[x]:\n                if sol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        for x in seen:\n            if sol[x-1] == a:\n                sol[x-1] = b\n            elif sol[x-1] == b:\n                sol[x-1] = a\n        # Repair if conflicts exploded: greedy recolor conflicted vertices within palette\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                # try to recolor u first\n                used = {sol[w-1] for w in adj[u]}\n                for c in sorted(set(sol)):\n                    if c not in used:\n                        sol[u-1] = c\n                        break\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0011240439}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution):  # returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helpers\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def total_conflicts(sol_list):\n        return sum(1 for (u,v) in edges if sol_list[u-1] == sol_list[v-1])\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    # Retry loop to avoid NoOp under conflicts\n    for _ in range(10):\n        conflicts_cnt = vertex_conflicts(new_sol)\n        tot_conf = total_conflicts(new_sol)\n        if tot_conf > 0:\n            # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n            candidates = list(range(1, n+1))\n            random.shuffle(candidates)\n            best_v = None\n            best_key = None\n            for v in candidates:\n                key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            v = best_v\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            chosen = None\n            # Try feasible color in palette\n            for c in palette:\n                if c not in neighbor_colors:\n                    chosen = c\n                    break\n            if chosen is None:\n                # If none feasible, allow introducing one new color\n                chosen = (max(palette) + 1) if palette else 1\n            if new_sol[v-1] != chosen:\n                cand = list(new_sol)\n                cand[v-1] = chosen\n                new_sol = cand\n                return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n            else:\n                # random tweak to escape tie\n                v = random.randint(1, n)\n                cand = list(new_sol)\n                cand[v-1] = max(new_sol) if new_sol[v-1] != max(new_sol) else 1\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomTweak\"\n        else:\n            # No conflicts: attempt color reduction via recoloring max-color class\n            colors_used = sorted(set(new_sol))\n            if colors_used:\n                max_color = max(colors_used)\n                holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n                if holders:\n                    v = random.choice(holders)\n                    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                    moved = False\n                    for c in range(1, max_color):\n                        if c not in neighbor_colors:\n                            cand = list(new_sol)\n                            cand[v-1] = c\n                            new_sol = cand\n                            moved = True\n                            break\n                    if moved:\n                        return new_sol, \"Local_Recolor\", \"ColorReduction\"\n                    # Kempe-chain swap between max_color and target t < max_color\n                    target_colors = [c for c in range(1, max_color)]\n                    random.shuffle(target_colors)\n                    for t in target_colors:\n                        a, b = max_color, t\n                        queue = deque([v])\n                        seen = set([v])\n                        while queue:\n                            x = queue.popleft()\n                            for y in adj[x]:\n                                if new_sol[y-1] in (a, b) and y not in seen:\n                                    seen.add(y)\n                                    queue.append(y)\n                        test = list(new_sol)\n                        for x in seen:\n                            if test[x-1] == a:\n                                test[x-1] = b\n                            elif test[x-1] == b:\n                                test[x-1] = a\n                        # Verify no conflicts introduced\n                        ok = True\n                        for (u, w) in edges:\n                            if test[u-1] == test[w-1]:\n                                ok = False\n                                break\n                        if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                            return test, \"Kempe_Swap\", \"ColorReduction\"\n            # Fallback: random feasible recolor within current palette\n            v = random.randint(1, n)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            feasible = [c for c in palette if c not in neighbor_colors]\n            if feasible:\n                cand = list(new_sol)\n                cand[v-1] = random.choice(feasible)\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # As a last resort, return the original (NoOp)\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Conflict-guided vertex set\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    # Choose k vertices to perturb (bias to conflicts)\n    base_k = max(2, min(4, n \/\/ 3))\n    chosen = list(conflicts)\n    random.shuffle(chosen)\n    if len(chosen) < base_k:\n        extra = [v for v in vertices if v not in chosen]\n        chosen += extra[: base_k - len(chosen)]\n    else:\n        chosen = chosen[:base_k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    # Apply mixed perturbations\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            sol[v-1] = random.randint(1, max_color)\n    # Optionally perform one Kempe swap between two random colors to diversify\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        start = random.randint(1, n)\n        queue = deque([start])\n        seen = set([start])\n        while queue:\n            x = queue.popleft()\n            for y in adj[x]:\n                if sol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        for x in seen:\n            if sol[x-1] == a:\n                sol[x-1] = b\n            elif sol[x-1] == b:\n                sol[x-1] = a\n        # Repair if conflicts exploded: greedy recolor conflicted vertices within palette\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                # try to recolor u first\n                used = {sol[w-1] for w in adj[u]}\n                for c in sorted(set(sol)):\n                    if c not in used:\n                        sol[u-1] = c\n                        break\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001387618}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution):  # returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helpers\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def total_conflicts(sol_list):\n        return sum(1 for (u,v) in edges if sol_list[u-1] == sol_list[v-1])\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    # Retry loop to avoid NoOp under conflicts\n    for _ in range(10):\n        conflicts_cnt = vertex_conflicts(new_sol)\n        tot_conf = total_conflicts(new_sol)\n        if tot_conf > 0:\n            # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n            candidates = list(range(1, n+1))\n            random.shuffle(candidates)\n            best_v = None\n            best_key = None\n            for v in candidates:\n                key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            v = best_v\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            chosen = None\n            # Try feasible color in palette\n            for c in palette:\n                if c not in neighbor_colors:\n                    chosen = c\n                    break\n            if chosen is None:\n                # If none feasible, allow introducing one new color\n                chosen = (max(palette) + 1) if palette else 1\n            if new_sol[v-1] != chosen:\n                cand = list(new_sol)\n                cand[v-1] = chosen\n                new_sol = cand\n                return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n            else:\n                # random tweak to escape tie\n                v = random.randint(1, n)\n                cand = list(new_sol)\n                cand[v-1] = max(new_sol) if new_sol[v-1] != max(new_sol) else 1\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomTweak\"\n        else:\n            # No conflicts: attempt color reduction via recoloring max-color class\n            colors_used = sorted(set(new_sol))\n            if colors_used:\n                max_color = max(colors_used)\n                holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n                if holders:\n                    v = random.choice(holders)\n                    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                    moved = False\n                    for c in range(1, max_color):\n                        if c not in neighbor_colors:\n                            cand = list(new_sol)\n                            cand[v-1] = c\n                            new_sol = cand\n                            moved = True\n                            break\n                    if moved:\n                        return new_sol, \"Local_Recolor\", \"ColorReduction\"\n                    # Kempe-chain swap between max_color and target t < max_color\n                    target_colors = [c for c in range(1, max_color)]\n                    random.shuffle(target_colors)\n                    for t in target_colors:\n                        a, b = max_color, t\n                        queue = deque([v])\n                        seen = set([v])\n                        while queue:\n                            x = queue.popleft()\n                            for y in adj[x]:\n                                if new_sol[y-1] in (a, b) and y not in seen:\n                                    seen.add(y)\n                                    queue.append(y)\n                        test = list(new_sol)\n                        for x in seen:\n                            if test[x-1] == a:\n                                test[x-1] = b\n                            elif test[x-1] == b:\n                                test[x-1] = a\n                        # Verify no conflicts introduced\n                        ok = True\n                        for (u, w) in edges:\n                            if test[u-1] == test[w-1]:\n                                ok = False\n                                break\n                        if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                            return test, \"Kempe_Swap\", \"ColorReduction\"\n            # Fallback: random feasible recolor within current palette\n            v = random.randint(1, n)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            feasible = [c for c in palette if c not in neighbor_colors]\n            if feasible:\n                cand = list(new_sol)\n                cand[v-1] = random.choice(feasible)\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # As a last resort, return the original (NoOp)\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Conflict-guided vertex set\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    # Choose k vertices to perturb (bias to conflicts)\n    base_k = max(2, min(4, n \/\/ 3))\n    chosen = list(conflicts)\n    random.shuffle(chosen)\n    if len(chosen) < base_k:\n        extra = [v for v in vertices if v not in chosen]\n        chosen += extra[: base_k - len(chosen)]\n    else:\n        chosen = chosen[:base_k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    # Apply mixed perturbations\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            sol[v-1] = random.randint(1, max_color)\n    # Optionally perform one Kempe swap between two random colors to diversify\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        start = random.randint(1, n)\n        queue = deque([start])\n        seen = set([start])\n        while queue:\n            x = queue.popleft()\n            for y in adj[x]:\n                if sol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        for x in seen:\n            if sol[x-1] == a:\n                sol[x-1] = b\n            elif sol[x-1] == b:\n                sol[x-1] = a\n        # Repair if conflicts exploded: greedy recolor conflicted vertices within palette\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                # try to recolor u first\n                used = {sol[w-1] for w in adj[u]}\n                for c in sorted(set(sol)):\n                    if c not in used:\n                        sol[u-1] = c\n                        break\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001385837}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    # Initialize defensively\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def total_conflicts(sol_list):\n        return sum(1 for (u,v) in edges if sol_list[u-1] == sol_list[v-1])\n    def canonicalize(sol_list):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    new_sol = list(sol)\n    # Attempt up to a few times to ensure a move is generated\n    for _ in range(12):\n        conflicts_cnt = vertex_conflicts(new_sol)\n        tot_conf = total_conflicts(new_sol)\n        palette = sorted(set(new_sol))\n        if tot_conf > 0:\n            # Pick vertex with max conflicts; tie-break by degree\n            candidates = list(range(1, n+1))\n            random.shuffle(candidates)\n            best_v = None\n            best_key = None\n            for v in candidates:\n                key = (conflicts_cnt[v], len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            v = best_v\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            # Min-conflicts recolor within current palette\n            best_c = None\n            best_nc = None\n            for c in palette:\n                nc = 0\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        nc += 1\n                if best_nc is None or nc < best_nc:\n                    best_nc = nc\n                    best_c = c\n                    if nc == 0:\n                        break\n            chosen = best_c\n            # If all current colors conflict (shouldn't happen often), allow at most one new color\n            if best_nc is not None and best_nc > 0:\n                chosen = best_c\n            if chosen is None:\n                chosen = max(palette) + 1 if palette else 1\n            if new_sol[v-1] != chosen:\n                cand = list(new_sol)\n                cand[v-1] = chosen\n                cand = canonicalize(cand)\n                return cand, \"Local_Recolor\", \"ConflictRepair_MinConflicts\"\n            else:\n                # Random tweak to escape\n                v = random.randint(1, n)\n                neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                feasible = [c for c in palette if c not in neighbor_colors and c != new_sol[v-1]]\n                if feasible:\n                    cand = list(new_sol)\n                    cand[v-1] = random.choice(feasible)\n                    cand = canonicalize(cand)\n                    return cand, \"Local_Recolor\", \"RandomFeasible_TieBreak\"\n        else:\n            # No conflicts: try color reduction by moving a max-color vertex into lower colors\n            colors_used = sorted(set(new_sol))\n            if colors_used:\n                max_color = max(colors_used)\n                holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n                if holders:\n                    v = random.choice(holders)\n                    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                    for c in range(1, max_color):\n                        if c not in neighbor_colors:\n                            cand = list(new_sol)\n                            cand[v-1] = c\n                            cand = canonicalize(cand)\n                            return cand, \"Local_Recolor\", \"ColorReduction_Greedy\"\n                    # Kempe-chain swap attempt\n                    target_colors = [c for c in range(1, max_color)]\n                    random.shuffle(target_colors)\n                    for t in target_colors:\n                        a, b = max_color, t\n                        queue = deque([v])\n                        seen = set([v])\n                        while queue:\n                            x = queue.popleft()\n                            for y in adj[x]:\n                                if new_sol[y-1] in (a, b) and y not in seen:\n                                    seen.add(y)\n                                    queue.append(y)\n                        test = list(new_sol)\n                        for x in seen:\n                            if test[x-1] == a:\n                                test[x-1] = b\n                            elif test[x-1] == b:\n                                test[x-1] = a\n                        # Validate no conflicts introduced\n                        ok = True\n                        for (u, w) in edges:\n                            if test[u-1] == test[w-1]:\n                                ok = False\n                                break\n                        if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                            test = canonicalize(test)\n                            return test, \"Kempe_Swap\", \"ColorReduction\"\n            # Fallback: random feasible recolor within current palette\n            v = random.randint(1, n)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            feasible = [c for c in palette if c not in neighbor_colors and c != new_sol[v-1]]\n            if feasible:\n                cand = list(new_sol)\n                cand[v-1] = random.choice(feasible)\n                cand = canonicalize(cand)\n                return cand, \"Local_Recolor\", \"RandomFeasible_Fallback\"\n    # NoOp as last resort\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Returns a diversified solution via bounded recolors and an optional Kempe swap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicted vertices\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    base_k = max(2, min(4, n \/\/ 3))\n    chosen = list(conflicts)\n    random.shuffle(chosen)\n    if len(chosen) < base_k:\n        extra = [v for v in vertices if v not in chosen]\n        chosen += extra[: base_k - len(chosen)]\n    else:\n        chosen = chosen[:base_k]\n    palette = sorted(set(sol))\n    # Min-conflicts recolor selected vertices within palette; avoid introducing new colors\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        best_c = None\n        best_nc = None\n        for c in palette:\n            nc = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    nc += 1\n            if best_nc is None or nc < best_nc:\n                best_nc = nc\n                best_c = c\n                if nc == 0:\n                    break\n        if best_c is not None and best_c != sol[v-1]:\n            sol[v-1] = best_c\n    # Optional Kempe swap between two randomly picked colors to diversify\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        start = random.randint(1, n)\n        queue = deque([start])\n        seen = set([start])\n        while queue:\n            x = queue.popleft()\n            for y in adj[x]:\n                if sol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        for x in seen:\n            if sol[x-1] == a:\n                sol[x-1] = b\n            elif sol[x-1] == b:\n                sol[x-1] = a\n        # Simple repair: greedy recolor any immediate conflicts within current palette\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                used = {sol[w-1] for w in adj[u]}\n                for c in sorted(set(sol)):\n                    if c not in used:\n                        sol[u-1] = c\n                        break\n    # Canonicalize colors to contiguous labels by first appearance\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001163114}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    # Initialize defensively\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def total_conflicts(sol_list):\n        return sum(1 for (u,v) in edges if sol_list[u-1] == sol_list[v-1])\n    def canonicalize(sol_list):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    new_sol = list(sol)\n    # Attempt up to a few times to ensure a move is generated\n    for _ in range(12):\n        conflicts_cnt = vertex_conflicts(new_sol)\n        tot_conf = total_conflicts(new_sol)\n        palette = sorted(set(new_sol))\n        if tot_conf > 0:\n            # Pick vertex with max conflicts; tie-break by degree\n            candidates = list(range(1, n+1))\n            random.shuffle(candidates)\n            best_v = None\n            best_key = None\n            for v in candidates:\n                key = (conflicts_cnt[v], len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            v = best_v\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            # Min-conflicts recolor within current palette\n            best_c = None\n            best_nc = None\n            for c in palette:\n                nc = 0\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        nc += 1\n                if best_nc is None or nc < best_nc:\n                    best_nc = nc\n                    best_c = c\n                    if nc == 0:\n                        break\n            chosen = best_c\n            # If all current colors conflict (shouldn't happen often), allow at most one new color\n            if best_nc is not None and best_nc > 0:\n                chosen = best_c\n            if chosen is None:\n                chosen = max(palette) + 1 if palette else 1\n            if new_sol[v-1] != chosen:\n                cand = list(new_sol)\n                cand[v-1] = chosen\n                cand = canonicalize(cand)\n                return cand, \"Local_Recolor\", \"ConflictRepair_MinConflicts\"\n            else:\n                # Random tweak to escape\n                v = random.randint(1, n)\n                neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                feasible = [c for c in palette if c not in neighbor_colors and c != new_sol[v-1]]\n                if feasible:\n                    cand = list(new_sol)\n                    cand[v-1] = random.choice(feasible)\n                    cand = canonicalize(cand)\n                    return cand, \"Local_Recolor\", \"RandomFeasible_TieBreak\"\n        else:\n            # No conflicts: try color reduction by moving a max-color vertex into lower colors\n            colors_used = sorted(set(new_sol))\n            if colors_used:\n                max_color = max(colors_used)\n                holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n                if holders:\n                    v = random.choice(holders)\n                    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                    for c in range(1, max_color):\n                        if c not in neighbor_colors:\n                            cand = list(new_sol)\n                            cand[v-1] = c\n                            cand = canonicalize(cand)\n                            return cand, \"Local_Recolor\", \"ColorReduction_Greedy\"\n                    # Kempe-chain swap attempt\n                    target_colors = [c for c in range(1, max_color)]\n                    random.shuffle(target_colors)\n                    for t in target_colors:\n                        a, b = max_color, t\n                        queue = deque([v])\n                        seen = set([v])\n                        while queue:\n                            x = queue.popleft()\n                            for y in adj[x]:\n                                if new_sol[y-1] in (a, b) and y not in seen:\n                                    seen.add(y)\n                                    queue.append(y)\n                        test = list(new_sol)\n                        for x in seen:\n                            if test[x-1] == a:\n                                test[x-1] = b\n                            elif test[x-1] == b:\n                                test[x-1] = a\n                        # Validate no conflicts introduced\n                        ok = True\n                        for (u, w) in edges:\n                            if test[u-1] == test[w-1]:\n                                ok = False\n                                break\n                        if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                            test = canonicalize(test)\n                            return test, \"Kempe_Swap\", \"ColorReduction\"\n            # Fallback: random feasible recolor within current palette\n            v = random.randint(1, n)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            feasible = [c for c in palette if c not in neighbor_colors and c != new_sol[v-1]]\n            if feasible:\n                cand = list(new_sol)\n                cand[v-1] = random.choice(feasible)\n                cand = canonicalize(cand)\n                return cand, \"Local_Recolor\", \"RandomFeasible_Fallback\"\n    # NoOp as last resort\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Returns a diversified solution via bounded recolors and an optional Kempe swap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicted vertices\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    base_k = max(2, min(4, n \/\/ 3))\n    chosen = list(conflicts)\n    random.shuffle(chosen)\n    if len(chosen) < base_k:\n        extra = [v for v in vertices if v not in chosen]\n        chosen += extra[: base_k - len(chosen)]\n    else:\n        chosen = chosen[:base_k]\n    palette = sorted(set(sol))\n    # Min-conflicts recolor selected vertices within palette; avoid introducing new colors\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        best_c = None\n        best_nc = None\n        for c in palette:\n            nc = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    nc += 1\n            if best_nc is None or nc < best_nc:\n                best_nc = nc\n                best_c = c\n                if nc == 0:\n                    break\n        if best_c is not None and best_c != sol[v-1]:\n            sol[v-1] = best_c\n    # Optional Kempe swap between two randomly picked colors to diversify\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        start = random.randint(1, n)\n        queue = deque([start])\n        seen = set([start])\n        while queue:\n            x = queue.popleft()\n            for y in adj[x]:\n                if sol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        for x in seen:\n            if sol[x-1] == a:\n                sol[x-1] = b\n            elif sol[x-1] == b:\n                sol[x-1] = a\n        # Simple repair: greedy recolor any immediate conflicts within current palette\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                used = {sol[w-1] for w in adj[u]}\n                for c in sorted(set(sol)):\n                    if c not in used:\n                        sol[u-1] = c\n                        break\n    # Canonicalize colors to contiguous labels by first appearance\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001432988}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    # Initialize defensively\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def total_conflicts(sol_list):\n        return sum(1 for (u,v) in edges if sol_list[u-1] == sol_list[v-1])\n    def canonicalize(sol_list):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    new_sol = list(sol)\n    # Attempt up to a few times to ensure a move is generated\n    for _ in range(12):\n        conflicts_cnt = vertex_conflicts(new_sol)\n        tot_conf = total_conflicts(new_sol)\n        palette = sorted(set(new_sol))\n        if tot_conf > 0:\n            # Pick vertex with max conflicts; tie-break by degree\n            candidates = list(range(1, n+1))\n            random.shuffle(candidates)\n            best_v = None\n            best_key = None\n            for v in candidates:\n                key = (conflicts_cnt[v], len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            v = best_v\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            # Min-conflicts recolor within current palette\n            best_c = None\n            best_nc = None\n            for c in palette:\n                nc = 0\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        nc += 1\n                if best_nc is None or nc < best_nc:\n                    best_nc = nc\n                    best_c = c\n                    if nc == 0:\n                        break\n            chosen = best_c\n            # If all current colors conflict (shouldn't happen often), allow at most one new color\n            if best_nc is not None and best_nc > 0:\n                chosen = best_c\n            if chosen is None:\n                chosen = max(palette) + 1 if palette else 1\n            if new_sol[v-1] != chosen:\n                cand = list(new_sol)\n                cand[v-1] = chosen\n                cand = canonicalize(cand)\n                return cand, \"Local_Recolor\", \"ConflictRepair_MinConflicts\"\n            else:\n                # Random tweak to escape\n                v = random.randint(1, n)\n                neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                feasible = [c for c in palette if c not in neighbor_colors and c != new_sol[v-1]]\n                if feasible:\n                    cand = list(new_sol)\n                    cand[v-1] = random.choice(feasible)\n                    cand = canonicalize(cand)\n                    return cand, \"Local_Recolor\", \"RandomFeasible_TieBreak\"\n        else:\n            # No conflicts: try color reduction by moving a max-color vertex into lower colors\n            colors_used = sorted(set(new_sol))\n            if colors_used:\n                max_color = max(colors_used)\n                holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n                if holders:\n                    v = random.choice(holders)\n                    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                    for c in range(1, max_color):\n                        if c not in neighbor_colors:\n                            cand = list(new_sol)\n                            cand[v-1] = c\n                            cand = canonicalize(cand)\n                            return cand, \"Local_Recolor\", \"ColorReduction_Greedy\"\n                    # Kempe-chain swap attempt\n                    target_colors = [c for c in range(1, max_color)]\n                    random.shuffle(target_colors)\n                    for t in target_colors:\n                        a, b = max_color, t\n                        queue = deque([v])\n                        seen = set([v])\n                        while queue:\n                            x = queue.popleft()\n                            for y in adj[x]:\n                                if new_sol[y-1] in (a, b) and y not in seen:\n                                    seen.add(y)\n                                    queue.append(y)\n                        test = list(new_sol)\n                        for x in seen:\n                            if test[x-1] == a:\n                                test[x-1] = b\n                            elif test[x-1] == b:\n                                test[x-1] = a\n                        # Validate no conflicts introduced\n                        ok = True\n                        for (u, w) in edges:\n                            if test[u-1] == test[w-1]:\n                                ok = False\n                                break\n                        if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                            test = canonicalize(test)\n                            return test, \"Kempe_Swap\", \"ColorReduction\"\n            # Fallback: random feasible recolor within current palette\n            v = random.randint(1, n)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            feasible = [c for c in palette if c not in neighbor_colors and c != new_sol[v-1]]\n            if feasible:\n                cand = list(new_sol)\n                cand[v-1] = random.choice(feasible)\n                cand = canonicalize(cand)\n                return cand, \"Local_Recolor\", \"RandomFeasible_Fallback\"\n    # NoOp as last resort\n    return new_sol, \"NoOp\", \"Stall\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Returns a diversified solution via bounded recolors and an optional Kempe swap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicted vertices\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    base_k = max(2, min(4, n \/\/ 3))\n    chosen = list(conflicts)\n    random.shuffle(chosen)\n    if len(chosen) < base_k:\n        extra = [v for v in vertices if v not in chosen]\n        chosen += extra[: base_k - len(chosen)]\n    else:\n        chosen = chosen[:base_k]\n    palette = sorted(set(sol))\n    # Min-conflicts recolor selected vertices within palette; avoid introducing new colors\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        best_c = None\n        best_nc = None\n        for c in palette:\n            nc = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    nc += 1\n            if best_nc is None or nc < best_nc:\n                best_nc = nc\n                best_c = c\n                if nc == 0:\n                    break\n        if best_c is not None and best_c != sol[v-1]:\n            sol[v-1] = best_c\n    # Optional Kempe swap between two randomly picked colors to diversify\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        start = random.randint(1, n)\n        queue = deque([start])\n        seen = set([start])\n        while queue:\n            x = queue.popleft()\n            for y in adj[x]:\n                if sol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        for x in seen:\n            if sol[x-1] == a:\n                sol[x-1] = b\n            elif sol[x-1] == b:\n                sol[x-1] = a\n        # Simple repair: greedy recolor any immediate conflicts within current palette\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                used = {sol[w-1] for w in adj[u]}\n                for c in sorted(set(sol)):\n                    if c not in used:\n                        sol[u-1] = c\n                        break\n    # Canonicalize colors to contiguous labels by first appearance\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001485558}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color of vertex i. Colors are 1-based labels. Equal colors are allowed only if the corresponding vertex pair is an edge in G. Objective: minimize number of distinct colors.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected, u<v normalized)\n    edges = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    E = set()\n    for (u,v) in edges:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    non_edges = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                non_edges.append((i,j))\n    # Count violations of complement-coloring constraint\n    violations = 0\n    for (i,j) in non_edges:\n        if solution[i-1] == solution[j-1]:\n            violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective is number of colors used\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Provide a basic valid random solution if input invalid\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    # Neighborhood move types: single-vertex recolor, color-swap, pairwise swap of vertices\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = set(sol)\n        # Allow moving to an existing color or (rarely) a new color to escape local minima\n        if random.random() < 0.1:\n            new_color = max(current_colors) + 1\n        else:\n            candidates = list(current_colors)\n            if len(candidates) == 1:\n                new_color = max(candidates) + 1\n            else:\n                new_color = random.choice([c for c in candidates if c != sol[i]])\n        sol[i] = int(new_color)\n        return sol\n    elif move_choice < 0.85:\n        # Swap the labels of two colors globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        else:\n            # fallback to recolor\n            i = random.randrange(n)\n            sol[i] = sol[i] if sol[i] > 1 else 2\n        return sol\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Apply multiple random neighbor moves for diversification\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 4) for _ in range(9)]\n    else:\n        sol = list(solution)\n    steps = 1 + int(3 + 4 * random.random())  # 4-7 random steps\n    for _ in range(steps):\n        # Inline minimal neighbor logic to avoid external deps\n        n = 9\n        move = random.random()\n        if move < 0.5:\n            i = random.randrange(n)\n            current_colors = set(sol)\n            if random.random() < 0.2:\n                new_color = max(current_colors) + 1\n            else:\n                cand = list(current_colors)\n                if len(cand) == 1:\n                    new_color = max(cand) + 1\n                else:\n                    new_color = random.choice([c for c in cand if c != sol[i]])\n            sol[i] = int(new_color)\n        elif move < 0.8:\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if sol[idx] == a:\n                        sol[idx] = b\n                    elif sol[idx] == b:\n                        sol[idx] = a\n        else:\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.000520077}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color of vertex i. Colors are 1-based labels. Equal colors are allowed only if the corresponding vertex pair is an edge in G. Objective: minimize number of distinct colors.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected, u<v normalized)\n    edges = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    E = set()\n    for (u,v) in edges:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    non_edges = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                non_edges.append((i,j))\n    # Count violations of complement-coloring constraint\n    violations = 0\n    for (i,j) in non_edges:\n        if solution[i-1] == solution[j-1]:\n            violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective is number of colors used\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Provide a basic valid random solution if input invalid\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    # Neighborhood move types: single-vertex recolor, color-swap, pairwise swap of vertices\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = set(sol)\n        # Allow moving to an existing color or (rarely) a new color to escape local minima\n        if random.random() < 0.1:\n            new_color = max(current_colors) + 1\n        else:\n            candidates = list(current_colors)\n            if len(candidates) == 1:\n                new_color = max(candidates) + 1\n            else:\n                new_color = random.choice([c for c in candidates if c != sol[i]])\n        sol[i] = int(new_color)\n        return sol\n    elif move_choice < 0.85:\n        # Swap the labels of two colors globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        else:\n            # fallback to recolor\n            i = random.randrange(n)\n            sol[i] = sol[i] if sol[i] > 1 else 2\n        return sol\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Apply multiple random neighbor moves for diversification\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 4) for _ in range(9)]\n    else:\n        sol = list(solution)\n    steps = 1 + int(3 + 4 * random.random())  # 4-7 random steps\n    for _ in range(steps):\n        # Inline minimal neighbor logic to avoid external deps\n        n = 9\n        move = random.random()\n        if move < 0.5:\n            i = random.randrange(n)\n            current_colors = set(sol)\n            if random.random() < 0.2:\n                new_color = max(current_colors) + 1\n            else:\n                cand = list(current_colors)\n                if len(cand) == 1:\n                    new_color = max(cand) + 1\n                else:\n                    new_color = random.choice([c for c in cand if c != sol[i]])\n            sol[i] = int(new_color)\n        elif move < 0.8:\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if sol[idx] == a:\n                        sol[idx] = b\n                    elif sol[idx] == b:\n                        sol[idx] = a\n        else:\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.000690998}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color of vertex i. Colors are 1-based labels. Equal colors are allowed only if the corresponding vertex pair is an edge in G. Objective: minimize number of distinct colors.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected, u<v normalized)\n    edges = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    E = set()\n    for (u,v) in edges:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    non_edges = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                non_edges.append((i,j))\n    # Count violations of complement-coloring constraint\n    violations = 0\n    for (i,j) in non_edges:\n        if solution[i-1] == solution[j-1]:\n            violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective is number of colors used\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Provide a basic valid random solution if input invalid\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    # Neighborhood move types: single-vertex recolor, color-swap, pairwise swap of vertices\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = set(sol)\n        # Allow moving to an existing color or (rarely) a new color to escape local minima\n        if random.random() < 0.1:\n            new_color = max(current_colors) + 1\n        else:\n            candidates = list(current_colors)\n            if len(candidates) == 1:\n                new_color = max(candidates) + 1\n            else:\n                new_color = random.choice([c for c in candidates if c != sol[i]])\n        sol[i] = int(new_color)\n        return sol\n    elif move_choice < 0.85:\n        # Swap the labels of two colors globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        else:\n            # fallback to recolor\n            i = random.randrange(n)\n            sol[i] = sol[i] if sol[i] > 1 else 2\n        return sol\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Apply multiple random neighbor moves for diversification\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 4) for _ in range(9)]\n    else:\n        sol = list(solution)\n    steps = 1 + int(3 + 4 * random.random())  # 4-7 random steps\n    for _ in range(steps):\n        # Inline minimal neighbor logic to avoid external deps\n        n = 9\n        move = random.random()\n        if move < 0.5:\n            i = random.randrange(n)\n            current_colors = set(sol)\n            if random.random() < 0.2:\n                new_color = max(current_colors) + 1\n            else:\n                cand = list(current_colors)\n                if len(cand) == 1:\n                    new_color = max(cand) + 1\n                else:\n                    new_color = random.choice([c for c in cand if c != sol[i]])\n            sol[i] = int(new_color)\n        elif move < 0.8:\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if sol[idx] == a:\n                        sol[idx] = b\n                    elif sol[idx] == b:\n                        sol[idx] = a\n        else:\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.000644108}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-based). Vertices sharing a color must be pairwise adjacent in G; objective is to minimize the number of distinct colors.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a basic valid random solution\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Neighborhood: recolor single vertex (prefer existing colors), color-swap, vertex-swap\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = list(set(sol))\n        # Prefer existing colors different from current; rarely add a new color\n        if len(current_colors) > 1 and random.random() < 0.95:\n            candidates = [c for c in current_colors if c != sol[i]]\n            if candidates:\n                sol[i] = int(random.choice(candidates))\n            else:\n                sol[i] = sol[i]\n        else:\n            sol[i] = int(max(current_colors) + 1)\n        return sol, \"recolor\"\n    elif r < 0.85:\n        # Swap two color labels globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        return sol, \"color_swap\"\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol, \"vertex_swap\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-step randomized diversification\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n    steps = 4 + int(4 * random.random())  # 4-7 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # Recolor vertex, occasionally introduce new color\n            i = random.randrange(n)\n            colors = list(set(sol))\n            if random.random() < 0.8 and len(colors) > 1:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n                else:\n                    sol[i] = sol[i]\n            else:\n                sol[i] = int(max(colors) + 1)\n        elif move < 0.8:\n            # Global color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        else:\n            # Swap colors between two vertices\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.000542826}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-based). Vertices sharing a color must be pairwise adjacent in G; objective is to minimize the number of distinct colors.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a basic valid random solution\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Neighborhood: recolor single vertex (prefer existing colors), color-swap, vertex-swap\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = list(set(sol))\n        # Prefer existing colors different from current; rarely add a new color\n        if len(current_colors) > 1 and random.random() < 0.95:\n            candidates = [c for c in current_colors if c != sol[i]]\n            if candidates:\n                sol[i] = int(random.choice(candidates))\n            else:\n                sol[i] = sol[i]\n        else:\n            sol[i] = int(max(current_colors) + 1)\n        return sol, \"recolor\"\n    elif r < 0.85:\n        # Swap two color labels globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        return sol, \"color_swap\"\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol, \"vertex_swap\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-step randomized diversification\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n    steps = 4 + int(4 * random.random())  # 4-7 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # Recolor vertex, occasionally introduce new color\n            i = random.randrange(n)\n            colors = list(set(sol))\n            if random.random() < 0.8 and len(colors) > 1:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n                else:\n                    sol[i] = sol[i]\n            else:\n                sol[i] = int(max(colors) + 1)\n        elif move < 0.8:\n            # Global color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        else:\n            # Swap colors between two vertices\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0006942779}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-based). Vertices sharing a color must be pairwise adjacent in G; objective is to minimize the number of distinct colors.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a basic valid random solution\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Neighborhood: recolor single vertex (prefer existing colors), color-swap, vertex-swap\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = list(set(sol))\n        # Prefer existing colors different from current; rarely add a new color\n        if len(current_colors) > 1 and random.random() < 0.95:\n            candidates = [c for c in current_colors if c != sol[i]]\n            if candidates:\n                sol[i] = int(random.choice(candidates))\n            else:\n                sol[i] = sol[i]\n        else:\n            sol[i] = int(max(current_colors) + 1)\n        return sol, \"recolor\"\n    elif r < 0.85:\n        # Swap two color labels globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        return sol, \"color_swap\"\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol, \"vertex_swap\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-step randomized diversification\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n    steps = 4 + int(4 * random.random())  # 4-7 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # Recolor vertex, occasionally introduce new color\n            i = random.randrange(n)\n            colors = list(set(sol))\n            if random.random() < 0.8 and len(colors) > 1:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n                else:\n                    sol[i] = sol[i]\n            else:\n                sol[i] = int(max(colors) + 1)\n        elif move < 0.8:\n            # Global color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        else:\n            # Swap colors between two vertices\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","Resultados":"Failed to run target heuristic: name 'random' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0006613281}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G and count violations when same color appears on non-edge pair\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers local to this function to avoid globals\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        # A vertex can join a color class if it is adjacent in G to all vertices already in that color\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def reduce_color_move(E, sol):\n        # Attempt to remove the highest color by reassigning its vertices to existing colors\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        success = True\n        random.shuffle(verts)\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = [c if c != max_color else max_color for c in sol]  # no remaining max_color\n            sol = normalize_colors(sol)\n            return sol, True\n        return sol, False\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        # Build conflict graph H where an edge exists if two vertices are non-adjacent in G\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        # vertices with color a or b\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        # BFS in H restricted to nodes colored a or b\n        visited = set()\n        q = deque([start])\n        visited.add(start)\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            out[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return normalize_colors(out)\n    # Start\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    r = random.random()\n    if r < 0.45:\n        # Single-vertex recolor (prefer existing colors, occasionally new)\n        i = random.randrange(n)\n        current_colors = sorted(set(sol))\n        move_to_new = (random.random() < 0.05)\n        if move_to_new:\n            sol[i] = max(current_colors) + 1\n            move = \"recolor_new\"\n        else:\n            choices = [c for c in current_colors if c != sol[i]]\n            if choices:\n                sol[i] = int(random.choice(choices))\n            move = \"recolor_existing\"\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.7:\n        # Global color label swap\n        colors = list(set(sol))\n        move = \"color_swap\"\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.85:\n        # Reduce-color attempt\n        new_sol, ok = reduce_color_move(E, sol)\n        return (new_sol if ok else sol), (\"reduce_color\" if ok else \"reduce_color_fail\")\n    else:\n        # Kempe-chain style swap in conflict graph\n        sol2 = kempe_chain_swap_on_conflict_graph(E, sol)\n        return sol2, \"kempe_chain\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helpers\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    steps = 5 + int(5 * random.random())  # 5-9 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.35:\n            # Random recolor (allow new colors with small prob)\n            i = random.randrange(n)\n            colors = sorted(set(sol))\n            if random.random() < 0.15:\n                sol[i] = max(colors) + 1\n            else:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n        elif move < 0.6:\n            # Random color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        elif move < 0.8:\n            # Greedy reassignment to existing colors for a random vertex\n            v = random.randrange(n) + 1\n            colors = sorted(set(sol))\n            random.shuffle(colors)\n            for c in colors:\n                if c != sol[v-1] and compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    break\n        else:\n            # Attempt to remove highest color by reassigning its vertices greedily\n            colors = sorted(set(sol))\n            if len(colors) > 1:\n                max_color = max(colors)\n                verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n                other_colors = [c for c in colors if c != max_color]\n                random.shuffle(verts)\n                for v in verts:\n                    random.shuffle(other_colors)\n                    for c in other_colors:\n                        if compatible_with_color(E, sol, v, c):\n                            sol[v-1] = c\n                            break\n        sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0011035929}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G and count violations when same color appears on non-edge pair\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers local to this function to avoid globals\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        # A vertex can join a color class if it is adjacent in G to all vertices already in that color\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def reduce_color_move(E, sol):\n        # Attempt to remove the highest color by reassigning its vertices to existing colors\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        success = True\n        random.shuffle(verts)\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = [c if c != max_color else max_color for c in sol]  # no remaining max_color\n            sol = normalize_colors(sol)\n            return sol, True\n        return sol, False\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        # Build conflict graph H where an edge exists if two vertices are non-adjacent in G\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        # vertices with color a or b\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        # BFS in H restricted to nodes colored a or b\n        visited = set()\n        q = deque([start])\n        visited.add(start)\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            out[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return normalize_colors(out)\n    # Start\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    r = random.random()\n    if r < 0.45:\n        # Single-vertex recolor (prefer existing colors, occasionally new)\n        i = random.randrange(n)\n        current_colors = sorted(set(sol))\n        move_to_new = (random.random() < 0.05)\n        if move_to_new:\n            sol[i] = max(current_colors) + 1\n            move = \"recolor_new\"\n        else:\n            choices = [c for c in current_colors if c != sol[i]]\n            if choices:\n                sol[i] = int(random.choice(choices))\n            move = \"recolor_existing\"\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.7:\n        # Global color label swap\n        colors = list(set(sol))\n        move = \"color_swap\"\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.85:\n        # Reduce-color attempt\n        new_sol, ok = reduce_color_move(E, sol)\n        return (new_sol if ok else sol), (\"reduce_color\" if ok else \"reduce_color_fail\")\n    else:\n        # Kempe-chain style swap in conflict graph\n        sol2 = kempe_chain_swap_on_conflict_graph(E, sol)\n        return sol2, \"kempe_chain\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helpers\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    steps = 5 + int(5 * random.random())  # 5-9 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.35:\n            # Random recolor (allow new colors with small prob)\n            i = random.randrange(n)\n            colors = sorted(set(sol))\n            if random.random() < 0.15:\n                sol[i] = max(colors) + 1\n            else:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n        elif move < 0.6:\n            # Random color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        elif move < 0.8:\n            # Greedy reassignment to existing colors for a random vertex\n            v = random.randrange(n) + 1\n            colors = sorted(set(sol))\n            random.shuffle(colors)\n            for c in colors:\n                if c != sol[v-1] and compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    break\n        else:\n            # Attempt to remove highest color by reassigning its vertices greedily\n            colors = sorted(set(sol))\n            if len(colors) > 1:\n                max_color = max(colors)\n                verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n                other_colors = [c for c in colors if c != max_color]\n                random.shuffle(verts)\n                for v in verts:\n                    random.shuffle(other_colors)\n                    for c in other_colors:\n                        if compatible_with_color(E, sol, v, c):\n                            sol[v-1] = c\n                            break\n        sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0013488671}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G and count violations when same color appears on non-edge pair\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers local to this function to avoid globals\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        # A vertex can join a color class if it is adjacent in G to all vertices already in that color\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def reduce_color_move(E, sol):\n        # Attempt to remove the highest color by reassigning its vertices to existing colors\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        success = True\n        random.shuffle(verts)\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = [c if c != max_color else max_color for c in sol]  # no remaining max_color\n            sol = normalize_colors(sol)\n            return sol, True\n        return sol, False\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        # Build conflict graph H where an edge exists if two vertices are non-adjacent in G\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        # vertices with color a or b\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        # BFS in H restricted to nodes colored a or b\n        visited = set()\n        q = deque([start])\n        visited.add(start)\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            out[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return normalize_colors(out)\n    # Start\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    r = random.random()\n    if r < 0.45:\n        # Single-vertex recolor (prefer existing colors, occasionally new)\n        i = random.randrange(n)\n        current_colors = sorted(set(sol))\n        move_to_new = (random.random() < 0.05)\n        if move_to_new:\n            sol[i] = max(current_colors) + 1\n            move = \"recolor_new\"\n        else:\n            choices = [c for c in current_colors if c != sol[i]]\n            if choices:\n                sol[i] = int(random.choice(choices))\n            move = \"recolor_existing\"\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.7:\n        # Global color label swap\n        colors = list(set(sol))\n        move = \"color_swap\"\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.85:\n        # Reduce-color attempt\n        new_sol, ok = reduce_color_move(E, sol)\n        return (new_sol if ok else sol), (\"reduce_color\" if ok else \"reduce_color_fail\")\n    else:\n        # Kempe-chain style swap in conflict graph\n        sol2 = kempe_chain_swap_on_conflict_graph(E, sol)\n        return sol2, \"kempe_chain\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helpers\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    steps = 5 + int(5 * random.random())  # 5-9 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.35:\n            # Random recolor (allow new colors with small prob)\n            i = random.randrange(n)\n            colors = sorted(set(sol))\n            if random.random() < 0.15:\n                sol[i] = max(colors) + 1\n            else:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n        elif move < 0.6:\n            # Random color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        elif move < 0.8:\n            # Greedy reassignment to existing colors for a random vertex\n            v = random.randrange(n) + 1\n            colors = sorted(set(sol))\n            random.shuffle(colors)\n            for c in colors:\n                if c != sol[v-1] and compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    break\n        else:\n            # Attempt to remove highest color by reassigning its vertices greedily\n            colors = sorted(set(sol))\n            if len(colors) > 1:\n                max_color = max(colors)\n                verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n                other_colors = [c for c in colors if c != max_color]\n                random.shuffle(verts)\n                for v in verts:\n                    random.shuffle(other_colors)\n                    for c in other_colors:\n                        if compatible_with_color(E, sol, v, c):\n                            sol[v-1] = c\n                            break\n        sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001328646}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON-serializable list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize the number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv. Color labels are symmetric; normalization may relabel colors while preserving partition.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Count violations on non-edges sharing a color\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (min(i,j), max(i,j)) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers local to this function to avoid globals\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        # Vertex can join a color class if adjacent in G to all vertices already in that color\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def reduce_color_move(E, sol):\n        # Attempt to remove the highest color by reassigning its vertices to existing colors\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            # All vertices of max_color reassigned; normalize to drop the color label\n            sol = normalize_colors(sol)\n            return sol, True\n        return sol, False\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        # Build conflict graph H where an edge exists if two vertices are non-adjacent in G\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            if out[v-1] == a:\n                out[v-1] = b\n            elif out[v-1] == b:\n                out[v-1] = a\n        return normalize_colors(out)\n    def merge_small_color_classes(E, sol):\n        # Attempt to merge two smallest color classes if their union is a clique in G\n        sol = list(sol)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return sol, False\n        # sort colors by class size asc\n        sizes = {c: sol.count(c) for c in colors}\n        ordered = sorted(colors, key=lambda c: sizes[c])\n        for i in range(len(ordered)):\n            for j in range(i+1, len(ordered)):\n                a, b = ordered[i], ordered[j]\n                # check feasibility of merging b into a\n                ok = True\n                verts_a = [idx+1 for idx,c in enumerate(sol) if c == a]\n                verts_b = [idx+1 for idx,c in enumerate(sol) if c == b]\n                for u in verts_b:\n                    for v in verts_a:\n                        if not is_edge(E, u, v):\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    for u in verts_b:\n                        sol[u-1] = a\n                    return normalize_colors(sol), True\n        return sol, False\n    def eject_and_best_fit(E, sol):\n        # Eject a random vertex to the best compatible existing color (or new color if none)\n        sol = list(sol)\n        n = 9\n        v = random.randrange(n) + 1\n        current_color = sol[v-1]\n        colors = [c for c in sorted(set(sol)) if c != current_color]\n        random.shuffle(colors)\n        placed = False\n        for c in colors:\n            if compatible_with_color(E, sol, v, c):\n                sol[v-1] = c\n                placed = True\n                break\n        if not placed:\n            # move to a new color label to diversify\n            sol[v-1] = max([current_color] + colors) + 1\n        return normalize_colors(sol)\n    # Start\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    r = random.random()\n    if r < 0.30:\n        # Targeted merge of color classes\n        new_sol, ok = merge_small_color_classes(E, sol)\n        return (new_sol if ok else sol), (\"merge\" if ok else \"merge_fail\")\n    elif r < 0.55:\n        # Single-vertex recolor preferring existing colors\n        i = random.randrange(n)\n        current_colors = sorted(set(sol))\n        choices = [c for c in current_colors if c != sol[i]]\n        move = \"recolor_existing\"\n        if choices:\n            sol[i] = int(random.choice(choices))\n        else:\n            sol[i] = max(current_colors) + 1\n            move = \"recolor_new\"\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.70:\n        # Color label swap (symmetry move)\n        colors = list(set(sol))\n        move = \"color_swap\"\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.85:\n        # Reduce-color attempt by reassigning highest label\n        new_sol, ok = reduce_color_move(E, sol)\n        return (new_sol if ok else sol), (\"reduce_color\" if ok else \"reduce_color_fail\")\n    elif r < 0.95:\n        # Ejection with best-fit insertion\n        return eject_and_best_fit(E, sol), \"eject_best_fit\"\n    else:\n        # Kempe-chain style swap in conflict graph\n        sol2 = kempe_chain_swap_on_conflict_graph(E, sol)\n        return sol2, \"kempe_chain\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helpers\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            if out[v-1] == a:\n                out[v-1] = b\n            elif out[v-1] == b:\n                out[v-1] = a\n        return normalize_colors(out)\n    def greedy_reassign_highest(E, sol):\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        random.shuffle(verts)\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                # if cannot place, keep as is\n                pass\n        return normalize_colors(sol)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    steps = 6\n    for t in range(steps):\n        move = random.random()\n        if move < 0.3:\n            # Multi-vertex recolor to existing compatible colors (feasibility-preserving when possible)\n            v = random.randrange(n) + 1\n            colors = sorted(set(sol))\n            random.shuffle(colors)\n            for c in colors:\n                if c != sol[v-1] and compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    break\n        elif move < 0.6:\n            # One Kempe-chain swap on conflict graph\n            sol = kempe_chain_swap_on_conflict_graph(E, sol)\n        elif move < 0.85:\n            # Greedy attempt to compress highest label\n            sol = greedy_reassign_highest(E, sol)\n        else:\n            # Small random symmetry: swap two labels\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n                sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001429077}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON-serializable list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize the number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv. Color labels are symmetric; normalization may relabel colors while preserving partition.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Count violations on non-edges sharing a color\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (min(i,j), max(i,j)) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers local to this function to avoid globals\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        # Vertex can join a color class if adjacent in G to all vertices already in that color\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def reduce_color_move(E, sol):\n        # Attempt to remove the highest color by reassigning its vertices to existing colors\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            # All vertices of max_color reassigned; normalize to drop the color label\n            sol = normalize_colors(sol)\n            return sol, True\n        return sol, False\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        # Build conflict graph H where an edge exists if two vertices are non-adjacent in G\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            if out[v-1] == a:\n                out[v-1] = b\n            elif out[v-1] == b:\n                out[v-1] = a\n        return normalize_colors(out)\n    def merge_small_color_classes(E, sol):\n        # Attempt to merge two smallest color classes if their union is a clique in G\n        sol = list(sol)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return sol, False\n        # sort colors by class size asc\n        sizes = {c: sol.count(c) for c in colors}\n        ordered = sorted(colors, key=lambda c: sizes[c])\n        for i in range(len(ordered)):\n            for j in range(i+1, len(ordered)):\n                a, b = ordered[i], ordered[j]\n                # check feasibility of merging b into a\n                ok = True\n                verts_a = [idx+1 for idx,c in enumerate(sol) if c == a]\n                verts_b = [idx+1 for idx,c in enumerate(sol) if c == b]\n                for u in verts_b:\n                    for v in verts_a:\n                        if not is_edge(E, u, v):\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    for u in verts_b:\n                        sol[u-1] = a\n                    return normalize_colors(sol), True\n        return sol, False\n    def eject_and_best_fit(E, sol):\n        # Eject a random vertex to the best compatible existing color (or new color if none)\n        sol = list(sol)\n        n = 9\n        v = random.randrange(n) + 1\n        current_color = sol[v-1]\n        colors = [c for c in sorted(set(sol)) if c != current_color]\n        random.shuffle(colors)\n        placed = False\n        for c in colors:\n            if compatible_with_color(E, sol, v, c):\n                sol[v-1] = c\n                placed = True\n                break\n        if not placed:\n            # move to a new color label to diversify\n            sol[v-1] = max([current_color] + colors) + 1\n        return normalize_colors(sol)\n    # Start\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    r = random.random()\n    if r < 0.30:\n        # Targeted merge of color classes\n        new_sol, ok = merge_small_color_classes(E, sol)\n        return (new_sol if ok else sol), (\"merge\" if ok else \"merge_fail\")\n    elif r < 0.55:\n        # Single-vertex recolor preferring existing colors\n        i = random.randrange(n)\n        current_colors = sorted(set(sol))\n        choices = [c for c in current_colors if c != sol[i]]\n        move = \"recolor_existing\"\n        if choices:\n            sol[i] = int(random.choice(choices))\n        else:\n            sol[i] = max(current_colors) + 1\n            move = \"recolor_new\"\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.70:\n        # Color label swap (symmetry move)\n        colors = list(set(sol))\n        move = \"color_swap\"\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.85:\n        # Reduce-color attempt by reassigning highest label\n        new_sol, ok = reduce_color_move(E, sol)\n        return (new_sol if ok else sol), (\"reduce_color\" if ok else \"reduce_color_fail\")\n    elif r < 0.95:\n        # Ejection with best-fit insertion\n        return eject_and_best_fit(E, sol), \"eject_best_fit\"\n    else:\n        # Kempe-chain style swap in conflict graph\n        sol2 = kempe_chain_swap_on_conflict_graph(E, sol)\n        return sol2, \"kempe_chain\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helpers\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            if out[v-1] == a:\n                out[v-1] = b\n            elif out[v-1] == b:\n                out[v-1] = a\n        return normalize_colors(out)\n    def greedy_reassign_highest(E, sol):\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        random.shuffle(verts)\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                # if cannot place, keep as is\n                pass\n        return normalize_colors(sol)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    steps = 6\n    for t in range(steps):\n        move = random.random()\n        if move < 0.3:\n            # Multi-vertex recolor to existing compatible colors (feasibility-preserving when possible)\n            v = random.randrange(n) + 1\n            colors = sorted(set(sol))\n            random.shuffle(colors)\n            for c in colors:\n                if c != sol[v-1] and compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    break\n        elif move < 0.6:\n            # One Kempe-chain swap on conflict graph\n            sol = kempe_chain_swap_on_conflict_graph(E, sol)\n        elif move < 0.85:\n            # Greedy attempt to compress highest label\n            sol = greedy_reassign_highest(E, sol)\n        else:\n            # Small random symmetry: swap two labels\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n                sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0017540409}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON-serializable list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize the number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv. Color labels are symmetric; normalization may relabel colors while preserving partition.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Count violations on non-edges sharing a color\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (min(i,j), max(i,j)) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers local to this function to avoid globals\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        # Vertex can join a color class if adjacent in G to all vertices already in that color\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def reduce_color_move(E, sol):\n        # Attempt to remove the highest color by reassigning its vertices to existing colors\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            # All vertices of max_color reassigned; normalize to drop the color label\n            sol = normalize_colors(sol)\n            return sol, True\n        return sol, False\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        # Build conflict graph H where an edge exists if two vertices are non-adjacent in G\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            if out[v-1] == a:\n                out[v-1] = b\n            elif out[v-1] == b:\n                out[v-1] = a\n        return normalize_colors(out)\n    def merge_small_color_classes(E, sol):\n        # Attempt to merge two smallest color classes if their union is a clique in G\n        sol = list(sol)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return sol, False\n        # sort colors by class size asc\n        sizes = {c: sol.count(c) for c in colors}\n        ordered = sorted(colors, key=lambda c: sizes[c])\n        for i in range(len(ordered)):\n            for j in range(i+1, len(ordered)):\n                a, b = ordered[i], ordered[j]\n                # check feasibility of merging b into a\n                ok = True\n                verts_a = [idx+1 for idx,c in enumerate(sol) if c == a]\n                verts_b = [idx+1 for idx,c in enumerate(sol) if c == b]\n                for u in verts_b:\n                    for v in verts_a:\n                        if not is_edge(E, u, v):\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    for u in verts_b:\n                        sol[u-1] = a\n                    return normalize_colors(sol), True\n        return sol, False\n    def eject_and_best_fit(E, sol):\n        # Eject a random vertex to the best compatible existing color (or new color if none)\n        sol = list(sol)\n        n = 9\n        v = random.randrange(n) + 1\n        current_color = sol[v-1]\n        colors = [c for c in sorted(set(sol)) if c != current_color]\n        random.shuffle(colors)\n        placed = False\n        for c in colors:\n            if compatible_with_color(E, sol, v, c):\n                sol[v-1] = c\n                placed = True\n                break\n        if not placed:\n            # move to a new color label to diversify\n            sol[v-1] = max([current_color] + colors) + 1\n        return normalize_colors(sol)\n    # Start\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    r = random.random()\n    if r < 0.30:\n        # Targeted merge of color classes\n        new_sol, ok = merge_small_color_classes(E, sol)\n        return (new_sol if ok else sol), (\"merge\" if ok else \"merge_fail\")\n    elif r < 0.55:\n        # Single-vertex recolor preferring existing colors\n        i = random.randrange(n)\n        current_colors = sorted(set(sol))\n        choices = [c for c in current_colors if c != sol[i]]\n        move = \"recolor_existing\"\n        if choices:\n            sol[i] = int(random.choice(choices))\n        else:\n            sol[i] = max(current_colors) + 1\n            move = \"recolor_new\"\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.70:\n        # Color label swap (symmetry move)\n        colors = list(set(sol))\n        move = \"color_swap\"\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.85:\n        # Reduce-color attempt by reassigning highest label\n        new_sol, ok = reduce_color_move(E, sol)\n        return (new_sol if ok else sol), (\"reduce_color\" if ok else \"reduce_color_fail\")\n    elif r < 0.95:\n        # Ejection with best-fit insertion\n        return eject_and_best_fit(E, sol), \"eject_best_fit\"\n    else:\n        # Kempe-chain style swap in conflict graph\n        sol2 = kempe_chain_swap_on_conflict_graph(E, sol)\n        return sol2, \"kempe_chain\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helpers\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            if out[v-1] == a:\n                out[v-1] = b\n            elif out[v-1] == b:\n                out[v-1] = a\n        return normalize_colors(out)\n    def greedy_reassign_highest(E, sol):\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        random.shuffle(verts)\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                # if cannot place, keep as is\n                pass\n        return normalize_colors(sol)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    steps = 6\n    for t in range(steps):\n        move = random.random()\n        if move < 0.3:\n            # Multi-vertex recolor to existing compatible colors (feasibility-preserving when possible)\n            v = random.randrange(n) + 1\n            colors = sorted(set(sol))\n            random.shuffle(colors)\n            for c in colors:\n                if c != sol[v-1] and compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    break\n        elif move < 0.6:\n            # One Kempe-chain swap on conflict graph\n            sol = kempe_chain_swap_on_conflict_graph(E, sol)\n        elif move < 0.85:\n            # Greedy attempt to compress highest label\n            sol = greedy_reassign_highest(E, sol)\n        else:\n            # Small random symmetry: swap two labels\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n                sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0017395309}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}.Example: \"1,1,1,2,3,2,3,4,4\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Parse\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n    # Graph definition\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n    # Minimality via complement coloring with k-1 colors\n    V = list(range(1, 10))\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j:\n                if not friends(i, j):\n                    comp_adj[i].add(j)\n                    comp_adj[j].add(i)\n    def can_color(K):\n        order = sorted(V, key=lambda x: len(comp_adj[x]), reverse=True)\n        color = {v: 0 for v in V}\n        def dfs(idx):\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            color[v] = 0\n            return False\n        return dfs(0)\n    if k > 1 and can_color(k-1):\n        return k + 10**6\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        # Map existing labels to 1..k in order of appearance\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    def feasible(L):\n        g = groups_of(L)\n        return all(is_group_clique(m) for m in g.values())\n\n    L = labels[:]\n\n    # Candidate moves: move, swap, merge, split\n    for _ in range(64):\n        move_type = random.choices([\"move\",\"swap\",\"merge\",\"split\"], weights=[0.5,0.2,0.15,0.15])[0]\n        cand = L[:]\n        if move_type == \"move\":\n            i = random.randrange(9)  # vertex index 0..8\n            current_lab = cand[i]\n            k = max(cand)\n            # possible target labels among existing labels or new one k+1\n            targets = list(set(range(1, k+1)))\n            # Optionally allow new label to diversify\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            moved = False\n            for t in targets:\n                if t == current_lab:\n                    continue\n                # Check clique with target group members\n                members = [idx+1 for idx, lab in enumerate(cand) if lab == t]\n                v = i+1\n                if all(friends(v, u) for u in members):\n                    cand[i] = t\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"move\"\n            # no move found, continue to other attempt\n        elif move_type == \"swap\":\n            i, j = random.sample(range(9), 2)\n            if L[i] != L[j]:\n                cand[i], cand[j] = cand[j], cand[i]\n                cand = compress(cand)\n                if feasible(cand):\n                    L = cand\n                    return ','.join(str(x) for x in L), \"swap\"\n        elif move_type == \"merge\":\n            k = max(L)\n            if k >= 2:\n                a, b = sorted(random.sample(range(1, k+1), 2))\n                # try merging group b into a if clique holds\n                members_a = [idx+1 for idx, lab in enumerate(cand) if lab == a]\n                members_b = [idx+1 for idx, lab in enumerate(cand) if lab == b]\n                ok = True\n                for u in members_b:\n                    if not all(friends(u, v) for v in members_a):\n                        ok = False\n                        break\n                if ok:\n                    for idx, lab in enumerate(cand):\n                        if lab == b:\n                            cand[idx] = a\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"merge\"\n        else:  # split\n            # Split a clique into two cliques by separating a subset that is a clique itself\n            g = groups_of(cand)\n            labs = [lab for lab, mem in g.items() if len(mem) >= 2]\n            if labs:\n                lab = random.choice(labs)\n                members = g[lab][:]\n                random.shuffle(members)\n                # try take a non-empty proper subset that is a clique\n                for sz in range(1, len(members)):\n                    subset = set(members[:sz])\n                    # check subset is clique and remaining is clique (always true since original is clique)\n                    def is_clique(S):\n                        S = list(S)\n                        for a in range(len(S)):\n                            for b in range(a+1, len(S)):\n                                if not friends(S[a], S[b]):\n                                    return False\n                        return True\n                    if is_clique(subset):\n                        new_lab = max(cand) + 1\n                        for idx, labv in enumerate(cand):\n                            if labv == lab and (idx+1) in subset:\n                                cand[idx] = new_lab\n                        cand = compress(cand)\n                        if feasible(cand):\n                            L = cand\n                            return ','.join(str(x) for x in L), \"split\"\n    return ','.join(str(x) for x in L), \"noop\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake: multiple random feasible moves with repairs\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(3, 8)\n    for _ in range(steps):\n        k = max(L)\n        i = random.randrange(9)\n        v = i+1\n        # choose candidate target labels including possibly new one\n        targets = list(set(range(1, k+1)))\n        if k < 9:\n            targets.append(k+1)\n        random.shuffle(targets)\n        moved = False\n        for t in targets:\n            if t == L[i]:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n            if all(friends(v, u) for u in members):\n                L[i] = t\n                L = compress(L)\n                if feasible(L):\n                    moved = True\n                    break\n        if not moved:\n            # try random relabel then repair by moving into singleton\n            L[i] = random.randint(1, max(L)+1)\n            L = compress(L)\n            if not feasible(L):\n                # revert if infeasible\n                L = labels[:]\n                break\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0018196229}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}.Example: \"1,1,1,2,3,2,3,4,4\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Parse\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n    # Graph definition\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n    # Minimality via complement coloring with k-1 colors\n    V = list(range(1, 10))\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j:\n                if not friends(i, j):\n                    comp_adj[i].add(j)\n                    comp_adj[j].add(i)\n    def can_color(K):\n        order = sorted(V, key=lambda x: len(comp_adj[x]), reverse=True)\n        color = {v: 0 for v in V}\n        def dfs(idx):\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            color[v] = 0\n            return False\n        return dfs(0)\n    if k > 1 and can_color(k-1):\n        return k + 10**6\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        # Map existing labels to 1..k in order of appearance\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    def feasible(L):\n        g = groups_of(L)\n        return all(is_group_clique(m) for m in g.values())\n\n    L = labels[:]\n\n    # Candidate moves: move, swap, merge, split\n    for _ in range(64):\n        move_type = random.choices([\"move\",\"swap\",\"merge\",\"split\"], weights=[0.5,0.2,0.15,0.15])[0]\n        cand = L[:]\n        if move_type == \"move\":\n            i = random.randrange(9)  # vertex index 0..8\n            current_lab = cand[i]\n            k = max(cand)\n            # possible target labels among existing labels or new one k+1\n            targets = list(set(range(1, k+1)))\n            # Optionally allow new label to diversify\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            moved = False\n            for t in targets:\n                if t == current_lab:\n                    continue\n                # Check clique with target group members\n                members = [idx+1 for idx, lab in enumerate(cand) if lab == t]\n                v = i+1\n                if all(friends(v, u) for u in members):\n                    cand[i] = t\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"move\"\n            # no move found, continue to other attempt\n        elif move_type == \"swap\":\n            i, j = random.sample(range(9), 2)\n            if L[i] != L[j]:\n                cand[i], cand[j] = cand[j], cand[i]\n                cand = compress(cand)\n                if feasible(cand):\n                    L = cand\n                    return ','.join(str(x) for x in L), \"swap\"\n        elif move_type == \"merge\":\n            k = max(L)\n            if k >= 2:\n                a, b = sorted(random.sample(range(1, k+1), 2))\n                # try merging group b into a if clique holds\n                members_a = [idx+1 for idx, lab in enumerate(cand) if lab == a]\n                members_b = [idx+1 for idx, lab in enumerate(cand) if lab == b]\n                ok = True\n                for u in members_b:\n                    if not all(friends(u, v) for v in members_a):\n                        ok = False\n                        break\n                if ok:\n                    for idx, lab in enumerate(cand):\n                        if lab == b:\n                            cand[idx] = a\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"merge\"\n        else:  # split\n            # Split a clique into two cliques by separating a subset that is a clique itself\n            g = groups_of(cand)\n            labs = [lab for lab, mem in g.items() if len(mem) >= 2]\n            if labs:\n                lab = random.choice(labs)\n                members = g[lab][:]\n                random.shuffle(members)\n                # try take a non-empty proper subset that is a clique\n                for sz in range(1, len(members)):\n                    subset = set(members[:sz])\n                    # check subset is clique and remaining is clique (always true since original is clique)\n                    def is_clique(S):\n                        S = list(S)\n                        for a in range(len(S)):\n                            for b in range(a+1, len(S)):\n                                if not friends(S[a], S[b]):\n                                    return False\n                        return True\n                    if is_clique(subset):\n                        new_lab = max(cand) + 1\n                        for idx, labv in enumerate(cand):\n                            if labv == lab and (idx+1) in subset:\n                                cand[idx] = new_lab\n                        cand = compress(cand)\n                        if feasible(cand):\n                            L = cand\n                            return ','.join(str(x) for x in L), \"split\"\n    return ','.join(str(x) for x in L), \"noop\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake: multiple random feasible moves with repairs\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(3, 8)\n    for _ in range(steps):\n        k = max(L)\n        i = random.randrange(9)\n        v = i+1\n        # choose candidate target labels including possibly new one\n        targets = list(set(range(1, k+1)))\n        if k < 9:\n            targets.append(k+1)\n        random.shuffle(targets)\n        moved = False\n        for t in targets:\n            if t == L[i]:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n            if all(friends(v, u) for u in members):\n                L[i] = t\n                L = compress(L)\n                if feasible(L):\n                    moved = True\n                    break\n        if not moved:\n            # try random relabel then repair by moving into singleton\n            L[i] = random.randint(1, max(L)+1)\n            L = compress(L)\n            if not feasible(L):\n                # revert if infeasible\n                L = labels[:]\n                break\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001817661}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}.Example: \"1,1,1,2,3,2,3,4,4\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Parse\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n    # Graph definition\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n    # Minimality via complement coloring with k-1 colors\n    V = list(range(1, 10))\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j:\n                if not friends(i, j):\n                    comp_adj[i].add(j)\n                    comp_adj[j].add(i)\n    def can_color(K):\n        order = sorted(V, key=lambda x: len(comp_adj[x]), reverse=True)\n        color = {v: 0 for v in V}\n        def dfs(idx):\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            color[v] = 0\n            return False\n        return dfs(0)\n    if k > 1 and can_color(k-1):\n        return k + 10**6\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        # Map existing labels to 1..k in order of appearance\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    def feasible(L):\n        g = groups_of(L)\n        return all(is_group_clique(m) for m in g.values())\n\n    L = labels[:]\n\n    # Candidate moves: move, swap, merge, split\n    for _ in range(64):\n        move_type = random.choices([\"move\",\"swap\",\"merge\",\"split\"], weights=[0.5,0.2,0.15,0.15])[0]\n        cand = L[:]\n        if move_type == \"move\":\n            i = random.randrange(9)  # vertex index 0..8\n            current_lab = cand[i]\n            k = max(cand)\n            # possible target labels among existing labels or new one k+1\n            targets = list(set(range(1, k+1)))\n            # Optionally allow new label to diversify\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            moved = False\n            for t in targets:\n                if t == current_lab:\n                    continue\n                # Check clique with target group members\n                members = [idx+1 for idx, lab in enumerate(cand) if lab == t]\n                v = i+1\n                if all(friends(v, u) for u in members):\n                    cand[i] = t\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"move\"\n            # no move found, continue to other attempt\n        elif move_type == \"swap\":\n            i, j = random.sample(range(9), 2)\n            if L[i] != L[j]:\n                cand[i], cand[j] = cand[j], cand[i]\n                cand = compress(cand)\n                if feasible(cand):\n                    L = cand\n                    return ','.join(str(x) for x in L), \"swap\"\n        elif move_type == \"merge\":\n            k = max(L)\n            if k >= 2:\n                a, b = sorted(random.sample(range(1, k+1), 2))\n                # try merging group b into a if clique holds\n                members_a = [idx+1 for idx, lab in enumerate(cand) if lab == a]\n                members_b = [idx+1 for idx, lab in enumerate(cand) if lab == b]\n                ok = True\n                for u in members_b:\n                    if not all(friends(u, v) for v in members_a):\n                        ok = False\n                        break\n                if ok:\n                    for idx, lab in enumerate(cand):\n                        if lab == b:\n                            cand[idx] = a\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"merge\"\n        else:  # split\n            # Split a clique into two cliques by separating a subset that is a clique itself\n            g = groups_of(cand)\n            labs = [lab for lab, mem in g.items() if len(mem) >= 2]\n            if labs:\n                lab = random.choice(labs)\n                members = g[lab][:]\n                random.shuffle(members)\n                # try take a non-empty proper subset that is a clique\n                for sz in range(1, len(members)):\n                    subset = set(members[:sz])\n                    # check subset is clique and remaining is clique (always true since original is clique)\n                    def is_clique(S):\n                        S = list(S)\n                        for a in range(len(S)):\n                            for b in range(a+1, len(S)):\n                                if not friends(S[a], S[b]):\n                                    return False\n                        return True\n                    if is_clique(subset):\n                        new_lab = max(cand) + 1\n                        for idx, labv in enumerate(cand):\n                            if labv == lab and (idx+1) in subset:\n                                cand[idx] = new_lab\n                        cand = compress(cand)\n                        if feasible(cand):\n                            L = cand\n                            return ','.join(str(x) for x in L), \"split\"\n    return ','.join(str(x) for x in L), \"noop\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake: multiple random feasible moves with repairs\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(3, 8)\n    for _ in range(steps):\n        k = max(L)\n        i = random.randrange(9)\n        v = i+1\n        # choose candidate target labels including possibly new one\n        targets = list(set(range(1, k+1)))\n        if k < 9:\n            targets.append(k+1)\n        random.shuffle(targets)\n        moved = False\n        for t in targets:\n            if t == L[i]:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n            if all(friends(v, u) for u in members):\n                L[i] = t\n                L = compress(L)\n                if feasible(L):\n                    moved = True\n                    break\n        if not moved:\n            # try random relabel then repair by moving into singleton\n            L[i] = random.randint(1, max(L)+1)\n            L = compress(L)\n            if not feasible(L):\n                # revert if infeasible\n                L = labels[:]\n                break\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001868433}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        def dfs(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            return False\n        return dfs(0)\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000  # soft penalty to discourage non-minimal k\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Try greedy MERGE that reduces k\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) Deterministic MOVE: try moving a single vertex to another existing label to enable future merges (keep feasibility)\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) As fallback, random feasible slight diversification: move into new singleton if allowed\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # light randomization\n        if move_type == \"merge\" and k >= 2:\n            # attempt random merge if compatible\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle labels of two vertices if remains feasible\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        # fallback to original if perturbation broke feasibility\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001502258}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        def dfs(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            return False\n        return dfs(0)\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000  # soft penalty to discourage non-minimal k\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Try greedy MERGE that reduces k\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) Deterministic MOVE: try moving a single vertex to another existing label to enable future merges (keep feasibility)\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) As fallback, random feasible slight diversification: move into new singleton if allowed\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # light randomization\n        if move_type == \"merge\" and k >= 2:\n            # attempt random merge if compatible\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle labels of two vertices if remains feasible\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        # fallback to original if perturbation broke feasibility\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.00167302}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        def dfs(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            return False\n        return dfs(0)\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000  # soft penalty to discourage non-minimal k\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Try greedy MERGE that reduces k\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) Deterministic MOVE: try moving a single vertex to another existing label to enable future merges (keep feasibility)\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) As fallback, random feasible slight diversification: move into new singleton if allowed\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # light randomization\n        if move_type == \"merge\" and k >= 2:\n            # attempt random merge if compatible\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle labels of two vertices if remains feasible\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        # fallback to original if perturbation broke feasibility\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001739911}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    INF = 10**9\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return INF\n    s = solution.strip()\n    if s == \"\":\n        return INF\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return INF\n    if len(labels) != 9:\n        return INF\n    if any(x <= 0 for x in labels):\n        return INF\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return INF\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return INF\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    # DSATUR-based backtracking to check colorability with K colors\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        sat_deg = {v: 0 for v in V}\n        used_colors_by = {v: set() for v in V}\n\n        def select_vertex():\n            # choose uncolored vertex with max saturation degree; break ties by degree\n            candidates = [v for v in V if color[v] == 0]\n            if not candidates:\n                return None\n            return max(candidates, key=lambda v: (sat_deg[v], len(comp_adj[v])))\n\n        def assign(v, c):\n            color[v] = c\n            for u in comp_adj[v]:\n                if color[u] == 0 and c not in used_colors_by[u]:\n                    used_colors_by[u].add(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def unassign(v, c):\n            color[v] = 0\n            for u in comp_adj[v]:\n                if color[u] == 0 and c in used_colors_by[u]:\n                    used_colors_by[u].remove(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def dfs() -> bool:\n            v = select_vertex()\n            if v is None:\n                return True\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            # try least constraining color first\n            for c in range(1, K+1):\n                if c not in forbidden:\n                    assign(v, c)\n                    if dfs():\n                        return True\n                    unassign(v, c)\n            return False\n\n        return dfs()\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Greedy MERGE that reduces k if feasible\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) MOVE: move a single vertex to another label while keeping feasibility\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) Diversify: move a random vertex to a new label (then compress)\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # randomization\n        if move_type == \"merge\" and k >= 2:\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001429257}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    INF = 10**9\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return INF\n    s = solution.strip()\n    if s == \"\":\n        return INF\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return INF\n    if len(labels) != 9:\n        return INF\n    if any(x <= 0 for x in labels):\n        return INF\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return INF\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return INF\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    # DSATUR-based backtracking to check colorability with K colors\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        sat_deg = {v: 0 for v in V}\n        used_colors_by = {v: set() for v in V}\n\n        def select_vertex():\n            # choose uncolored vertex with max saturation degree; break ties by degree\n            candidates = [v for v in V if color[v] == 0]\n            if not candidates:\n                return None\n            return max(candidates, key=lambda v: (sat_deg[v], len(comp_adj[v])))\n\n        def assign(v, c):\n            color[v] = c\n            for u in comp_adj[v]:\n                if color[u] == 0 and c not in used_colors_by[u]:\n                    used_colors_by[u].add(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def unassign(v, c):\n            color[v] = 0\n            for u in comp_adj[v]:\n                if color[u] == 0 and c in used_colors_by[u]:\n                    used_colors_by[u].remove(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def dfs() -> bool:\n            v = select_vertex()\n            if v is None:\n                return True\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            # try least constraining color first\n            for c in range(1, K+1):\n                if c not in forbidden:\n                    assign(v, c)\n                    if dfs():\n                        return True\n                    unassign(v, c)\n            return False\n\n        return dfs()\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Greedy MERGE that reduces k if feasible\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) MOVE: move a single vertex to another label while keeping feasibility\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) Diversify: move a random vertex to a new label (then compress)\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # randomization\n        if move_type == \"merge\" and k >= 2:\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001834742}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    INF = 10**9\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return INF\n    s = solution.strip()\n    if s == \"\":\n        return INF\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return INF\n    if len(labels) != 9:\n        return INF\n    if any(x <= 0 for x in labels):\n        return INF\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return INF\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return INF\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    # DSATUR-based backtracking to check colorability with K colors\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        sat_deg = {v: 0 for v in V}\n        used_colors_by = {v: set() for v in V}\n\n        def select_vertex():\n            # choose uncolored vertex with max saturation degree; break ties by degree\n            candidates = [v for v in V if color[v] == 0]\n            if not candidates:\n                return None\n            return max(candidates, key=lambda v: (sat_deg[v], len(comp_adj[v])))\n\n        def assign(v, c):\n            color[v] = c\n            for u in comp_adj[v]:\n                if color[u] == 0 and c not in used_colors_by[u]:\n                    used_colors_by[u].add(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def unassign(v, c):\n            color[v] = 0\n            for u in comp_adj[v]:\n                if color[u] == 0 and c in used_colors_by[u]:\n                    used_colors_by[u].remove(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def dfs() -> bool:\n            v = select_vertex()\n            if v is None:\n                return True\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            # try least constraining color first\n            for c in range(1, K+1):\n                if c not in forbidden:\n                    assign(v, c)\n                    if dfs():\n                        return True\n                    unassign(v, c)\n            return False\n\n        return dfs()\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Greedy MERGE that reduces k if feasible\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) MOVE: move a single vertex to another label while keeping feasibility\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) Diversify: move a random vertex to a new label (then compress)\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # randomization\n        if move_type == \"merge\" and k >= 2:\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001788582}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.Each xi is a positive int label. Labels contiguous {1..k}. Feasible iff vertices sharing a label form a clique in G.","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    INF = 10**9\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return INF\n    s = solution.strip()\n    if s == \"\":\n        return INF\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return INF\n    if len(labels) != 9:\n        return INF\n    if any(x <= 0 for x in labels):\n        return INF\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Contiguous labels check\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return INF\n\n    # Feasibility: each group is a clique\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return INF\n\n    # Build complement adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in range(i+1, 10):\n            if not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    # Quick bounds for (k-1)-colorability\n    K = k - 1\n    if k <= 1:\n        return k\n    max_deg = max(len(comp_adj[v]) for v in V)\n    if max_deg + 1 > K:\n        # Not colorable with K colors -> current k is potentially minimal\n        return k\n\n    # Greedy coloring upper bound for complement graph\n    order = sorted(V, key=lambda x: len(comp_adj[x]), reverse=True)\n    def greedy_color(limit_colors=None):\n        color = {v: 0 for v in V}\n        used_colors = 0\n        for v in order:\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            color[v] = c\n            if c > used_colors:\n                used_colors = c\n                if limit_colors is not None and used_colors > limit_colors:\n                    return used_colors\n        return used_colors\n\n    greedy_used = greedy_color(limit_colors=K)\n    if greedy_used <= K:\n        # Non-minimal: can color complement with K colors\n        # Adaptive small penalty to guide SA scales smoothly\n        return k + 0.25\n\n    # DSATUR backtracking only if necessary (bounds are close)\n    @lru_cache(maxsize=None)\n    def can_color_with(Kc: int) -> bool:\n        color = {v: 0 for v in V}\n        sat_deg = {v: 0 for v in V}\n        used_by = {v: set() for v in V}\n        remaining = set(V)\n\n        def select_vertex():\n            if not remaining:\n                return None\n            return max(remaining, key=lambda v: (sat_deg[v], len(comp_adj[v])))\n\n        def assign(v, c):\n            color[v] = c\n            remaining.remove(v)\n            for u in comp_adj[v]:\n                if color[u] == 0 and c not in used_by[u]:\n                    used_by[u].add(c)\n                    sat_deg[u] = len(used_by[u])\n\n        def unassign(v, c):\n            color[v] = 0\n            remaining.add(v)\n            for u in comp_adj[v]:\n                if color[u] == 0 and c in used_by[u]:\n                    used_by[u].remove(c)\n                    sat_deg[u] = len(used_by[u])\n\n        backtrack_limit = 20000\n        counter = [0]\n\n        def dfs():\n            counter[0] += 1\n            if counter[0] > backtrack_limit:\n                return False\n            v = select_vertex()\n            if v is None:\n                return True\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            for c in range(1, Kc+1):\n                if c not in forbidden:\n                    assign(v, c)\n                    if dfs():\n                        return True\n                    unassign(v, c)\n            return False\n\n        return dfs()\n\n    if can_color_with(K):\n        return k + 0.25\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    s = solution.strip()\n    parts = s.split(',')\n    try:\n        L0 = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(L0) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    def compress_stable(L):\n        # Only relabel when gaps exist; preserve original relative order of labels\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        if max(L) == len(uniq):\n            return L[:]  # already contiguous\n        return [mp[x] for x in L]\n\n    L = L0[:]\n    k = max(L)\n    gmap = groups_of(L)\n\n    # Candidate collector with randomized iteration to avoid determinism\n    candidates = []  # list of (csv, move_type)\n\n    labs = list(range(1, k+1))\n    random.shuffle(labs)\n    # 1) MERGE attempts that reduce k\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress_stable(cand)\n                candidates.append((','.join(str(x) for x in cand), \"merge\"))\n\n    # 2) MOVE: move single vertex to another existing label if feasible\n    idxs = list(range(9))\n    random.shuffle(idxs)\n    for i in idxs:\n        vi = i+1\n        cur = L[i]\n        targets = list(range(1, k+1))\n        random.shuffle(targets)\n        for t in targets:\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L[:]\n                cand[i] = t\n                cand = compress_stable(cand)\n                candidates.append((','.join(str(x) for x in cand), \"move\"))\n\n    # 3) SWAP labels of two vertices while preserving feasibility\n    pairs = [(i, j) for i in range(9) for j in range(i+1, 9)]\n    random.shuffle(pairs)\n    for i, j in pairs:\n        if L[i] == L[j]:\n            continue\n        cand = L[:]\n        cand[i], cand[j] = cand[j], cand[i]\n        cand = compress_stable(cand)\n        g = groups_of(cand)\n        feasible = True\n        for mem in g.values():\n            if not is_group_clique(mem):\n                feasible = False\n                break\n        if feasible:\n            candidates.append((','.join(str(x) for x in cand), \"swap\"))\n\n    # 4) Diversify: split a vertex from the largest group into a new label (bounded growth)\n    if len(candidates) == 0:\n        from collections import Counter\n        cnt = Counter(L)\n        largest_label = max(cnt, key=lambda x: cnt[x])\n        idxs = [i for i, lab in enumerate(L) if lab == largest_label]\n        i = random.choice(idxs)\n        cand = L[:]\n        if k < 9:\n            cand[i] = k + 1\n        cand = compress_stable(cand)\n        return ','.join(str(x) for x in cand), \"diversify\"\n\n    # Prefer moves that reduce k; otherwise random best among candidates with minimal max label\n    min_k = min(max(map(int, c[0].split(','))) for c in candidates)\n    filtered = [c for c in candidates if max(map(int, c[0].split(','))) == min_k]\n    return random.choice(filtered)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-kick perturbation targeting largest groups; preserves feasibility when possible\n    if not isinstance(solution, str):\n        return solution\n    s = solution.strip()\n    parts = s.split(',')\n    try:\n        L = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(L) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress_stable(Lx):\n        uniq = []\n        seen = set()\n        for x in Lx:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        if max(Lx) == len(uniq):\n            return Lx[:]\n        return [mp[x] for x in Lx]\n\n    def feasible(Lx):\n        groups = {}\n        for i, g in enumerate(Lx, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    from collections import Counter\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        k = max(L)\n        cnt = Counter(L)\n        # choose one of the largest groups to split\/move from\n        largest_labels = sorted(cnt.keys(), key=lambda x: (-cnt[x], x))[:2]\n        action = random.choice([\"split\", \"move\", \"swap\"]) if k < 9 else random.choice([\"move\", \"swap\"])  # cap growth\n        if action == \"split\" and k < 9:\n            lab = random.choice(largest_labels)\n            idxs = [i for i, labx in enumerate(L) if labx == lab]\n            if idxs:\n                pick = random.choice(idxs)\n                L[pick] = k + 1\n                L = compress_stable(L)\n        elif action == \"move\":\n            i = random.randrange(9)\n            vi = i + 1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress_stable(L)\n                    break\n        else:  # swap\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress_stable(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        return solution\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0017954089}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.Each xi is a positive int label. Labels contiguous {1..k}. Feasible iff vertices sharing a label form a clique in G.","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    INF = 10**9\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return INF\n    s = solution.strip()\n    if s == \"\":\n        return INF\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return INF\n    if len(labels) != 9:\n        return INF\n    if any(x <= 0 for x in labels):\n        return INF\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Contiguous labels check\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return INF\n\n    # Feasibility: each group is a clique\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return INF\n\n    # Build complement adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in range(i+1, 10):\n            if not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    # Quick bounds for (k-1)-colorability\n    K = k - 1\n    if k <= 1:\n        return k\n    max_deg = max(len(comp_adj[v]) for v in V)\n    if max_deg + 1 > K:\n        # Not colorable with K colors -> current k is potentially minimal\n        return k\n\n    # Greedy coloring upper bound for complement graph\n    order = sorted(V, key=lambda x: len(comp_adj[x]), reverse=True)\n    def greedy_color(limit_colors=None):\n        color = {v: 0 for v in V}\n        used_colors = 0\n        for v in order:\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            color[v] = c\n            if c > used_colors:\n                used_colors = c\n                if limit_colors is not None and used_colors > limit_colors:\n                    return used_colors\n        return used_colors\n\n    greedy_used = greedy_color(limit_colors=K)\n    if greedy_used <= K:\n        # Non-minimal: can color complement with K colors\n        # Adaptive small penalty to guide SA scales smoothly\n        return k + 0.25\n\n    # DSATUR backtracking only if necessary (bounds are close)\n    @lru_cache(maxsize=None)\n    def can_color_with(Kc: int) -> bool:\n        color = {v: 0 for v in V}\n        sat_deg = {v: 0 for v in V}\n        used_by = {v: set() for v in V}\n        remaining = set(V)\n\n        def select_vertex():\n            if not remaining:\n                return None\n            return max(remaining, key=lambda v: (sat_deg[v], len(comp_adj[v])))\n\n        def assign(v, c):\n            color[v] = c\n            remaining.remove(v)\n            for u in comp_adj[v]:\n                if color[u] == 0 and c not in used_by[u]:\n                    used_by[u].add(c)\n                    sat_deg[u] = len(used_by[u])\n\n        def unassign(v, c):\n            color[v] = 0\n            remaining.add(v)\n            for u in comp_adj[v]:\n                if color[u] == 0 and c in used_by[u]:\n                    used_by[u].remove(c)\n                    sat_deg[u] = len(used_by[u])\n\n        backtrack_limit = 20000\n        counter = [0]\n\n        def dfs():\n            counter[0] += 1\n            if counter[0] > backtrack_limit:\n                return False\n            v = select_vertex()\n            if v is None:\n                return True\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            for c in range(1, Kc+1):\n                if c not in forbidden:\n                    assign(v, c)\n                    if dfs():\n                        return True\n                    unassign(v, c)\n            return False\n\n        return dfs()\n\n    if can_color_with(K):\n        return k + 0.25\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    s = solution.strip()\n    parts = s.split(',')\n    try:\n        L0 = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(L0) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    def compress_stable(L):\n        # Only relabel when gaps exist; preserve original relative order of labels\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        if max(L) == len(uniq):\n            return L[:]  # already contiguous\n        return [mp[x] for x in L]\n\n    L = L0[:]\n    k = max(L)\n    gmap = groups_of(L)\n\n    # Candidate collector with randomized iteration to avoid determinism\n    candidates = []  # list of (csv, move_type)\n\n    labs = list(range(1, k+1))\n    random.shuffle(labs)\n    # 1) MERGE attempts that reduce k\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress_stable(cand)\n                candidates.append((','.join(str(x) for x in cand), \"merge\"))\n\n    # 2) MOVE: move single vertex to another existing label if feasible\n    idxs = list(range(9))\n    random.shuffle(idxs)\n    for i in idxs:\n        vi = i+1\n        cur = L[i]\n        targets = list(range(1, k+1))\n        random.shuffle(targets)\n        for t in targets:\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L[:]\n                cand[i] = t\n                cand = compress_stable(cand)\n                candidates.append((','.join(str(x) for x in cand), \"move\"))\n\n    # 3) SWAP labels of two vertices while preserving feasibility\n    pairs = [(i, j) for i in range(9) for j in range(i+1, 9)]\n    random.shuffle(pairs)\n    for i, j in pairs:\n        if L[i] == L[j]:\n            continue\n        cand = L[:]\n        cand[i], cand[j] = cand[j], cand[i]\n        cand = compress_stable(cand)\n        g = groups_of(cand)\n        feasible = True\n        for mem in g.values():\n            if not is_group_clique(mem):\n                feasible = False\n                break\n        if feasible:\n            candidates.append((','.join(str(x) for x in cand), \"swap\"))\n\n    # 4) Diversify: split a vertex from the largest group into a new label (bounded growth)\n    if len(candidates) == 0:\n        from collections import Counter\n        cnt = Counter(L)\n        largest_label = max(cnt, key=lambda x: cnt[x])\n        idxs = [i for i, lab in enumerate(L) if lab == largest_label]\n        i = random.choice(idxs)\n        cand = L[:]\n        if k < 9:\n            cand[i] = k + 1\n        cand = compress_stable(cand)\n        return ','.join(str(x) for x in cand), \"diversify\"\n\n    # Prefer moves that reduce k; otherwise random best among candidates with minimal max label\n    min_k = min(max(map(int, c[0].split(','))) for c in candidates)\n    filtered = [c for c in candidates if max(map(int, c[0].split(','))) == min_k]\n    return random.choice(filtered)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-kick perturbation targeting largest groups; preserves feasibility when possible\n    if not isinstance(solution, str):\n        return solution\n    s = solution.strip()\n    parts = s.split(',')\n    try:\n        L = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(L) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress_stable(Lx):\n        uniq = []\n        seen = set()\n        for x in Lx:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        if max(Lx) == len(uniq):\n            return Lx[:]\n        return [mp[x] for x in Lx]\n\n    def feasible(Lx):\n        groups = {}\n        for i, g in enumerate(Lx, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    from collections import Counter\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        k = max(L)\n        cnt = Counter(L)\n        # choose one of the largest groups to split\/move from\n        largest_labels = sorted(cnt.keys(), key=lambda x: (-cnt[x], x))[:2]\n        action = random.choice([\"split\", \"move\", \"swap\"]) if k < 9 else random.choice([\"move\", \"swap\"])  # cap growth\n        if action == \"split\" and k < 9:\n            lab = random.choice(largest_labels)\n            idxs = [i for i, labx in enumerate(L) if labx == lab]\n            if idxs:\n                pick = random.choice(idxs)\n                L[pick] = k + 1\n                L = compress_stable(L)\n        elif action == \"move\":\n            i = random.randrange(9)\n            vi = i + 1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress_stable(L)\n                    break\n        else:  # swap\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress_stable(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        return solution\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0020854919}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.Each xi is a positive int label. Labels contiguous {1..k}. Feasible iff vertices sharing a label form a clique in G.","Evaluacion":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    INF = 10**9\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return INF\n    s = solution.strip()\n    if s == \"\":\n        return INF\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return INF\n    if len(labels) != 9:\n        return INF\n    if any(x <= 0 for x in labels):\n        return INF\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Contiguous labels check\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return INF\n\n    # Feasibility: each group is a clique\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return INF\n\n    # Build complement adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in range(i+1, 10):\n            if not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    # Quick bounds for (k-1)-colorability\n    K = k - 1\n    if k <= 1:\n        return k\n    max_deg = max(len(comp_adj[v]) for v in V)\n    if max_deg + 1 > K:\n        # Not colorable with K colors -> current k is potentially minimal\n        return k\n\n    # Greedy coloring upper bound for complement graph\n    order = sorted(V, key=lambda x: len(comp_adj[x]), reverse=True)\n    def greedy_color(limit_colors=None):\n        color = {v: 0 for v in V}\n        used_colors = 0\n        for v in order:\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            color[v] = c\n            if c > used_colors:\n                used_colors = c\n                if limit_colors is not None and used_colors > limit_colors:\n                    return used_colors\n        return used_colors\n\n    greedy_used = greedy_color(limit_colors=K)\n    if greedy_used <= K:\n        # Non-minimal: can color complement with K colors\n        # Adaptive small penalty to guide SA scales smoothly\n        return k + 0.25\n\n    # DSATUR backtracking only if necessary (bounds are close)\n    @lru_cache(maxsize=None)\n    def can_color_with(Kc: int) -> bool:\n        color = {v: 0 for v in V}\n        sat_deg = {v: 0 for v in V}\n        used_by = {v: set() for v in V}\n        remaining = set(V)\n\n        def select_vertex():\n            if not remaining:\n                return None\n            return max(remaining, key=lambda v: (sat_deg[v], len(comp_adj[v])))\n\n        def assign(v, c):\n            color[v] = c\n            remaining.remove(v)\n            for u in comp_adj[v]:\n                if color[u] == 0 and c not in used_by[u]:\n                    used_by[u].add(c)\n                    sat_deg[u] = len(used_by[u])\n\n        def unassign(v, c):\n            color[v] = 0\n            remaining.add(v)\n            for u in comp_adj[v]:\n                if color[u] == 0 and c in used_by[u]:\n                    used_by[u].remove(c)\n                    sat_deg[u] = len(used_by[u])\n\n        backtrack_limit = 20000\n        counter = [0]\n\n        def dfs():\n            counter[0] += 1\n            if counter[0] > backtrack_limit:\n                return False\n            v = select_vertex()\n            if v is None:\n                return True\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            for c in range(1, Kc+1):\n                if c not in forbidden:\n                    assign(v, c)\n                    if dfs():\n                        return True\n                    unassign(v, c)\n            return False\n\n        return dfs()\n\n    if can_color_with(K):\n        return k + 0.25\n    return k\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    s = solution.strip()\n    parts = s.split(',')\n    try:\n        L0 = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(L0) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    def compress_stable(L):\n        # Only relabel when gaps exist; preserve original relative order of labels\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        if max(L) == len(uniq):\n            return L[:]  # already contiguous\n        return [mp[x] for x in L]\n\n    L = L0[:]\n    k = max(L)\n    gmap = groups_of(L)\n\n    # Candidate collector with randomized iteration to avoid determinism\n    candidates = []  # list of (csv, move_type)\n\n    labs = list(range(1, k+1))\n    random.shuffle(labs)\n    # 1) MERGE attempts that reduce k\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress_stable(cand)\n                candidates.append((','.join(str(x) for x in cand), \"merge\"))\n\n    # 2) MOVE: move single vertex to another existing label if feasible\n    idxs = list(range(9))\n    random.shuffle(idxs)\n    for i in idxs:\n        vi = i+1\n        cur = L[i]\n        targets = list(range(1, k+1))\n        random.shuffle(targets)\n        for t in targets:\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L[:]\n                cand[i] = t\n                cand = compress_stable(cand)\n                candidates.append((','.join(str(x) for x in cand), \"move\"))\n\n    # 3) SWAP labels of two vertices while preserving feasibility\n    pairs = [(i, j) for i in range(9) for j in range(i+1, 9)]\n    random.shuffle(pairs)\n    for i, j in pairs:\n        if L[i] == L[j]:\n            continue\n        cand = L[:]\n        cand[i], cand[j] = cand[j], cand[i]\n        cand = compress_stable(cand)\n        g = groups_of(cand)\n        feasible = True\n        for mem in g.values():\n            if not is_group_clique(mem):\n                feasible = False\n                break\n        if feasible:\n            candidates.append((','.join(str(x) for x in cand), \"swap\"))\n\n    # 4) Diversify: split a vertex from the largest group into a new label (bounded growth)\n    if len(candidates) == 0:\n        from collections import Counter\n        cnt = Counter(L)\n        largest_label = max(cnt, key=lambda x: cnt[x])\n        idxs = [i for i, lab in enumerate(L) if lab == largest_label]\n        i = random.choice(idxs)\n        cand = L[:]\n        if k < 9:\n            cand[i] = k + 1\n        cand = compress_stable(cand)\n        return ','.join(str(x) for x in cand), \"diversify\"\n\n    # Prefer moves that reduce k; otherwise random best among candidates with minimal max label\n    min_k = min(max(map(int, c[0].split(','))) for c in candidates)\n    filtered = [c for c in candidates if max(map(int, c[0].split(','))) == min_k]\n    return random.choice(filtered)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-kick perturbation targeting largest groups; preserves feasibility when possible\n    if not isinstance(solution, str):\n        return solution\n    s = solution.strip()\n    parts = s.split(',')\n    try:\n        L = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(L) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress_stable(Lx):\n        uniq = []\n        seen = set()\n        for x in Lx:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        if max(Lx) == len(uniq):\n            return Lx[:]\n        return [mp[x] for x in Lx]\n\n    def feasible(Lx):\n        groups = {}\n        for i, g in enumerate(Lx, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    from collections import Counter\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        k = max(L)\n        cnt = Counter(L)\n        # choose one of the largest groups to split\/move from\n        largest_labels = sorted(cnt.keys(), key=lambda x: (-cnt[x], x))[:2]\n        action = random.choice([\"split\", \"move\", \"swap\"]) if k < 9 else random.choice([\"move\", \"swap\"])  # cap growth\n        if action == \"split\" and k < 9:\n            lab = random.choice(largest_labels)\n            idxs = [i for i, labx in enumerate(L) if labx == lab]\n            if idxs:\n                pick = random.choice(idxs)\n                L[pick] = k + 1\n                L = compress_stable(L)\n        elif action == \"move\":\n            i = random.randrange(9)\n            vi = i + 1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress_stable(L)\n                    break\n        else:  # swap\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress_stable(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        return solution\n    return ','.join(str(x) for x in L)\n","Resultados":"Failed to run target heuristic: Expected first argument to be an integer, a callable, or None.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0021495031}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; each solution is a string of 9 positive integers separated by commas, e.g., \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive ints; objective is to minimize max label. Functions accept either this CSV string or a Python list of 9 ints; they always return the CSV string form when producing solutions.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    # Map labels to 1..m by order of first appearance to keep canonical\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None:\n        return 10**9\n    if len(arr) != n:\n        return 10**9\n    # Validate entries\n    k = -1\n    for x in arr:\n        if not isinstance(x, int):\n            return 10**9\n        if x <= 0:\n            return 10**9\n        if x > k:\n            k = x\n    if k < 1:\n        return 10**9\n    # Build complement edge set (non-edges in original graph among distinct pairs)\n    comp: Set[Tuple[int,int]] = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations (equal labels on complement pairs)\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        # fallback to a random valid-shaped solution\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    move = None\n    r = random.random()\n    if r < 0.5:\n        # Relabel a single vertex to an existing or new label\n        idx = random.randrange(n)\n        # choose from 1..k+1 with small prob to explore new label\n        if random.random() < 0.2:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _compress_labels(arr2)\n        move = 'RelabelSingle'\n        nb_type = 'Local'\n        return (_encode_csv(arr2), nb_type, move)\n    else:\n        # Swap two labels present in the solution\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _compress_labels(arr2)\n            move = 'SwapLabels'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n        else:\n            # Fallback to relabel if only one label present\n            idx = random.randrange(n)\n            new_label = 1\n            arr2 = arr[:]\n            arr2[idx] = new_label\n            arr2 = _compress_labels(arr2)\n            move = 'RelabelSingle'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Apply a moderate random shake: multiple random relabels and an optional label merge\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel 3 positions\n    m = 3\n    for _ in range(m):\n        idx = random.randrange(n)\n        # pick label from 1..max(1,k+1) to allow exploration\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With some probability, try to merge highest label into a lower label (without feasibility check here)\n    if random.random() < 0.5 and max(arr2) > 1:\n        labels = sorted(set(arr2))\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1]) if len(labels) > 1 else hi\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _compress_labels(arr2)\n    return _encode_csv(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.000838479}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; each solution is a string of 9 positive integers separated by commas, e.g., \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive ints; objective is to minimize max label. Functions accept either this CSV string or a Python list of 9 ints; they always return the CSV string form when producing solutions.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    # Map labels to 1..m by order of first appearance to keep canonical\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None:\n        return 10**9\n    if len(arr) != n:\n        return 10**9\n    # Validate entries\n    k = -1\n    for x in arr:\n        if not isinstance(x, int):\n            return 10**9\n        if x <= 0:\n            return 10**9\n        if x > k:\n            k = x\n    if k < 1:\n        return 10**9\n    # Build complement edge set (non-edges in original graph among distinct pairs)\n    comp: Set[Tuple[int,int]] = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations (equal labels on complement pairs)\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        # fallback to a random valid-shaped solution\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    move = None\n    r = random.random()\n    if r < 0.5:\n        # Relabel a single vertex to an existing or new label\n        idx = random.randrange(n)\n        # choose from 1..k+1 with small prob to explore new label\n        if random.random() < 0.2:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _compress_labels(arr2)\n        move = 'RelabelSingle'\n        nb_type = 'Local'\n        return (_encode_csv(arr2), nb_type, move)\n    else:\n        # Swap two labels present in the solution\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _compress_labels(arr2)\n            move = 'SwapLabels'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n        else:\n            # Fallback to relabel if only one label present\n            idx = random.randrange(n)\n            new_label = 1\n            arr2 = arr[:]\n            arr2[idx] = new_label\n            arr2 = _compress_labels(arr2)\n            move = 'RelabelSingle'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Apply a moderate random shake: multiple random relabels and an optional label merge\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel 3 positions\n    m = 3\n    for _ in range(m):\n        idx = random.randrange(n)\n        # pick label from 1..max(1,k+1) to allow exploration\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With some probability, try to merge highest label into a lower label (without feasibility check here)\n    if random.random() < 0.5 and max(arr2) > 1:\n        labels = sorted(set(arr2))\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1]) if len(labels) > 1 else hi\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _compress_labels(arr2)\n    return _encode_csv(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0009504111}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; each solution is a string of 9 positive integers separated by commas, e.g., \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive ints; objective is to minimize max label. Functions accept either this CSV string or a Python list of 9 ints; they always return the CSV string form when producing solutions.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    # Map labels to 1..m by order of first appearance to keep canonical\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None:\n        return 10**9\n    if len(arr) != n:\n        return 10**9\n    # Validate entries\n    k = -1\n    for x in arr:\n        if not isinstance(x, int):\n            return 10**9\n        if x <= 0:\n            return 10**9\n        if x > k:\n            k = x\n    if k < 1:\n        return 10**9\n    # Build complement edge set (non-edges in original graph among distinct pairs)\n    comp: Set[Tuple[int,int]] = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations (equal labels on complement pairs)\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        # fallback to a random valid-shaped solution\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    move = None\n    r = random.random()\n    if r < 0.5:\n        # Relabel a single vertex to an existing or new label\n        idx = random.randrange(n)\n        # choose from 1..k+1 with small prob to explore new label\n        if random.random() < 0.2:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _compress_labels(arr2)\n        move = 'RelabelSingle'\n        nb_type = 'Local'\n        return (_encode_csv(arr2), nb_type, move)\n    else:\n        # Swap two labels present in the solution\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _compress_labels(arr2)\n            move = 'SwapLabels'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n        else:\n            # Fallback to relabel if only one label present\n            idx = random.randrange(n)\n            new_label = 1\n            arr2 = arr[:]\n            arr2[idx] = new_label\n            arr2 = _compress_labels(arr2)\n            move = 'RelabelSingle'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Apply a moderate random shake: multiple random relabels and an optional label merge\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel 3 positions\n    m = 3\n    for _ in range(m):\n        idx = random.randrange(n)\n        # pick label from 1..max(1,k+1) to allow exploration\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With some probability, try to merge highest label into a lower label (without feasibility check here)\n    if random.random() < 0.5 and max(arr2) > 1:\n        labels = sorted(set(arr2))\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1]) if len(labels) > 1 else hi\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _compress_labels(arr2)\n    return _encode_csv(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.000910989}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a string of 9 positive integers separated by commas (or a Python list[int] of length 9 accepted as input but always emitted as CSV string). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive integers; objective minimizes max label under feasibility on complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List\n\ndef _nb_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _nb_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _nb_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    r = random.random()\n    if r < 0.5:\n        # Conflict-directed single relabel if possible, else random relabel\n        idx = random.randrange(n)\n        # Prefer existing labels; small chance to explore new label\n        if random.random() < 0.15:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _nb_compress_labels(arr2)\n        return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n    else:\n        # Swap two existing labels if at least two exist; else fallback relabel\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'SwapLabels')\n        else:\n            idx = random.randrange(n)\n            arr2 = arr[:]\n            arr2[idx] = 1\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n","Perturbacion":"import random\nfrom typing import List\n\ndef _pt_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _pt_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _pt_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Moderate shake: multiple relabels + optional label merge\n    arr = _pt_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel r positions\n    r = random.randint(2, 4)\n    idxs = random.sample(range(n), r)\n    for idx in idxs:\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With probability, merge highest label into a random lower label\n    labels = sorted(set(arr2))\n    if len(labels) > 1 and random.random() < 0.5:\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1])\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _pt_compress_labels(arr2)\n    return _pt_encode_csv(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0007987679}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a string of 9 positive integers separated by commas (or a Python list[int] of length 9 accepted as input but always emitted as CSV string). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive integers; objective minimizes max label under feasibility on complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List\n\ndef _nb_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _nb_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _nb_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    r = random.random()\n    if r < 0.5:\n        # Conflict-directed single relabel if possible, else random relabel\n        idx = random.randrange(n)\n        # Prefer existing labels; small chance to explore new label\n        if random.random() < 0.15:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _nb_compress_labels(arr2)\n        return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n    else:\n        # Swap two existing labels if at least two exist; else fallback relabel\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'SwapLabels')\n        else:\n            idx = random.randrange(n)\n            arr2 = arr[:]\n            arr2[idx] = 1\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n","Perturbacion":"import random\nfrom typing import List\n\ndef _pt_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _pt_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _pt_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Moderate shake: multiple relabels + optional label merge\n    arr = _pt_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel r positions\n    r = random.randint(2, 4)\n    idxs = random.sample(range(n), r)\n    for idx in idxs:\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With probability, merge highest label into a random lower label\n    labels = sorted(set(arr2))\n    if len(labels) > 1 and random.random() < 0.5:\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1])\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _pt_compress_labels(arr2)\n    return _pt_encode_csv(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.000928901}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a string of 9 positive integers separated by commas (or a Python list[int] of length 9 accepted as input but always emitted as CSV string). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive integers; objective minimizes max label under feasibility on complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List\n\ndef _nb_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _nb_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _nb_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    r = random.random()\n    if r < 0.5:\n        # Conflict-directed single relabel if possible, else random relabel\n        idx = random.randrange(n)\n        # Prefer existing labels; small chance to explore new label\n        if random.random() < 0.15:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _nb_compress_labels(arr2)\n        return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n    else:\n        # Swap two existing labels if at least two exist; else fallback relabel\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'SwapLabels')\n        else:\n            idx = random.randrange(n)\n            arr2 = arr[:]\n            arr2[idx] = 1\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n","Perturbacion":"import random\nfrom typing import List\n\ndef _pt_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _pt_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _pt_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Moderate shake: multiple relabels + optional label merge\n    arr = _pt_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel r positions\n    r = random.randint(2, 4)\n    idxs = random.sample(range(n), r)\n    for idx in idxs:\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With probability, merge highest label into a random lower label\n    labels = sorted(set(arr2))\n    if len(labels) > 1 and random.random() < 0.5:\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1])\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _pt_compress_labels(arr2)\n    return _pt_encode_csv(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.000886049}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _eval_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            arr = [int(x) for x in solution]\n        except Exception:\n            return None\n        return arr\n    return None\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    # Undirected edges of G (given)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _eval_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _nb_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _nb_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _nb_comp_adjacency():\n    # complement adjacency list for nodes 1..9\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _nb_conflict_vertices(arr, comp_adj):\n    # returns list of vertices (1-indexed) with at least one conflict in complement graph\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _nb_color_conflicts(u, color, arr, comp_adj):\n    # number of conflicts at vertex u if assigned 'color'\n    cnt = 0\n    for v in comp_adj[u]:\n        if arr[v-1] == color:\n            cnt += 1\n    return cnt\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse(solution)\n    if arr is None or len(arr) != 9:\n        # initialize with a reasonable seed close to known optimal pattern\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    comp_adj = _nb_comp_adjacency()\n    k = max(arr)\n    conflicted = _nb_conflict_vertices(arr, comp_adj)\n    rng = random.random()\n    if conflicted:\n        # Conflict-directed recolor (min-conflicts)\n        u = random.choice(conflicted)\n        # Candidate colors: 1..k plus with small probability k+1 when conflicts persist\n        cand = list(range(1, k+1))\n        if rng < 0.1:\n            cand.append(k+1)\n        best_colors = []\n        best_val = None\n        for c in cand:\n            val = _nb_color_conflicts(u, c, arr, comp_adj)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        arr2 = arr[:]\n        arr2[u-1] = new_c\n        return (_nb_encode(arr2), 'Local', 'MinConflictsRelabel')\n    else:\n        # Feasible: try to reduce k by moving a vertex of the highest label to a lower feasible label\n        highest = k\n        idxs = [i for i,x in enumerate(arr, start=1) if x == highest]\n        random.shuffle(idxs)\n        moved = False\n        for u in idxs:\n            lower_colors = list(range(1, highest))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if _nb_color_conflicts(u, c, arr, comp_adj) == 0:\n                    arr2 = arr[:]\n                    arr2[u-1] = c\n                    # do not compress labels here; maintain continuity\n                    return (_nb_encode(arr2), 'Local', 'FeasibleReduceK')\n        # If no direct reduction possible, perform a label swap between two labels to reshape landscape\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            return (_nb_encode(arr2), 'Local', 'SwapLabels')\n        # Fallback: random single relabel to any existing color\n        u = random.randint(1, n)\n        c = random.randint(1, k)\n        arr2 = arr[:]\n        arr2[u-1] = c\n        return (_nb_encode(arr2), 'Local', 'FallbackRelabel')\n","Perturbacion":"import random\nfrom typing import List\n\ndef _pt_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _pt_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _pt_comp_adjacency():\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _pt_conflict_vertices(arr, comp_adj):\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef perturb_solution(solution):\n    # Moderate shake focusing on conflicted vertices; preserves encoding\n    arr = _pt_parse(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    k = max(arr)\n    comp_adj = _pt_comp_adjacency()\n    conf = _pt_conflict_vertices(arr, comp_adj)\n    arr2 = arr[:]\n    # Relabel 2-4 vertices (prefer conflicted ones)\n    r = random.randint(2, 4)\n    pool = conf[:] if conf else list(range(1, n+1))\n    idxs = []\n    if len(pool) >= r:\n        idxs = random.sample(pool, r)\n    else:\n        idxs = pool + random.sample([i for i in range(1, n+1) if i not in pool], r - len(pool))\n    for u in idxs:\n        # Choose random existing color; with small prob introduce k+1\n        if random.random() < 0.15:\n            new_c = k + 1\n        else:\n            new_c = random.randint(1, max(1, k))\n        arr2[u-1] = new_c\n    # Optional label swap to diversify\n    labels = sorted(set(arr2))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        arr2 = [b if x==a else a if x==b else x for x in arr2]\n    return _pt_encode(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0011794131}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _eval_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            arr = [int(x) for x in solution]\n        except Exception:\n            return None\n        return arr\n    return None\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    # Undirected edges of G (given)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _eval_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _nb_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _nb_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _nb_comp_adjacency():\n    # complement adjacency list for nodes 1..9\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _nb_conflict_vertices(arr, comp_adj):\n    # returns list of vertices (1-indexed) with at least one conflict in complement graph\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _nb_color_conflicts(u, color, arr, comp_adj):\n    # number of conflicts at vertex u if assigned 'color'\n    cnt = 0\n    for v in comp_adj[u]:\n        if arr[v-1] == color:\n            cnt += 1\n    return cnt\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse(solution)\n    if arr is None or len(arr) != 9:\n        # initialize with a reasonable seed close to known optimal pattern\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    comp_adj = _nb_comp_adjacency()\n    k = max(arr)\n    conflicted = _nb_conflict_vertices(arr, comp_adj)\n    rng = random.random()\n    if conflicted:\n        # Conflict-directed recolor (min-conflicts)\n        u = random.choice(conflicted)\n        # Candidate colors: 1..k plus with small probability k+1 when conflicts persist\n        cand = list(range(1, k+1))\n        if rng < 0.1:\n            cand.append(k+1)\n        best_colors = []\n        best_val = None\n        for c in cand:\n            val = _nb_color_conflicts(u, c, arr, comp_adj)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        arr2 = arr[:]\n        arr2[u-1] = new_c\n        return (_nb_encode(arr2), 'Local', 'MinConflictsRelabel')\n    else:\n        # Feasible: try to reduce k by moving a vertex of the highest label to a lower feasible label\n        highest = k\n        idxs = [i for i,x in enumerate(arr, start=1) if x == highest]\n        random.shuffle(idxs)\n        moved = False\n        for u in idxs:\n            lower_colors = list(range(1, highest))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if _nb_color_conflicts(u, c, arr, comp_adj) == 0:\n                    arr2 = arr[:]\n                    arr2[u-1] = c\n                    # do not compress labels here; maintain continuity\n                    return (_nb_encode(arr2), 'Local', 'FeasibleReduceK')\n        # If no direct reduction possible, perform a label swap between two labels to reshape landscape\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            return (_nb_encode(arr2), 'Local', 'SwapLabels')\n        # Fallback: random single relabel to any existing color\n        u = random.randint(1, n)\n        c = random.randint(1, k)\n        arr2 = arr[:]\n        arr2[u-1] = c\n        return (_nb_encode(arr2), 'Local', 'FallbackRelabel')\n","Perturbacion":"import random\nfrom typing import List\n\ndef _pt_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _pt_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _pt_comp_adjacency():\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _pt_conflict_vertices(arr, comp_adj):\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef perturb_solution(solution):\n    # Moderate shake focusing on conflicted vertices; preserves encoding\n    arr = _pt_parse(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    k = max(arr)\n    comp_adj = _pt_comp_adjacency()\n    conf = _pt_conflict_vertices(arr, comp_adj)\n    arr2 = arr[:]\n    # Relabel 2-4 vertices (prefer conflicted ones)\n    r = random.randint(2, 4)\n    pool = conf[:] if conf else list(range(1, n+1))\n    idxs = []\n    if len(pool) >= r:\n        idxs = random.sample(pool, r)\n    else:\n        idxs = pool + random.sample([i for i in range(1, n+1) if i not in pool], r - len(pool))\n    for u in idxs:\n        # Choose random existing color; with small prob introduce k+1\n        if random.random() < 0.15:\n            new_c = k + 1\n        else:\n            new_c = random.randint(1, max(1, k))\n        arr2[u-1] = new_c\n    # Optional label swap to diversify\n    labels = sorted(set(arr2))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        arr2 = [b if x==a else a if x==b else x for x in arr2]\n    return _pt_encode(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001645489}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set\n\ndef _eval_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            arr = [int(x) for x in solution]\n        except Exception:\n            return None\n        return arr\n    return None\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    # Undirected edges of G (given)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _eval_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _nb_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _nb_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _nb_comp_adjacency():\n    # complement adjacency list for nodes 1..9\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _nb_conflict_vertices(arr, comp_adj):\n    # returns list of vertices (1-indexed) with at least one conflict in complement graph\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _nb_color_conflicts(u, color, arr, comp_adj):\n    # number of conflicts at vertex u if assigned 'color'\n    cnt = 0\n    for v in comp_adj[u]:\n        if arr[v-1] == color:\n            cnt += 1\n    return cnt\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse(solution)\n    if arr is None or len(arr) != 9:\n        # initialize with a reasonable seed close to known optimal pattern\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    comp_adj = _nb_comp_adjacency()\n    k = max(arr)\n    conflicted = _nb_conflict_vertices(arr, comp_adj)\n    rng = random.random()\n    if conflicted:\n        # Conflict-directed recolor (min-conflicts)\n        u = random.choice(conflicted)\n        # Candidate colors: 1..k plus with small probability k+1 when conflicts persist\n        cand = list(range(1, k+1))\n        if rng < 0.1:\n            cand.append(k+1)\n        best_colors = []\n        best_val = None\n        for c in cand:\n            val = _nb_color_conflicts(u, c, arr, comp_adj)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        arr2 = arr[:]\n        arr2[u-1] = new_c\n        return (_nb_encode(arr2), 'Local', 'MinConflictsRelabel')\n    else:\n        # Feasible: try to reduce k by moving a vertex of the highest label to a lower feasible label\n        highest = k\n        idxs = [i for i,x in enumerate(arr, start=1) if x == highest]\n        random.shuffle(idxs)\n        moved = False\n        for u in idxs:\n            lower_colors = list(range(1, highest))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if _nb_color_conflicts(u, c, arr, comp_adj) == 0:\n                    arr2 = arr[:]\n                    arr2[u-1] = c\n                    # do not compress labels here; maintain continuity\n                    return (_nb_encode(arr2), 'Local', 'FeasibleReduceK')\n        # If no direct reduction possible, perform a label swap between two labels to reshape landscape\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            return (_nb_encode(arr2), 'Local', 'SwapLabels')\n        # Fallback: random single relabel to any existing color\n        u = random.randint(1, n)\n        c = random.randint(1, k)\n        arr2 = arr[:]\n        arr2[u-1] = c\n        return (_nb_encode(arr2), 'Local', 'FallbackRelabel')\n","Perturbacion":"import random\nfrom typing import List\n\ndef _pt_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _pt_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _pt_comp_adjacency():\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _pt_conflict_vertices(arr, comp_adj):\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef perturb_solution(solution):\n    # Moderate shake focusing on conflicted vertices; preserves encoding\n    arr = _pt_parse(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    k = max(arr)\n    comp_adj = _pt_comp_adjacency()\n    conf = _pt_conflict_vertices(arr, comp_adj)\n    arr2 = arr[:]\n    # Relabel 2-4 vertices (prefer conflicted ones)\n    r = random.randint(2, 4)\n    pool = conf[:] if conf else list(range(1, n+1))\n    idxs = []\n    if len(pool) >= r:\n        idxs = random.sample(pool, r)\n    else:\n        idxs = pool + random.sample([i for i in range(1, n+1) if i not in pool], r - len(pool))\n    for u in idxs:\n        # Choose random existing color; with small prob introduce k+1\n        if random.random() < 0.15:\n            new_c = k + 1\n        else:\n            new_c = random.randint(1, max(1, k))\n        arr2[u-1] = new_c\n    # Optional label swap to diversify\n    labels = sorted(set(arr2))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        arr2 = [b if x==a else a if x==b else x for x in arr2]\n    return _pt_encode(arr2)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001408605}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set, Optional\n\ndef _eval_parse_solution_csv_or_list(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            arr = [int(x) for x in solution]\n        except Exception:\n            return None\n        return arr\n    return None\n\ndef evaluate_solution(solution) -> float:\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    # Undirected edges of G (given)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _eval_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Optional\n\ndef _nb_parse(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _nb_encode(arr: List[int]) -> Optional[str]:\n    if not isinstance(arr, list) or len(arr) != 9:\n        return None\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return None\n    return ','.join(str(x) for x in arr)\n\ndef _nb_comp_adjacency():\n    # complement adjacency list for nodes 1..9\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _nb_conflict_vertices(arr: List[int], comp_adj) -> List[int]:\n    # returns list of vertices (1-indexed) with at least one conflict in complement graph\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _nb_color_conflicts(u: int, color: int, arr: List[int], comp_adj) -> int:\n    # number of conflicts at vertex u if assigned 'color'\n    cnt = 0\n    for v in comp_adj[u]:\n        if arr[v-1] == color:\n            cnt += 1\n    return cnt\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    # Map existing labels to 1..m in order of appearance to stabilize k\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse(solution)\n    if arr is None or len(arr) != 9:\n        # initialize with a reasonable seed close to known optimal pattern\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    comp_adj = _nb_comp_adjacency()\n    k = max(arr)\n    conflicted = _nb_conflict_vertices(arr, comp_adj)\n    if conflicted:\n        # Conflict-directed recolor (min-conflicts)\n        u = random.choice(conflicted)\n        cand = list(range(1, k+1))\n        # occasionally allow new color to escape heavy conflicts\n        if random.random() < 0.1:\n            cand.append(k+1)\n        best_colors = []\n        best_val = None\n        for c in cand:\n            val = _nb_color_conflicts(u, c, arr, comp_adj)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        arr2 = arr[:]\n        arr2[u-1] = new_c\n        arr2 = _compress_labels(arr2)\n        enc = _nb_encode(arr2)\n        if enc is None:\n            return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n        return (enc, 'Local', 'MinConflictsRelabel')\n    else:\n        # Feasible: try to reduce k by moving a vertex of the highest label to a lower feasible label\n        highest = k\n        idxs = [i for i,x in enumerate(arr, start=1) if x == highest]\n        random.shuffle(idxs)\n        for u in idxs:\n            lower_colors = list(range(1, highest))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if _nb_color_conflicts(u, c, arr, comp_adj) == 0:\n                    arr2 = arr[:]\n                    arr2[u-1] = c\n                    arr2 = _compress_labels(arr2)\n                    enc = _nb_encode(arr2)\n                    if enc is None:\n                        return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n                    return (enc, 'Local', 'FeasibleReduceK')\n        # If no direct reduction possible, perform label swap between two labels\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _compress_labels(arr2)\n            enc = _nb_encode(arr2)\n            if enc is None:\n                return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n            return (enc, 'Local', 'SwapLabels')\n        # Fallback: random single relabel to any existing color\n        u = random.randint(1, n)\n        c = random.randint(1, k)\n        arr2 = arr[:]\n        arr2[u-1] = c\n        arr2 = _compress_labels(arr2)\n        enc = _nb_encode(arr2)\n        if enc is None:\n            return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n        return (enc, 'Local', 'FallbackRelabel')\n","Perturbacion":"import random\nfrom typing import List, Optional\n\ndef _pt_parse(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _pt_encode(arr: List[int]) -> Optional[str]:\n    if not isinstance(arr, list) or len(arr) != 9:\n        return None\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return None\n    return ','.join(str(x) for x in arr)\n\ndef _pt_comp_adjacency():\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _pt_conflict_vertices(arr: List[int], comp_adj) -> List[int]:\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _compress_labels_pt(arr: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef perturb_solution(solution):\n    # Moderate shake focusing on conflicted vertices; preserves encoding\n    arr = _pt_parse(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    k = max(arr)\n    comp_adj = _pt_comp_adjacency()\n    conf = _pt_conflict_vertices(arr, comp_adj)\n    arr2 = arr[:]\n    # Relabel 2-4 vertices (prefer conflicted ones)\n    r = random.randint(2, 4)\n    pool = conf[:] if conf else list(range(1, n+1))\n    idxs = []\n    if len(pool) >= r:\n        idxs = random.sample(pool, r)\n    else:\n        remaining = [i for i in range(1, n+1) if i not in pool]\n        add_cnt = r - len(pool)\n        if remaining:\n            extra = random.sample(remaining, add_cnt if add_cnt <= len(remaining) else len(remaining))\n        else:\n            extra = []\n        idxs = pool + extra\n    for u in idxs:\n        # Choose random existing color; with small prob introduce k+1\n        if random.random() < 0.15:\n            new_c = k + 1\n        else:\n            new_c = random.randint(1, max(1, k))\n        arr2[u-1] = new_c\n    # Optional label swap to diversify\n    labels = sorted(set(arr2))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        arr2 = [b if x==a else a if x==b else x for x in arr2]\n    arr2 = _compress_labels_pt(arr2)\n    enc = _pt_encode(arr2)\n    if enc is None:\n        return ','.join(str(x) for x in arr)\n    return enc\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001367135}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set, Optional\n\ndef _eval_parse_solution_csv_or_list(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            arr = [int(x) for x in solution]\n        except Exception:\n            return None\n        return arr\n    return None\n\ndef evaluate_solution(solution) -> float:\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    # Undirected edges of G (given)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _eval_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Optional\n\ndef _nb_parse(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _nb_encode(arr: List[int]) -> Optional[str]:\n    if not isinstance(arr, list) or len(arr) != 9:\n        return None\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return None\n    return ','.join(str(x) for x in arr)\n\ndef _nb_comp_adjacency():\n    # complement adjacency list for nodes 1..9\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _nb_conflict_vertices(arr: List[int], comp_adj) -> List[int]:\n    # returns list of vertices (1-indexed) with at least one conflict in complement graph\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _nb_color_conflicts(u: int, color: int, arr: List[int], comp_adj) -> int:\n    # number of conflicts at vertex u if assigned 'color'\n    cnt = 0\n    for v in comp_adj[u]:\n        if arr[v-1] == color:\n            cnt += 1\n    return cnt\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    # Map existing labels to 1..m in order of appearance to stabilize k\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse(solution)\n    if arr is None or len(arr) != 9:\n        # initialize with a reasonable seed close to known optimal pattern\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    comp_adj = _nb_comp_adjacency()\n    k = max(arr)\n    conflicted = _nb_conflict_vertices(arr, comp_adj)\n    if conflicted:\n        # Conflict-directed recolor (min-conflicts)\n        u = random.choice(conflicted)\n        cand = list(range(1, k+1))\n        # occasionally allow new color to escape heavy conflicts\n        if random.random() < 0.1:\n            cand.append(k+1)\n        best_colors = []\n        best_val = None\n        for c in cand:\n            val = _nb_color_conflicts(u, c, arr, comp_adj)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        arr2 = arr[:]\n        arr2[u-1] = new_c\n        arr2 = _compress_labels(arr2)\n        enc = _nb_encode(arr2)\n        if enc is None:\n            return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n        return (enc, 'Local', 'MinConflictsRelabel')\n    else:\n        # Feasible: try to reduce k by moving a vertex of the highest label to a lower feasible label\n        highest = k\n        idxs = [i for i,x in enumerate(arr, start=1) if x == highest]\n        random.shuffle(idxs)\n        for u in idxs:\n            lower_colors = list(range(1, highest))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if _nb_color_conflicts(u, c, arr, comp_adj) == 0:\n                    arr2 = arr[:]\n                    arr2[u-1] = c\n                    arr2 = _compress_labels(arr2)\n                    enc = _nb_encode(arr2)\n                    if enc is None:\n                        return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n                    return (enc, 'Local', 'FeasibleReduceK')\n        # If no direct reduction possible, perform label swap between two labels\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _compress_labels(arr2)\n            enc = _nb_encode(arr2)\n            if enc is None:\n                return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n            return (enc, 'Local', 'SwapLabels')\n        # Fallback: random single relabel to any existing color\n        u = random.randint(1, n)\n        c = random.randint(1, k)\n        arr2 = arr[:]\n        arr2[u-1] = c\n        arr2 = _compress_labels(arr2)\n        enc = _nb_encode(arr2)\n        if enc is None:\n            return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n        return (enc, 'Local', 'FallbackRelabel')\n","Perturbacion":"import random\nfrom typing import List, Optional\n\ndef _pt_parse(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _pt_encode(arr: List[int]) -> Optional[str]:\n    if not isinstance(arr, list) or len(arr) != 9:\n        return None\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return None\n    return ','.join(str(x) for x in arr)\n\ndef _pt_comp_adjacency():\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _pt_conflict_vertices(arr: List[int], comp_adj) -> List[int]:\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _compress_labels_pt(arr: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef perturb_solution(solution):\n    # Moderate shake focusing on conflicted vertices; preserves encoding\n    arr = _pt_parse(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    k = max(arr)\n    comp_adj = _pt_comp_adjacency()\n    conf = _pt_conflict_vertices(arr, comp_adj)\n    arr2 = arr[:]\n    # Relabel 2-4 vertices (prefer conflicted ones)\n    r = random.randint(2, 4)\n    pool = conf[:] if conf else list(range(1, n+1))\n    idxs = []\n    if len(pool) >= r:\n        idxs = random.sample(pool, r)\n    else:\n        remaining = [i for i in range(1, n+1) if i not in pool]\n        add_cnt = r - len(pool)\n        if remaining:\n            extra = random.sample(remaining, add_cnt if add_cnt <= len(remaining) else len(remaining))\n        else:\n            extra = []\n        idxs = pool + extra\n    for u in idxs:\n        # Choose random existing color; with small prob introduce k+1\n        if random.random() < 0.15:\n            new_c = k + 1\n        else:\n            new_c = random.randint(1, max(1, k))\n        arr2[u-1] = new_c\n    # Optional label swap to diversify\n    labels = sorted(set(arr2))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        arr2 = [b if x==a else a if x==b else x for x in arr2]\n    arr2 = _compress_labels_pt(arr2)\n    enc = _pt_encode(arr2)\n    if enc is None:\n        return ','.join(str(x) for x in arr)\n    return enc\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001678379}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","Evaluacion":"import math\nfrom typing import List, Tuple, Set, Optional\n\ndef _eval_parse_solution_csv_or_list(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            arr = [int(x) for x in solution]\n        except Exception:\n            return None\n        return arr\n    return None\n\ndef evaluate_solution(solution) -> float:\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    # Undirected edges of G (given)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _eval_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Optional\n\ndef _nb_parse(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _nb_encode(arr: List[int]) -> Optional[str]:\n    if not isinstance(arr, list) or len(arr) != 9:\n        return None\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return None\n    return ','.join(str(x) for x in arr)\n\ndef _nb_comp_adjacency():\n    # complement adjacency list for nodes 1..9\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _nb_conflict_vertices(arr: List[int], comp_adj) -> List[int]:\n    # returns list of vertices (1-indexed) with at least one conflict in complement graph\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _nb_color_conflicts(u: int, color: int, arr: List[int], comp_adj) -> int:\n    # number of conflicts at vertex u if assigned 'color'\n    cnt = 0\n    for v in comp_adj[u]:\n        if arr[v-1] == color:\n            cnt += 1\n    return cnt\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    # Map existing labels to 1..m in order of appearance to stabilize k\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse(solution)\n    if arr is None or len(arr) != 9:\n        # initialize with a reasonable seed close to known optimal pattern\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    comp_adj = _nb_comp_adjacency()\n    k = max(arr)\n    conflicted = _nb_conflict_vertices(arr, comp_adj)\n    if conflicted:\n        # Conflict-directed recolor (min-conflicts)\n        u = random.choice(conflicted)\n        cand = list(range(1, k+1))\n        # occasionally allow new color to escape heavy conflicts\n        if random.random() < 0.1:\n            cand.append(k+1)\n        best_colors = []\n        best_val = None\n        for c in cand:\n            val = _nb_color_conflicts(u, c, arr, comp_adj)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        arr2 = arr[:]\n        arr2[u-1] = new_c\n        arr2 = _compress_labels(arr2)\n        enc = _nb_encode(arr2)\n        if enc is None:\n            return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n        return (enc, 'Local', 'MinConflictsRelabel')\n    else:\n        # Feasible: try to reduce k by moving a vertex of the highest label to a lower feasible label\n        highest = k\n        idxs = [i for i,x in enumerate(arr, start=1) if x == highest]\n        random.shuffle(idxs)\n        for u in idxs:\n            lower_colors = list(range(1, highest))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if _nb_color_conflicts(u, c, arr, comp_adj) == 0:\n                    arr2 = arr[:]\n                    arr2[u-1] = c\n                    arr2 = _compress_labels(arr2)\n                    enc = _nb_encode(arr2)\n                    if enc is None:\n                        return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n                    return (enc, 'Local', 'FeasibleReduceK')\n        # If no direct reduction possible, perform label swap between two labels\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _compress_labels(arr2)\n            enc = _nb_encode(arr2)\n            if enc is None:\n                return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n            return (enc, 'Local', 'SwapLabels')\n        # Fallback: random single relabel to any existing color\n        u = random.randint(1, n)\n        c = random.randint(1, k)\n        arr2 = arr[:]\n        arr2[u-1] = c\n        arr2 = _compress_labels(arr2)\n        enc = _nb_encode(arr2)\n        if enc is None:\n            return (','.join(str(x) for x in arr), 'Local', 'NoOp')\n        return (enc, 'Local', 'FallbackRelabel')\n","Perturbacion":"import random\nfrom typing import List, Optional\n\ndef _pt_parse(solution) -> Optional[List[int]]:\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _pt_encode(arr: List[int]) -> Optional[str]:\n    if not isinstance(arr, list) or len(arr) != 9:\n        return None\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return None\n    return ','.join(str(x) for x in arr)\n\ndef _pt_comp_adjacency():\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _pt_conflict_vertices(arr: List[int], comp_adj) -> List[int]:\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _compress_labels_pt(arr: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef perturb_solution(solution):\n    # Moderate shake focusing on conflicted vertices; preserves encoding\n    arr = _pt_parse(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    k = max(arr)\n    comp_adj = _pt_comp_adjacency()\n    conf = _pt_conflict_vertices(arr, comp_adj)\n    arr2 = arr[:]\n    # Relabel 2-4 vertices (prefer conflicted ones)\n    r = random.randint(2, 4)\n    pool = conf[:] if conf else list(range(1, n+1))\n    idxs = []\n    if len(pool) >= r:\n        idxs = random.sample(pool, r)\n    else:\n        remaining = [i for i in range(1, n+1) if i not in pool]\n        add_cnt = r - len(pool)\n        if remaining:\n            extra = random.sample(remaining, add_cnt if add_cnt <= len(remaining) else len(remaining))\n        else:\n            extra = []\n        idxs = pool + extra\n    for u in idxs:\n        # Choose random existing color; with small prob introduce k+1\n        if random.random() < 0.15:\n            new_c = k + 1\n        else:\n            new_c = random.randint(1, max(1, k))\n        arr2[u-1] = new_c\n    # Optional label swap to diversify\n    labels = sorted(set(arr2))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        arr2 = [b if x==a else a if x==b else x for x in arr2]\n    arr2 = _compress_labels_pt(arr2)\n    enc = _pt_encode(arr2)\n    if enc is None:\n        return ','.join(str(x) for x in arr)\n    return enc\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001722679}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a list of 9 positive integers [x1,...,x9], where xi is the party label of vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better. SA target (to be used by user): def SA(currentSolution,best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor).","Evaluacion":"import math\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    # Validate domain\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    undirected: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        undirected.add((a,b))\n        undirected.add((b,a))\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j]:\n                if (i+1, j+1) not in undirected:\n                    conflicts += 1\n    distinct_parties = len(set(solution))\n    # Big-M penalty ensures feasibility preferred before minimizing parties\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        # Relabel parties to 1..m in order of first appearance\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    move = random.choice([\"Reassign\", \"SwapLabels\", \"MergeLabels\"])  # movement types\n\n    if move == \"Reassign\":\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # choose either existing label or a potential new label up to max_label+1\n        candidates = list(used) + [max_label + 1]\n        new_label = random.choice(candidates)\n        curr[i] = new_label\n        nb_type = \"Local\"\n        mv_type = \"Reassign\"\n    elif move == \"SwapLabels\":\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            curr = [b if x == a else a if x == b else x for x in curr]\n            nb_type = \"Local\"\n            mv_type = \"SwapLabels\"\n        else:\n            # fallback to reassignment\n            i = random.randrange(n)\n            curr[i] = curr[i]\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n    else:  # MergeLabels\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            # Merge label b into a\n            curr = [a if x == b else x for x in curr]\n            nb_type = \"PerturbLocal\"\n            mv_type = \"MergeLabels\"\n        else:\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n\n    curr = canonicalize(curr)\n    return curr, nb_type, mv_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: multiple random reassignments and a random relabel shuffle\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # allow creating a new label with small probability\n        if random.random() < 0.4:\n            new_label = max_label + 1\n        else:\n            new_label = random.choice(list(used))\n        curr[i] = new_label\n        curr = canonicalize(curr)\n\n    # Random relabel permutation to escape label-symmetry traps\n    labels = list(set(curr))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {labels[i]: perm[i] for i in range(len(labels))}\n    curr = [mapping[x] for x in curr]\n    curr = canonicalize(curr)\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0005693061}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a list of 9 positive integers [x1,...,x9], where xi is the party label of vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better. SA target (to be used by user): def SA(currentSolution,best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor).","Evaluacion":"import math\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    # Validate domain\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    undirected: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        undirected.add((a,b))\n        undirected.add((b,a))\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j]:\n                if (i+1, j+1) not in undirected:\n                    conflicts += 1\n    distinct_parties = len(set(solution))\n    # Big-M penalty ensures feasibility preferred before minimizing parties\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        # Relabel parties to 1..m in order of first appearance\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    move = random.choice([\"Reassign\", \"SwapLabels\", \"MergeLabels\"])  # movement types\n\n    if move == \"Reassign\":\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # choose either existing label or a potential new label up to max_label+1\n        candidates = list(used) + [max_label + 1]\n        new_label = random.choice(candidates)\n        curr[i] = new_label\n        nb_type = \"Local\"\n        mv_type = \"Reassign\"\n    elif move == \"SwapLabels\":\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            curr = [b if x == a else a if x == b else x for x in curr]\n            nb_type = \"Local\"\n            mv_type = \"SwapLabels\"\n        else:\n            # fallback to reassignment\n            i = random.randrange(n)\n            curr[i] = curr[i]\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n    else:  # MergeLabels\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            # Merge label b into a\n            curr = [a if x == b else x for x in curr]\n            nb_type = \"PerturbLocal\"\n            mv_type = \"MergeLabels\"\n        else:\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n\n    curr = canonicalize(curr)\n    return curr, nb_type, mv_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: multiple random reassignments and a random relabel shuffle\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # allow creating a new label with small probability\n        if random.random() < 0.4:\n            new_label = max_label + 1\n        else:\n            new_label = random.choice(list(used))\n        curr[i] = new_label\n        curr = canonicalize(curr)\n\n    # Random relabel permutation to escape label-symmetry traps\n    labels = list(set(curr))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {labels[i]: perm[i] for i in range(len(labels))}\n    curr = [mapping[x] for x in curr]\n    curr = canonicalize(curr)\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.0007032771}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a list of 9 positive integers [x1,...,x9], where xi is the party label of vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better. SA target (to be used by user): def SA(currentSolution,best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor).","Evaluacion":"import math\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    # Validate domain\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    undirected: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        undirected.add((a,b))\n        undirected.add((b,a))\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j]:\n                if (i+1, j+1) not in undirected:\n                    conflicts += 1\n    distinct_parties = len(set(solution))\n    # Big-M penalty ensures feasibility preferred before minimizing parties\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        # Relabel parties to 1..m in order of first appearance\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    move = random.choice([\"Reassign\", \"SwapLabels\", \"MergeLabels\"])  # movement types\n\n    if move == \"Reassign\":\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # choose either existing label or a potential new label up to max_label+1\n        candidates = list(used) + [max_label + 1]\n        new_label = random.choice(candidates)\n        curr[i] = new_label\n        nb_type = \"Local\"\n        mv_type = \"Reassign\"\n    elif move == \"SwapLabels\":\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            curr = [b if x == a else a if x == b else x for x in curr]\n            nb_type = \"Local\"\n            mv_type = \"SwapLabels\"\n        else:\n            # fallback to reassignment\n            i = random.randrange(n)\n            curr[i] = curr[i]\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n    else:  # MergeLabels\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            # Merge label b into a\n            curr = [a if x == b else x for x in curr]\n            nb_type = \"PerturbLocal\"\n            mv_type = \"MergeLabels\"\n        else:\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n\n    curr = canonicalize(curr)\n    return curr, nb_type, mv_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: multiple random reassignments and a random relabel shuffle\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # allow creating a new label with small probability\n        if random.random() < 0.4:\n            new_label = max_label + 1\n        else:\n            new_label = random.choice(list(used))\n        curr[i] = new_label\n        curr = canonicalize(curr)\n\n    # Random relabel permutation to escape label-symmetry traps\n    labels = list(set(curr))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {labels[i]: perm[i] for i in range(len(labels))}\n    curr = [mapping[x] for x in curr]\n    curr = canonicalize(curr)\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.000686727}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a Python list of 9 positive integers [x1,...,x9], where xi is the party label assigned to vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better.","Evaluacion":"from typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # Build adjacency matrix for O(1) checks\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    # Penalize infeasibility heavily to prioritize feasibility\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    # Embedded graph\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def is_label_clique(labels: List[int], target_label: int) -> bool:\n        verts = [i+1 for i,x in enumerate(labels) if x == target_label]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False\n        return True\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        # Check if vertex (1-based v_idx+1) can join target_label (forms clique with all in that label)\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        # Merge label b into a if union remains a clique\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    # Movement generators (feasibility-preserving)\n    for _ in range(20):  # resample until non-NoOp\n        move = random.choice([\"ReassignFeasible\", \"MergeFeasible\", \"SplitGreedy\"])  # all structural\n\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            used_labels = list(set(curr))\n            random.shuffle(used_labels)\n            candidates = []\n            for lab in used_labels:\n                if lab != curr[i] and can_place_vertex_in_label(curr, i, lab):\n                    candidates.append(lab)\n            # allow creating a new singleton label if no feasible existing label\n            if not candidates:\n                max_lab = max(used_labels) if used_labels else 0\n                candidates = [max_lab + 1]\n            new_label = random.choice(candidates)\n            if new_label != curr[i]:\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            labels = list(set(curr))\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok:\n                    return merged, \"Local\", \"MergeFeasible\"\n        else:  # SplitGreedy: pick a label that is not a clique (rare if feasible), else split largest label by moving 1 vertex to feasible lowest label or new\n            labels = list(set(curr))\n            # choose a label with size >=2\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                # find lowest feasible label for i (excluding current)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n    # Fallback: minimal change create new label for a random vertex (always structural and feasible)\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(curr) if curr else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake while preserving feasibility as much as possible\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    # Phase 1: random feasible reassignments\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        # 30% chance to create a new label\n        if random.random() < 0.3:\n            new_label = (max(labels) if labels else 0) + 1\n            curr[i] = new_label\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                # create singleton if no feasible placement\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    # Phase 2: attempt a few feasible merges\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # test if union is clique\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0010316711}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a Python list of 9 positive integers [x1,...,x9], where xi is the party label assigned to vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better.","Evaluacion":"from typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # Build adjacency matrix for O(1) checks\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    # Penalize infeasibility heavily to prioritize feasibility\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    # Embedded graph\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def is_label_clique(labels: List[int], target_label: int) -> bool:\n        verts = [i+1 for i,x in enumerate(labels) if x == target_label]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False\n        return True\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        # Check if vertex (1-based v_idx+1) can join target_label (forms clique with all in that label)\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        # Merge label b into a if union remains a clique\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    # Movement generators (feasibility-preserving)\n    for _ in range(20):  # resample until non-NoOp\n        move = random.choice([\"ReassignFeasible\", \"MergeFeasible\", \"SplitGreedy\"])  # all structural\n\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            used_labels = list(set(curr))\n            random.shuffle(used_labels)\n            candidates = []\n            for lab in used_labels:\n                if lab != curr[i] and can_place_vertex_in_label(curr, i, lab):\n                    candidates.append(lab)\n            # allow creating a new singleton label if no feasible existing label\n            if not candidates:\n                max_lab = max(used_labels) if used_labels else 0\n                candidates = [max_lab + 1]\n            new_label = random.choice(candidates)\n            if new_label != curr[i]:\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            labels = list(set(curr))\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok:\n                    return merged, \"Local\", \"MergeFeasible\"\n        else:  # SplitGreedy: pick a label that is not a clique (rare if feasible), else split largest label by moving 1 vertex to feasible lowest label or new\n            labels = list(set(curr))\n            # choose a label with size >=2\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                # find lowest feasible label for i (excluding current)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n    # Fallback: minimal change create new label for a random vertex (always structural and feasible)\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(curr) if curr else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake while preserving feasibility as much as possible\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    # Phase 1: random feasible reassignments\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        # 30% chance to create a new label\n        if random.random() < 0.3:\n            new_label = (max(labels) if labels else 0) + 1\n            curr[i] = new_label\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                # create singleton if no feasible placement\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    # Phase 2: attempt a few feasible merges\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # test if union is clique\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001237193}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a Python list of 9 positive integers [x1,...,x9], where xi is the party label assigned to vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better.","Evaluacion":"from typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # Build adjacency matrix for O(1) checks\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    # Penalize infeasibility heavily to prioritize feasibility\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    # Embedded graph\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def is_label_clique(labels: List[int], target_label: int) -> bool:\n        verts = [i+1 for i,x in enumerate(labels) if x == target_label]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False\n        return True\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        # Check if vertex (1-based v_idx+1) can join target_label (forms clique with all in that label)\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        # Merge label b into a if union remains a clique\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    # Movement generators (feasibility-preserving)\n    for _ in range(20):  # resample until non-NoOp\n        move = random.choice([\"ReassignFeasible\", \"MergeFeasible\", \"SplitGreedy\"])  # all structural\n\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            used_labels = list(set(curr))\n            random.shuffle(used_labels)\n            candidates = []\n            for lab in used_labels:\n                if lab != curr[i] and can_place_vertex_in_label(curr, i, lab):\n                    candidates.append(lab)\n            # allow creating a new singleton label if no feasible existing label\n            if not candidates:\n                max_lab = max(used_labels) if used_labels else 0\n                candidates = [max_lab + 1]\n            new_label = random.choice(candidates)\n            if new_label != curr[i]:\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            labels = list(set(curr))\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok:\n                    return merged, \"Local\", \"MergeFeasible\"\n        else:  # SplitGreedy: pick a label that is not a clique (rare if feasible), else split largest label by moving 1 vertex to feasible lowest label or new\n            labels = list(set(curr))\n            # choose a label with size >=2\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                # find lowest feasible label for i (excluding current)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n    # Fallback: minimal change create new label for a random vertex (always structural and feasible)\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(curr) if curr else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake while preserving feasibility as much as possible\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    # Phase 1: random feasible reassignments\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        # 30% chance to create a new label\n        if random.random() < 0.3:\n            new_label = (max(labels) if labels else 0) + 1\n            curr[i] = new_label\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                # create singleton if no feasible placement\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    # Phase 2: attempt a few feasible merges\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # test if union is clique\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001214924}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based vertices). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize k = number of distinct labels. Lower is better.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    labels = list(set(curr))\n    move_types = [\"ReassignFeasible\", \"MergeFeasible\", \"LabelSwap\", \"SplitGreedy\"]\n    for _ in range(30):\n        move = random.choice(move_types)\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            candidates = [lab for lab in labels if lab != curr[i] and can_place_vertex_in_label(curr, i, lab)]\n            if not candidates:\n                new_label = (max(labels) if labels else 0) + 1\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasibleNew\"\n            else:\n                nxt = curr[:]\n                nxt[i] = random.choice(candidates)\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok and merged != curr:\n                    return merged, \"Local\", \"MergeFeasible\"\n        elif move == \"LabelSwap\":\n            i, j = random.sample(range(n), 2)\n            if curr[i] != curr[j]:\n                li, lj = curr[i], curr[j]\n                feas_i = can_place_vertex_in_label(curr, i, lj)\n                feas_j = can_place_vertex_in_label(curr, j, li)\n                if feas_i and feas_j:\n                    nxt = curr[:]\n                    nxt[i], nxt[j] = nxt[j], nxt[i]\n                    nxt = canonicalize(nxt)\n                    if nxt != curr:\n                        return nxt, \"Local\", \"LabelSwap\"\n        else:  # SplitGreedy\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n        labels = list(set(curr))\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(labels) if labels else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        if random.random() < 0.35:\n            curr[i] = (max(labels) if labels else 0) + 1\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.00097112}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based vertices). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize k = number of distinct labels. Lower is better.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    labels = list(set(curr))\n    move_types = [\"ReassignFeasible\", \"MergeFeasible\", \"LabelSwap\", \"SplitGreedy\"]\n    for _ in range(30):\n        move = random.choice(move_types)\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            candidates = [lab for lab in labels if lab != curr[i] and can_place_vertex_in_label(curr, i, lab)]\n            if not candidates:\n                new_label = (max(labels) if labels else 0) + 1\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasibleNew\"\n            else:\n                nxt = curr[:]\n                nxt[i] = random.choice(candidates)\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok and merged != curr:\n                    return merged, \"Local\", \"MergeFeasible\"\n        elif move == \"LabelSwap\":\n            i, j = random.sample(range(n), 2)\n            if curr[i] != curr[j]:\n                li, lj = curr[i], curr[j]\n                feas_i = can_place_vertex_in_label(curr, i, lj)\n                feas_j = can_place_vertex_in_label(curr, j, li)\n                if feas_i and feas_j:\n                    nxt = curr[:]\n                    nxt[i], nxt[j] = nxt[j], nxt[i]\n                    nxt = canonicalize(nxt)\n                    if nxt != curr:\n                        return nxt, \"Local\", \"LabelSwap\"\n        else:  # SplitGreedy\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n        labels = list(set(curr))\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(labels) if labels else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        if random.random() < 0.35:\n            curr[i] = (max(labels) if labels else 0) + 1\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001350905}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based vertices). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize k = number of distinct labels. Lower is better.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    labels = list(set(curr))\n    move_types = [\"ReassignFeasible\", \"MergeFeasible\", \"LabelSwap\", \"SplitGreedy\"]\n    for _ in range(30):\n        move = random.choice(move_types)\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            candidates = [lab for lab in labels if lab != curr[i] and can_place_vertex_in_label(curr, i, lab)]\n            if not candidates:\n                new_label = (max(labels) if labels else 0) + 1\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasibleNew\"\n            else:\n                nxt = curr[:]\n                nxt[i] = random.choice(candidates)\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok and merged != curr:\n                    return merged, \"Local\", \"MergeFeasible\"\n        elif move == \"LabelSwap\":\n            i, j = random.sample(range(n), 2)\n            if curr[i] != curr[j]:\n                li, lj = curr[i], curr[j]\n                feas_i = can_place_vertex_in_label(curr, i, lj)\n                feas_j = can_place_vertex_in_label(curr, j, li)\n                if feas_i and feas_j:\n                    nxt = curr[:]\n                    nxt[i], nxt[j] = nxt[j], nxt[i]\n                    nxt = canonicalize(nxt)\n                    if nxt != curr:\n                        return nxt, \"Local\", \"LabelSwap\"\n        else:  # SplitGreedy\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n        labels = list(set(curr))\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(labels) if labels else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        if random.random() < 0.35:\n            curr[i] = (max(labels) if labels else 0) + 1\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0017343289}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize the number of distinct labels.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr: List[int] = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out: List[int] = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    labels = sorted(set(curr))\n    move_types = (\"ReassignFeasible\", \"MergeFeasible\", \"LabelSwap\")\n    for _ in range(30):\n        move = random.choice(move_types)\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            lbls = sorted(set(curr))\n            candidates = [lab for lab in lbls if lab != curr[i] and can_place_vertex_in_label(curr, i, lab)]\n            if candidates:\n                nxt = curr[:]\n                nxt[i] = random.choice(candidates)\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            lbls = sorted(set(curr))\n            if len(lbls) >= 2:\n                a, b = random.sample(lbls, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok and merged != curr:\n                    return merged, \"Local\", \"MergeFeasible\"\n        else:  # LabelSwap\n            i, j = random.sample(range(n), 2)\n            if curr[i] != curr[j]:\n                li, lj = curr[i], curr[j]\n                feas_i = can_place_vertex_in_label(curr, i, lj)\n                feas_j = can_place_vertex_in_label(curr, j, li)\n                if feas_i and feas_j:\n                    nxt = curr[:]\n                    nxt[i], nxt[j] = nxt[j], nxt[i]\n                    nxt = canonicalize(nxt)\n                    if nxt != curr:\n                        return nxt, \"Local\", \"LabelSwap\"\n\n    # Fallback: create singleton (diversification) then canonicalize\n    i = random.randrange(n)\n    lbls = sorted(set(curr))\n    nxt = curr[:]\n    nxt[i] = (max(lbls) if lbls else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr: List[int] = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out: List[int] = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    # Ejection of k vertices from largest labels\n    sizes = {}\n    for lab in curr:\n        sizes[lab] = sizes.get(lab, 0) + 1\n    labs_by_size = sorted(sizes.items(), key=lambda x: (-x[1], x[0]))\n    pool: List[int] = []\n    for lab, cnt in labs_by_size:\n        pool.extend([idx for idx, x in enumerate(curr) if x == lab])\n    k = min(n, max(3, len(set(curr))))\n    eject_idxs = sorted(random.sample(pool, k))\n\n    temp = curr[:]\n    for i in eject_idxs:\n        temp[i] = 0  # unassigned\n\n    # Greedy reinsertion\n    for i in eject_idxs:\n        lbls = sorted(set(x for x in temp if x > 0))\n        placed = False\n        for L in lbls:\n            if can_place_vertex_in_label(temp, i, L):\n                temp[i] = L\n                placed = True\n                break\n        if not placed:\n            temp[i] = (max(lbls) if lbls else 0) + 1\n    temp = canonicalize(temp)\n\n    # Attempt a few feasible merges to reduce labels\n    tries = 3\n    for _ in range(tries):\n        lbls = sorted(set(temp))\n        if len(lbls) < 2:\n            break\n        a, b = random.sample(lbls, 2)\n        verts = [idx+1 for idx, x in enumerate(temp) if x in (a, b)]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            temp = [a if x == b else x for x in temp]\n            temp = canonicalize(temp)\n\n    return temp\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.000824559}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize the number of distinct labels.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr: List[int] = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out: List[int] = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    labels = sorted(set(curr))\n    move_types = (\"ReassignFeasible\", \"MergeFeasible\", \"LabelSwap\")\n    for _ in range(30):\n        move = random.choice(move_types)\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            lbls = sorted(set(curr))\n            candidates = [lab for lab in lbls if lab != curr[i] and can_place_vertex_in_label(curr, i, lab)]\n            if candidates:\n                nxt = curr[:]\n                nxt[i] = random.choice(candidates)\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            lbls = sorted(set(curr))\n            if len(lbls) >= 2:\n                a, b = random.sample(lbls, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok and merged != curr:\n                    return merged, \"Local\", \"MergeFeasible\"\n        else:  # LabelSwap\n            i, j = random.sample(range(n), 2)\n            if curr[i] != curr[j]:\n                li, lj = curr[i], curr[j]\n                feas_i = can_place_vertex_in_label(curr, i, lj)\n                feas_j = can_place_vertex_in_label(curr, j, li)\n                if feas_i and feas_j:\n                    nxt = curr[:]\n                    nxt[i], nxt[j] = nxt[j], nxt[i]\n                    nxt = canonicalize(nxt)\n                    if nxt != curr:\n                        return nxt, \"Local\", \"LabelSwap\"\n\n    # Fallback: create singleton (diversification) then canonicalize\n    i = random.randrange(n)\n    lbls = sorted(set(curr))\n    nxt = curr[:]\n    nxt[i] = (max(lbls) if lbls else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr: List[int] = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out: List[int] = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    # Ejection of k vertices from largest labels\n    sizes = {}\n    for lab in curr:\n        sizes[lab] = sizes.get(lab, 0) + 1\n    labs_by_size = sorted(sizes.items(), key=lambda x: (-x[1], x[0]))\n    pool: List[int] = []\n    for lab, cnt in labs_by_size:\n        pool.extend([idx for idx, x in enumerate(curr) if x == lab])\n    k = min(n, max(3, len(set(curr))))\n    eject_idxs = sorted(random.sample(pool, k))\n\n    temp = curr[:]\n    for i in eject_idxs:\n        temp[i] = 0  # unassigned\n\n    # Greedy reinsertion\n    for i in eject_idxs:\n        lbls = sorted(set(x for x in temp if x > 0))\n        placed = False\n        for L in lbls:\n            if can_place_vertex_in_label(temp, i, L):\n                temp[i] = L\n                placed = True\n                break\n        if not placed:\n            temp[i] = (max(lbls) if lbls else 0) + 1\n    temp = canonicalize(temp)\n\n    # Attempt a few feasible merges to reduce labels\n    tries = 3\n    for _ in range(tries):\n        lbls = sorted(set(temp))\n        if len(lbls) < 2:\n            break\n        a, b = random.sample(lbls, 2)\n        verts = [idx+1 for idx, x in enumerate(temp) if x in (a, b)]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            temp = [a if x == b else x for x in temp]\n            temp = canonicalize(temp)\n\n    return temp\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001184933}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize the number of distinct labels.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    return conflicts * 1_000_000 + distinct_parties\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr: List[int] = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out: List[int] = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    labels = sorted(set(curr))\n    move_types = (\"ReassignFeasible\", \"MergeFeasible\", \"LabelSwap\")\n    for _ in range(30):\n        move = random.choice(move_types)\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            lbls = sorted(set(curr))\n            candidates = [lab for lab in lbls if lab != curr[i] and can_place_vertex_in_label(curr, i, lab)]\n            if candidates:\n                nxt = curr[:]\n                nxt[i] = random.choice(candidates)\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            lbls = sorted(set(curr))\n            if len(lbls) >= 2:\n                a, b = random.sample(lbls, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok and merged != curr:\n                    return merged, \"Local\", \"MergeFeasible\"\n        else:  # LabelSwap\n            i, j = random.sample(range(n), 2)\n            if curr[i] != curr[j]:\n                li, lj = curr[i], curr[j]\n                feas_i = can_place_vertex_in_label(curr, i, lj)\n                feas_j = can_place_vertex_in_label(curr, j, li)\n                if feas_i and feas_j:\n                    nxt = curr[:]\n                    nxt[i], nxt[j] = nxt[j], nxt[i]\n                    nxt = canonicalize(nxt)\n                    if nxt != curr:\n                        return nxt, \"Local\", \"LabelSwap\"\n\n    # Fallback: create singleton (diversification) then canonicalize\n    i = random.randrange(n)\n    lbls = sorted(set(curr))\n    nxt = curr[:]\n    nxt[i] = (max(lbls) if lbls else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr: List[int] = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out: List[int] = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    # Ejection of k vertices from largest labels\n    sizes = {}\n    for lab in curr:\n        sizes[lab] = sizes.get(lab, 0) + 1\n    labs_by_size = sorted(sizes.items(), key=lambda x: (-x[1], x[0]))\n    pool: List[int] = []\n    for lab, cnt in labs_by_size:\n        pool.extend([idx for idx, x in enumerate(curr) if x == lab])\n    k = min(n, max(3, len(set(curr))))\n    eject_idxs = sorted(random.sample(pool, k))\n\n    temp = curr[:]\n    for i in eject_idxs:\n        temp[i] = 0  # unassigned\n\n    # Greedy reinsertion\n    for i in eject_idxs:\n        lbls = sorted(set(x for x in temp if x > 0))\n        placed = False\n        for L in lbls:\n            if can_place_vertex_in_label(temp, i, L):\n                temp[i] = L\n                placed = True\n                break\n        if not placed:\n            temp[i] = (max(lbls) if lbls else 0) + 1\n    temp = canonicalize(temp)\n\n    # Attempt a few feasible merges to reduce labels\n    tries = 3\n    for _ in range(tries):\n        lbls = sorted(set(temp))\n        if len(lbls) < 2:\n            break\n        a, b = random.sample(lbls, 2)\n        verts = [idx+1 for idx, x in enumerate(temp) if x in (a, b)]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            temp = [a if x == b else x for x in temp]\n            temp = canonicalize(temp)\n\n    return temp\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.0012171039}
